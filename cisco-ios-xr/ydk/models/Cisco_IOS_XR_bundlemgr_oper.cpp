
#include <sstream>
#include <iostream>
#include "ydk/entity_util.hpp"
#include "Cisco_IOS_XR_bundlemgr_oper.hpp"

namespace ydk {
namespace Cisco_IOS_XR_bundlemgr_oper {

LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "actor-bundle-data";
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::~MacAddress()
{
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "actor-bundle-data";
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::~BfdConfig()
{
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::ActorBundleData()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "actor-bundle-data"; yang_parent_name = "data";
}

LacpBundles::Bundles::Bundle::Data::ActorBundleData::~ActorBundleData()
{
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool LacpBundles::Bundles::Bundle::Data::ActorBundleData::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string LacpBundles::Bundles::Bundle::Data::ActorBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-bundle-data";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::ActorBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::ActorBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::ActorBundleData::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Data::ActorBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "bundle-system-id";
}

LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

LacpBundles::Bundles::Bundle::Data::BundleSystemId::BundleSystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "bundle-system-id"; yang_parent_name = "data";
}

LacpBundles::Bundles::Bundle::Data::BundleSystemId::~BundleSystemId()
{
}

bool LacpBundles::Bundles::Bundle::Data::BundleSystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool LacpBundles::Bundles::Bundle::Data::BundleSystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string LacpBundles::Bundles::Bundle::Data::BundleSystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-system-id";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::BundleSystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::BundleSystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<LacpBundles::Bundles::Bundle::Data::BundleSystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::BundleSystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Data::BundleSystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

LacpBundles::Bundles::Bundle::Data::Data()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"}
    	,
    actor_bundle_data(std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData>())
	,bundle_system_id(std::make_unique<LacpBundles::Bundles::Bundle::Data::BundleSystemId>())
{
    actor_bundle_data->parent = this;
    children["actor-bundle-data"] = actor_bundle_data.get();

    bundle_system_id->parent = this;
    children["bundle-system-id"] = bundle_system_id.get();

    yang_name = "data"; yang_parent_name = "bundle";
}

LacpBundles::Bundles::Bundle::Data::~Data()
{
}

bool LacpBundles::Bundles::Bundle::Data::has_data() const
{
    return actor_operational_key.is_set
	|| partner_operational_key.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_data())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_data());
}

bool LacpBundles::Bundles::Bundle::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_operation())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_operation());
}

std::string LacpBundles::Bundles::Bundle::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-bundle-data")
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        else
        {
            actor_bundle_data = std::make_unique<LacpBundles::Bundles::Bundle::Data::ActorBundleData>();
            actor_bundle_data->parent = this;
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        return children.at("actor-bundle-data");
    }

    if(child_yang_name == "bundle-system-id")
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
        else
        {
            bundle_system_id = std::make_unique<LacpBundles::Bundles::Bundle::Data::BundleSystemId>();
            bundle_system_id->parent = this;
            children["bundle-system-id"] = bundle_system_id.get();
        }
        return children.at("bundle-system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Data::get_children()
{
    if(children.find("actor-bundle-data") == children.end())
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
    }

    if(children.find("bundle-system-id") == children.end())
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Member::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"}
{
    yang_name = "counters"; yang_parent_name = "member";
}

LacpBundles::Bundles::Bundle::Members::Member::Counters::~Counters()
{
}

bool LacpBundles::Bundles::Bundle::Members::Member::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set;
}

bool LacpBundles::Bundles::Bundle::Members::Member::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation);
}

std::string LacpBundles::Bundles::Bundle::Members::Member::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::Member::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::Member::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::Member::Counters::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Members::Member::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Member::LinkData::LinkData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "link-data"; yang_parent_name = "member";
}

LacpBundles::Bundles::Bundle::Members::Member::LinkData::~LinkData()
{
}

bool LacpBundles::Bundles::Bundle::Members::Member::LinkData::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool LacpBundles::Bundles::Bundle::Members::Member::LinkData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string LacpBundles::Bundles::Bundle::Members::Member::LinkData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-data";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::Member::LinkData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::Member::LinkData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::Member::LinkData::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Members::Member::LinkData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::MemberMuxStateReasonData()
    :
    	reason_type{YType::enumeration, "reason-type"},
	 severity{YType::enumeration, "severity"}
{
    yang_name = "member-mux-state-reason-data"; yang_parent_name = "member-mux-data";
}

LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::~MemberMuxStateReasonData()
{
}

bool LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::has_data() const
{
    return reason_type.is_set
	|| severity.is_set;
}

bool LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_type.operation)
	|| is_set(severity.operation);
}

std::string LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-state-reason-data";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_type.is_set || is_set(reason_type.operation)) leaf_name_data.push_back(reason_type.get_name_leafdata());
    if (severity.is_set || is_set(severity.operation)) leaf_name_data.push_back(severity.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-type")
    {
        reason_type = value;
    }
    if(value_path == "severity")
    {
        severity = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxData()
    :
    	error{YType::uint32, "error"},
	 member_mux_state_reason{YType::enumeration, "member-mux-state-reason"},
	 member_state{YType::enumeration, "member-state"},
	 mux_state{YType::enumeration, "mux-state"},
	 mux_state_reason{YType::enumeration, "mux-state-reason"}
    	,
    member_mux_state_reason_data(std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData>())
{
    member_mux_state_reason_data->parent = this;
    children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();

    yang_name = "member-mux-data"; yang_parent_name = "member";
}

LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::~MemberMuxData()
{
}

bool LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::has_data() const
{
    return error.is_set
	|| member_mux_state_reason.is_set
	|| member_state.is_set
	|| mux_state.is_set
	|| mux_state_reason.is_set
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_data());
}

bool LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::has_operation() const
{
    return is_set(operation)
	|| is_set(error.operation)
	|| is_set(member_mux_state_reason.operation)
	|| is_set(member_state.operation)
	|| is_set(mux_state.operation)
	|| is_set(mux_state_reason.operation)
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_operation());
}

std::string LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-data";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (member_mux_state_reason.is_set || is_set(member_mux_state_reason.operation)) leaf_name_data.push_back(member_mux_state_reason.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (mux_state_reason.is_set || is_set(mux_state_reason.operation)) leaf_name_data.push_back(mux_state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-mux-state-reason-data")
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        else
        {
            member_mux_state_reason_data = std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData>();
            member_mux_state_reason_data->parent = this;
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        return children.at("member-mux-state-reason-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::get_children()
{
    if(children.find("member-mux-state-reason-data") == children.end())
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "member-mux-state-reason")
    {
        member_mux_state_reason = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "mux-state-reason")
    {
        mux_state_reason = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Member::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "member";
}

LacpBundles::Bundles::Bundle::Members::Member::MacAddress::~MacAddress()
{
}

bool LacpBundles::Bundles::Bundle::Members::Member::MacAddress::has_data() const
{
    return address.is_set;
}

bool LacpBundles::Bundles::Bundle::Members::Member::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string LacpBundles::Bundles::Bundle::Members::Member::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::Member::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::Member::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::Member::MacAddress::get_children()
{
    return children;
}

void LacpBundles::Bundles::Bundle::Members::Member::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Member::Member()
    :
    	member_interface{YType::str, "member-interface"},
	 bandwidth{YType::uint32, "bandwidth"},
	 iccp_node{YType::uint32, "iccp-node"},
	 interface_name{YType::str, "interface-name"},
	 link_order_number{YType::uint16, "link-order-number"},
	 member_name{YType::str, "member-name"},
	 member_type{YType::enumeration, "member-type"},
	 port_number{YType::uint16, "port-number"},
	 port_priority{YType::uint16, "port-priority"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
    	,
    counters(std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::Counters>())
	,link_data(std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::LinkData>())
	,mac_address(std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::MacAddress>())
	,member_mux_data(std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    link_data->parent = this;
    children["link-data"] = link_data.get();

    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    member_mux_data->parent = this;
    children["member-mux-data"] = member_mux_data.get();

    yang_name = "member"; yang_parent_name = "members";
}

LacpBundles::Bundles::Bundle::Members::Member::~Member()
{
}

bool LacpBundles::Bundles::Bundle::Members::Member::has_data() const
{
    return member_interface.is_set
	|| bandwidth.is_set
	|| iccp_node.is_set
	|| interface_name.is_set
	|| link_order_number.is_set
	|| member_name.is_set
	|| member_type.is_set
	|| port_number.is_set
	|| port_priority.is_set
	|| underlying_link_id.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (link_data !=  nullptr && link_data->has_data())
	|| (mac_address !=  nullptr && mac_address->has_data())
	|| (member_mux_data !=  nullptr && member_mux_data->has_data());
}

bool LacpBundles::Bundles::Bundle::Members::Member::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(bandwidth.operation)
	|| is_set(iccp_node.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_order_number.operation)
	|| is_set(member_name.operation)
	|| is_set(member_type.operation)
	|| is_set(port_number.operation)
	|| is_set(port_priority.operation)
	|| is_set(underlying_link_id.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (link_data !=  nullptr && link_data->has_operation())
	|| (mac_address !=  nullptr && mac_address->has_operation())
	|| (member_mux_data !=  nullptr && member_mux_data->has_operation());
}

std::string LacpBundles::Bundles::Bundle::Members::Member::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::Member::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (iccp_node.is_set || is_set(iccp_node.operation)) leaf_name_data.push_back(iccp_node.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (member_type.is_set || is_set(member_type.operation)) leaf_name_data.push_back(member_type.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::Member::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "link-data")
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
        else
        {
            link_data = std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::LinkData>();
            link_data->parent = this;
            children["link-data"] = link_data.get();
        }
        return children.at("link-data");
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    if(child_yang_name == "member-mux-data")
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
        else
        {
            member_mux_data = std::make_unique<LacpBundles::Bundles::Bundle::Members::Member::MemberMuxData>();
            member_mux_data->parent = this;
            children["member-mux-data"] = member_mux_data.get();
        }
        return children.at("member-mux-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::Member::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("link-data") == children.end())
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    if(children.find("member-mux-data") == children.end())
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Members::Member::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "iccp-node")
    {
        iccp_node = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "member-type")
    {
        member_type = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

LacpBundles::Bundles::Bundle::Members::Members()
{
    yang_name = "members"; yang_parent_name = "bundle";
}

LacpBundles::Bundles::Bundle::Members::~Members()
{
}

bool LacpBundles::Bundles::Bundle::Members::has_data() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_data())
            return true;
    }
    return false;
}

bool LacpBundles::Bundles::Bundle::Members::has_operation() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string LacpBundles::Bundles::Bundle::Members::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "members";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::Members::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::Members::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member")
    {
        for(auto const & c : member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<LacpBundles::Bundles::Bundle::Members::Member>();
        c->parent = this;
        member.push_back(std::move(c));
        children[segment_path] = member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::Members::get_children()
{
    for (auto const & c : member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::Members::set_value(const std::string & value_path, std::string value)
{
}

LacpBundles::Bundles::Bundle::Bundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    data(std::make_unique<LacpBundles::Bundles::Bundle::Data>())
	,members(std::make_unique<LacpBundles::Bundles::Bundle::Members>())
{
    data->parent = this;
    children["data"] = data.get();

    members->parent = this;
    children["members"] = members.get();

    yang_name = "bundle"; yang_parent_name = "bundles";
}

LacpBundles::Bundles::Bundle::~Bundle()
{
}

bool LacpBundles::Bundles::Bundle::has_data() const
{
    return bundle_interface.is_set
	|| (data !=  nullptr && data->has_data())
	|| (members !=  nullptr && members->has_data());
}

bool LacpBundles::Bundles::Bundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (data !=  nullptr && data->has_operation())
	|| (members !=  nullptr && members->has_operation());
}

std::string LacpBundles::Bundles::Bundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::Bundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundles/bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::Bundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<LacpBundles::Bundles::Bundle::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    if(child_yang_name == "members")
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
        else
        {
            members = std::make_unique<LacpBundles::Bundles::Bundle::Members>();
            members->parent = this;
            children["members"] = members.get();
        }
        return children.at("members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::Bundle::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    if(children.find("members") == children.end())
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::Bundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

LacpBundles::Bundles::Bundles()
{
    yang_name = "bundles"; yang_parent_name = "lacp-bundles";
}

LacpBundles::Bundles::~Bundles()
{
}

bool LacpBundles::Bundles::has_data() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_data())
            return true;
    }
    return false;
}

bool LacpBundles::Bundles::has_operation() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string LacpBundles::Bundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundles";

    return path_buffer.str();

}

EntityPath LacpBundles::Bundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::Bundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle")
    {
        for(auto const & c : bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<LacpBundles::Bundles::Bundle>();
        c->parent = this;
        bundle.push_back(std::move(c));
        children[segment_path] = bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::Bundles::get_children()
{
    for (auto const & c : bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void LacpBundles::Bundles::set_value(const std::string & value_path, std::string value)
{
}

LacpBundles::LacpBundles()
    :
    bundles(std::make_unique<LacpBundles::Bundles>())
{
    bundles->parent = this;
    children["bundles"] = bundles.get();

    yang_name = "lacp-bundles"; yang_parent_name = "Cisco-IOS-XR-bundlemgr-oper";
}

LacpBundles::~LacpBundles()
{
}

bool LacpBundles::has_data() const
{
    return (bundles !=  nullptr && bundles->has_data());
}

bool LacpBundles::has_operation() const
{
    return is_set(operation)
	|| (bundles !=  nullptr && bundles->has_operation());
}

std::string LacpBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundles";

    return path_buffer.str();

}

EntityPath LacpBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundles")
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
        else
        {
            bundles = std::make_unique<LacpBundles::Bundles>();
            bundles->parent = this;
            children["bundles"] = bundles.get();
        }
        return children.at("bundles");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundles::get_children()
{
    if(children.find("bundles") == children.end())
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
    }

    return children;
}

void LacpBundles::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> LacpBundles::clone_ptr()
{
    return std::make_unique<LacpBundles>();
}
BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::BundleName()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "bundle-name"; yang_parent_name = "bfd-counters-bundle-descendant";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::~BundleName()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::has_data() const
{
    return item_name.is_set;
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::has_operation() const
{
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-name";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::get_children()
{
    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::BfdCounter()
    :
    	down{YType::uint32, "down"},
	 last_time_cleared{YType::uint64, "last-time-cleared"},
	 member_name{YType::str, "member-name"},
	 neighbor_unconfigured{YType::uint32, "neighbor-unconfigured"},
	 neighbor_unconfigured_timeouts{YType::uint32, "neighbor-unconfigured-timeouts"},
	 start_timeouts{YType::uint32, "start-timeouts"},
	 starting{YType::uint32, "starting"},
	 time_since_cleared{YType::uint64, "time-since-cleared"},
	 up{YType::uint32, "up"}
{
    yang_name = "bfd-counter"; yang_parent_name = "bfd-counters-bundle-descendant";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::~BfdCounter()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::has_data() const
{
    return down.is_set
	|| last_time_cleared.is_set
	|| member_name.is_set
	|| neighbor_unconfigured.is_set
	|| neighbor_unconfigured_timeouts.is_set
	|| start_timeouts.is_set
	|| starting.is_set
	|| time_since_cleared.is_set
	|| up.is_set;
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(down.operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(member_name.operation)
	|| is_set(neighbor_unconfigured.operation)
	|| is_set(neighbor_unconfigured_timeouts.operation)
	|| is_set(start_timeouts.operation)
	|| is_set(starting.operation)
	|| is_set(time_since_cleared.operation)
	|| is_set(up.operation);
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counter";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down.is_set || is_set(down.operation)) leaf_name_data.push_back(down.get_name_leafdata());
    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (neighbor_unconfigured.is_set || is_set(neighbor_unconfigured.operation)) leaf_name_data.push_back(neighbor_unconfigured.get_name_leafdata());
    if (neighbor_unconfigured_timeouts.is_set || is_set(neighbor_unconfigured_timeouts.operation)) leaf_name_data.push_back(neighbor_unconfigured_timeouts.get_name_leafdata());
    if (start_timeouts.is_set || is_set(start_timeouts.operation)) leaf_name_data.push_back(start_timeouts.get_name_leafdata());
    if (starting.is_set || is_set(starting.operation)) leaf_name_data.push_back(starting.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());
    if (up.is_set || is_set(up.operation)) leaf_name_data.push_back(up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::get_children()
{
    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down")
    {
        down = value;
    }
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "neighbor-unconfigured")
    {
        neighbor_unconfigured = value;
    }
    if(value_path == "neighbor-unconfigured-timeouts")
    {
        neighbor_unconfigured_timeouts = value;
    }
    if(value_path == "start-timeouts")
    {
        start_timeouts = value;
    }
    if(value_path == "starting")
    {
        starting = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
    if(value_path == "up")
    {
        up = value;
    }
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCountersBundleDescendant()
    :
    bundle_name(std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName>())
{
    bundle_name->parent = this;
    children["bundle-name"] = bundle_name.get();

    yang_name = "bfd-counters-bundle-descendant"; yang_parent_name = "bfd-counters-bundle";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::~BfdCountersBundleDescendant()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::has_data() const
{
    for (std::size_t index=0; index<bfd_counter.size(); index++)
    {
        if(bfd_counter[index]->has_data())
            return true;
    }
    return (bundle_name !=  nullptr && bundle_name->has_data());
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::has_operation() const
{
    for (std::size_t index=0; index<bfd_counter.size(); index++)
    {
        if(bfd_counter[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_name !=  nullptr && bundle_name->has_operation());
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-bundle-descendant";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counter")
    {
        for(auto const & c : bfd_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BfdCounter>();
        c->parent = this;
        bfd_counter.push_back(std::move(c));
        children[segment_path] = bfd_counter.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-name")
    {
        if(bundle_name != nullptr)
        {
            children["bundle-name"] = bundle_name.get();
        }
        else
        {
            bundle_name = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::BundleName>();
            bundle_name->parent = this;
            children["bundle-name"] = bundle_name.get();
        }
        return children.at("bundle-name");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::get_children()
{
    for (auto const & c : bfd_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("bundle-name") == children.end())
    {
        if(bundle_name != nullptr)
        {
            children["bundle-name"] = bundle_name.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::BfdCountersBundleChildrenMember()
    :
    	member_interface{YType::str, "member-interface"},
	 down{YType::uint32, "down"},
	 last_time_cleared{YType::uint64, "last-time-cleared"},
	 member_name{YType::str, "member-name"},
	 neighbor_unconfigured{YType::uint32, "neighbor-unconfigured"},
	 neighbor_unconfigured_timeouts{YType::uint32, "neighbor-unconfigured-timeouts"},
	 start_timeouts{YType::uint32, "start-timeouts"},
	 starting{YType::uint32, "starting"},
	 time_since_cleared{YType::uint64, "time-since-cleared"},
	 up{YType::uint32, "up"}
{
    yang_name = "bfd-counters-bundle-children-member"; yang_parent_name = "bfd-counters-bundle-children-members";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::~BfdCountersBundleChildrenMember()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::has_data() const
{
    return member_interface.is_set
	|| down.is_set
	|| last_time_cleared.is_set
	|| member_name.is_set
	|| neighbor_unconfigured.is_set
	|| neighbor_unconfigured_timeouts.is_set
	|| start_timeouts.is_set
	|| starting.is_set
	|| time_since_cleared.is_set
	|| up.is_set;
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(down.operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(member_name.operation)
	|| is_set(neighbor_unconfigured.operation)
	|| is_set(neighbor_unconfigured_timeouts.operation)
	|| is_set(start_timeouts.operation)
	|| is_set(starting.operation)
	|| is_set(time_since_cleared.operation)
	|| is_set(up.operation);
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-bundle-children-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (down.is_set || is_set(down.operation)) leaf_name_data.push_back(down.get_name_leafdata());
    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (neighbor_unconfigured.is_set || is_set(neighbor_unconfigured.operation)) leaf_name_data.push_back(neighbor_unconfigured.get_name_leafdata());
    if (neighbor_unconfigured_timeouts.is_set || is_set(neighbor_unconfigured_timeouts.operation)) leaf_name_data.push_back(neighbor_unconfigured_timeouts.get_name_leafdata());
    if (start_timeouts.is_set || is_set(start_timeouts.operation)) leaf_name_data.push_back(start_timeouts.get_name_leafdata());
    if (starting.is_set || is_set(starting.operation)) leaf_name_data.push_back(starting.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());
    if (up.is_set || is_set(up.operation)) leaf_name_data.push_back(up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::get_children()
{
    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "down")
    {
        down = value;
    }
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "neighbor-unconfigured")
    {
        neighbor_unconfigured = value;
    }
    if(value_path == "neighbor-unconfigured-timeouts")
    {
        neighbor_unconfigured_timeouts = value;
    }
    if(value_path == "start-timeouts")
    {
        start_timeouts = value;
    }
    if(value_path == "starting")
    {
        starting = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
    if(value_path == "up")
    {
        up = value;
    }
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMembers()
{
    yang_name = "bfd-counters-bundle-children-members"; yang_parent_name = "bfd-counters-bundle";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::~BfdCountersBundleChildrenMembers()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::has_data() const
{
    for (std::size_t index=0; index<bfd_counters_bundle_children_member.size(); index++)
    {
        if(bfd_counters_bundle_children_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::has_operation() const
{
    for (std::size_t index=0; index<bfd_counters_bundle_children_member.size(); index++)
    {
        if(bfd_counters_bundle_children_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-bundle-children-members";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters-bundle-children-member")
    {
        for(auto const & c : bfd_counters_bundle_children_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::BfdCountersBundleChildrenMember>();
        c->parent = this;
        bfd_counters_bundle_children_member.push_back(std::move(c));
        children[segment_path] = bfd_counters_bundle_children_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::get_children()
{
    for (auto const & c : bfd_counters_bundle_children_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::BfdCountersBundleItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "bfd-counters-bundle-item"; yang_parent_name = "bfd-counters-bundle";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::~BfdCountersBundleItem()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::has_data() const
{
    return item_name.is_set;
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::has_operation() const
{
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::get_children()
{
    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    bfd_counters_bundle_children_members(std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers>())
	,bfd_counters_bundle_descendant(std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant>())
	,bfd_counters_bundle_item(std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem>())
{
    bfd_counters_bundle_children_members->parent = this;
    children["bfd-counters-bundle-children-members"] = bfd_counters_bundle_children_members.get();

    bfd_counters_bundle_descendant->parent = this;
    children["bfd-counters-bundle-descendant"] = bfd_counters_bundle_descendant.get();

    bfd_counters_bundle_item->parent = this;
    children["bfd-counters-bundle-item"] = bfd_counters_bundle_item.get();

    yang_name = "bfd-counters-bundle"; yang_parent_name = "bfd-counters-bundles";
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::~BfdCountersBundle()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::has_data() const
{
    return bundle_interface.is_set
	|| (bfd_counters_bundle_children_members !=  nullptr && bfd_counters_bundle_children_members->has_data())
	|| (bfd_counters_bundle_descendant !=  nullptr && bfd_counters_bundle_descendant->has_data())
	|| (bfd_counters_bundle_item !=  nullptr && bfd_counters_bundle_item->has_data());
}

bool BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (bfd_counters_bundle_children_members !=  nullptr && bfd_counters_bundle_children_members->has_operation())
	|| (bfd_counters_bundle_descendant !=  nullptr && bfd_counters_bundle_descendant->has_operation())
	|| (bfd_counters_bundle_item !=  nullptr && bfd_counters_bundle_item->has_operation());
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bfd-counters/bfd-counters-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters-bundle-children-members")
    {
        if(bfd_counters_bundle_children_members != nullptr)
        {
            children["bfd-counters-bundle-children-members"] = bfd_counters_bundle_children_members.get();
        }
        else
        {
            bfd_counters_bundle_children_members = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleChildrenMembers>();
            bfd_counters_bundle_children_members->parent = this;
            children["bfd-counters-bundle-children-members"] = bfd_counters_bundle_children_members.get();
        }
        return children.at("bfd-counters-bundle-children-members");
    }

    if(child_yang_name == "bfd-counters-bundle-descendant")
    {
        if(bfd_counters_bundle_descendant != nullptr)
        {
            children["bfd-counters-bundle-descendant"] = bfd_counters_bundle_descendant.get();
        }
        else
        {
            bfd_counters_bundle_descendant = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleDescendant>();
            bfd_counters_bundle_descendant->parent = this;
            children["bfd-counters-bundle-descendant"] = bfd_counters_bundle_descendant.get();
        }
        return children.at("bfd-counters-bundle-descendant");
    }

    if(child_yang_name == "bfd-counters-bundle-item")
    {
        if(bfd_counters_bundle_item != nullptr)
        {
            children["bfd-counters-bundle-item"] = bfd_counters_bundle_item.get();
        }
        else
        {
            bfd_counters_bundle_item = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::BfdCountersBundleItem>();
            bfd_counters_bundle_item->parent = this;
            children["bfd-counters-bundle-item"] = bfd_counters_bundle_item.get();
        }
        return children.at("bfd-counters-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::get_children()
{
    if(children.find("bfd-counters-bundle-children-members") == children.end())
    {
        if(bfd_counters_bundle_children_members != nullptr)
        {
            children["bfd-counters-bundle-children-members"] = bfd_counters_bundle_children_members.get();
        }
    }

    if(children.find("bfd-counters-bundle-descendant") == children.end())
    {
        if(bfd_counters_bundle_descendant != nullptr)
        {
            children["bfd-counters-bundle-descendant"] = bfd_counters_bundle_descendant.get();
        }
    }

    if(children.find("bfd-counters-bundle-item") == children.end())
    {
        if(bfd_counters_bundle_item != nullptr)
        {
            children["bfd-counters-bundle-item"] = bfd_counters_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundles()
{
    yang_name = "bfd-counters-bundles"; yang_parent_name = "bfd-counters";
}

BundleInformation::BfdCounters::BfdCountersBundles::~BfdCountersBundles()
{
}

bool BundleInformation::BfdCounters::BfdCountersBundles::has_data() const
{
    for (std::size_t index=0; index<bfd_counters_bundle.size(); index++)
    {
        if(bfd_counters_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::BfdCounters::BfdCountersBundles::has_operation() const
{
    for (std::size_t index=0; index<bfd_counters_bundle.size(); index++)
    {
        if(bfd_counters_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::BfdCounters::BfdCountersBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bfd-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters-bundle")
    {
        for(auto const & c : bfd_counters_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles::BfdCountersBundle>();
        c->parent = this;
        bfd_counters_bundle.push_back(std::move(c));
        children[segment_path] = bfd_counters_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersBundles::get_children()
{
    for (auto const & c : bfd_counters_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::BfdCountersBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::BfdCountersMemberItem()
    :
    	down{YType::uint32, "down"},
	 last_time_cleared{YType::uint64, "last-time-cleared"},
	 member_name{YType::str, "member-name"},
	 neighbor_unconfigured{YType::uint32, "neighbor-unconfigured"},
	 neighbor_unconfigured_timeouts{YType::uint32, "neighbor-unconfigured-timeouts"},
	 start_timeouts{YType::uint32, "start-timeouts"},
	 starting{YType::uint32, "starting"},
	 time_since_cleared{YType::uint64, "time-since-cleared"},
	 up{YType::uint32, "up"}
{
    yang_name = "bfd-counters-member-item"; yang_parent_name = "bfd-counters-member";
}

BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::~BfdCountersMemberItem()
{
}

bool BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::has_data() const
{
    return down.is_set
	|| last_time_cleared.is_set
	|| member_name.is_set
	|| neighbor_unconfigured.is_set
	|| neighbor_unconfigured_timeouts.is_set
	|| start_timeouts.is_set
	|| starting.is_set
	|| time_since_cleared.is_set
	|| up.is_set;
}

bool BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::has_operation() const
{
    return is_set(operation)
	|| is_set(down.operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(member_name.operation)
	|| is_set(neighbor_unconfigured.operation)
	|| is_set(neighbor_unconfigured_timeouts.operation)
	|| is_set(start_timeouts.operation)
	|| is_set(starting.operation)
	|| is_set(time_since_cleared.operation)
	|| is_set(up.operation);
}

std::string BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-member-item";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down.is_set || is_set(down.operation)) leaf_name_data.push_back(down.get_name_leafdata());
    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (neighbor_unconfigured.is_set || is_set(neighbor_unconfigured.operation)) leaf_name_data.push_back(neighbor_unconfigured.get_name_leafdata());
    if (neighbor_unconfigured_timeouts.is_set || is_set(neighbor_unconfigured_timeouts.operation)) leaf_name_data.push_back(neighbor_unconfigured_timeouts.get_name_leafdata());
    if (start_timeouts.is_set || is_set(start_timeouts.operation)) leaf_name_data.push_back(start_timeouts.get_name_leafdata());
    if (starting.is_set || is_set(starting.operation)) leaf_name_data.push_back(starting.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());
    if (up.is_set || is_set(up.operation)) leaf_name_data.push_back(up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::get_children()
{
    return children;
}

void BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down")
    {
        down = value;
    }
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "neighbor-unconfigured")
    {
        neighbor_unconfigured = value;
    }
    if(value_path == "neighbor-unconfigured-timeouts")
    {
        neighbor_unconfigured_timeouts = value;
    }
    if(value_path == "start-timeouts")
    {
        start_timeouts = value;
    }
    if(value_path == "starting")
    {
        starting = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
    if(value_path == "up")
    {
        up = value;
    }
}

BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    bfd_counters_member_item(std::make_unique<BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem>())
{
    bfd_counters_member_item->parent = this;
    children["bfd-counters-member-item"] = bfd_counters_member_item.get();

    yang_name = "bfd-counters-member"; yang_parent_name = "bfd-counters-members";
}

BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::~BfdCountersMember()
{
}

bool BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::has_data() const
{
    return member_interface.is_set
	|| (bfd_counters_member_item !=  nullptr && bfd_counters_member_item->has_data());
}

bool BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (bfd_counters_member_item !=  nullptr && bfd_counters_member_item->has_operation());
}

std::string BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bfd-counters/bfd-counters-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters-member-item")
    {
        if(bfd_counters_member_item != nullptr)
        {
            children["bfd-counters-member-item"] = bfd_counters_member_item.get();
        }
        else
        {
            bfd_counters_member_item = std::make_unique<BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::BfdCountersMemberItem>();
            bfd_counters_member_item->parent = this;
            children["bfd-counters-member-item"] = bfd_counters_member_item.get();
        }
        return children.at("bfd-counters-member-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::get_children()
{
    if(children.find("bfd-counters-member-item") == children.end())
    {
        if(bfd_counters_member_item != nullptr)
        {
            children["bfd-counters-member-item"] = bfd_counters_member_item.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMembers()
{
    yang_name = "bfd-counters-members"; yang_parent_name = "bfd-counters";
}

BundleInformation::BfdCounters::BfdCountersMembers::~BfdCountersMembers()
{
}

bool BundleInformation::BfdCounters::BfdCountersMembers::has_data() const
{
    for (std::size_t index=0; index<bfd_counters_member.size(); index++)
    {
        if(bfd_counters_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::BfdCounters::BfdCountersMembers::has_operation() const
{
    for (std::size_t index=0; index<bfd_counters_member.size(); index++)
    {
        if(bfd_counters_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::BfdCounters::BfdCountersMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters-members";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::BfdCountersMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bfd-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::BfdCountersMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters-member")
    {
        for(auto const & c : bfd_counters_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::BfdCounters::BfdCountersMembers::BfdCountersMember>();
        c->parent = this;
        bfd_counters_member.push_back(std::move(c));
        children[segment_path] = bfd_counters_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::BfdCountersMembers::get_children()
{
    for (auto const & c : bfd_counters_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::BfdCountersMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::BfdCounters::BfdCounters()
    :
    bfd_counters_bundles(std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles>())
	,bfd_counters_members(std::make_unique<BundleInformation::BfdCounters::BfdCountersMembers>())
{
    bfd_counters_bundles->parent = this;
    children["bfd-counters-bundles"] = bfd_counters_bundles.get();

    bfd_counters_members->parent = this;
    children["bfd-counters-members"] = bfd_counters_members.get();

    yang_name = "bfd-counters"; yang_parent_name = "bundle-information";
}

BundleInformation::BfdCounters::~BfdCounters()
{
}

bool BundleInformation::BfdCounters::has_data() const
{
    return (bfd_counters_bundles !=  nullptr && bfd_counters_bundles->has_data())
	|| (bfd_counters_members !=  nullptr && bfd_counters_members->has_data());
}

bool BundleInformation::BfdCounters::has_operation() const
{
    return is_set(operation)
	|| (bfd_counters_bundles !=  nullptr && bfd_counters_bundles->has_operation())
	|| (bfd_counters_members !=  nullptr && bfd_counters_members->has_operation());
}

std::string BundleInformation::BfdCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::BfdCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BfdCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters-bundles")
    {
        if(bfd_counters_bundles != nullptr)
        {
            children["bfd-counters-bundles"] = bfd_counters_bundles.get();
        }
        else
        {
            bfd_counters_bundles = std::make_unique<BundleInformation::BfdCounters::BfdCountersBundles>();
            bfd_counters_bundles->parent = this;
            children["bfd-counters-bundles"] = bfd_counters_bundles.get();
        }
        return children.at("bfd-counters-bundles");
    }

    if(child_yang_name == "bfd-counters-members")
    {
        if(bfd_counters_members != nullptr)
        {
            children["bfd-counters-members"] = bfd_counters_members.get();
        }
        else
        {
            bfd_counters_members = std::make_unique<BundleInformation::BfdCounters::BfdCountersMembers>();
            bfd_counters_members->parent = this;
            children["bfd-counters-members"] = bfd_counters_members.get();
        }
        return children.at("bfd-counters-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BfdCounters::get_children()
{
    if(children.find("bfd-counters-bundles") == children.end())
    {
        if(bfd_counters_bundles != nullptr)
        {
            children["bfd-counters-bundles"] = bfd_counters_bundles.get();
        }
    }

    if(children.find("bfd-counters-members") == children.end())
    {
        if(bfd_counters_members != nullptr)
        {
            children["bfd-counters-members"] = bfd_counters_members.get();
        }
    }

    return children;
}

void BundleInformation::BfdCounters::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::ScheduledAction()
    :
    	action_state{YType::enumeration, "action-state"},
	 mlacp_action{YType::enumeration, "mlacp-action"},
	 time_remaining{YType::uint64, "time-remaining"}
{
    yang_name = "scheduled-action"; yang_parent_name = "scheduled-actions-bundle-item";
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::~ScheduledAction()
{
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::has_data() const
{
    return action_state.is_set
	|| mlacp_action.is_set
	|| time_remaining.is_set;
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::has_operation() const
{
    return is_set(operation)
	|| is_set(action_state.operation)
	|| is_set(mlacp_action.operation)
	|| is_set(time_remaining.operation);
}

std::string BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "scheduled-action";

    return path_buffer.str();

}

EntityPath BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (action_state.is_set || is_set(action_state.operation)) leaf_name_data.push_back(action_state.get_name_leafdata());
    if (mlacp_action.is_set || is_set(mlacp_action.operation)) leaf_name_data.push_back(mlacp_action.get_name_leafdata());
    if (time_remaining.is_set || is_set(time_remaining.operation)) leaf_name_data.push_back(time_remaining.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::get_children()
{
    return children;
}

void BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "action-state")
    {
        action_state = value;
    }
    if(value_path == "mlacp-action")
    {
        mlacp_action = value;
    }
    if(value_path == "time-remaining")
    {
        time_remaining = value;
    }
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledActionsBundleItem()
    :
    	bundle_name{YType::str, "bundle-name"}
{
    yang_name = "scheduled-actions-bundle-item"; yang_parent_name = "scheduled-actions-bundle";
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::~ScheduledActionsBundleItem()
{
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::has_data() const
{
    for (std::size_t index=0; index<scheduled_action.size(); index++)
    {
        if(scheduled_action[index]->has_data())
            return true;
    }
    return bundle_name.is_set;
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::has_operation() const
{
    for (std::size_t index=0; index<scheduled_action.size(); index++)
    {
        if(scheduled_action[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(bundle_name.operation);
}

std::string BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "scheduled-actions-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "scheduled-action")
    {
        for(auto const & c : scheduled_action)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::ScheduledAction>();
        c->parent = this;
        scheduled_action.push_back(std::move(c));
        children[segment_path] = scheduled_action.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::get_children()
{
    for (auto const & c : scheduled_action)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    scheduled_actions_bundle_item(std::make_unique<BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem>())
{
    scheduled_actions_bundle_item->parent = this;
    children["scheduled-actions-bundle-item"] = scheduled_actions_bundle_item.get();

    yang_name = "scheduled-actions-bundle"; yang_parent_name = "scheduled-actions-bundles";
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::~ScheduledActionsBundle()
{
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::has_data() const
{
    return bundle_interface.is_set
	|| (scheduled_actions_bundle_item !=  nullptr && scheduled_actions_bundle_item->has_data());
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (scheduled_actions_bundle_item !=  nullptr && scheduled_actions_bundle_item->has_operation());
}

std::string BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "scheduled-actions-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/scheduled-actions/scheduled-actions-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "scheduled-actions-bundle-item")
    {
        if(scheduled_actions_bundle_item != nullptr)
        {
            children["scheduled-actions-bundle-item"] = scheduled_actions_bundle_item.get();
        }
        else
        {
            scheduled_actions_bundle_item = std::make_unique<BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::ScheduledActionsBundleItem>();
            scheduled_actions_bundle_item->parent = this;
            children["scheduled-actions-bundle-item"] = scheduled_actions_bundle_item.get();
        }
        return children.at("scheduled-actions-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::get_children()
{
    if(children.find("scheduled-actions-bundle-item") == children.end())
    {
        if(scheduled_actions_bundle_item != nullptr)
        {
            children["scheduled-actions-bundle-item"] = scheduled_actions_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundles()
{
    yang_name = "scheduled-actions-bundles"; yang_parent_name = "scheduled-actions";
}

BundleInformation::ScheduledActions::ScheduledActionsBundles::~ScheduledActionsBundles()
{
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::has_data() const
{
    for (std::size_t index=0; index<scheduled_actions_bundle.size(); index++)
    {
        if(scheduled_actions_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::ScheduledActions::ScheduledActionsBundles::has_operation() const
{
    for (std::size_t index=0; index<scheduled_actions_bundle.size(); index++)
    {
        if(scheduled_actions_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::ScheduledActions::ScheduledActionsBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "scheduled-actions-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::ScheduledActions::ScheduledActionsBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/scheduled-actions/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::ScheduledActions::ScheduledActionsBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "scheduled-actions-bundle")
    {
        for(auto const & c : scheduled_actions_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::ScheduledActions::ScheduledActionsBundles::ScheduledActionsBundle>();
        c->parent = this;
        scheduled_actions_bundle.push_back(std::move(c));
        children[segment_path] = scheduled_actions_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::ScheduledActions::ScheduledActionsBundles::get_children()
{
    for (auto const & c : scheduled_actions_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::ScheduledActions::ScheduledActionsBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::ScheduledActions::ScheduledActions()
    :
    scheduled_actions_bundles(std::make_unique<BundleInformation::ScheduledActions::ScheduledActionsBundles>())
{
    scheduled_actions_bundles->parent = this;
    children["scheduled-actions-bundles"] = scheduled_actions_bundles.get();

    yang_name = "scheduled-actions"; yang_parent_name = "bundle-information";
}

BundleInformation::ScheduledActions::~ScheduledActions()
{
}

bool BundleInformation::ScheduledActions::has_data() const
{
    return (scheduled_actions_bundles !=  nullptr && scheduled_actions_bundles->has_data());
}

bool BundleInformation::ScheduledActions::has_operation() const
{
    return is_set(operation)
	|| (scheduled_actions_bundles !=  nullptr && scheduled_actions_bundles->has_operation());
}

std::string BundleInformation::ScheduledActions::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "scheduled-actions";

    return path_buffer.str();

}

EntityPath BundleInformation::ScheduledActions::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::ScheduledActions::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "scheduled-actions-bundles")
    {
        if(scheduled_actions_bundles != nullptr)
        {
            children["scheduled-actions-bundles"] = scheduled_actions_bundles.get();
        }
        else
        {
            scheduled_actions_bundles = std::make_unique<BundleInformation::ScheduledActions::ScheduledActionsBundles>();
            scheduled_actions_bundles->parent = this;
            children["scheduled-actions-bundles"] = scheduled_actions_bundles.get();
        }
        return children.at("scheduled-actions-bundles");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::ScheduledActions::get_children()
{
    if(children.find("scheduled-actions-bundles") == children.end())
    {
        if(scheduled_actions_bundles != nullptr)
        {
            children["scheduled-actions-bundles"] = scheduled_actions_bundles.get();
        }
    }

    return children;
}

void BundleInformation::ScheduledActions::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "bundle-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "bundle-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BundleData()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "bundle-data"; yang_parent_name = "bundle-bundle-descendant";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::~BundleData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"}
{
    yang_name = "counters"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::~Counters()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::LinkData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "link-data"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::~LinkData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::MemberMuxStateReasonData()
    :
    	reason_type{YType::enumeration, "reason-type"},
	 severity{YType::enumeration, "severity"}
{
    yang_name = "member-mux-state-reason-data"; yang_parent_name = "member-mux-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::~MemberMuxStateReasonData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::has_data() const
{
    return reason_type.is_set
	|| severity.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_type.operation)
	|| is_set(severity.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-state-reason-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_type.is_set || is_set(reason_type.operation)) leaf_name_data.push_back(reason_type.get_name_leafdata());
    if (severity.is_set || is_set(severity.operation)) leaf_name_data.push_back(severity.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-type")
    {
        reason_type = value;
    }
    if(value_path == "severity")
    {
        severity = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxData()
    :
    	error{YType::uint32, "error"},
	 member_mux_state_reason{YType::enumeration, "member-mux-state-reason"},
	 member_state{YType::enumeration, "member-state"},
	 mux_state{YType::enumeration, "mux-state"},
	 mux_state_reason{YType::enumeration, "mux-state-reason"}
    	,
    member_mux_state_reason_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData>())
{
    member_mux_state_reason_data->parent = this;
    children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();

    yang_name = "member-mux-data"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::~MemberMuxData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::has_data() const
{
    return error.is_set
	|| member_mux_state_reason.is_set
	|| member_state.is_set
	|| mux_state.is_set
	|| mux_state_reason.is_set
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::has_operation() const
{
    return is_set(operation)
	|| is_set(error.operation)
	|| is_set(member_mux_state_reason.operation)
	|| is_set(member_state.operation)
	|| is_set(mux_state.operation)
	|| is_set(mux_state_reason.operation)
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (member_mux_state_reason.is_set || is_set(member_mux_state_reason.operation)) leaf_name_data.push_back(member_mux_state_reason.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (mux_state_reason.is_set || is_set(mux_state_reason.operation)) leaf_name_data.push_back(mux_state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-mux-state-reason-data")
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        else
        {
            member_mux_state_reason_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::MemberMuxStateReasonData>();
            member_mux_state_reason_data->parent = this;
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        return children.at("member-mux-state-reason-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::get_children()
{
    if(children.find("member-mux-state-reason-data") == children.end())
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "member-mux-state-reason")
    {
        member_mux_state_reason = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "mux-state-reason")
    {
        mux_state_reason = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberData()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 iccp_node{YType::uint32, "iccp-node"},
	 interface_name{YType::str, "interface-name"},
	 link_order_number{YType::uint16, "link-order-number"},
	 member_name{YType::str, "member-name"},
	 member_type{YType::enumeration, "member-type"},
	 port_number{YType::uint16, "port-number"},
	 port_priority{YType::uint16, "port-priority"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
    	,
    counters(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters>())
	,link_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData>())
	,mac_address(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress>())
	,member_mux_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    link_data->parent = this;
    children["link-data"] = link_data.get();

    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    member_mux_data->parent = this;
    children["member-mux-data"] = member_mux_data.get();

    yang_name = "member-data"; yang_parent_name = "bundle-bundle-descendant";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::~MemberData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::has_data() const
{
    return bandwidth.is_set
	|| iccp_node.is_set
	|| interface_name.is_set
	|| link_order_number.is_set
	|| member_name.is_set
	|| member_type.is_set
	|| port_number.is_set
	|| port_priority.is_set
	|| underlying_link_id.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (link_data !=  nullptr && link_data->has_data())
	|| (mac_address !=  nullptr && mac_address->has_data())
	|| (member_mux_data !=  nullptr && member_mux_data->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(iccp_node.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_order_number.operation)
	|| is_set(member_name.operation)
	|| is_set(member_type.operation)
	|| is_set(port_number.operation)
	|| is_set(port_priority.operation)
	|| is_set(underlying_link_id.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (link_data !=  nullptr && link_data->has_operation())
	|| (mac_address !=  nullptr && mac_address->has_operation())
	|| (member_mux_data !=  nullptr && member_mux_data->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (iccp_node.is_set || is_set(iccp_node.operation)) leaf_name_data.push_back(iccp_node.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (member_type.is_set || is_set(member_type.operation)) leaf_name_data.push_back(member_type.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "link-data")
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
        else
        {
            link_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::LinkData>();
            link_data->parent = this;
            children["link-data"] = link_data.get();
        }
        return children.at("link-data");
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    if(child_yang_name == "member-mux-data")
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
        else
        {
            member_mux_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::MemberMuxData>();
            member_mux_data->parent = this;
            children["member-mux-data"] = member_mux_data.get();
        }
        return children.at("member-mux-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("link-data") == children.end())
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    if(children.find("member-mux-data") == children.end())
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "iccp-node")
    {
        iccp_node = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "member-type")
    {
        member_type = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleBundleDescendant()
    :
    bundle_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "bundle-bundle-descendant"; yang_parent_name = "bundle-bundle";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::~BundleBundleDescendant()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-bundle-descendant";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"}
{
    yang_name = "counters"; yang_parent_name = "bundle-bundle-children-member";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::~Counters()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::LinkData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "link-data"; yang_parent_name = "bundle-bundle-children-member";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::~LinkData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::MemberMuxStateReasonData()
    :
    	reason_type{YType::enumeration, "reason-type"},
	 severity{YType::enumeration, "severity"}
{
    yang_name = "member-mux-state-reason-data"; yang_parent_name = "member-mux-data";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::~MemberMuxStateReasonData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::has_data() const
{
    return reason_type.is_set
	|| severity.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_type.operation)
	|| is_set(severity.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-state-reason-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_type.is_set || is_set(reason_type.operation)) leaf_name_data.push_back(reason_type.get_name_leafdata());
    if (severity.is_set || is_set(severity.operation)) leaf_name_data.push_back(severity.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-type")
    {
        reason_type = value;
    }
    if(value_path == "severity")
    {
        severity = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxData()
    :
    	error{YType::uint32, "error"},
	 member_mux_state_reason{YType::enumeration, "member-mux-state-reason"},
	 member_state{YType::enumeration, "member-state"},
	 mux_state{YType::enumeration, "mux-state"},
	 mux_state_reason{YType::enumeration, "mux-state-reason"}
    	,
    member_mux_state_reason_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData>())
{
    member_mux_state_reason_data->parent = this;
    children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();

    yang_name = "member-mux-data"; yang_parent_name = "bundle-bundle-children-member";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::~MemberMuxData()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::has_data() const
{
    return error.is_set
	|| member_mux_state_reason.is_set
	|| member_state.is_set
	|| mux_state.is_set
	|| mux_state_reason.is_set
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::has_operation() const
{
    return is_set(operation)
	|| is_set(error.operation)
	|| is_set(member_mux_state_reason.operation)
	|| is_set(member_state.operation)
	|| is_set(mux_state.operation)
	|| is_set(mux_state_reason.operation)
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (member_mux_state_reason.is_set || is_set(member_mux_state_reason.operation)) leaf_name_data.push_back(member_mux_state_reason.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (mux_state_reason.is_set || is_set(mux_state_reason.operation)) leaf_name_data.push_back(mux_state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-mux-state-reason-data")
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        else
        {
            member_mux_state_reason_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::MemberMuxStateReasonData>();
            member_mux_state_reason_data->parent = this;
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        return children.at("member-mux-state-reason-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::get_children()
{
    if(children.find("member-mux-state-reason-data") == children.end())
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "member-mux-state-reason")
    {
        member_mux_state_reason = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "mux-state-reason")
    {
        mux_state_reason = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "bundle-bundle-children-member";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::BundleBundleChildrenMember()
    :
    	member_interface{YType::str, "member-interface"},
	 bandwidth{YType::uint32, "bandwidth"},
	 iccp_node{YType::uint32, "iccp-node"},
	 interface_name{YType::str, "interface-name"},
	 link_order_number{YType::uint16, "link-order-number"},
	 member_name{YType::str, "member-name"},
	 member_type{YType::enumeration, "member-type"},
	 port_number{YType::uint16, "port-number"},
	 port_priority{YType::uint16, "port-priority"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
    	,
    counters(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters>())
	,link_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData>())
	,mac_address(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress>())
	,member_mux_data(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    link_data->parent = this;
    children["link-data"] = link_data.get();

    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    member_mux_data->parent = this;
    children["member-mux-data"] = member_mux_data.get();

    yang_name = "bundle-bundle-children-member"; yang_parent_name = "bundle-bundle-children-members";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::~BundleBundleChildrenMember()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::has_data() const
{
    return member_interface.is_set
	|| bandwidth.is_set
	|| iccp_node.is_set
	|| interface_name.is_set
	|| link_order_number.is_set
	|| member_name.is_set
	|| member_type.is_set
	|| port_number.is_set
	|| port_priority.is_set
	|| underlying_link_id.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (link_data !=  nullptr && link_data->has_data())
	|| (mac_address !=  nullptr && mac_address->has_data())
	|| (member_mux_data !=  nullptr && member_mux_data->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(bandwidth.operation)
	|| is_set(iccp_node.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_order_number.operation)
	|| is_set(member_name.operation)
	|| is_set(member_type.operation)
	|| is_set(port_number.operation)
	|| is_set(port_priority.operation)
	|| is_set(underlying_link_id.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (link_data !=  nullptr && link_data->has_operation())
	|| (mac_address !=  nullptr && mac_address->has_operation())
	|| (member_mux_data !=  nullptr && member_mux_data->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-bundle-children-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (iccp_node.is_set || is_set(iccp_node.operation)) leaf_name_data.push_back(iccp_node.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (member_type.is_set || is_set(member_type.operation)) leaf_name_data.push_back(member_type.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "link-data")
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
        else
        {
            link_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::LinkData>();
            link_data->parent = this;
            children["link-data"] = link_data.get();
        }
        return children.at("link-data");
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    if(child_yang_name == "member-mux-data")
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
        else
        {
            member_mux_data = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::MemberMuxData>();
            member_mux_data->parent = this;
            children["member-mux-data"] = member_mux_data.get();
        }
        return children.at("member-mux-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("link-data") == children.end())
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    if(children.find("member-mux-data") == children.end())
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "iccp-node")
    {
        iccp_node = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "member-type")
    {
        member_type = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMembers()
{
    yang_name = "bundle-bundle-children-members"; yang_parent_name = "bundle-bundle";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::~BundleBundleChildrenMembers()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::has_data() const
{
    for (std::size_t index=0; index<bundle_bundle_children_member.size(); index++)
    {
        if(bundle_bundle_children_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::has_operation() const
{
    for (std::size_t index=0; index<bundle_bundle_children_member.size(); index++)
    {
        if(bundle_bundle_children_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-bundle-children-members";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-bundle-children-member")
    {
        for(auto const & c : bundle_bundle_children_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::BundleBundleChildrenMember>();
        c->parent = this;
        bundle_bundle_children_member.push_back(std::move(c));
        children[segment_path] = bundle_bundle_children_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::get_children()
{
    for (auto const & c : bundle_bundle_children_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "bundle-bundle-item";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "bundle-bundle-item";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BundleBundleItem()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "bundle-bundle-item"; yang_parent_name = "bundle-bundle";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::~BundleBundleItem()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    bundle_bundle_children_members(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers>())
	,bundle_bundle_descendant(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant>())
	,bundle_bundle_item(std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem>())
{
    bundle_bundle_children_members->parent = this;
    children["bundle-bundle-children-members"] = bundle_bundle_children_members.get();

    bundle_bundle_descendant->parent = this;
    children["bundle-bundle-descendant"] = bundle_bundle_descendant.get();

    bundle_bundle_item->parent = this;
    children["bundle-bundle-item"] = bundle_bundle_item.get();

    yang_name = "bundle-bundle"; yang_parent_name = "bundle-bundles";
}

BundleInformation::Bundle::BundleBundles::BundleBundle::~BundleBundle()
{
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::has_data() const
{
    return bundle_interface.is_set
	|| (bundle_bundle_children_members !=  nullptr && bundle_bundle_children_members->has_data())
	|| (bundle_bundle_descendant !=  nullptr && bundle_bundle_descendant->has_data())
	|| (bundle_bundle_item !=  nullptr && bundle_bundle_item->has_data());
}

bool BundleInformation::Bundle::BundleBundles::BundleBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (bundle_bundle_children_members !=  nullptr && bundle_bundle_children_members->has_operation())
	|| (bundle_bundle_descendant !=  nullptr && bundle_bundle_descendant->has_operation())
	|| (bundle_bundle_item !=  nullptr && bundle_bundle_item->has_operation());
}

std::string BundleInformation::Bundle::BundleBundles::BundleBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::BundleBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bundle/bundle-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::BundleBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-bundle-children-members")
    {
        if(bundle_bundle_children_members != nullptr)
        {
            children["bundle-bundle-children-members"] = bundle_bundle_children_members.get();
        }
        else
        {
            bundle_bundle_children_members = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleChildrenMembers>();
            bundle_bundle_children_members->parent = this;
            children["bundle-bundle-children-members"] = bundle_bundle_children_members.get();
        }
        return children.at("bundle-bundle-children-members");
    }

    if(child_yang_name == "bundle-bundle-descendant")
    {
        if(bundle_bundle_descendant != nullptr)
        {
            children["bundle-bundle-descendant"] = bundle_bundle_descendant.get();
        }
        else
        {
            bundle_bundle_descendant = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleDescendant>();
            bundle_bundle_descendant->parent = this;
            children["bundle-bundle-descendant"] = bundle_bundle_descendant.get();
        }
        return children.at("bundle-bundle-descendant");
    }

    if(child_yang_name == "bundle-bundle-item")
    {
        if(bundle_bundle_item != nullptr)
        {
            children["bundle-bundle-item"] = bundle_bundle_item.get();
        }
        else
        {
            bundle_bundle_item = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle::BundleBundleItem>();
            bundle_bundle_item->parent = this;
            children["bundle-bundle-item"] = bundle_bundle_item.get();
        }
        return children.at("bundle-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::BundleBundle::get_children()
{
    if(children.find("bundle-bundle-children-members") == children.end())
    {
        if(bundle_bundle_children_members != nullptr)
        {
            children["bundle-bundle-children-members"] = bundle_bundle_children_members.get();
        }
    }

    if(children.find("bundle-bundle-descendant") == children.end())
    {
        if(bundle_bundle_descendant != nullptr)
        {
            children["bundle-bundle-descendant"] = bundle_bundle_descendant.get();
        }
    }

    if(children.find("bundle-bundle-item") == children.end())
    {
        if(bundle_bundle_item != nullptr)
        {
            children["bundle-bundle-item"] = bundle_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::BundleBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::Bundle::BundleBundles::BundleBundles()
{
    yang_name = "bundle-bundles"; yang_parent_name = "bundle";
}

BundleInformation::Bundle::BundleBundles::~BundleBundles()
{
}

bool BundleInformation::Bundle::BundleBundles::has_data() const
{
    for (std::size_t index=0; index<bundle_bundle.size(); index++)
    {
        if(bundle_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Bundle::BundleBundles::has_operation() const
{
    for (std::size_t index=0; index<bundle_bundle.size(); index++)
    {
        if(bundle_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Bundle::BundleBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bundle/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-bundle")
    {
        for(auto const & c : bundle_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleBundles::BundleBundle>();
        c->parent = this;
        bundle_bundle.push_back(std::move(c));
        children[segment_path] = bundle_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleBundles::get_children()
{
    for (auto const & c : bundle_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "bundle-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "bundle-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BundleData()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "bundle-data"; yang_parent_name = "bundle-member-ancestor";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::~BundleData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"}
{
    yang_name = "counters"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::~Counters()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::LinkData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "link-data"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::~LinkData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::MemberMuxStateReasonData()
    :
    	reason_type{YType::enumeration, "reason-type"},
	 severity{YType::enumeration, "severity"}
{
    yang_name = "member-mux-state-reason-data"; yang_parent_name = "member-mux-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::~MemberMuxStateReasonData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::has_data() const
{
    return reason_type.is_set
	|| severity.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_type.operation)
	|| is_set(severity.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-state-reason-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_type.is_set || is_set(reason_type.operation)) leaf_name_data.push_back(reason_type.get_name_leafdata());
    if (severity.is_set || is_set(severity.operation)) leaf_name_data.push_back(severity.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-type")
    {
        reason_type = value;
    }
    if(value_path == "severity")
    {
        severity = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxData()
    :
    	error{YType::uint32, "error"},
	 member_mux_state_reason{YType::enumeration, "member-mux-state-reason"},
	 member_state{YType::enumeration, "member-state"},
	 mux_state{YType::enumeration, "mux-state"},
	 mux_state_reason{YType::enumeration, "mux-state-reason"}
    	,
    member_mux_state_reason_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData>())
{
    member_mux_state_reason_data->parent = this;
    children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();

    yang_name = "member-mux-data"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::~MemberMuxData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::has_data() const
{
    return error.is_set
	|| member_mux_state_reason.is_set
	|| member_state.is_set
	|| mux_state.is_set
	|| mux_state_reason.is_set
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::has_operation() const
{
    return is_set(operation)
	|| is_set(error.operation)
	|| is_set(member_mux_state_reason.operation)
	|| is_set(member_state.operation)
	|| is_set(mux_state.operation)
	|| is_set(mux_state_reason.operation)
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (member_mux_state_reason.is_set || is_set(member_mux_state_reason.operation)) leaf_name_data.push_back(member_mux_state_reason.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (mux_state_reason.is_set || is_set(mux_state_reason.operation)) leaf_name_data.push_back(mux_state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-mux-state-reason-data")
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        else
        {
            member_mux_state_reason_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::MemberMuxStateReasonData>();
            member_mux_state_reason_data->parent = this;
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        return children.at("member-mux-state-reason-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::get_children()
{
    if(children.find("member-mux-state-reason-data") == children.end())
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "member-mux-state-reason")
    {
        member_mux_state_reason = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "mux-state-reason")
    {
        mux_state_reason = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "member-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberData()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 iccp_node{YType::uint32, "iccp-node"},
	 interface_name{YType::str, "interface-name"},
	 link_order_number{YType::uint16, "link-order-number"},
	 member_name{YType::str, "member-name"},
	 member_type{YType::enumeration, "member-type"},
	 port_number{YType::uint16, "port-number"},
	 port_priority{YType::uint16, "port-priority"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
    	,
    counters(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters>())
	,link_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData>())
	,mac_address(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress>())
	,member_mux_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    link_data->parent = this;
    children["link-data"] = link_data.get();

    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    member_mux_data->parent = this;
    children["member-mux-data"] = member_mux_data.get();

    yang_name = "member-data"; yang_parent_name = "bundle-member-ancestor";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::~MemberData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::has_data() const
{
    return bandwidth.is_set
	|| iccp_node.is_set
	|| interface_name.is_set
	|| link_order_number.is_set
	|| member_name.is_set
	|| member_type.is_set
	|| port_number.is_set
	|| port_priority.is_set
	|| underlying_link_id.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (link_data !=  nullptr && link_data->has_data())
	|| (mac_address !=  nullptr && mac_address->has_data())
	|| (member_mux_data !=  nullptr && member_mux_data->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(iccp_node.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_order_number.operation)
	|| is_set(member_name.operation)
	|| is_set(member_type.operation)
	|| is_set(port_number.operation)
	|| is_set(port_priority.operation)
	|| is_set(underlying_link_id.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (link_data !=  nullptr && link_data->has_operation())
	|| (mac_address !=  nullptr && mac_address->has_operation())
	|| (member_mux_data !=  nullptr && member_mux_data->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (iccp_node.is_set || is_set(iccp_node.operation)) leaf_name_data.push_back(iccp_node.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (member_type.is_set || is_set(member_type.operation)) leaf_name_data.push_back(member_type.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "link-data")
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
        else
        {
            link_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::LinkData>();
            link_data->parent = this;
            children["link-data"] = link_data.get();
        }
        return children.at("link-data");
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    if(child_yang_name == "member-mux-data")
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
        else
        {
            member_mux_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::MemberMuxData>();
            member_mux_data->parent = this;
            children["member-mux-data"] = member_mux_data.get();
        }
        return children.at("member-mux-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("link-data") == children.end())
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    if(children.find("member-mux-data") == children.end())
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "iccp-node")
    {
        iccp_node = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "member-type")
    {
        member_type = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleMemberAncestor()
    :
    bundle_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "bundle-member-ancestor"; yang_parent_name = "bundle-member";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::~BundleMemberAncestor()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-member-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"}
{
    yang_name = "counters"; yang_parent_name = "bundle-member-item";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::~Counters()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::LinkData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "link-data"; yang_parent_name = "bundle-member-item";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::~LinkData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::MemberMuxStateReasonData()
    :
    	reason_type{YType::enumeration, "reason-type"},
	 severity{YType::enumeration, "severity"}
{
    yang_name = "member-mux-state-reason-data"; yang_parent_name = "member-mux-data";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::~MemberMuxStateReasonData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::has_data() const
{
    return reason_type.is_set
	|| severity.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_type.operation)
	|| is_set(severity.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-state-reason-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_type.is_set || is_set(reason_type.operation)) leaf_name_data.push_back(reason_type.get_name_leafdata());
    if (severity.is_set || is_set(severity.operation)) leaf_name_data.push_back(severity.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-type")
    {
        reason_type = value;
    }
    if(value_path == "severity")
    {
        severity = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxData()
    :
    	error{YType::uint32, "error"},
	 member_mux_state_reason{YType::enumeration, "member-mux-state-reason"},
	 member_state{YType::enumeration, "member-state"},
	 mux_state{YType::enumeration, "mux-state"},
	 mux_state_reason{YType::enumeration, "mux-state-reason"}
    	,
    member_mux_state_reason_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData>())
{
    member_mux_state_reason_data->parent = this;
    children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();

    yang_name = "member-mux-data"; yang_parent_name = "bundle-member-item";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::~MemberMuxData()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::has_data() const
{
    return error.is_set
	|| member_mux_state_reason.is_set
	|| member_state.is_set
	|| mux_state.is_set
	|| mux_state_reason.is_set
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::has_operation() const
{
    return is_set(operation)
	|| is_set(error.operation)
	|| is_set(member_mux_state_reason.operation)
	|| is_set(member_state.operation)
	|| is_set(mux_state.operation)
	|| is_set(mux_state_reason.operation)
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (member_mux_state_reason.is_set || is_set(member_mux_state_reason.operation)) leaf_name_data.push_back(member_mux_state_reason.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (mux_state_reason.is_set || is_set(mux_state_reason.operation)) leaf_name_data.push_back(mux_state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-mux-state-reason-data")
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        else
        {
            member_mux_state_reason_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::MemberMuxStateReasonData>();
            member_mux_state_reason_data->parent = this;
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        return children.at("member-mux-state-reason-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::get_children()
{
    if(children.find("member-mux-state-reason-data") == children.end())
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "member-mux-state-reason")
    {
        member_mux_state_reason = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "mux-state-reason")
    {
        mux_state_reason = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "bundle-member-item";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::~MacAddress()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::BundleMemberItem()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 iccp_node{YType::uint32, "iccp-node"},
	 interface_name{YType::str, "interface-name"},
	 link_order_number{YType::uint16, "link-order-number"},
	 member_name{YType::str, "member-name"},
	 member_type{YType::enumeration, "member-type"},
	 port_number{YType::uint16, "port-number"},
	 port_priority{YType::uint16, "port-priority"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
    	,
    counters(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters>())
	,link_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData>())
	,mac_address(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress>())
	,member_mux_data(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    link_data->parent = this;
    children["link-data"] = link_data.get();

    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    member_mux_data->parent = this;
    children["member-mux-data"] = member_mux_data.get();

    yang_name = "bundle-member-item"; yang_parent_name = "bundle-member";
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::~BundleMemberItem()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::has_data() const
{
    return bandwidth.is_set
	|| iccp_node.is_set
	|| interface_name.is_set
	|| link_order_number.is_set
	|| member_name.is_set
	|| member_type.is_set
	|| port_number.is_set
	|| port_priority.is_set
	|| underlying_link_id.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (link_data !=  nullptr && link_data->has_data())
	|| (mac_address !=  nullptr && mac_address->has_data())
	|| (member_mux_data !=  nullptr && member_mux_data->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(iccp_node.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_order_number.operation)
	|| is_set(member_name.operation)
	|| is_set(member_type.operation)
	|| is_set(port_number.operation)
	|| is_set(port_priority.operation)
	|| is_set(underlying_link_id.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (link_data !=  nullptr && link_data->has_operation())
	|| (mac_address !=  nullptr && mac_address->has_operation())
	|| (member_mux_data !=  nullptr && member_mux_data->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-member-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (iccp_node.is_set || is_set(iccp_node.operation)) leaf_name_data.push_back(iccp_node.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (member_type.is_set || is_set(member_type.operation)) leaf_name_data.push_back(member_type.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "link-data")
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
        else
        {
            link_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::LinkData>();
            link_data->parent = this;
            children["link-data"] = link_data.get();
        }
        return children.at("link-data");
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    if(child_yang_name == "member-mux-data")
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
        else
        {
            member_mux_data = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::MemberMuxData>();
            member_mux_data->parent = this;
            children["member-mux-data"] = member_mux_data.get();
        }
        return children.at("member-mux-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("link-data") == children.end())
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    if(children.find("member-mux-data") == children.end())
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "iccp-node")
    {
        iccp_node = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "member-type")
    {
        member_type = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMember::BundleMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    bundle_member_ancestor(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor>())
	,bundle_member_item(std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem>())
{
    bundle_member_ancestor->parent = this;
    children["bundle-member-ancestor"] = bundle_member_ancestor.get();

    bundle_member_item->parent = this;
    children["bundle-member-item"] = bundle_member_item.get();

    yang_name = "bundle-member"; yang_parent_name = "bundle-members";
}

BundleInformation::Bundle::BundleMembers::BundleMember::~BundleMember()
{
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::has_data() const
{
    return member_interface.is_set
	|| (bundle_member_ancestor !=  nullptr && bundle_member_ancestor->has_data())
	|| (bundle_member_item !=  nullptr && bundle_member_item->has_data());
}

bool BundleInformation::Bundle::BundleMembers::BundleMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (bundle_member_ancestor !=  nullptr && bundle_member_ancestor->has_operation())
	|| (bundle_member_item !=  nullptr && bundle_member_item->has_operation());
}

std::string BundleInformation::Bundle::BundleMembers::BundleMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::BundleMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bundle/bundle-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::BundleMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-member-ancestor")
    {
        if(bundle_member_ancestor != nullptr)
        {
            children["bundle-member-ancestor"] = bundle_member_ancestor.get();
        }
        else
        {
            bundle_member_ancestor = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberAncestor>();
            bundle_member_ancestor->parent = this;
            children["bundle-member-ancestor"] = bundle_member_ancestor.get();
        }
        return children.at("bundle-member-ancestor");
    }

    if(child_yang_name == "bundle-member-item")
    {
        if(bundle_member_item != nullptr)
        {
            children["bundle-member-item"] = bundle_member_item.get();
        }
        else
        {
            bundle_member_item = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember::BundleMemberItem>();
            bundle_member_item->parent = this;
            children["bundle-member-item"] = bundle_member_item.get();
        }
        return children.at("bundle-member-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::BundleMember::get_children()
{
    if(children.find("bundle-member-ancestor") == children.end())
    {
        if(bundle_member_ancestor != nullptr)
        {
            children["bundle-member-ancestor"] = bundle_member_ancestor.get();
        }
    }

    if(children.find("bundle-member-item") == children.end())
    {
        if(bundle_member_item != nullptr)
        {
            children["bundle-member-item"] = bundle_member_item.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::BundleMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::Bundle::BundleMembers::BundleMembers()
{
    yang_name = "bundle-members"; yang_parent_name = "bundle";
}

BundleInformation::Bundle::BundleMembers::~BundleMembers()
{
}

bool BundleInformation::Bundle::BundleMembers::has_data() const
{
    for (std::size_t index=0; index<bundle_member.size(); index++)
    {
        if(bundle_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Bundle::BundleMembers::has_operation() const
{
    for (std::size_t index=0; index<bundle_member.size(); index++)
    {
        if(bundle_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Bundle::BundleMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-members";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::BundleMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bundle/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::BundleMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-member")
    {
        for(auto const & c : bundle_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Bundle::BundleMembers::BundleMember>();
        c->parent = this;
        bundle_member.push_back(std::move(c));
        children[segment_path] = bundle_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::BundleMembers::get_children()
{
    for (auto const & c : bundle_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::BundleMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Bundle::Bundle()
    :
    bundle_bundles(std::make_unique<BundleInformation::Bundle::BundleBundles>())
	,bundle_members(std::make_unique<BundleInformation::Bundle::BundleMembers>())
{
    bundle_bundles->parent = this;
    children["bundle-bundles"] = bundle_bundles.get();

    bundle_members->parent = this;
    children["bundle-members"] = bundle_members.get();

    yang_name = "bundle"; yang_parent_name = "bundle-information";
}

BundleInformation::Bundle::~Bundle()
{
}

bool BundleInformation::Bundle::has_data() const
{
    return (bundle_bundles !=  nullptr && bundle_bundles->has_data())
	|| (bundle_members !=  nullptr && bundle_members->has_data());
}

bool BundleInformation::Bundle::has_operation() const
{
    return is_set(operation)
	|| (bundle_bundles !=  nullptr && bundle_bundles->has_operation())
	|| (bundle_members !=  nullptr && bundle_members->has_operation());
}

std::string BundleInformation::Bundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle";

    return path_buffer.str();

}

EntityPath BundleInformation::Bundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Bundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-bundles")
    {
        if(bundle_bundles != nullptr)
        {
            children["bundle-bundles"] = bundle_bundles.get();
        }
        else
        {
            bundle_bundles = std::make_unique<BundleInformation::Bundle::BundleBundles>();
            bundle_bundles->parent = this;
            children["bundle-bundles"] = bundle_bundles.get();
        }
        return children.at("bundle-bundles");
    }

    if(child_yang_name == "bundle-members")
    {
        if(bundle_members != nullptr)
        {
            children["bundle-members"] = bundle_members.get();
        }
        else
        {
            bundle_members = std::make_unique<BundleInformation::Bundle::BundleMembers>();
            bundle_members->parent = this;
            children["bundle-members"] = bundle_members.get();
        }
        return children.at("bundle-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Bundle::get_children()
{
    if(children.find("bundle-bundles") == children.end())
    {
        if(bundle_bundles != nullptr)
        {
            children["bundle-bundles"] = bundle_bundles.get();
        }
    }

    if(children.find("bundle-members") == children.end())
    {
        if(bundle_members != nullptr)
        {
            children["bundle-members"] = bundle_members.get();
        }
    }

    return children;
}

void BundleInformation::Bundle::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-rg-member-ancestor";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::~Items()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::EventsRgMemberAncestor()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-rg-member-ancestor"; yang_parent_name = "events-rg-member";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::~EventsRgMemberAncestor()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-member-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    events_rg_member_ancestor(std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor>())
{
    events_rg_member_ancestor->parent = this;
    children["events-rg-member-ancestor"] = events_rg_member_ancestor.get();

    yang_name = "events-rg-member"; yang_parent_name = "events-rg-members";
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::~EventsRgMember()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::has_data() const
{
    return member_interface.is_set
	|| (events_rg_member_ancestor !=  nullptr && events_rg_member_ancestor->has_data());
}

bool BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (events_rg_member_ancestor !=  nullptr && events_rg_member_ancestor->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-rg/events-rg-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-member-ancestor")
    {
        if(events_rg_member_ancestor != nullptr)
        {
            children["events-rg-member-ancestor"] = events_rg_member_ancestor.get();
        }
        else
        {
            events_rg_member_ancestor = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::EventsRgMemberAncestor>();
            events_rg_member_ancestor->parent = this;
            children["events-rg-member-ancestor"] = events_rg_member_ancestor.get();
        }
        return children.at("events-rg-member-ancestor");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::get_children()
{
    if(children.find("events-rg-member-ancestor") == children.end())
    {
        if(events_rg_member_ancestor != nullptr)
        {
            children["events-rg-member-ancestor"] = events_rg_member_ancestor.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::EventsRgMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::EventsRg::EventsRgMembers::EventsRgMembers()
{
    yang_name = "events-rg-members"; yang_parent_name = "events-rg";
}

BundleInformation::EventsRg::EventsRgMembers::~EventsRgMembers()
{
}

bool BundleInformation::EventsRg::EventsRgMembers::has_data() const
{
    for (std::size_t index=0; index<events_rg_member.size(); index++)
    {
        if(events_rg_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsRg::EventsRgMembers::has_operation() const
{
    for (std::size_t index=0; index<events_rg_member.size(); index++)
    {
        if(events_rg_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsRg::EventsRgMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-members";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-rg/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-member")
    {
        for(auto const & c : events_rg_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsRg::EventsRgMembers::EventsRgMember>();
        c->parent = this;
        events_rg_member.push_back(std::move(c));
        children[segment_path] = events_rg_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgMembers::get_children()
{
    for (auto const & c : events_rg_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-rg-bundle-item-iccp-group";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::~Items()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::EventsRgBundleItemIccpGroup()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-rg-bundle-item-iccp-group"; yang_parent_name = "events-rg-iccp-group";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::~EventsRgBundleItemIccpGroup()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-bundle-item-iccp-group";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgIccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    events_rg_bundle_item_iccp_group(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup>())
{
    events_rg_bundle_item_iccp_group->parent = this;
    children["events-rg-bundle-item-iccp-group"] = events_rg_bundle_item_iccp_group.get();

    yang_name = "events-rg-iccp-group"; yang_parent_name = "events-rg-iccp-groups";
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::~EventsRgIccpGroup()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (events_rg_bundle_item_iccp_group !=  nullptr && events_rg_bundle_item_iccp_group->has_data());
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (events_rg_bundle_item_iccp_group !=  nullptr && events_rg_bundle_item_iccp_group->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-rg/events-rg-iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-bundle-item-iccp-group")
    {
        if(events_rg_bundle_item_iccp_group != nullptr)
        {
            children["events-rg-bundle-item-iccp-group"] = events_rg_bundle_item_iccp_group.get();
        }
        else
        {
            events_rg_bundle_item_iccp_group = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::EventsRgBundleItemIccpGroup>();
            events_rg_bundle_item_iccp_group->parent = this;
            children["events-rg-bundle-item-iccp-group"] = events_rg_bundle_item_iccp_group.get();
        }
        return children.at("events-rg-bundle-item-iccp-group");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::get_children()
{
    if(children.find("events-rg-bundle-item-iccp-group") == children.end())
    {
        if(events_rg_bundle_item_iccp_group != nullptr)
        {
            children["events-rg-bundle-item-iccp-group"] = events_rg_bundle_item_iccp_group.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroups()
{
    yang_name = "events-rg-iccp-groups"; yang_parent_name = "events-rg";
}

BundleInformation::EventsRg::EventsRgIccpGroups::~EventsRgIccpGroups()
{
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::has_data() const
{
    for (std::size_t index=0; index<events_rg_iccp_group.size(); index++)
    {
        if(events_rg_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsRg::EventsRgIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<events_rg_iccp_group.size(); index++)
    {
        if(events_rg_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsRg::EventsRgIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-rg/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-iccp-group")
    {
        for(auto const & c : events_rg_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups::EventsRgIccpGroup>();
        c->parent = this;
        events_rg_iccp_group.push_back(std::move(c));
        children[segment_path] = events_rg_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgIccpGroups::get_children()
{
    for (auto const & c : events_rg_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-rg-bundle-ancestor";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::~Items()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::EventsRgBundleAncestor()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-rg-bundle-ancestor"; yang_parent_name = "events-rg-bundle";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::~EventsRgBundleAncestor()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-bundle-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    events_rg_bundle_ancestor(std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor>())
{
    events_rg_bundle_ancestor->parent = this;
    children["events-rg-bundle-ancestor"] = events_rg_bundle_ancestor.get();

    yang_name = "events-rg-bundle"; yang_parent_name = "events-rg-bundles";
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::~EventsRgBundle()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::has_data() const
{
    return bundle_interface.is_set
	|| (events_rg_bundle_ancestor !=  nullptr && events_rg_bundle_ancestor->has_data());
}

bool BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (events_rg_bundle_ancestor !=  nullptr && events_rg_bundle_ancestor->has_operation());
}

std::string BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-rg/events-rg-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-bundle-ancestor")
    {
        if(events_rg_bundle_ancestor != nullptr)
        {
            children["events-rg-bundle-ancestor"] = events_rg_bundle_ancestor.get();
        }
        else
        {
            events_rg_bundle_ancestor = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::EventsRgBundleAncestor>();
            events_rg_bundle_ancestor->parent = this;
            children["events-rg-bundle-ancestor"] = events_rg_bundle_ancestor.get();
        }
        return children.at("events-rg-bundle-ancestor");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::get_children()
{
    if(children.find("events-rg-bundle-ancestor") == children.end())
    {
        if(events_rg_bundle_ancestor != nullptr)
        {
            children["events-rg-bundle-ancestor"] = events_rg_bundle_ancestor.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::EventsRg::EventsRgBundles::EventsRgBundles()
{
    yang_name = "events-rg-bundles"; yang_parent_name = "events-rg";
}

BundleInformation::EventsRg::EventsRgBundles::~EventsRgBundles()
{
}

bool BundleInformation::EventsRg::EventsRgBundles::has_data() const
{
    for (std::size_t index=0; index<events_rg_bundle.size(); index++)
    {
        if(events_rg_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsRg::EventsRgBundles::has_operation() const
{
    for (std::size_t index=0; index<events_rg_bundle.size(); index++)
    {
        if(events_rg_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsRg::EventsRgBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::EventsRgBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-rg/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::EventsRgBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-bundle")
    {
        for(auto const & c : events_rg_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsRg::EventsRgBundles::EventsRgBundle>();
        c->parent = this;
        events_rg_bundle.push_back(std::move(c));
        children[segment_path] = events_rg_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::EventsRgBundles::get_children()
{
    for (auto const & c : events_rg_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::EventsRgBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsRg::EventsRg()
    :
    events_rg_bundles(std::make_unique<BundleInformation::EventsRg::EventsRgBundles>())
	,events_rg_iccp_groups(std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups>())
	,events_rg_members(std::make_unique<BundleInformation::EventsRg::EventsRgMembers>())
{
    events_rg_bundles->parent = this;
    children["events-rg-bundles"] = events_rg_bundles.get();

    events_rg_iccp_groups->parent = this;
    children["events-rg-iccp-groups"] = events_rg_iccp_groups.get();

    events_rg_members->parent = this;
    children["events-rg-members"] = events_rg_members.get();

    yang_name = "events-rg"; yang_parent_name = "bundle-information";
}

BundleInformation::EventsRg::~EventsRg()
{
}

bool BundleInformation::EventsRg::has_data() const
{
    return (events_rg_bundles !=  nullptr && events_rg_bundles->has_data())
	|| (events_rg_iccp_groups !=  nullptr && events_rg_iccp_groups->has_data())
	|| (events_rg_members !=  nullptr && events_rg_members->has_data());
}

bool BundleInformation::EventsRg::has_operation() const
{
    return is_set(operation)
	|| (events_rg_bundles !=  nullptr && events_rg_bundles->has_operation())
	|| (events_rg_iccp_groups !=  nullptr && events_rg_iccp_groups->has_operation())
	|| (events_rg_members !=  nullptr && events_rg_members->has_operation());
}

std::string BundleInformation::EventsRg::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-rg";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsRg::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsRg::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-rg-bundles")
    {
        if(events_rg_bundles != nullptr)
        {
            children["events-rg-bundles"] = events_rg_bundles.get();
        }
        else
        {
            events_rg_bundles = std::make_unique<BundleInformation::EventsRg::EventsRgBundles>();
            events_rg_bundles->parent = this;
            children["events-rg-bundles"] = events_rg_bundles.get();
        }
        return children.at("events-rg-bundles");
    }

    if(child_yang_name == "events-rg-iccp-groups")
    {
        if(events_rg_iccp_groups != nullptr)
        {
            children["events-rg-iccp-groups"] = events_rg_iccp_groups.get();
        }
        else
        {
            events_rg_iccp_groups = std::make_unique<BundleInformation::EventsRg::EventsRgIccpGroups>();
            events_rg_iccp_groups->parent = this;
            children["events-rg-iccp-groups"] = events_rg_iccp_groups.get();
        }
        return children.at("events-rg-iccp-groups");
    }

    if(child_yang_name == "events-rg-members")
    {
        if(events_rg_members != nullptr)
        {
            children["events-rg-members"] = events_rg_members.get();
        }
        else
        {
            events_rg_members = std::make_unique<BundleInformation::EventsRg::EventsRgMembers>();
            events_rg_members->parent = this;
            children["events-rg-members"] = events_rg_members.get();
        }
        return children.at("events-rg-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsRg::get_children()
{
    if(children.find("events-rg-bundles") == children.end())
    {
        if(events_rg_bundles != nullptr)
        {
            children["events-rg-bundles"] = events_rg_bundles.get();
        }
    }

    if(children.find("events-rg-iccp-groups") == children.end())
    {
        if(events_rg_iccp_groups != nullptr)
        {
            children["events-rg-iccp-groups"] = events_rg_iccp_groups.get();
        }
    }

    if(children.find("events-rg-members") == children.end())
    {
        if(events_rg_members != nullptr)
        {
            children["events-rg-members"] = events_rg_members.get();
        }
    }

    return children;
}

void BundleInformation::EventsRg::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "actor-bundle-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "actor-bundle-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::ActorBundleData()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "actor-bundle-data"; yang_parent_name = "lacp-bundle-item";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::~ActorBundleData()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "bundle-system-id";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::BundleSystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "bundle-system-id"; yang_parent_name = "lacp-bundle-item";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::~BundleSystemId()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::LacpBundleItem()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"}
    	,
    actor_bundle_data(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData>())
	,bundle_system_id(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId>())
{
    actor_bundle_data->parent = this;
    children["actor-bundle-data"] = actor_bundle_data.get();

    bundle_system_id->parent = this;
    children["bundle-system-id"] = bundle_system_id.get();

    yang_name = "lacp-bundle-item"; yang_parent_name = "lacp-bundle";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::~LacpBundleItem()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::has_data() const
{
    return actor_operational_key.is_set
	|| partner_operational_key.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_data())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_operation())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-bundle-data")
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        else
        {
            actor_bundle_data = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::ActorBundleData>();
            actor_bundle_data->parent = this;
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        return children.at("actor-bundle-data");
    }

    if(child_yang_name == "bundle-system-id")
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
        else
        {
            bundle_system_id = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::BundleSystemId>();
            bundle_system_id->parent = this;
            children["bundle-system-id"] = bundle_system_id.get();
        }
        return children.at("bundle-system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::get_children()
{
    if(children.find("actor-bundle-data") == children.end())
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
    }

    if(children.find("bundle-system-id") == children.end())
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "actor-bundle-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "actor-bundle-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::ActorBundleData()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "actor-bundle-data"; yang_parent_name = "bundle-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::~ActorBundleData()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "bundle-system-id";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::BundleSystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "bundle-system-id"; yang_parent_name = "bundle-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::~BundleSystemId()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"}
    	,
    actor_bundle_data(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData>())
	,bundle_system_id(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId>())
{
    actor_bundle_data->parent = this;
    children["actor-bundle-data"] = actor_bundle_data.get();

    bundle_system_id->parent = this;
    children["bundle-system-id"] = bundle_system_id.get();

    yang_name = "bundle-data"; yang_parent_name = "lacp-bundle-descendant";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::~BundleData()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::has_data() const
{
    return actor_operational_key.is_set
	|| partner_operational_key.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_data())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_operation())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-bundle-data")
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        else
        {
            actor_bundle_data = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::ActorBundleData>();
            actor_bundle_data->parent = this;
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        return children.at("actor-bundle-data");
    }

    if(child_yang_name == "bundle-system-id")
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
        else
        {
            bundle_system_id = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::BundleSystemId>();
            bundle_system_id->parent = this;
            children["bundle-system-id"] = bundle_system_id.get();
        }
        return children.at("bundle-system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::get_children()
{
    if(children.find("actor-bundle-data") == children.end())
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
    }

    if(children.find("bundle-system-id") == children.end())
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "actor-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::ActorInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "actor-info"; yang_parent_name = "member-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::~ActorInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "partner-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PartnerInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "partner-info"; yang_parent_name = "member-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::~PartnerInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "partner-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::Local()
    :
    	interface_handle{YType::str, "interface-handle"}
{
    yang_name = "local"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::~Local()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::has_data() const
{
    return interface_handle.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_handle.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "local";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::Foreign()
    :
    	member_name{YType::str, "member-name"},
	 peer_address{YType::str, "peer-address"}
{
    yang_name = "foreign"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::~Foreign()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::has_data() const
{
    return member_name.is_set
	|| peer_address.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::has_operation() const
{
    return is_set(operation)
	|| is_set(member_name.operation)
	|| is_set(peer_address.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "foreign";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (peer_address.is_set || is_set(peer_address.operation)) leaf_name_data.push_back(peer_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "peer-address")
    {
        peer_address = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::AdditionalInfo()
    :
    	mbr_type{YType::enumeration, "mbr-type"}
    	,
    foreign(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign>())
	,local(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local>())
{
    foreign->parent = this;
    children["foreign"] = foreign.get();

    local->parent = this;
    children["local"] = local.get();

    yang_name = "additional-info"; yang_parent_name = "member-data";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::~AdditionalInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::has_data() const
{
    return mbr_type.is_set
	|| (foreign !=  nullptr && foreign->has_data())
	|| (local !=  nullptr && local->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(mbr_type.operation)
	|| (foreign !=  nullptr && foreign->has_operation())
	|| (local !=  nullptr && local->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "additional-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mbr_type.is_set || is_set(mbr_type.operation)) leaf_name_data.push_back(mbr_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "foreign")
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
        else
        {
            foreign = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Foreign>();
            foreign->parent = this;
            children["foreign"] = foreign.get();
        }
        return children.at("foreign");
    }

    if(child_yang_name == "local")
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
        else
        {
            local = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::Local>();
            local->parent = this;
            children["local"] = local.get();
        }
        return children.at("local");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::get_children()
{
    if(children.find("foreign") == children.end())
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
    }

    if(children.find("local") == children.end())
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mbr-type")
    {
        mbr_type = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::MemberData()
    :
    	actor_churn_state{YType::enumeration, "actor-churn-state"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 mux_state{YType::enumeration, "mux-state"},
	 partner_churn_state{YType::enumeration, "partner-churn-state"},
	 period_state{YType::enumeration, "period-state"},
	 receive_machine_state{YType::enumeration, "receive-machine-state"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"},
	 selection_state{YType::enumeration, "selection-state"}
    	,
    actor_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo>())
	,additional_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo>())
	,partner_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo>())
{
    actor_info->parent = this;
    children["actor-info"] = actor_info.get();

    additional_info->parent = this;
    children["additional-info"] = additional_info.get();

    partner_info->parent = this;
    children["partner-info"] = partner_info.get();

    yang_name = "member-data"; yang_parent_name = "lacp-bundle-descendant";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::~MemberData()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::has_data() const
{
    return actor_churn_state.is_set
	|| attached_aggregator_id.is_set
	|| iccp_group_id.is_set
	|| mux_state.is_set
	|| partner_churn_state.is_set
	|| period_state.is_set
	|| receive_machine_state.is_set
	|| selected_aggregator_id.is_set
	|| selection_state.is_set
	|| (actor_info !=  nullptr && actor_info->has_data())
	|| (additional_info !=  nullptr && additional_info->has_data())
	|| (partner_info !=  nullptr && partner_info->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_churn_state.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(mux_state.operation)
	|| is_set(partner_churn_state.operation)
	|| is_set(period_state.operation)
	|| is_set(receive_machine_state.operation)
	|| is_set(selected_aggregator_id.operation)
	|| is_set(selection_state.operation)
	|| (actor_info !=  nullptr && actor_info->has_operation())
	|| (additional_info !=  nullptr && additional_info->has_operation())
	|| (partner_info !=  nullptr && partner_info->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_churn_state.is_set || is_set(actor_churn_state.operation)) leaf_name_data.push_back(actor_churn_state.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (partner_churn_state.is_set || is_set(partner_churn_state.operation)) leaf_name_data.push_back(partner_churn_state.get_name_leafdata());
    if (period_state.is_set || is_set(period_state.operation)) leaf_name_data.push_back(period_state.get_name_leafdata());
    if (receive_machine_state.is_set || is_set(receive_machine_state.operation)) leaf_name_data.push_back(receive_machine_state.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());
    if (selection_state.is_set || is_set(selection_state.operation)) leaf_name_data.push_back(selection_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-info")
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
        else
        {
            actor_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::ActorInfo>();
            actor_info->parent = this;
            children["actor-info"] = actor_info.get();
        }
        return children.at("actor-info");
    }

    if(child_yang_name == "additional-info")
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
        else
        {
            additional_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::AdditionalInfo>();
            additional_info->parent = this;
            children["additional-info"] = additional_info.get();
        }
        return children.at("additional-info");
    }

    if(child_yang_name == "partner-info")
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
        else
        {
            partner_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::PartnerInfo>();
            partner_info->parent = this;
            children["partner-info"] = partner_info.get();
        }
        return children.at("partner-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::get_children()
{
    if(children.find("actor-info") == children.end())
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
    }

    if(children.find("additional-info") == children.end())
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
    }

    if(children.find("partner-info") == children.end())
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-churn-state")
    {
        actor_churn_state = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "partner-churn-state")
    {
        partner_churn_state = value;
    }
    if(value_path == "period-state")
    {
        period_state = value;
    }
    if(value_path == "receive-machine-state")
    {
        receive_machine_state = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
    if(value_path == "selection-state")
    {
        selection_state = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::LacpBundleDescendant()
    :
    bundle_data(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "lacp-bundle-descendant"; yang_parent_name = "lacp-bundle";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::~LacpBundleDescendant()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-bundle-descendant";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "actor-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::ActorInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "actor-info"; yang_parent_name = "lacp-bundle-children-member";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::~ActorInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "partner-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PartnerInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "partner-info"; yang_parent_name = "lacp-bundle-children-member";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::~PartnerInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "partner-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::Local()
    :
    	interface_handle{YType::str, "interface-handle"}
{
    yang_name = "local"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::~Local()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::has_data() const
{
    return interface_handle.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_handle.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "local";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::Foreign()
    :
    	member_name{YType::str, "member-name"},
	 peer_address{YType::str, "peer-address"}
{
    yang_name = "foreign"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::~Foreign()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::has_data() const
{
    return member_name.is_set
	|| peer_address.is_set;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::has_operation() const
{
    return is_set(operation)
	|| is_set(member_name.operation)
	|| is_set(peer_address.operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "foreign";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (peer_address.is_set || is_set(peer_address.operation)) leaf_name_data.push_back(peer_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "peer-address")
    {
        peer_address = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::AdditionalInfo()
    :
    	mbr_type{YType::enumeration, "mbr-type"}
    	,
    foreign(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign>())
	,local(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local>())
{
    foreign->parent = this;
    children["foreign"] = foreign.get();

    local->parent = this;
    children["local"] = local.get();

    yang_name = "additional-info"; yang_parent_name = "lacp-bundle-children-member";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::~AdditionalInfo()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::has_data() const
{
    return mbr_type.is_set
	|| (foreign !=  nullptr && foreign->has_data())
	|| (local !=  nullptr && local->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(mbr_type.operation)
	|| (foreign !=  nullptr && foreign->has_operation())
	|| (local !=  nullptr && local->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "additional-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mbr_type.is_set || is_set(mbr_type.operation)) leaf_name_data.push_back(mbr_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "foreign")
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
        else
        {
            foreign = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Foreign>();
            foreign->parent = this;
            children["foreign"] = foreign.get();
        }
        return children.at("foreign");
    }

    if(child_yang_name == "local")
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
        else
        {
            local = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::Local>();
            local->parent = this;
            children["local"] = local.get();
        }
        return children.at("local");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::get_children()
{
    if(children.find("foreign") == children.end())
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
    }

    if(children.find("local") == children.end())
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mbr-type")
    {
        mbr_type = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::LacpBundleChildrenMember()
    :
    	member_interface{YType::str, "member-interface"},
	 actor_churn_state{YType::enumeration, "actor-churn-state"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 mux_state{YType::enumeration, "mux-state"},
	 partner_churn_state{YType::enumeration, "partner-churn-state"},
	 period_state{YType::enumeration, "period-state"},
	 receive_machine_state{YType::enumeration, "receive-machine-state"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"},
	 selection_state{YType::enumeration, "selection-state"}
    	,
    actor_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo>())
	,additional_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo>())
	,partner_info(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo>())
{
    actor_info->parent = this;
    children["actor-info"] = actor_info.get();

    additional_info->parent = this;
    children["additional-info"] = additional_info.get();

    partner_info->parent = this;
    children["partner-info"] = partner_info.get();

    yang_name = "lacp-bundle-children-member"; yang_parent_name = "lacp-bundle-children-members";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::~LacpBundleChildrenMember()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::has_data() const
{
    return member_interface.is_set
	|| actor_churn_state.is_set
	|| attached_aggregator_id.is_set
	|| iccp_group_id.is_set
	|| mux_state.is_set
	|| partner_churn_state.is_set
	|| period_state.is_set
	|| receive_machine_state.is_set
	|| selected_aggregator_id.is_set
	|| selection_state.is_set
	|| (actor_info !=  nullptr && actor_info->has_data())
	|| (additional_info !=  nullptr && additional_info->has_data())
	|| (partner_info !=  nullptr && partner_info->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(actor_churn_state.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(mux_state.operation)
	|| is_set(partner_churn_state.operation)
	|| is_set(period_state.operation)
	|| is_set(receive_machine_state.operation)
	|| is_set(selected_aggregator_id.operation)
	|| is_set(selection_state.operation)
	|| (actor_info !=  nullptr && actor_info->has_operation())
	|| (additional_info !=  nullptr && additional_info->has_operation())
	|| (partner_info !=  nullptr && partner_info->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-bundle-children-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (actor_churn_state.is_set || is_set(actor_churn_state.operation)) leaf_name_data.push_back(actor_churn_state.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (partner_churn_state.is_set || is_set(partner_churn_state.operation)) leaf_name_data.push_back(partner_churn_state.get_name_leafdata());
    if (period_state.is_set || is_set(period_state.operation)) leaf_name_data.push_back(period_state.get_name_leafdata());
    if (receive_machine_state.is_set || is_set(receive_machine_state.operation)) leaf_name_data.push_back(receive_machine_state.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());
    if (selection_state.is_set || is_set(selection_state.operation)) leaf_name_data.push_back(selection_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-info")
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
        else
        {
            actor_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::ActorInfo>();
            actor_info->parent = this;
            children["actor-info"] = actor_info.get();
        }
        return children.at("actor-info");
    }

    if(child_yang_name == "additional-info")
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
        else
        {
            additional_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::AdditionalInfo>();
            additional_info->parent = this;
            children["additional-info"] = additional_info.get();
        }
        return children.at("additional-info");
    }

    if(child_yang_name == "partner-info")
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
        else
        {
            partner_info = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::PartnerInfo>();
            partner_info->parent = this;
            children["partner-info"] = partner_info.get();
        }
        return children.at("partner-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::get_children()
{
    if(children.find("actor-info") == children.end())
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
    }

    if(children.find("additional-info") == children.end())
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
    }

    if(children.find("partner-info") == children.end())
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "actor-churn-state")
    {
        actor_churn_state = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "partner-churn-state")
    {
        partner_churn_state = value;
    }
    if(value_path == "period-state")
    {
        period_state = value;
    }
    if(value_path == "receive-machine-state")
    {
        receive_machine_state = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
    if(value_path == "selection-state")
    {
        selection_state = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMembers()
{
    yang_name = "lacp-bundle-children-members"; yang_parent_name = "lacp-bundle";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::~LacpBundleChildrenMembers()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::has_data() const
{
    for (std::size_t index=0; index<lacp_bundle_children_member.size(); index++)
    {
        if(lacp_bundle_children_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::has_operation() const
{
    for (std::size_t index=0; index<lacp_bundle_children_member.size(); index++)
    {
        if(lacp_bundle_children_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-bundle-children-members";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lacp-bundle-children-member")
    {
        for(auto const & c : lacp_bundle_children_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::LacpBundleChildrenMember>();
        c->parent = this;
        lacp_bundle_children_member.push_back(std::move(c));
        children[segment_path] = lacp_bundle_children_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::get_children()
{
    for (auto const & c : lacp_bundle_children_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    lacp_bundle_children_members(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers>())
	,lacp_bundle_descendant(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant>())
	,lacp_bundle_item(std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem>())
{
    lacp_bundle_children_members->parent = this;
    children["lacp-bundle-children-members"] = lacp_bundle_children_members.get();

    lacp_bundle_descendant->parent = this;
    children["lacp-bundle-descendant"] = lacp_bundle_descendant.get();

    lacp_bundle_item->parent = this;
    children["lacp-bundle-item"] = lacp_bundle_item.get();

    yang_name = "lacp-bundle"; yang_parent_name = "lacp-bundles";
}

BundleInformation::Lacp::LacpBundles::LacpBundle::~LacpBundle()
{
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::has_data() const
{
    return bundle_interface.is_set
	|| (lacp_bundle_children_members !=  nullptr && lacp_bundle_children_members->has_data())
	|| (lacp_bundle_descendant !=  nullptr && lacp_bundle_descendant->has_data())
	|| (lacp_bundle_item !=  nullptr && lacp_bundle_item->has_data());
}

bool BundleInformation::Lacp::LacpBundles::LacpBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (lacp_bundle_children_members !=  nullptr && lacp_bundle_children_members->has_operation())
	|| (lacp_bundle_descendant !=  nullptr && lacp_bundle_descendant->has_operation())
	|| (lacp_bundle_item !=  nullptr && lacp_bundle_item->has_operation());
}

std::string BundleInformation::Lacp::LacpBundles::LacpBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::LacpBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/lacp/lacp-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::LacpBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lacp-bundle-children-members")
    {
        if(lacp_bundle_children_members != nullptr)
        {
            children["lacp-bundle-children-members"] = lacp_bundle_children_members.get();
        }
        else
        {
            lacp_bundle_children_members = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleChildrenMembers>();
            lacp_bundle_children_members->parent = this;
            children["lacp-bundle-children-members"] = lacp_bundle_children_members.get();
        }
        return children.at("lacp-bundle-children-members");
    }

    if(child_yang_name == "lacp-bundle-descendant")
    {
        if(lacp_bundle_descendant != nullptr)
        {
            children["lacp-bundle-descendant"] = lacp_bundle_descendant.get();
        }
        else
        {
            lacp_bundle_descendant = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleDescendant>();
            lacp_bundle_descendant->parent = this;
            children["lacp-bundle-descendant"] = lacp_bundle_descendant.get();
        }
        return children.at("lacp-bundle-descendant");
    }

    if(child_yang_name == "lacp-bundle-item")
    {
        if(lacp_bundle_item != nullptr)
        {
            children["lacp-bundle-item"] = lacp_bundle_item.get();
        }
        else
        {
            lacp_bundle_item = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle::LacpBundleItem>();
            lacp_bundle_item->parent = this;
            children["lacp-bundle-item"] = lacp_bundle_item.get();
        }
        return children.at("lacp-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::LacpBundle::get_children()
{
    if(children.find("lacp-bundle-children-members") == children.end())
    {
        if(lacp_bundle_children_members != nullptr)
        {
            children["lacp-bundle-children-members"] = lacp_bundle_children_members.get();
        }
    }

    if(children.find("lacp-bundle-descendant") == children.end())
    {
        if(lacp_bundle_descendant != nullptr)
        {
            children["lacp-bundle-descendant"] = lacp_bundle_descendant.get();
        }
    }

    if(children.find("lacp-bundle-item") == children.end())
    {
        if(lacp_bundle_item != nullptr)
        {
            children["lacp-bundle-item"] = lacp_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::LacpBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::Lacp::LacpBundles::LacpBundles()
{
    yang_name = "lacp-bundles"; yang_parent_name = "lacp";
}

BundleInformation::Lacp::LacpBundles::~LacpBundles()
{
}

bool BundleInformation::Lacp::LacpBundles::has_data() const
{
    for (std::size_t index=0; index<lacp_bundle.size(); index++)
    {
        if(lacp_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Lacp::LacpBundles::has_operation() const
{
    for (std::size_t index=0; index<lacp_bundle.size(); index++)
    {
        if(lacp_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Lacp::LacpBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/lacp/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lacp-bundle")
    {
        for(auto const & c : lacp_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpBundles::LacpBundle>();
        c->parent = this;
        lacp_bundle.push_back(std::move(c));
        children[segment_path] = lacp_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpBundles::get_children()
{
    for (auto const & c : lacp_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "actor-bundle-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "actor-bundle-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::ActorBundleData()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "actor-bundle-data"; yang_parent_name = "bundle-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::~ActorBundleData()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "bundle-system-id";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::BundleSystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "bundle-system-id"; yang_parent_name = "bundle-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::~BundleSystemId()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"}
    	,
    actor_bundle_data(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData>())
	,bundle_system_id(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId>())
{
    actor_bundle_data->parent = this;
    children["actor-bundle-data"] = actor_bundle_data.get();

    bundle_system_id->parent = this;
    children["bundle-system-id"] = bundle_system_id.get();

    yang_name = "bundle-data"; yang_parent_name = "lacp-member-ancestor";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::~BundleData()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::has_data() const
{
    return actor_operational_key.is_set
	|| partner_operational_key.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_data())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| (actor_bundle_data !=  nullptr && actor_bundle_data->has_operation())
	|| (bundle_system_id !=  nullptr && bundle_system_id->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-bundle-data")
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        else
        {
            actor_bundle_data = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::ActorBundleData>();
            actor_bundle_data->parent = this;
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
        return children.at("actor-bundle-data");
    }

    if(child_yang_name == "bundle-system-id")
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
        else
        {
            bundle_system_id = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::BundleSystemId>();
            bundle_system_id->parent = this;
            children["bundle-system-id"] = bundle_system_id.get();
        }
        return children.at("bundle-system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::get_children()
{
    if(children.find("actor-bundle-data") == children.end())
    {
        if(actor_bundle_data != nullptr)
        {
            children["actor-bundle-data"] = actor_bundle_data.get();
        }
    }

    if(children.find("bundle-system-id") == children.end())
    {
        if(bundle_system_id != nullptr)
        {
            children["bundle-system-id"] = bundle_system_id.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "actor-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::ActorInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "actor-info"; yang_parent_name = "member-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::~ActorInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "partner-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PartnerInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "partner-info"; yang_parent_name = "member-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::~PartnerInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "partner-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::Local()
    :
    	interface_handle{YType::str, "interface-handle"}
{
    yang_name = "local"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::~Local()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::has_data() const
{
    return interface_handle.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_handle.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "local";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::Foreign()
    :
    	member_name{YType::str, "member-name"},
	 peer_address{YType::str, "peer-address"}
{
    yang_name = "foreign"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::~Foreign()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::has_data() const
{
    return member_name.is_set
	|| peer_address.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::has_operation() const
{
    return is_set(operation)
	|| is_set(member_name.operation)
	|| is_set(peer_address.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "foreign";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (peer_address.is_set || is_set(peer_address.operation)) leaf_name_data.push_back(peer_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "peer-address")
    {
        peer_address = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::AdditionalInfo()
    :
    	mbr_type{YType::enumeration, "mbr-type"}
    	,
    foreign(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign>())
	,local(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local>())
{
    foreign->parent = this;
    children["foreign"] = foreign.get();

    local->parent = this;
    children["local"] = local.get();

    yang_name = "additional-info"; yang_parent_name = "member-data";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::~AdditionalInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::has_data() const
{
    return mbr_type.is_set
	|| (foreign !=  nullptr && foreign->has_data())
	|| (local !=  nullptr && local->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(mbr_type.operation)
	|| (foreign !=  nullptr && foreign->has_operation())
	|| (local !=  nullptr && local->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "additional-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mbr_type.is_set || is_set(mbr_type.operation)) leaf_name_data.push_back(mbr_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "foreign")
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
        else
        {
            foreign = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Foreign>();
            foreign->parent = this;
            children["foreign"] = foreign.get();
        }
        return children.at("foreign");
    }

    if(child_yang_name == "local")
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
        else
        {
            local = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::Local>();
            local->parent = this;
            children["local"] = local.get();
        }
        return children.at("local");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::get_children()
{
    if(children.find("foreign") == children.end())
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
    }

    if(children.find("local") == children.end())
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mbr-type")
    {
        mbr_type = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::MemberData()
    :
    	actor_churn_state{YType::enumeration, "actor-churn-state"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 mux_state{YType::enumeration, "mux-state"},
	 partner_churn_state{YType::enumeration, "partner-churn-state"},
	 period_state{YType::enumeration, "period-state"},
	 receive_machine_state{YType::enumeration, "receive-machine-state"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"},
	 selection_state{YType::enumeration, "selection-state"}
    	,
    actor_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo>())
	,additional_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo>())
	,partner_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo>())
{
    actor_info->parent = this;
    children["actor-info"] = actor_info.get();

    additional_info->parent = this;
    children["additional-info"] = additional_info.get();

    partner_info->parent = this;
    children["partner-info"] = partner_info.get();

    yang_name = "member-data"; yang_parent_name = "lacp-member-ancestor";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::~MemberData()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::has_data() const
{
    return actor_churn_state.is_set
	|| attached_aggregator_id.is_set
	|| iccp_group_id.is_set
	|| mux_state.is_set
	|| partner_churn_state.is_set
	|| period_state.is_set
	|| receive_machine_state.is_set
	|| selected_aggregator_id.is_set
	|| selection_state.is_set
	|| (actor_info !=  nullptr && actor_info->has_data())
	|| (additional_info !=  nullptr && additional_info->has_data())
	|| (partner_info !=  nullptr && partner_info->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_churn_state.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(mux_state.operation)
	|| is_set(partner_churn_state.operation)
	|| is_set(period_state.operation)
	|| is_set(receive_machine_state.operation)
	|| is_set(selected_aggregator_id.operation)
	|| is_set(selection_state.operation)
	|| (actor_info !=  nullptr && actor_info->has_operation())
	|| (additional_info !=  nullptr && additional_info->has_operation())
	|| (partner_info !=  nullptr && partner_info->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_churn_state.is_set || is_set(actor_churn_state.operation)) leaf_name_data.push_back(actor_churn_state.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (partner_churn_state.is_set || is_set(partner_churn_state.operation)) leaf_name_data.push_back(partner_churn_state.get_name_leafdata());
    if (period_state.is_set || is_set(period_state.operation)) leaf_name_data.push_back(period_state.get_name_leafdata());
    if (receive_machine_state.is_set || is_set(receive_machine_state.operation)) leaf_name_data.push_back(receive_machine_state.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());
    if (selection_state.is_set || is_set(selection_state.operation)) leaf_name_data.push_back(selection_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-info")
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
        else
        {
            actor_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::ActorInfo>();
            actor_info->parent = this;
            children["actor-info"] = actor_info.get();
        }
        return children.at("actor-info");
    }

    if(child_yang_name == "additional-info")
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
        else
        {
            additional_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::AdditionalInfo>();
            additional_info->parent = this;
            children["additional-info"] = additional_info.get();
        }
        return children.at("additional-info");
    }

    if(child_yang_name == "partner-info")
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
        else
        {
            partner_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::PartnerInfo>();
            partner_info->parent = this;
            children["partner-info"] = partner_info.get();
        }
        return children.at("partner-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::get_children()
{
    if(children.find("actor-info") == children.end())
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
    }

    if(children.find("additional-info") == children.end())
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
    }

    if(children.find("partner-info") == children.end())
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-churn-state")
    {
        actor_churn_state = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "partner-churn-state")
    {
        partner_churn_state = value;
    }
    if(value_path == "period-state")
    {
        period_state = value;
    }
    if(value_path == "receive-machine-state")
    {
        receive_machine_state = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
    if(value_path == "selection-state")
    {
        selection_state = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::LacpMemberAncestor()
    :
    bundle_data(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "lacp-member-ancestor"; yang_parent_name = "lacp-member";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::~LacpMemberAncestor()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-member-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "actor-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::ActorInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "actor-info"; yang_parent_name = "lacp-member-item";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::~ActorInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "actor-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::System()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::~System()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::Port()
    :
    	link_number{YType::uint16, "link-number"},
	 link_priority{YType::uint16, "link-priority"}
{
    yang_name = "port"; yang_parent_name = "port-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::~Port()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::has_data() const
{
    return link_number.is_set
	|| link_priority.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::has_operation() const
{
    return is_set(operation)
	|| is_set(link_number.operation)
	|| is_set(link_priority.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_number.is_set || is_set(link_number.operation)) leaf_name_data.push_back(link_number.get_name_leafdata());
    if (link_priority.is_set || is_set(link_priority.operation)) leaf_name_data.push_back(link_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-number")
    {
        link_number = value;
    }
    if(value_path == "link-priority")
    {
        link_priority = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::PortInfo()
    :
    	key{YType::uint16, "key"},
	 state{YType::uint8, "state"}
    	,
    port(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port>())
	,system(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System>())
{
    port->parent = this;
    children["port"] = port.get();

    system->parent = this;
    children["system"] = system.get();

    yang_name = "port-info"; yang_parent_name = "partner-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::~PortInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::has_data() const
{
    return key.is_set
	|| state.is_set
	|| (port !=  nullptr && port->has_data())
	|| (system !=  nullptr && system->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(key.operation)
	|| is_set(state.operation)
	|| (port !=  nullptr && port->has_operation())
	|| (system !=  nullptr && system->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "port-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (key.is_set || is_set(key.operation)) leaf_name_data.push_back(key.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port")
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
        else
        {
            port = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::Port>();
            port->parent = this;
            children["port"] = port.get();
        }
        return children.at("port");
    }

    if(child_yang_name == "system")
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
        else
        {
            system = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::System>();
            system->parent = this;
            children["system"] = system.get();
        }
        return children.at("system");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::get_children()
{
    if(children.find("port") == children.end())
    {
        if(port != nullptr)
        {
            children["port"] = port.get();
        }
    }

    if(children.find("system") == children.end())
    {
        if(system != nullptr)
        {
            children["system"] = system.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "key")
    {
        key = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PartnerInfo()
    :
    	tx_period{YType::uint32, "tx-period"}
    	,
    port_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo>())
{
    port_info->parent = this;
    children["port-info"] = port_info.get();

    yang_name = "partner-info"; yang_parent_name = "lacp-member-item";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::~PartnerInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::has_data() const
{
    return tx_period.is_set
	|| (port_info !=  nullptr && port_info->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(tx_period.operation)
	|| (port_info !=  nullptr && port_info->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "partner-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tx_period.is_set || is_set(tx_period.operation)) leaf_name_data.push_back(tx_period.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "port-info")
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
        else
        {
            port_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::PortInfo>();
            port_info->parent = this;
            children["port-info"] = port_info.get();
        }
        return children.at("port-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::get_children()
{
    if(children.find("port-info") == children.end())
    {
        if(port_info != nullptr)
        {
            children["port-info"] = port_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tx-period")
    {
        tx_period = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::Local()
    :
    	interface_handle{YType::str, "interface-handle"}
{
    yang_name = "local"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::~Local()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::has_data() const
{
    return interface_handle.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_handle.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "local";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::Foreign()
    :
    	member_name{YType::str, "member-name"},
	 peer_address{YType::str, "peer-address"}
{
    yang_name = "foreign"; yang_parent_name = "additional-info";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::~Foreign()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::has_data() const
{
    return member_name.is_set
	|| peer_address.is_set;
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::has_operation() const
{
    return is_set(operation)
	|| is_set(member_name.operation)
	|| is_set(peer_address.operation);
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "foreign";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (peer_address.is_set || is_set(peer_address.operation)) leaf_name_data.push_back(peer_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::get_children()
{
    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "peer-address")
    {
        peer_address = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::AdditionalInfo()
    :
    	mbr_type{YType::enumeration, "mbr-type"}
    	,
    foreign(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign>())
	,local(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local>())
{
    foreign->parent = this;
    children["foreign"] = foreign.get();

    local->parent = this;
    children["local"] = local.get();

    yang_name = "additional-info"; yang_parent_name = "lacp-member-item";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::~AdditionalInfo()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::has_data() const
{
    return mbr_type.is_set
	|| (foreign !=  nullptr && foreign->has_data())
	|| (local !=  nullptr && local->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(mbr_type.operation)
	|| (foreign !=  nullptr && foreign->has_operation())
	|| (local !=  nullptr && local->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "additional-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mbr_type.is_set || is_set(mbr_type.operation)) leaf_name_data.push_back(mbr_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "foreign")
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
        else
        {
            foreign = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Foreign>();
            foreign->parent = this;
            children["foreign"] = foreign.get();
        }
        return children.at("foreign");
    }

    if(child_yang_name == "local")
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
        else
        {
            local = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::Local>();
            local->parent = this;
            children["local"] = local.get();
        }
        return children.at("local");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::get_children()
{
    if(children.find("foreign") == children.end())
    {
        if(foreign != nullptr)
        {
            children["foreign"] = foreign.get();
        }
    }

    if(children.find("local") == children.end())
    {
        if(local != nullptr)
        {
            children["local"] = local.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mbr-type")
    {
        mbr_type = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::LacpMemberItem()
    :
    	actor_churn_state{YType::enumeration, "actor-churn-state"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 mux_state{YType::enumeration, "mux-state"},
	 partner_churn_state{YType::enumeration, "partner-churn-state"},
	 period_state{YType::enumeration, "period-state"},
	 receive_machine_state{YType::enumeration, "receive-machine-state"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"},
	 selection_state{YType::enumeration, "selection-state"}
    	,
    actor_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo>())
	,additional_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo>())
	,partner_info(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo>())
{
    actor_info->parent = this;
    children["actor-info"] = actor_info.get();

    additional_info->parent = this;
    children["additional-info"] = additional_info.get();

    partner_info->parent = this;
    children["partner-info"] = partner_info.get();

    yang_name = "lacp-member-item"; yang_parent_name = "lacp-member";
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::~LacpMemberItem()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::has_data() const
{
    return actor_churn_state.is_set
	|| attached_aggregator_id.is_set
	|| iccp_group_id.is_set
	|| mux_state.is_set
	|| partner_churn_state.is_set
	|| period_state.is_set
	|| receive_machine_state.is_set
	|| selected_aggregator_id.is_set
	|| selection_state.is_set
	|| (actor_info !=  nullptr && actor_info->has_data())
	|| (additional_info !=  nullptr && additional_info->has_data())
	|| (partner_info !=  nullptr && partner_info->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_churn_state.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(mux_state.operation)
	|| is_set(partner_churn_state.operation)
	|| is_set(period_state.operation)
	|| is_set(receive_machine_state.operation)
	|| is_set(selected_aggregator_id.operation)
	|| is_set(selection_state.operation)
	|| (actor_info !=  nullptr && actor_info->has_operation())
	|| (additional_info !=  nullptr && additional_info->has_operation())
	|| (partner_info !=  nullptr && partner_info->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-member-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_churn_state.is_set || is_set(actor_churn_state.operation)) leaf_name_data.push_back(actor_churn_state.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (partner_churn_state.is_set || is_set(partner_churn_state.operation)) leaf_name_data.push_back(partner_churn_state.get_name_leafdata());
    if (period_state.is_set || is_set(period_state.operation)) leaf_name_data.push_back(period_state.get_name_leafdata());
    if (receive_machine_state.is_set || is_set(receive_machine_state.operation)) leaf_name_data.push_back(receive_machine_state.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());
    if (selection_state.is_set || is_set(selection_state.operation)) leaf_name_data.push_back(selection_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "actor-info")
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
        else
        {
            actor_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::ActorInfo>();
            actor_info->parent = this;
            children["actor-info"] = actor_info.get();
        }
        return children.at("actor-info");
    }

    if(child_yang_name == "additional-info")
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
        else
        {
            additional_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::AdditionalInfo>();
            additional_info->parent = this;
            children["additional-info"] = additional_info.get();
        }
        return children.at("additional-info");
    }

    if(child_yang_name == "partner-info")
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
        else
        {
            partner_info = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::PartnerInfo>();
            partner_info->parent = this;
            children["partner-info"] = partner_info.get();
        }
        return children.at("partner-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::get_children()
{
    if(children.find("actor-info") == children.end())
    {
        if(actor_info != nullptr)
        {
            children["actor-info"] = actor_info.get();
        }
    }

    if(children.find("additional-info") == children.end())
    {
        if(additional_info != nullptr)
        {
            children["additional-info"] = additional_info.get();
        }
    }

    if(children.find("partner-info") == children.end())
    {
        if(partner_info != nullptr)
        {
            children["partner-info"] = partner_info.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-churn-state")
    {
        actor_churn_state = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "partner-churn-state")
    {
        partner_churn_state = value;
    }
    if(value_path == "period-state")
    {
        period_state = value;
    }
    if(value_path == "receive-machine-state")
    {
        receive_machine_state = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
    if(value_path == "selection-state")
    {
        selection_state = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMember::LacpMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    lacp_member_ancestor(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor>())
	,lacp_member_item(std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem>())
{
    lacp_member_ancestor->parent = this;
    children["lacp-member-ancestor"] = lacp_member_ancestor.get();

    lacp_member_item->parent = this;
    children["lacp-member-item"] = lacp_member_item.get();

    yang_name = "lacp-member"; yang_parent_name = "lacp-members";
}

BundleInformation::Lacp::LacpMembers::LacpMember::~LacpMember()
{
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::has_data() const
{
    return member_interface.is_set
	|| (lacp_member_ancestor !=  nullptr && lacp_member_ancestor->has_data())
	|| (lacp_member_item !=  nullptr && lacp_member_item->has_data());
}

bool BundleInformation::Lacp::LacpMembers::LacpMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (lacp_member_ancestor !=  nullptr && lacp_member_ancestor->has_operation())
	|| (lacp_member_item !=  nullptr && lacp_member_item->has_operation());
}

std::string BundleInformation::Lacp::LacpMembers::LacpMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::LacpMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/lacp/lacp-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::LacpMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lacp-member-ancestor")
    {
        if(lacp_member_ancestor != nullptr)
        {
            children["lacp-member-ancestor"] = lacp_member_ancestor.get();
        }
        else
        {
            lacp_member_ancestor = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberAncestor>();
            lacp_member_ancestor->parent = this;
            children["lacp-member-ancestor"] = lacp_member_ancestor.get();
        }
        return children.at("lacp-member-ancestor");
    }

    if(child_yang_name == "lacp-member-item")
    {
        if(lacp_member_item != nullptr)
        {
            children["lacp-member-item"] = lacp_member_item.get();
        }
        else
        {
            lacp_member_item = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember::LacpMemberItem>();
            lacp_member_item->parent = this;
            children["lacp-member-item"] = lacp_member_item.get();
        }
        return children.at("lacp-member-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::LacpMember::get_children()
{
    if(children.find("lacp-member-ancestor") == children.end())
    {
        if(lacp_member_ancestor != nullptr)
        {
            children["lacp-member-ancestor"] = lacp_member_ancestor.get();
        }
    }

    if(children.find("lacp-member-item") == children.end())
    {
        if(lacp_member_item != nullptr)
        {
            children["lacp-member-item"] = lacp_member_item.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::LacpMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::Lacp::LacpMembers::LacpMembers()
{
    yang_name = "lacp-members"; yang_parent_name = "lacp";
}

BundleInformation::Lacp::LacpMembers::~LacpMembers()
{
}

bool BundleInformation::Lacp::LacpMembers::has_data() const
{
    for (std::size_t index=0; index<lacp_member.size(); index++)
    {
        if(lacp_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Lacp::LacpMembers::has_operation() const
{
    for (std::size_t index=0; index<lacp_member.size(); index++)
    {
        if(lacp_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Lacp::LacpMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp-members";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::LacpMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/lacp/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::LacpMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lacp-member")
    {
        for(auto const & c : lacp_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Lacp::LacpMembers::LacpMember>();
        c->parent = this;
        lacp_member.push_back(std::move(c));
        children[segment_path] = lacp_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::LacpMembers::get_children()
{
    for (auto const & c : lacp_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::LacpMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Lacp::Lacp()
    :
    lacp_bundles(std::make_unique<BundleInformation::Lacp::LacpBundles>())
	,lacp_members(std::make_unique<BundleInformation::Lacp::LacpMembers>())
{
    lacp_bundles->parent = this;
    children["lacp-bundles"] = lacp_bundles.get();

    lacp_members->parent = this;
    children["lacp-members"] = lacp_members.get();

    yang_name = "lacp"; yang_parent_name = "bundle-information";
}

BundleInformation::Lacp::~Lacp()
{
}

bool BundleInformation::Lacp::has_data() const
{
    return (lacp_bundles !=  nullptr && lacp_bundles->has_data())
	|| (lacp_members !=  nullptr && lacp_members->has_data());
}

bool BundleInformation::Lacp::has_operation() const
{
    return is_set(operation)
	|| (lacp_bundles !=  nullptr && lacp_bundles->has_operation())
	|| (lacp_members !=  nullptr && lacp_members->has_operation());
}

std::string BundleInformation::Lacp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lacp";

    return path_buffer.str();

}

EntityPath BundleInformation::Lacp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Lacp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lacp-bundles")
    {
        if(lacp_bundles != nullptr)
        {
            children["lacp-bundles"] = lacp_bundles.get();
        }
        else
        {
            lacp_bundles = std::make_unique<BundleInformation::Lacp::LacpBundles>();
            lacp_bundles->parent = this;
            children["lacp-bundles"] = lacp_bundles.get();
        }
        return children.at("lacp-bundles");
    }

    if(child_yang_name == "lacp-members")
    {
        if(lacp_members != nullptr)
        {
            children["lacp-members"] = lacp_members.get();
        }
        else
        {
            lacp_members = std::make_unique<BundleInformation::Lacp::LacpMembers>();
            lacp_members->parent = this;
            children["lacp-members"] = lacp_members.get();
        }
        return children.at("lacp-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Lacp::get_children()
{
    if(children.find("lacp-bundles") == children.end())
    {
        if(lacp_bundles != nullptr)
        {
            children["lacp-bundles"] = lacp_bundles.get();
        }
    }

    if(children.find("lacp-members") == children.end())
    {
        if(lacp_members != nullptr)
        {
            children["lacp-members"] = lacp_members.get();
        }
    }

    return children;
}

void BundleInformation::Lacp::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-bundles";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::MlacpSyncRequestsOnAllLocalBundles()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-bundles"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::~MlacpSyncRequestsOnAllLocalBundles()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "bundle-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::has_data() const
{
    return bundle_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::IccpGroupData()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_bundles(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles>())
	,mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_bundles->parent = this;
    children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();

    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "iccp-group-data"; yang_parent_name = "iccp-group-item";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_bundles !=  nullptr && mlacp_sync_requests_on_all_local_bundles->has_data())
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_bundles !=  nullptr && mlacp_sync_requests_on_all_local_bundles->has_operation())
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-bundles")
    {
        if(mlacp_sync_requests_on_all_local_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_bundles = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles>();
            mlacp_sync_requests_on_all_local_bundles->parent = this;
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-bundles");
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-local-bundles") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-bundles";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::MlacpSyncRequestsOnAllForeignBundles()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-bundles"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::~MlacpSyncRequestsOnAllForeignBundles()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::NodeData_()
    :
    	node_id{YType::uint32, "node-id"}
    	,
    mlacp_sync_requests_on_all_foreign_bundles(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles>())
	,mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts>())
{
    mlacp_sync_requests_on_all_foreign_bundles->parent = this;
    children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();

    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::has_data() const
{
    return node_id.is_set
	|| (mlacp_sync_requests_on_all_foreign_bundles !=  nullptr && mlacp_sync_requests_on_all_foreign_bundles->has_data())
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(node_id.operation)
	|| (mlacp_sync_requests_on_all_foreign_bundles !=  nullptr && mlacp_sync_requests_on_all_foreign_bundles->has_operation())
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-bundles")
    {
        if(mlacp_sync_requests_on_all_foreign_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_bundles = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles>();
            mlacp_sync_requests_on_all_foreign_bundles->parent = this;
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-bundles");
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-foreign-bundles") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "bundle-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::has_data() const
{
    return bundle_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData()
    :
    node_data(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_>())
{
    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "iccp-group-item";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupItem()
    :
    iccp_group_data(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "iccp-group-item"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::~IccpGroupItem()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::get_children()
{
    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    iccp_group_item(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem>())
{
    iccp_group_item->parent = this;
    children["iccp-group-item"] = iccp_group_item.get();

    yang_name = "iccp-group"; yang_parent_name = "iccp-groups";
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::~IccpGroup()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (iccp_group_item !=  nullptr && iccp_group_item->has_data());
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (iccp_group_item !=  nullptr && iccp_group_item->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-bundle-counters/iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-item")
    {
        if(iccp_group_item != nullptr)
        {
            children["iccp-group-item"] = iccp_group_item.get();
        }
        else
        {
            iccp_group_item = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::IccpGroupItem>();
            iccp_group_item->parent = this;
            children["iccp-group-item"] = iccp_group_item.get();
        }
        return children.at("iccp-group-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::get_children()
{
    if(children.find("iccp-group-item") == children.end())
    {
        if(iccp_group_item != nullptr)
        {
            children["iccp-group-item"] = iccp_group_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroups()
{
    yang_name = "iccp-groups"; yang_parent_name = "mlacp-bundle-counters";
}

BundleInformation::MlacpBundleCounters::IccpGroups::~IccpGroups()
{
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::has_data() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBundleCounters::IccpGroups::has_operation() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBundleCounters::IccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::IccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-bundle-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::IccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group")
    {
        for(auto const & c : iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups::IccpGroup>();
        c->parent = this;
        iccp_group.push_back(std::move(c));
        children[segment_path] = iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::IccpGroups::get_children()
{
    for (auto const & c : iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::IccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-bundles";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::MlacpSyncRequestsOnAllLocalBundles()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-bundles"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::~MlacpSyncRequestsOnAllLocalBundles()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "bundle-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::has_data() const
{
    return bundle_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::IccpGroupData()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_bundles(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles>())
	,mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_bundles->parent = this;
    children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();

    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "iccp-group-data"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_bundles !=  nullptr && mlacp_sync_requests_on_all_local_bundles->has_data())
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_bundles !=  nullptr && mlacp_sync_requests_on_all_local_bundles->has_operation())
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-bundles")
    {
        if(mlacp_sync_requests_on_all_local_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_bundles = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles>();
            mlacp_sync_requests_on_all_local_bundles->parent = this;
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-bundles");
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-local-bundles") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-bundles";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::MlacpSyncRequestsOnAllForeignBundles()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-bundles"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::~MlacpSyncRequestsOnAllForeignBundles()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::NodeData_()
    :
    	node_id{YType::uint32, "node-id"}
    	,
    mlacp_sync_requests_on_all_foreign_bundles(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles>())
	,mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts>())
{
    mlacp_sync_requests_on_all_foreign_bundles->parent = this;
    children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();

    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::has_data() const
{
    return node_id.is_set
	|| (mlacp_sync_requests_on_all_foreign_bundles !=  nullptr && mlacp_sync_requests_on_all_foreign_bundles->has_data())
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(node_id.operation)
	|| (mlacp_sync_requests_on_all_foreign_bundles !=  nullptr && mlacp_sync_requests_on_all_foreign_bundles->has_operation())
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-bundles")
    {
        if(mlacp_sync_requests_on_all_foreign_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_bundles = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles>();
            mlacp_sync_requests_on_all_foreign_bundles->parent = this;
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-bundles");
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-foreign-bundles") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "bundle-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::has_data() const
{
    return bundle_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData()
    :
    node_data(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_>())
{
    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroup()
    :
    iccp_group_data(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "iccp-group"; yang_parent_name = "bundle-item";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::~IccpGroup()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::get_children()
{
    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::BundleItem()
{
    yang_name = "bundle-item"; yang_parent_name = "bundle";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::~BundleItem()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::has_data() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::has_operation() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group")
    {
        for(auto const & c : iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::IccpGroup>();
        c->parent = this;
        iccp_group.push_back(std::move(c));
        children[segment_path] = iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::get_children()
{
    for (auto const & c : iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::Bundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    bundle_item(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem>())
{
    bundle_item->parent = this;
    children["bundle-item"] = bundle_item.get();

    yang_name = "bundle"; yang_parent_name = "bundles";
}

BundleInformation::MlacpBundleCounters::Bundles::Bundle::~Bundle()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::has_data() const
{
    return bundle_interface.is_set
	|| (bundle_item !=  nullptr && bundle_item->has_data());
}

bool BundleInformation::MlacpBundleCounters::Bundles::Bundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (bundle_item !=  nullptr && bundle_item->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Bundles::Bundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::Bundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-bundle-counters/bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::Bundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-item")
    {
        if(bundle_item != nullptr)
        {
            children["bundle-item"] = bundle_item.get();
        }
        else
        {
            bundle_item = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle::BundleItem>();
            bundle_item->parent = this;
            children["bundle-item"] = bundle_item.get();
        }
        return children.at("bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::Bundle::get_children()
{
    if(children.find("bundle-item") == children.end())
    {
        if(bundle_item != nullptr)
        {
            children["bundle-item"] = bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::Bundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::MlacpBundleCounters::Bundles::Bundles()
{
    yang_name = "bundles"; yang_parent_name = "mlacp-bundle-counters";
}

BundleInformation::MlacpBundleCounters::Bundles::~Bundles()
{
}

bool BundleInformation::MlacpBundleCounters::Bundles::has_data() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBundleCounters::Bundles::has_operation() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBundleCounters::Bundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Bundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-bundle-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Bundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle")
    {
        for(auto const & c : bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles::Bundle>();
        c->parent = this;
        bundle.push_back(std::move(c));
        children[segment_path] = bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Bundles::get_children()
{
    for (auto const & c : bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Bundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-bundles";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::MlacpSyncRequestsOnAllLocalBundles()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-bundles"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::~MlacpSyncRequestsOnAllLocalBundles()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "bundle-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::has_data() const
{
    return bundle_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::IccpGroupData()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_bundles(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles>())
	,mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_bundles->parent = this;
    children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();

    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "iccp-group-data"; yang_parent_name = "node-item";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_bundles !=  nullptr && mlacp_sync_requests_on_all_local_bundles->has_data())
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_bundles !=  nullptr && mlacp_sync_requests_on_all_local_bundles->has_operation())
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-bundles")
    {
        if(mlacp_sync_requests_on_all_local_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_bundles = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalBundles>();
            mlacp_sync_requests_on_all_local_bundles->parent = this;
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-bundles");
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-local-bundles") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-bundles"] = mlacp_sync_requests_on_all_local_bundles.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-bundles";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::MlacpSyncRequestsOnAllForeignBundles()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-bundles"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::~MlacpSyncRequestsOnAllForeignBundles()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::NodeData_()
    :
    	node_id{YType::uint32, "node-id"}
    	,
    mlacp_sync_requests_on_all_foreign_bundles(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles>())
	,mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts>())
{
    mlacp_sync_requests_on_all_foreign_bundles->parent = this;
    children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();

    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::has_data() const
{
    return node_id.is_set
	|| (mlacp_sync_requests_on_all_foreign_bundles !=  nullptr && mlacp_sync_requests_on_all_foreign_bundles->has_data())
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(node_id.operation)
	|| (mlacp_sync_requests_on_all_foreign_bundles !=  nullptr && mlacp_sync_requests_on_all_foreign_bundles->has_operation())
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-bundles")
    {
        if(mlacp_sync_requests_on_all_foreign_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_bundles = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignBundles>();
            mlacp_sync_requests_on_all_foreign_bundles->parent = this;
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-bundles");
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-foreign-bundles") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_bundles != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-bundles"] = mlacp_sync_requests_on_all_foreign_bundles.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "bundle-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::has_data() const
{
    return bundle_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData()
    :
    node_data(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_>())
{
    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "node-item";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeItem()
    :
    iccp_group_data(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "node-item"; yang_parent_name = "node";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::~NodeItem()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::get_children()
{
    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::Nodes::Node::Node()
    :
    	node{YType::str, "node"}
    	,
    node_item(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem>())
{
    node_item->parent = this;
    children["node-item"] = node_item.get();

    yang_name = "node"; yang_parent_name = "nodes";
}

BundleInformation::MlacpBundleCounters::Nodes::Node::~Node()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::has_data() const
{
    return node.is_set
	|| (node_item !=  nullptr && node_item->has_data());
}

bool BundleInformation::MlacpBundleCounters::Nodes::Node::has_operation() const
{
    return is_set(operation)
	|| is_set(node.operation)
	|| (node_item !=  nullptr && node_item->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::Nodes::Node::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node" <<"[node='" <<node.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::Node::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-bundle-counters/nodes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node.is_set || is_set(node.operation)) leaf_name_data.push_back(node.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::Node::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-item")
    {
        if(node_item != nullptr)
        {
            children["node-item"] = node_item.get();
        }
        else
        {
            node_item = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node::NodeItem>();
            node_item->parent = this;
            children["node-item"] = node_item.get();
        }
        return children.at("node-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::Node::get_children()
{
    if(children.find("node-item") == children.end())
    {
        if(node_item != nullptr)
        {
            children["node-item"] = node_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::Node::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node")
    {
        node = value;
    }
}

BundleInformation::MlacpBundleCounters::Nodes::Nodes()
{
    yang_name = "nodes"; yang_parent_name = "mlacp-bundle-counters";
}

BundleInformation::MlacpBundleCounters::Nodes::~Nodes()
{
}

bool BundleInformation::MlacpBundleCounters::Nodes::has_data() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBundleCounters::Nodes::has_operation() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBundleCounters::Nodes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodes";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::Nodes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-bundle-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::Nodes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node")
    {
        for(auto const & c : node)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes::Node>();
        c->parent = this;
        node.push_back(std::move(c));
        children[segment_path] = node.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::Nodes::get_children()
{
    for (auto const & c : node)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::Nodes::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBundleCounters::MlacpBundleCounters()
    :
    bundles(std::make_unique<BundleInformation::MlacpBundleCounters::Bundles>())
	,iccp_groups(std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups>())
	,nodes(std::make_unique<BundleInformation::MlacpBundleCounters::Nodes>())
{
    bundles->parent = this;
    children["bundles"] = bundles.get();

    iccp_groups->parent = this;
    children["iccp-groups"] = iccp_groups.get();

    nodes->parent = this;
    children["nodes"] = nodes.get();

    yang_name = "mlacp-bundle-counters"; yang_parent_name = "bundle-information";
}

BundleInformation::MlacpBundleCounters::~MlacpBundleCounters()
{
}

bool BundleInformation::MlacpBundleCounters::has_data() const
{
    return (bundles !=  nullptr && bundles->has_data())
	|| (iccp_groups !=  nullptr && iccp_groups->has_data())
	|| (nodes !=  nullptr && nodes->has_data());
}

bool BundleInformation::MlacpBundleCounters::has_operation() const
{
    return is_set(operation)
	|| (bundles !=  nullptr && bundles->has_operation())
	|| (iccp_groups !=  nullptr && iccp_groups->has_operation())
	|| (nodes !=  nullptr && nodes->has_operation());
}

std::string BundleInformation::MlacpBundleCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBundleCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBundleCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundles")
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
        else
        {
            bundles = std::make_unique<BundleInformation::MlacpBundleCounters::Bundles>();
            bundles->parent = this;
            children["bundles"] = bundles.get();
        }
        return children.at("bundles");
    }

    if(child_yang_name == "iccp-groups")
    {
        if(iccp_groups != nullptr)
        {
            children["iccp-groups"] = iccp_groups.get();
        }
        else
        {
            iccp_groups = std::make_unique<BundleInformation::MlacpBundleCounters::IccpGroups>();
            iccp_groups->parent = this;
            children["iccp-groups"] = iccp_groups.get();
        }
        return children.at("iccp-groups");
    }

    if(child_yang_name == "nodes")
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
        else
        {
            nodes = std::make_unique<BundleInformation::MlacpBundleCounters::Nodes>();
            nodes->parent = this;
            children["nodes"] = nodes.get();
        }
        return children.at("nodes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBundleCounters::get_children()
{
    if(children.find("bundles") == children.end())
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
    }

    if(children.find("iccp-groups") == children.end())
    {
        if(iccp_groups != nullptr)
        {
            children["iccp-groups"] = iccp_groups.get();
        }
    }

    if(children.find("nodes") == children.end())
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBundleCounters::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::MemberInfo()
    :
    	active{YType::boolean, "active"},
	 bandwidth{YType::uint32, "bandwidth"},
	 interface_handle{YType::str, "interface-handle"},
	 link_order_number{YType::uint16, "link-order-number"},
	 node{YType::str, "node"},
	 notification_received{YType::boolean, "notification-received"},
	 slow_path_up{YType::boolean, "slow-path-up"},
	 time_stamp{YType::uint64, "time-stamp"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
{
    yang_name = "member-info"; yang_parent_name = "protect-bundle-item";
}

BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::~MemberInfo()
{
}

bool BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::has_data() const
{
    return active.is_set
	|| bandwidth.is_set
	|| interface_handle.is_set
	|| link_order_number.is_set
	|| node.is_set
	|| notification_received.is_set
	|| slow_path_up.is_set
	|| time_stamp.is_set
	|| underlying_link_id.is_set;
}

bool BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(active.operation)
	|| is_set(bandwidth.operation)
	|| is_set(interface_handle.operation)
	|| is_set(link_order_number.operation)
	|| is_set(node.operation)
	|| is_set(notification_received.operation)
	|| is_set(slow_path_up.operation)
	|| is_set(time_stamp.operation)
	|| is_set(underlying_link_id.operation);
}

std::string BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active.is_set || is_set(active.operation)) leaf_name_data.push_back(active.get_name_leafdata());
    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (node.is_set || is_set(node.operation)) leaf_name_data.push_back(node.get_name_leafdata());
    if (notification_received.is_set || is_set(notification_received.operation)) leaf_name_data.push_back(notification_received.get_name_leafdata());
    if (slow_path_up.is_set || is_set(slow_path_up.operation)) leaf_name_data.push_back(slow_path_up.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::get_children()
{
    return children;
}

void BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active")
    {
        active = value;
    }
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "node")
    {
        node = value;
    }
    if(value_path == "notification-received")
    {
        notification_received = value;
    }
    if(value_path == "slow-path-up")
    {
        slow_path_up = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::ProtectBundleItem()
    :
    	bundle_interface_handle{YType::str, "bundle-interface-handle"},
	 event_type{YType::enumeration, "event-type"},
	 interface_up{YType::boolean, "interface-up"},
	 minimum_active_links{YType::uint32, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 registered{YType::boolean, "registered"},
	 slow_path_trigger{YType::boolean, "slow-path-trigger"},
	 slow_path_up{YType::boolean, "slow-path-up"},
	 time_stamp{YType::uint64, "time-stamp"}
{
    yang_name = "protect-bundle-item"; yang_parent_name = "protect-bundle";
}

BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::~ProtectBundleItem()
{
}

bool BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::has_data() const
{
    for (std::size_t index=0; index<member_info.size(); index++)
    {
        if(member_info[index]->has_data())
            return true;
    }
    return bundle_interface_handle.is_set
	|| event_type.is_set
	|| interface_up.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| registered.is_set
	|| slow_path_trigger.is_set
	|| slow_path_up.is_set
	|| time_stamp.is_set;
}

bool BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::has_operation() const
{
    for (std::size_t index=0; index<member_info.size(); index++)
    {
        if(member_info[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(bundle_interface_handle.operation)
	|| is_set(event_type.operation)
	|| is_set(interface_up.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(registered.operation)
	|| is_set(slow_path_trigger.operation)
	|| is_set(slow_path_up.operation)
	|| is_set(time_stamp.operation);
}

std::string BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protect-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface_handle.is_set || is_set(bundle_interface_handle.operation)) leaf_name_data.push_back(bundle_interface_handle.get_name_leafdata());
    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());
    if (interface_up.is_set || is_set(interface_up.operation)) leaf_name_data.push_back(interface_up.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (registered.is_set || is_set(registered.operation)) leaf_name_data.push_back(registered.get_name_leafdata());
    if (slow_path_trigger.is_set || is_set(slow_path_trigger.operation)) leaf_name_data.push_back(slow_path_trigger.get_name_leafdata());
    if (slow_path_up.is_set || is_set(slow_path_up.operation)) leaf_name_data.push_back(slow_path_up.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-info")
    {
        for(auto const & c : member_info)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::MemberInfo>();
        c->parent = this;
        member_info.push_back(std::move(c));
        children[segment_path] = member_info.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::get_children()
{
    for (auto const & c : member_info)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface-handle")
    {
        bundle_interface_handle = value;
    }
    if(value_path == "event-type")
    {
        event_type = value;
    }
    if(value_path == "interface-up")
    {
        interface_up = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "registered")
    {
        registered = value;
    }
    if(value_path == "slow-path-trigger")
    {
        slow_path_trigger = value;
    }
    if(value_path == "slow-path-up")
    {
        slow_path_up = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    protect_bundle_item(std::make_unique<BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem>())
{
    protect_bundle_item->parent = this;
    children["protect-bundle-item"] = protect_bundle_item.get();

    yang_name = "protect-bundle"; yang_parent_name = "protect-bundles";
}

BundleInformation::Protect::ProtectBundles::ProtectBundle::~ProtectBundle()
{
}

bool BundleInformation::Protect::ProtectBundles::ProtectBundle::has_data() const
{
    return bundle_interface.is_set
	|| (protect_bundle_item !=  nullptr && protect_bundle_item->has_data());
}

bool BundleInformation::Protect::ProtectBundles::ProtectBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (protect_bundle_item !=  nullptr && protect_bundle_item->has_operation());
}

std::string BundleInformation::Protect::ProtectBundles::ProtectBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protect-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Protect::ProtectBundles::ProtectBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/protect/protect-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Protect::ProtectBundles::ProtectBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "protect-bundle-item")
    {
        if(protect_bundle_item != nullptr)
        {
            children["protect-bundle-item"] = protect_bundle_item.get();
        }
        else
        {
            protect_bundle_item = std::make_unique<BundleInformation::Protect::ProtectBundles::ProtectBundle::ProtectBundleItem>();
            protect_bundle_item->parent = this;
            children["protect-bundle-item"] = protect_bundle_item.get();
        }
        return children.at("protect-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Protect::ProtectBundles::ProtectBundle::get_children()
{
    if(children.find("protect-bundle-item") == children.end())
    {
        if(protect_bundle_item != nullptr)
        {
            children["protect-bundle-item"] = protect_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::Protect::ProtectBundles::ProtectBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::Protect::ProtectBundles::ProtectBundles()
{
    yang_name = "protect-bundles"; yang_parent_name = "protect";
}

BundleInformation::Protect::ProtectBundles::~ProtectBundles()
{
}

bool BundleInformation::Protect::ProtectBundles::has_data() const
{
    for (std::size_t index=0; index<protect_bundle.size(); index++)
    {
        if(protect_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Protect::ProtectBundles::has_operation() const
{
    for (std::size_t index=0; index<protect_bundle.size(); index++)
    {
        if(protect_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Protect::ProtectBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protect-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::Protect::ProtectBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/protect/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Protect::ProtectBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "protect-bundle")
    {
        for(auto const & c : protect_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Protect::ProtectBundles::ProtectBundle>();
        c->parent = this;
        protect_bundle.push_back(std::move(c));
        children[segment_path] = protect_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Protect::ProtectBundles::get_children()
{
    for (auto const & c : protect_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Protect::ProtectBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Protect::Protect()
    :
    protect_bundles(std::make_unique<BundleInformation::Protect::ProtectBundles>())
{
    protect_bundles->parent = this;
    children["protect-bundles"] = protect_bundles.get();

    yang_name = "protect"; yang_parent_name = "bundle-information";
}

BundleInformation::Protect::~Protect()
{
}

bool BundleInformation::Protect::has_data() const
{
    return (protect_bundles !=  nullptr && protect_bundles->has_data());
}

bool BundleInformation::Protect::has_operation() const
{
    return is_set(operation)
	|| (protect_bundles !=  nullptr && protect_bundles->has_operation());
}

std::string BundleInformation::Protect::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protect";

    return path_buffer.str();

}

EntityPath BundleInformation::Protect::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Protect::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "protect-bundles")
    {
        if(protect_bundles != nullptr)
        {
            children["protect-bundles"] = protect_bundles.get();
        }
        else
        {
            protect_bundles = std::make_unique<BundleInformation::Protect::ProtectBundles>();
            protect_bundles->parent = this;
            children["protect-bundles"] = protect_bundles.get();
        }
        return children.at("protect-bundles");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Protect::get_children()
{
    if(children.find("protect-bundles") == children.end())
    {
        if(protect_bundles != nullptr)
        {
            children["protect-bundles"] = protect_bundles.get();
        }
    }

    return children;
}

void BundleInformation::Protect::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::~SystemId()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::NodeData()
    :
    	iccp_group_state{YType::enumeration, "iccp-group-state"},
	 ldp_id{YType::str, "ldp-id"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 node_state{YType::enumeration, "node-state"},
	 version_number{YType::uint32, "version-number"}
    	,
    system_id(std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "node-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::has_data() const
{
    return iccp_group_state.is_set
	|| ldp_id.is_set
	|| mlacp_node_id.is_set
	|| node_state.is_set
	|| version_number.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_state.operation)
	|| is_set(ldp_id.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(node_state.operation)
	|| is_set(version_number.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_state.is_set || is_set(iccp_group_state.operation)) leaf_name_data.push_back(iccp_group_state.get_name_leafdata());
    if (ldp_id.is_set || is_set(ldp_id.operation)) leaf_name_data.push_back(ldp_id.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (node_state.is_set || is_set(node_state.operation)) leaf_name_data.push_back(node_state.get_name_leafdata());
    if (version_number.is_set || is_set(version_number.operation)) leaf_name_data.push_back(version_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::SystemId>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-state")
    {
        iccp_group_state = value;
    }
    if(value_path == "ldp-id")
    {
        ldp_id = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "node-state")
    {
        node_state = value;
    }
    if(value_path == "version-number")
    {
        version_number = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::IccpGroupData()
    :
    	connect_timer_running{YType::uint64, "connect-timer-running"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 singleton{YType::boolean, "singleton"}
{
    yang_name = "iccp-group-data"; yang_parent_name = "mlacp-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return connect_timer_running.is_set
	|| iccp_group_id.is_set
	|| singleton.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(connect_timer_running.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(singleton.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (connect_timer_running.is_set || is_set(connect_timer_running.operation)) leaf_name_data.push_back(connect_timer_running.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::get_children()
{
    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "connect-timer-running")
    {
        connect_timer_running = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "mlacp-bundle-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MlacpBundleData()
    :
    	aggregator_id{YType::uint16, "aggregator-id"},
	 bundle_name{YType::str, "bundle-name"},
	 bundle_state{YType::enumeration, "bundle-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 port_priority{YType::uint16, "port-priority"}
    	,
    mac_address(std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "mlacp-bundle-data"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::~MlacpBundleData()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::has_data() const
{
    return aggregator_id.is_set
	|| bundle_name.is_set
	|| bundle_state.is_set
	|| mlacp_node_id.is_set
	|| port_priority.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(aggregator_id.operation)
	|| is_set(bundle_name.operation)
	|| is_set(bundle_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(port_priority.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (aggregator_id.is_set || is_set(aggregator_id.operation)) leaf_name_data.push_back(aggregator_id.get_name_leafdata());
    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (bundle_state.is_set || is_set(bundle_state.operation)) leaf_name_data.push_back(bundle_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::get_children()
{
    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "aggregator-id")
    {
        aggregator_id = value;
    }
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "bundle-state")
    {
        bundle_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::MlacpMemberData()
    :
    	configured_priority{YType::uint16, "configured-priority"},
	 interface_handle{YType::str, "interface-handle"},
	 member_state{YType::enumeration, "member-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 operational_priority{YType::uint16, "operational-priority"},
	 port_name{YType::str, "port-name"},
	 port_number{YType::uint16, "port-number"}
{
    yang_name = "mlacp-member-data"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::~MlacpMemberData()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::has_data() const
{
    return configured_priority.is_set
	|| interface_handle.is_set
	|| member_state.is_set
	|| mlacp_node_id.is_set
	|| operational_priority.is_set
	|| port_name.is_set
	|| port_number.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_priority.operation)
	|| is_set(interface_handle.operation)
	|| is_set(member_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(operational_priority.operation)
	|| is_set(port_name.operation)
	|| is_set(port_number.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_priority.is_set || is_set(configured_priority.operation)) leaf_name_data.push_back(configured_priority.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (operational_priority.is_set || is_set(operational_priority.operation)) leaf_name_data.push_back(operational_priority.get_name_leafdata());
    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::get_children()
{
    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-priority")
    {
        configured_priority = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "operational-priority")
    {
        operational_priority = value;
    }
    if(value_path == "port-name")
    {
        port_name = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::BundleData()
    :
    	bundle_interface_key{YType::uint16, "bundle-interface-key"},
	 media_type{YType::enumeration, "media-type"},
	 redundancy_object_id{YType::uint64, "redundancy-object-id"}
{
    yang_name = "bundle-data"; yang_parent_name = "mlacp-data";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::has_data() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_data())
            return true;
    }
    return bundle_interface_key.is_set
	|| media_type.is_set
	|| redundancy_object_id.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::has_operation() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(bundle_interface_key.operation)
	|| is_set(media_type.operation)
	|| is_set(redundancy_object_id.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface_key.is_set || is_set(bundle_interface_key.operation)) leaf_name_data.push_back(bundle_interface_key.get_name_leafdata());
    if (media_type.is_set || is_set(media_type.operation)) leaf_name_data.push_back(media_type.get_name_leafdata());
    if (redundancy_object_id.is_set || is_set(redundancy_object_id.operation)) leaf_name_data.push_back(redundancy_object_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-data")
    {
        for(auto const & c : mlacp_bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpBundleData>();
        c->parent = this;
        mlacp_bundle_data.push_back(std::move(c));
        children[segment_path] = mlacp_bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-member-data")
    {
        for(auto const & c : mlacp_member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::MlacpMemberData>();
        c->parent = this;
        mlacp_member_data.push_back(std::move(c));
        children[segment_path] = mlacp_member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::get_children()
{
    for (auto const & c : mlacp_bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : mlacp_member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface-key")
    {
        bundle_interface_key = value;
    }
    if(value_path == "media-type")
    {
        media_type = value;
    }
    if(value_path == "redundancy-object-id")
    {
        redundancy_object_id = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::MlacpData()
    :
    iccp_group_data(std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "mlacp-data"; yang_parent_name = "mlacp-bundle-item-brief";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::~MlacpData()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpBundleItemBrief()
{
    yang_name = "mlacp-bundle-item-brief"; yang_parent_name = "mlacp-bundle-brief";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::~MlacpBundleItemBrief()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::has_data() const
{
    for (std::size_t index=0; index<mlacp_data.size(); index++)
    {
        if(mlacp_data[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::has_operation() const
{
    for (std::size_t index=0; index<mlacp_data.size(); index++)
    {
        if(mlacp_data[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-item-brief";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-data")
    {
        for(auto const & c : mlacp_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::MlacpData>();
        c->parent = this;
        mlacp_data.push_back(std::move(c));
        children[segment_path] = mlacp_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::get_children()
{
    for (auto const & c : mlacp_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleBrief()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    mlacp_bundle_item_brief(std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief>())
{
    mlacp_bundle_item_brief->parent = this;
    children["mlacp-bundle-item-brief"] = mlacp_bundle_item_brief.get();

    yang_name = "mlacp-bundle-brief"; yang_parent_name = "mlacp-bundle-briefs";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::~MlacpBundleBrief()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::has_data() const
{
    return bundle_interface.is_set
	|| (mlacp_bundle_item_brief !=  nullptr && mlacp_bundle_item_brief->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (mlacp_bundle_item_brief !=  nullptr && mlacp_bundle_item_brief->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-brief" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-brief/mlacp-bundle-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-item-brief")
    {
        if(mlacp_bundle_item_brief != nullptr)
        {
            children["mlacp-bundle-item-brief"] = mlacp_bundle_item_brief.get();
        }
        else
        {
            mlacp_bundle_item_brief = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::MlacpBundleItemBrief>();
            mlacp_bundle_item_brief->parent = this;
            children["mlacp-bundle-item-brief"] = mlacp_bundle_item_brief.get();
        }
        return children.at("mlacp-bundle-item-brief");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::get_children()
{
    if(children.find("mlacp-bundle-item-brief") == children.end())
    {
        if(mlacp_bundle_item_brief != nullptr)
        {
            children["mlacp-bundle-item-brief"] = mlacp_bundle_item_brief.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBriefs()
{
    yang_name = "mlacp-bundle-briefs"; yang_parent_name = "mlacp-brief";
}

BundleInformation::MlacpBrief::MlacpBundleBriefs::~MlacpBundleBriefs()
{
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::has_data() const
{
    for (std::size_t index=0; index<mlacp_bundle_brief.size(); index++)
    {
        if(mlacp_bundle_brief[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBrief::MlacpBundleBriefs::has_operation() const
{
    for (std::size_t index=0; index<mlacp_bundle_brief.size(); index++)
    {
        if(mlacp_bundle_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBrief::MlacpBundleBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-briefs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBundleBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBundleBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-brief")
    {
        for(auto const & c : mlacp_bundle_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs::MlacpBundleBrief>();
        c->parent = this;
        mlacp_bundle_brief.push_back(std::move(c));
        children[segment_path] = mlacp_bundle_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBundleBriefs::get_children()
{
    for (auto const & c : mlacp_bundle_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBundleBriefs::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "node-data";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::~SystemId()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::NodeData()
    :
    	iccp_group_state{YType::enumeration, "iccp-group-state"},
	 ldp_id{YType::str, "ldp-id"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 node_state{YType::enumeration, "node-state"},
	 version_number{YType::uint32, "version-number"}
    	,
    system_id(std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "node-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::has_data() const
{
    return iccp_group_state.is_set
	|| ldp_id.is_set
	|| mlacp_node_id.is_set
	|| node_state.is_set
	|| version_number.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_state.operation)
	|| is_set(ldp_id.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(node_state.operation)
	|| is_set(version_number.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_state.is_set || is_set(iccp_group_state.operation)) leaf_name_data.push_back(iccp_group_state.get_name_leafdata());
    if (ldp_id.is_set || is_set(ldp_id.operation)) leaf_name_data.push_back(ldp_id.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (node_state.is_set || is_set(node_state.operation)) leaf_name_data.push_back(node_state.get_name_leafdata());
    if (version_number.is_set || is_set(version_number.operation)) leaf_name_data.push_back(version_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::SystemId>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-state")
    {
        iccp_group_state = value;
    }
    if(value_path == "ldp-id")
    {
        ldp_id = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "node-state")
    {
        node_state = value;
    }
    if(value_path == "version-number")
    {
        version_number = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::IccpGroupData()
    :
    	connect_timer_running{YType::uint64, "connect-timer-running"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 singleton{YType::boolean, "singleton"}
{
    yang_name = "iccp-group-data"; yang_parent_name = "mlacp-brief-iccp-group-item";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return connect_timer_running.is_set
	|| iccp_group_id.is_set
	|| singleton.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(connect_timer_running.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(singleton.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (connect_timer_running.is_set || is_set(connect_timer_running.operation)) leaf_name_data.push_back(connect_timer_running.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::get_children()
{
    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "connect-timer-running")
    {
        connect_timer_running = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "mlacp-bundle-data";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MlacpBundleData()
    :
    	aggregator_id{YType::uint16, "aggregator-id"},
	 bundle_name{YType::str, "bundle-name"},
	 bundle_state{YType::enumeration, "bundle-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 port_priority{YType::uint16, "port-priority"}
    	,
    mac_address(std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "mlacp-bundle-data"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::~MlacpBundleData()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::has_data() const
{
    return aggregator_id.is_set
	|| bundle_name.is_set
	|| bundle_state.is_set
	|| mlacp_node_id.is_set
	|| port_priority.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(aggregator_id.operation)
	|| is_set(bundle_name.operation)
	|| is_set(bundle_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(port_priority.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (aggregator_id.is_set || is_set(aggregator_id.operation)) leaf_name_data.push_back(aggregator_id.get_name_leafdata());
    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (bundle_state.is_set || is_set(bundle_state.operation)) leaf_name_data.push_back(bundle_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::get_children()
{
    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "aggregator-id")
    {
        aggregator_id = value;
    }
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "bundle-state")
    {
        bundle_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::MlacpMemberData()
    :
    	configured_priority{YType::uint16, "configured-priority"},
	 interface_handle{YType::str, "interface-handle"},
	 member_state{YType::enumeration, "member-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 operational_priority{YType::uint16, "operational-priority"},
	 port_name{YType::str, "port-name"},
	 port_number{YType::uint16, "port-number"}
{
    yang_name = "mlacp-member-data"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::~MlacpMemberData()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::has_data() const
{
    return configured_priority.is_set
	|| interface_handle.is_set
	|| member_state.is_set
	|| mlacp_node_id.is_set
	|| operational_priority.is_set
	|| port_name.is_set
	|| port_number.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_priority.operation)
	|| is_set(interface_handle.operation)
	|| is_set(member_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(operational_priority.operation)
	|| is_set(port_name.operation)
	|| is_set(port_number.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_priority.is_set || is_set(configured_priority.operation)) leaf_name_data.push_back(configured_priority.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (operational_priority.is_set || is_set(operational_priority.operation)) leaf_name_data.push_back(operational_priority.get_name_leafdata());
    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::get_children()
{
    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-priority")
    {
        configured_priority = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "operational-priority")
    {
        operational_priority = value;
    }
    if(value_path == "port-name")
    {
        port_name = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::BundleData()
    :
    	bundle_interface_key{YType::uint16, "bundle-interface-key"},
	 media_type{YType::enumeration, "media-type"},
	 redundancy_object_id{YType::uint64, "redundancy-object-id"}
{
    yang_name = "bundle-data"; yang_parent_name = "mlacp-brief-iccp-group-item";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::has_data() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_data())
            return true;
    }
    return bundle_interface_key.is_set
	|| media_type.is_set
	|| redundancy_object_id.is_set;
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::has_operation() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(bundle_interface_key.operation)
	|| is_set(media_type.operation)
	|| is_set(redundancy_object_id.operation);
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface_key.is_set || is_set(bundle_interface_key.operation)) leaf_name_data.push_back(bundle_interface_key.get_name_leafdata());
    if (media_type.is_set || is_set(media_type.operation)) leaf_name_data.push_back(media_type.get_name_leafdata());
    if (redundancy_object_id.is_set || is_set(redundancy_object_id.operation)) leaf_name_data.push_back(redundancy_object_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-data")
    {
        for(auto const & c : mlacp_bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpBundleData>();
        c->parent = this;
        mlacp_bundle_data.push_back(std::move(c));
        children[segment_path] = mlacp_bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-member-data")
    {
        for(auto const & c : mlacp_member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::MlacpMemberData>();
        c->parent = this;
        mlacp_member_data.push_back(std::move(c));
        children[segment_path] = mlacp_member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::get_children()
{
    for (auto const & c : mlacp_bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : mlacp_member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface-key")
    {
        bundle_interface_key = value;
    }
    if(value_path == "media-type")
    {
        media_type = value;
    }
    if(value_path == "redundancy-object-id")
    {
        redundancy_object_id = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::MlacpBriefIccpGroupItem()
    :
    iccp_group_data(std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "mlacp-brief-iccp-group-item"; yang_parent_name = "mlacp-brief-iccp-group";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::~MlacpBriefIccpGroupItem()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-brief-iccp-group-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    mlacp_brief_iccp_group_item(std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem>())
{
    mlacp_brief_iccp_group_item->parent = this;
    children["mlacp-brief-iccp-group-item"] = mlacp_brief_iccp_group_item.get();

    yang_name = "mlacp-brief-iccp-group"; yang_parent_name = "mlacp-brief-iccp-groups";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::~MlacpBriefIccpGroup()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (mlacp_brief_iccp_group_item !=  nullptr && mlacp_brief_iccp_group_item->has_data());
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (mlacp_brief_iccp_group_item !=  nullptr && mlacp_brief_iccp_group_item->has_operation());
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-brief-iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-brief/mlacp-brief-iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-brief-iccp-group-item")
    {
        if(mlacp_brief_iccp_group_item != nullptr)
        {
            children["mlacp-brief-iccp-group-item"] = mlacp_brief_iccp_group_item.get();
        }
        else
        {
            mlacp_brief_iccp_group_item = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::MlacpBriefIccpGroupItem>();
            mlacp_brief_iccp_group_item->parent = this;
            children["mlacp-brief-iccp-group-item"] = mlacp_brief_iccp_group_item.get();
        }
        return children.at("mlacp-brief-iccp-group-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::get_children()
{
    if(children.find("mlacp-brief-iccp-group-item") == children.end())
    {
        if(mlacp_brief_iccp_group_item != nullptr)
        {
            children["mlacp-brief-iccp-group-item"] = mlacp_brief_iccp_group_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroups()
{
    yang_name = "mlacp-brief-iccp-groups"; yang_parent_name = "mlacp-brief";
}

BundleInformation::MlacpBrief::MlacpBriefIccpGroups::~MlacpBriefIccpGroups()
{
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::has_data() const
{
    for (std::size_t index=0; index<mlacp_brief_iccp_group.size(); index++)
    {
        if(mlacp_brief_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpBrief::MlacpBriefIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<mlacp_brief_iccp_group.size(); index++)
    {
        if(mlacp_brief_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpBrief::MlacpBriefIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-brief-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::MlacpBriefIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::MlacpBriefIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-brief-iccp-group")
    {
        for(auto const & c : mlacp_brief_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups::MlacpBriefIccpGroup>();
        c->parent = this;
        mlacp_brief_iccp_group.push_back(std::move(c));
        children[segment_path] = mlacp_brief_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::MlacpBriefIccpGroups::get_children()
{
    for (auto const & c : mlacp_brief_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::MlacpBriefIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpBrief::MlacpBrief()
    :
    mlacp_brief_iccp_groups(std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups>())
	,mlacp_bundle_briefs(std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs>())
{
    mlacp_brief_iccp_groups->parent = this;
    children["mlacp-brief-iccp-groups"] = mlacp_brief_iccp_groups.get();

    mlacp_bundle_briefs->parent = this;
    children["mlacp-bundle-briefs"] = mlacp_bundle_briefs.get();

    yang_name = "mlacp-brief"; yang_parent_name = "bundle-information";
}

BundleInformation::MlacpBrief::~MlacpBrief()
{
}

bool BundleInformation::MlacpBrief::has_data() const
{
    return (mlacp_brief_iccp_groups !=  nullptr && mlacp_brief_iccp_groups->has_data())
	|| (mlacp_bundle_briefs !=  nullptr && mlacp_bundle_briefs->has_data());
}

bool BundleInformation::MlacpBrief::has_operation() const
{
    return is_set(operation)
	|| (mlacp_brief_iccp_groups !=  nullptr && mlacp_brief_iccp_groups->has_operation())
	|| (mlacp_bundle_briefs !=  nullptr && mlacp_bundle_briefs->has_operation());
}

std::string BundleInformation::MlacpBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-brief";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-brief-iccp-groups")
    {
        if(mlacp_brief_iccp_groups != nullptr)
        {
            children["mlacp-brief-iccp-groups"] = mlacp_brief_iccp_groups.get();
        }
        else
        {
            mlacp_brief_iccp_groups = std::make_unique<BundleInformation::MlacpBrief::MlacpBriefIccpGroups>();
            mlacp_brief_iccp_groups->parent = this;
            children["mlacp-brief-iccp-groups"] = mlacp_brief_iccp_groups.get();
        }
        return children.at("mlacp-brief-iccp-groups");
    }

    if(child_yang_name == "mlacp-bundle-briefs")
    {
        if(mlacp_bundle_briefs != nullptr)
        {
            children["mlacp-bundle-briefs"] = mlacp_bundle_briefs.get();
        }
        else
        {
            mlacp_bundle_briefs = std::make_unique<BundleInformation::MlacpBrief::MlacpBundleBriefs>();
            mlacp_bundle_briefs->parent = this;
            children["mlacp-bundle-briefs"] = mlacp_bundle_briefs.get();
        }
        return children.at("mlacp-bundle-briefs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpBrief::get_children()
{
    if(children.find("mlacp-brief-iccp-groups") == children.end())
    {
        if(mlacp_brief_iccp_groups != nullptr)
        {
            children["mlacp-brief-iccp-groups"] = mlacp_brief_iccp_groups.get();
        }
    }

    if(children.find("mlacp-bundle-briefs") == children.end())
    {
        if(mlacp_bundle_briefs != nullptr)
        {
            children["mlacp-bundle-briefs"] = mlacp_bundle_briefs.get();
        }
    }

    return children;
}

void BundleInformation::MlacpBrief::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "node-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::~SystemId()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::NodeData()
    :
    	iccp_group_state{YType::enumeration, "iccp-group-state"},
	 ldp_id{YType::str, "ldp-id"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 node_state{YType::enumeration, "node-state"},
	 version_number{YType::uint32, "version-number"}
    	,
    system_id(std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "node-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::~NodeData()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::has_data() const
{
    return iccp_group_state.is_set
	|| ldp_id.is_set
	|| mlacp_node_id.is_set
	|| node_state.is_set
	|| version_number.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_state.operation)
	|| is_set(ldp_id.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(node_state.operation)
	|| is_set(version_number.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_state.is_set || is_set(iccp_group_state.operation)) leaf_name_data.push_back(iccp_group_state.get_name_leafdata());
    if (ldp_id.is_set || is_set(ldp_id.operation)) leaf_name_data.push_back(ldp_id.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (node_state.is_set || is_set(node_state.operation)) leaf_name_data.push_back(node_state.get_name_leafdata());
    if (version_number.is_set || is_set(version_number.operation)) leaf_name_data.push_back(version_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::SystemId>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-state")
    {
        iccp_group_state = value;
    }
    if(value_path == "ldp-id")
    {
        ldp_id = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "node-state")
    {
        node_state = value;
    }
    if(value_path == "version-number")
    {
        version_number = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::IccpGroupData()
    :
    	connect_timer_running{YType::uint64, "connect-timer-running"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 singleton{YType::boolean, "singleton"}
{
    yang_name = "iccp-group-data"; yang_parent_name = "mlacp-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return connect_timer_running.is_set
	|| iccp_group_id.is_set
	|| singleton.is_set;
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(connect_timer_running.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(singleton.operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (connect_timer_running.is_set || is_set(connect_timer_running.operation)) leaf_name_data.push_back(connect_timer_running.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::get_children()
{
    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "connect-timer-running")
    {
        connect_timer_running = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "mlacp-bundle-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MlacpBundleData()
    :
    	aggregator_id{YType::uint16, "aggregator-id"},
	 bundle_name{YType::str, "bundle-name"},
	 bundle_state{YType::enumeration, "bundle-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 port_priority{YType::uint16, "port-priority"}
    	,
    mac_address(std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "mlacp-bundle-data"; yang_parent_name = "bundle-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::~MlacpBundleData()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::has_data() const
{
    return aggregator_id.is_set
	|| bundle_name.is_set
	|| bundle_state.is_set
	|| mlacp_node_id.is_set
	|| port_priority.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(aggregator_id.operation)
	|| is_set(bundle_name.operation)
	|| is_set(bundle_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(port_priority.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (aggregator_id.is_set || is_set(aggregator_id.operation)) leaf_name_data.push_back(aggregator_id.get_name_leafdata());
    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (bundle_state.is_set || is_set(bundle_state.operation)) leaf_name_data.push_back(bundle_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::get_children()
{
    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "aggregator-id")
    {
        aggregator_id = value;
    }
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "bundle-state")
    {
        bundle_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::MlacpMemberData()
    :
    	configured_priority{YType::uint16, "configured-priority"},
	 interface_handle{YType::str, "interface-handle"},
	 member_state{YType::enumeration, "member-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 operational_priority{YType::uint16, "operational-priority"},
	 port_name{YType::str, "port-name"},
	 port_number{YType::uint16, "port-number"}
{
    yang_name = "mlacp-member-data"; yang_parent_name = "bundle-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::~MlacpMemberData()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::has_data() const
{
    return configured_priority.is_set
	|| interface_handle.is_set
	|| member_state.is_set
	|| mlacp_node_id.is_set
	|| operational_priority.is_set
	|| port_name.is_set
	|| port_number.is_set;
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_priority.operation)
	|| is_set(interface_handle.operation)
	|| is_set(member_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(operational_priority.operation)
	|| is_set(port_name.operation)
	|| is_set(port_number.operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_priority.is_set || is_set(configured_priority.operation)) leaf_name_data.push_back(configured_priority.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (operational_priority.is_set || is_set(operational_priority.operation)) leaf_name_data.push_back(operational_priority.get_name_leafdata());
    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::get_children()
{
    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-priority")
    {
        configured_priority = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "operational-priority")
    {
        operational_priority = value;
    }
    if(value_path == "port-name")
    {
        port_name = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::BundleData()
    :
    	bundle_interface_key{YType::uint16, "bundle-interface-key"},
	 media_type{YType::enumeration, "media-type"},
	 redundancy_object_id{YType::uint64, "redundancy-object-id"}
{
    yang_name = "bundle-data"; yang_parent_name = "mlacp-data";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::~BundleData()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::has_data() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_data())
            return true;
    }
    return bundle_interface_key.is_set
	|| media_type.is_set
	|| redundancy_object_id.is_set;
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::has_operation() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(bundle_interface_key.operation)
	|| is_set(media_type.operation)
	|| is_set(redundancy_object_id.operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface_key.is_set || is_set(bundle_interface_key.operation)) leaf_name_data.push_back(bundle_interface_key.get_name_leafdata());
    if (media_type.is_set || is_set(media_type.operation)) leaf_name_data.push_back(media_type.get_name_leafdata());
    if (redundancy_object_id.is_set || is_set(redundancy_object_id.operation)) leaf_name_data.push_back(redundancy_object_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-data")
    {
        for(auto const & c : mlacp_bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpBundleData>();
        c->parent = this;
        mlacp_bundle_data.push_back(std::move(c));
        children[segment_path] = mlacp_bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-member-data")
    {
        for(auto const & c : mlacp_member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::MlacpMemberData>();
        c->parent = this;
        mlacp_member_data.push_back(std::move(c));
        children[segment_path] = mlacp_member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::get_children()
{
    for (auto const & c : mlacp_bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : mlacp_member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface-key")
    {
        bundle_interface_key = value;
    }
    if(value_path == "media-type")
    {
        media_type = value;
    }
    if(value_path == "redundancy-object-id")
    {
        redundancy_object_id = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::MlacpData()
    :
    iccp_group_data(std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "mlacp-data"; yang_parent_name = "mlacp-bundle-item";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::~MlacpData()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpBundleItem()
{
    yang_name = "mlacp-bundle-item"; yang_parent_name = "mlacp-bundle";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::~MlacpBundleItem()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::has_data() const
{
    for (std::size_t index=0; index<mlacp_data.size(); index++)
    {
        if(mlacp_data[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::has_operation() const
{
    for (std::size_t index=0; index<mlacp_data.size(); index++)
    {
        if(mlacp_data[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-data")
    {
        for(auto const & c : mlacp_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::MlacpData>();
        c->parent = this;
        mlacp_data.push_back(std::move(c));
        children[segment_path] = mlacp_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::get_children()
{
    for (auto const & c : mlacp_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    mlacp_bundle_item(std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem>())
{
    mlacp_bundle_item->parent = this;
    children["mlacp-bundle-item"] = mlacp_bundle_item.get();

    yang_name = "mlacp-bundle"; yang_parent_name = "mlacp-bundles";
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundle::~MlacpBundle()
{
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::has_data() const
{
    return bundle_interface.is_set
	|| (mlacp_bundle_item !=  nullptr && mlacp_bundle_item->has_data());
}

bool BundleInformation::Mlacp::MlacpBundles::MlacpBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (mlacp_bundle_item !=  nullptr && mlacp_bundle_item->has_operation());
}

std::string BundleInformation::Mlacp::MlacpBundles::MlacpBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::MlacpBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp/mlacp-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::MlacpBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-item")
    {
        if(mlacp_bundle_item != nullptr)
        {
            children["mlacp-bundle-item"] = mlacp_bundle_item.get();
        }
        else
        {
            mlacp_bundle_item = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle::MlacpBundleItem>();
            mlacp_bundle_item->parent = this;
            children["mlacp-bundle-item"] = mlacp_bundle_item.get();
        }
        return children.at("mlacp-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::MlacpBundle::get_children()
{
    if(children.find("mlacp-bundle-item") == children.end())
    {
        if(mlacp_bundle_item != nullptr)
        {
            children["mlacp-bundle-item"] = mlacp_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::MlacpBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::Mlacp::MlacpBundles::MlacpBundles()
{
    yang_name = "mlacp-bundles"; yang_parent_name = "mlacp";
}

BundleInformation::Mlacp::MlacpBundles::~MlacpBundles()
{
}

bool BundleInformation::Mlacp::MlacpBundles::has_data() const
{
    for (std::size_t index=0; index<mlacp_bundle.size(); index++)
    {
        if(mlacp_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Mlacp::MlacpBundles::has_operation() const
{
    for (std::size_t index=0; index<mlacp_bundle.size(); index++)
    {
        if(mlacp_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Mlacp::MlacpBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle")
    {
        for(auto const & c : mlacp_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpBundles::MlacpBundle>();
        c->parent = this;
        mlacp_bundle.push_back(std::move(c));
        children[segment_path] = mlacp_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpBundles::get_children()
{
    for (auto const & c : mlacp_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemId()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "node-data";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::~SystemId()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::NodeData()
    :
    	iccp_group_state{YType::enumeration, "iccp-group-state"},
	 ldp_id{YType::str, "ldp-id"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 node_state{YType::enumeration, "node-state"},
	 version_number{YType::uint32, "version-number"}
    	,
    system_id(std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "node-data"; yang_parent_name = "iccp-group-data";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::~NodeData()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::has_data() const
{
    return iccp_group_state.is_set
	|| ldp_id.is_set
	|| mlacp_node_id.is_set
	|| node_state.is_set
	|| version_number.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_state.operation)
	|| is_set(ldp_id.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(node_state.operation)
	|| is_set(version_number.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_state.is_set || is_set(iccp_group_state.operation)) leaf_name_data.push_back(iccp_group_state.get_name_leafdata());
    if (ldp_id.is_set || is_set(ldp_id.operation)) leaf_name_data.push_back(ldp_id.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (node_state.is_set || is_set(node_state.operation)) leaf_name_data.push_back(node_state.get_name_leafdata());
    if (version_number.is_set || is_set(version_number.operation)) leaf_name_data.push_back(version_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::SystemId>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-state")
    {
        iccp_group_state = value;
    }
    if(value_path == "ldp-id")
    {
        ldp_id = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "node-state")
    {
        node_state = value;
    }
    if(value_path == "version-number")
    {
        version_number = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::IccpGroupData()
    :
    	connect_timer_running{YType::uint64, "connect-timer-running"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 singleton{YType::boolean, "singleton"}
{
    yang_name = "iccp-group-data"; yang_parent_name = "mlacp-iccp-group-item";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::~IccpGroupData()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::has_data() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return connect_timer_running.is_set
	|| iccp_group_id.is_set
	|| singleton.is_set;
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::has_operation() const
{
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(connect_timer_running.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(singleton.operation);
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (connect_timer_running.is_set || is_set(connect_timer_running.operation)) leaf_name_data.push_back(connect_timer_running.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::get_children()
{
    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "connect-timer-running")
    {
        connect_timer_running = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "mlacp-bundle-data";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::~MacAddress()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::get_children()
{
    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MlacpBundleData()
    :
    	aggregator_id{YType::uint16, "aggregator-id"},
	 bundle_name{YType::str, "bundle-name"},
	 bundle_state{YType::enumeration, "bundle-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 port_priority{YType::uint16, "port-priority"}
    	,
    mac_address(std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "mlacp-bundle-data"; yang_parent_name = "bundle-data";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::~MlacpBundleData()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::has_data() const
{
    return aggregator_id.is_set
	|| bundle_name.is_set
	|| bundle_state.is_set
	|| mlacp_node_id.is_set
	|| port_priority.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(aggregator_id.operation)
	|| is_set(bundle_name.operation)
	|| is_set(bundle_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(port_priority.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (aggregator_id.is_set || is_set(aggregator_id.operation)) leaf_name_data.push_back(aggregator_id.get_name_leafdata());
    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (bundle_state.is_set || is_set(bundle_state.operation)) leaf_name_data.push_back(bundle_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::get_children()
{
    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "aggregator-id")
    {
        aggregator_id = value;
    }
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "bundle-state")
    {
        bundle_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::MlacpMemberData()
    :
    	configured_priority{YType::uint16, "configured-priority"},
	 interface_handle{YType::str, "interface-handle"},
	 member_state{YType::enumeration, "member-state"},
	 mlacp_node_id{YType::uint8, "mlacp-node-id"},
	 operational_priority{YType::uint16, "operational-priority"},
	 port_name{YType::str, "port-name"},
	 port_number{YType::uint16, "port-number"}
{
    yang_name = "mlacp-member-data"; yang_parent_name = "bundle-data";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::~MlacpMemberData()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::has_data() const
{
    return configured_priority.is_set
	|| interface_handle.is_set
	|| member_state.is_set
	|| mlacp_node_id.is_set
	|| operational_priority.is_set
	|| port_name.is_set
	|| port_number.is_set;
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_priority.operation)
	|| is_set(interface_handle.operation)
	|| is_set(member_state.operation)
	|| is_set(mlacp_node_id.operation)
	|| is_set(operational_priority.operation)
	|| is_set(port_name.operation)
	|| is_set(port_number.operation);
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_priority.is_set || is_set(configured_priority.operation)) leaf_name_data.push_back(configured_priority.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mlacp_node_id.is_set || is_set(mlacp_node_id.operation)) leaf_name_data.push_back(mlacp_node_id.get_name_leafdata());
    if (operational_priority.is_set || is_set(operational_priority.operation)) leaf_name_data.push_back(operational_priority.get_name_leafdata());
    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::get_children()
{
    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-priority")
    {
        configured_priority = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mlacp-node-id")
    {
        mlacp_node_id = value;
    }
    if(value_path == "operational-priority")
    {
        operational_priority = value;
    }
    if(value_path == "port-name")
    {
        port_name = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::BundleData()
    :
    	bundle_interface_key{YType::uint16, "bundle-interface-key"},
	 media_type{YType::enumeration, "media-type"},
	 redundancy_object_id{YType::uint64, "redundancy-object-id"}
{
    yang_name = "bundle-data"; yang_parent_name = "mlacp-iccp-group-item";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::~BundleData()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::has_data() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_data())
            return true;
    }
    return bundle_interface_key.is_set
	|| media_type.is_set
	|| redundancy_object_id.is_set;
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::has_operation() const
{
    for (std::size_t index=0; index<mlacp_bundle_data.size(); index++)
    {
        if(mlacp_bundle_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<mlacp_member_data.size(); index++)
    {
        if(mlacp_member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(bundle_interface_key.operation)
	|| is_set(media_type.operation)
	|| is_set(redundancy_object_id.operation);
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface_key.is_set || is_set(bundle_interface_key.operation)) leaf_name_data.push_back(bundle_interface_key.get_name_leafdata());
    if (media_type.is_set || is_set(media_type.operation)) leaf_name_data.push_back(media_type.get_name_leafdata());
    if (redundancy_object_id.is_set || is_set(redundancy_object_id.operation)) leaf_name_data.push_back(redundancy_object_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundle-data")
    {
        for(auto const & c : mlacp_bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpBundleData>();
        c->parent = this;
        mlacp_bundle_data.push_back(std::move(c));
        children[segment_path] = mlacp_bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-member-data")
    {
        for(auto const & c : mlacp_member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::MlacpMemberData>();
        c->parent = this;
        mlacp_member_data.push_back(std::move(c));
        children[segment_path] = mlacp_member_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::get_children()
{
    for (auto const & c : mlacp_bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : mlacp_member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface-key")
    {
        bundle_interface_key = value;
    }
    if(value_path == "media-type")
    {
        media_type = value;
    }
    if(value_path == "redundancy-object-id")
    {
        redundancy_object_id = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::MlacpIccpGroupItem()
    :
    iccp_group_data(std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData>())
{
    iccp_group_data->parent = this;
    children["iccp-group-data"] = iccp_group_data.get();

    yang_name = "mlacp-iccp-group-item"; yang_parent_name = "mlacp-iccp-group";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::~MlacpIccpGroupItem()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return (iccp_group_data !=  nullptr && iccp_group_data->has_data());
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (iccp_group_data !=  nullptr && iccp_group_data->has_operation());
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-iccp-group-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-data")
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
        else
        {
            iccp_group_data = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::IccpGroupData>();
            iccp_group_data->parent = this;
            children["iccp-group-data"] = iccp_group_data.get();
        }
        return children.at("iccp-group-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("iccp-group-data") == children.end())
    {
        if(iccp_group_data != nullptr)
        {
            children["iccp-group-data"] = iccp_group_data.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    mlacp_iccp_group_item(std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem>())
{
    mlacp_iccp_group_item->parent = this;
    children["mlacp-iccp-group-item"] = mlacp_iccp_group_item.get();

    yang_name = "mlacp-iccp-group"; yang_parent_name = "mlacp-iccp-groups";
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::~MlacpIccpGroup()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (mlacp_iccp_group_item !=  nullptr && mlacp_iccp_group_item->has_data());
}

bool BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (mlacp_iccp_group_item !=  nullptr && mlacp_iccp_group_item->has_operation());
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp/mlacp-iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-iccp-group-item")
    {
        if(mlacp_iccp_group_item != nullptr)
        {
            children["mlacp-iccp-group-item"] = mlacp_iccp_group_item.get();
        }
        else
        {
            mlacp_iccp_group_item = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::MlacpIccpGroupItem>();
            mlacp_iccp_group_item->parent = this;
            children["mlacp-iccp-group-item"] = mlacp_iccp_group_item.get();
        }
        return children.at("mlacp-iccp-group-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::get_children()
{
    if(children.find("mlacp-iccp-group-item") == children.end())
    {
        if(mlacp_iccp_group_item != nullptr)
        {
            children["mlacp-iccp-group-item"] = mlacp_iccp_group_item.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroups()
{
    yang_name = "mlacp-iccp-groups"; yang_parent_name = "mlacp";
}

BundleInformation::Mlacp::MlacpIccpGroups::~MlacpIccpGroups()
{
}

bool BundleInformation::Mlacp::MlacpIccpGroups::has_data() const
{
    for (std::size_t index=0; index<mlacp_iccp_group.size(); index++)
    {
        if(mlacp_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Mlacp::MlacpIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<mlacp_iccp_group.size(); index++)
    {
        if(mlacp_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Mlacp::MlacpIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::MlacpIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::MlacpIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-iccp-group")
    {
        for(auto const & c : mlacp_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups::MlacpIccpGroup>();
        c->parent = this;
        mlacp_iccp_group.push_back(std::move(c));
        children[segment_path] = mlacp_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::MlacpIccpGroups::get_children()
{
    for (auto const & c : mlacp_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::MlacpIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Mlacp::Mlacp()
    :
    mlacp_bundles(std::make_unique<BundleInformation::Mlacp::MlacpBundles>())
	,mlacp_iccp_groups(std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups>())
{
    mlacp_bundles->parent = this;
    children["mlacp-bundles"] = mlacp_bundles.get();

    mlacp_iccp_groups->parent = this;
    children["mlacp-iccp-groups"] = mlacp_iccp_groups.get();

    yang_name = "mlacp"; yang_parent_name = "bundle-information";
}

BundleInformation::Mlacp::~Mlacp()
{
}

bool BundleInformation::Mlacp::has_data() const
{
    return (mlacp_bundles !=  nullptr && mlacp_bundles->has_data())
	|| (mlacp_iccp_groups !=  nullptr && mlacp_iccp_groups->has_data());
}

bool BundleInformation::Mlacp::has_operation() const
{
    return is_set(operation)
	|| (mlacp_bundles !=  nullptr && mlacp_bundles->has_operation())
	|| (mlacp_iccp_groups !=  nullptr && mlacp_iccp_groups->has_operation());
}

std::string BundleInformation::Mlacp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp";

    return path_buffer.str();

}

EntityPath BundleInformation::Mlacp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Mlacp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-bundles")
    {
        if(mlacp_bundles != nullptr)
        {
            children["mlacp-bundles"] = mlacp_bundles.get();
        }
        else
        {
            mlacp_bundles = std::make_unique<BundleInformation::Mlacp::MlacpBundles>();
            mlacp_bundles->parent = this;
            children["mlacp-bundles"] = mlacp_bundles.get();
        }
        return children.at("mlacp-bundles");
    }

    if(child_yang_name == "mlacp-iccp-groups")
    {
        if(mlacp_iccp_groups != nullptr)
        {
            children["mlacp-iccp-groups"] = mlacp_iccp_groups.get();
        }
        else
        {
            mlacp_iccp_groups = std::make_unique<BundleInformation::Mlacp::MlacpIccpGroups>();
            mlacp_iccp_groups->parent = this;
            children["mlacp-iccp-groups"] = mlacp_iccp_groups.get();
        }
        return children.at("mlacp-iccp-groups");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Mlacp::get_children()
{
    if(children.find("mlacp-bundles") == children.end())
    {
        if(mlacp_bundles != nullptr)
        {
            children["mlacp-bundles"] = mlacp_bundles.get();
        }
    }

    if(children.find("mlacp-iccp-groups") == children.end())
    {
        if(mlacp_iccp_groups != nullptr)
        {
            children["mlacp-iccp-groups"] = mlacp_iccp_groups.get();
        }
    }

    return children;
}

void BundleInformation::Mlacp::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "mac-allocation-global-item";
}

BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::~MacAddress()
{
}

bool BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mac-allocation/mac-allocation-global/mac-allocation-global-item/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::get_children()
{
    return children;
}

void BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAllocationGlobalItem()
{
    yang_name = "mac-allocation-global-item"; yang_parent_name = "mac-allocation-global";
}

BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::~MacAllocationGlobalItem()
{
}

bool BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::has_data() const
{
    for (std::size_t index=0; index<mac_address.size(); index++)
    {
        if(mac_address[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::has_operation() const
{
    for (std::size_t index=0; index<mac_address.size(); index++)
    {
        if(mac_address[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-allocation-global-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mac-allocation/mac-allocation-global/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        for(auto const & c : mac_address)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::MacAddress>();
        c->parent = this;
        mac_address.push_back(std::move(c));
        children[segment_path] = mac_address.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::get_children()
{
    for (auto const & c : mac_address)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobal()
    :
    mac_allocation_global_item(std::make_unique<BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem>())
{
    mac_allocation_global_item->parent = this;
    children["mac-allocation-global-item"] = mac_allocation_global_item.get();

    yang_name = "mac-allocation-global"; yang_parent_name = "mac-allocation";
}

BundleInformation::MacAllocation::MacAllocationGlobal::~MacAllocationGlobal()
{
}

bool BundleInformation::MacAllocation::MacAllocationGlobal::has_data() const
{
    return (mac_allocation_global_item !=  nullptr && mac_allocation_global_item->has_data());
}

bool BundleInformation::MacAllocation::MacAllocationGlobal::has_operation() const
{
    return is_set(operation)
	|| (mac_allocation_global_item !=  nullptr && mac_allocation_global_item->has_operation());
}

std::string BundleInformation::MacAllocation::MacAllocationGlobal::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-allocation-global";

    return path_buffer.str();

}

EntityPath BundleInformation::MacAllocation::MacAllocationGlobal::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mac-allocation/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MacAllocation::MacAllocationGlobal::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-allocation-global-item")
    {
        if(mac_allocation_global_item != nullptr)
        {
            children["mac-allocation-global-item"] = mac_allocation_global_item.get();
        }
        else
        {
            mac_allocation_global_item = std::make_unique<BundleInformation::MacAllocation::MacAllocationGlobal::MacAllocationGlobalItem>();
            mac_allocation_global_item->parent = this;
            children["mac-allocation-global-item"] = mac_allocation_global_item.get();
        }
        return children.at("mac-allocation-global-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MacAllocation::MacAllocationGlobal::get_children()
{
    if(children.find("mac-allocation-global-item") == children.end())
    {
        if(mac_allocation_global_item != nullptr)
        {
            children["mac-allocation-global-item"] = mac_allocation_global_item.get();
        }
    }

    return children;
}

void BundleInformation::MacAllocation::MacAllocationGlobal::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MacAllocation::MacAllocation()
    :
    mac_allocation_global(std::make_unique<BundleInformation::MacAllocation::MacAllocationGlobal>())
{
    mac_allocation_global->parent = this;
    children["mac-allocation-global"] = mac_allocation_global.get();

    yang_name = "mac-allocation"; yang_parent_name = "bundle-information";
}

BundleInformation::MacAllocation::~MacAllocation()
{
}

bool BundleInformation::MacAllocation::has_data() const
{
    return (mac_allocation_global !=  nullptr && mac_allocation_global->has_data());
}

bool BundleInformation::MacAllocation::has_operation() const
{
    return is_set(operation)
	|| (mac_allocation_global !=  nullptr && mac_allocation_global->has_operation());
}

std::string BundleInformation::MacAllocation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-allocation";

    return path_buffer.str();

}

EntityPath BundleInformation::MacAllocation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MacAllocation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-allocation-global")
    {
        if(mac_allocation_global != nullptr)
        {
            children["mac-allocation-global"] = mac_allocation_global.get();
        }
        else
        {
            mac_allocation_global = std::make_unique<BundleInformation::MacAllocation::MacAllocationGlobal>();
            mac_allocation_global->parent = this;
            children["mac-allocation-global"] = mac_allocation_global.get();
        }
        return children.at("mac-allocation-global");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MacAllocation::get_children()
{
    if(children.find("mac-allocation-global") == children.end())
    {
        if(mac_allocation_global != nullptr)
        {
            children["mac-allocation-global"] = mac_allocation_global.get();
        }
    }

    return children;
}

void BundleInformation::MacAllocation::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-member-item";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::~Items()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::EventsMemberItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-member-item"; yang_parent_name = "events-member";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::~EventsMemberItem()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-member-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-member-ancestor";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::~Items()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::EventsMemberAncestor()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-member-ancestor"; yang_parent_name = "events-member";
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::~EventsMemberAncestor()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-member-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMember::EventsMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    events_member_ancestor(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor>())
	,events_member_item(std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem>())
{
    events_member_ancestor->parent = this;
    children["events-member-ancestor"] = events_member_ancestor.get();

    events_member_item->parent = this;
    children["events-member-item"] = events_member_item.get();

    yang_name = "events-member"; yang_parent_name = "events-members";
}

BundleInformation::Events::EventsMembers::EventsMember::~EventsMember()
{
}

bool BundleInformation::Events::EventsMembers::EventsMember::has_data() const
{
    return member_interface.is_set
	|| (events_member_ancestor !=  nullptr && events_member_ancestor->has_data())
	|| (events_member_item !=  nullptr && events_member_item->has_data());
}

bool BundleInformation::Events::EventsMembers::EventsMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (events_member_ancestor !=  nullptr && events_member_ancestor->has_operation())
	|| (events_member_item !=  nullptr && events_member_item->has_operation());
}

std::string BundleInformation::Events::EventsMembers::EventsMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::EventsMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events/events-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::EventsMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-member-ancestor")
    {
        if(events_member_ancestor != nullptr)
        {
            children["events-member-ancestor"] = events_member_ancestor.get();
        }
        else
        {
            events_member_ancestor = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberAncestor>();
            events_member_ancestor->parent = this;
            children["events-member-ancestor"] = events_member_ancestor.get();
        }
        return children.at("events-member-ancestor");
    }

    if(child_yang_name == "events-member-item")
    {
        if(events_member_item != nullptr)
        {
            children["events-member-item"] = events_member_item.get();
        }
        else
        {
            events_member_item = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember::EventsMemberItem>();
            events_member_item->parent = this;
            children["events-member-item"] = events_member_item.get();
        }
        return children.at("events-member-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::EventsMember::get_children()
{
    if(children.find("events-member-ancestor") == children.end())
    {
        if(events_member_ancestor != nullptr)
        {
            children["events-member-ancestor"] = events_member_ancestor.get();
        }
    }

    if(children.find("events-member-item") == children.end())
    {
        if(events_member_item != nullptr)
        {
            children["events-member-item"] = events_member_item.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::EventsMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::Events::EventsMembers::EventsMembers()
{
    yang_name = "events-members"; yang_parent_name = "events";
}

BundleInformation::Events::EventsMembers::~EventsMembers()
{
}

bool BundleInformation::Events::EventsMembers::has_data() const
{
    for (std::size_t index=0; index<events_member.size(); index++)
    {
        if(events_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Events::EventsMembers::has_operation() const
{
    for (std::size_t index=0; index<events_member.size(); index++)
    {
        if(events_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Events::EventsMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-members";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-member")
    {
        for(auto const & c : events_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsMembers::EventsMember>();
        c->parent = this;
        events_member.push_back(std::move(c));
        children[segment_path] = events_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsMembers::get_children()
{
    for (auto const & c : events_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-bundle-ancestor";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::~Items()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::EventsBundleAncestor()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-bundle-ancestor"; yang_parent_name = "events-bundle";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::~EventsBundleAncestor()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundle-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-bundle-item";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::~Items()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::EventsBundleItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-bundle-item"; yang_parent_name = "events-bundle";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::~EventsBundleItem()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-item";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::~Items()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::EventsItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-item"; yang_parent_name = "events-bundle-descendant";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::~EventsItem()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-item";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsBundleDescendant()
{
    yang_name = "events-bundle-descendant"; yang_parent_name = "events-bundle";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::~EventsBundleDescendant()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::has_data() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::has_operation() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundle-descendant";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-item")
    {
        for(auto const & c : events_item)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::EventsItem>();
        c->parent = this;
        events_item.push_back(std::move(c));
        children[segment_path] = events_item.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::get_children()
{
    for (auto const & c : events_item)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-bundle-children-member";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::~Items()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::EventsBundleChildrenMember()
    :
    	member_interface{YType::str, "member-interface"},
	 item_name{YType::str, "item-name"}
{
    yang_name = "events-bundle-children-member"; yang_parent_name = "events-bundle-children-members";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::~EventsBundleChildrenMember()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return member_interface.is_set
	|| item_name.is_set;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundle-children-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMembers()
{
    yang_name = "events-bundle-children-members"; yang_parent_name = "events-bundle";
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::~EventsBundleChildrenMembers()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::has_data() const
{
    for (std::size_t index=0; index<events_bundle_children_member.size(); index++)
    {
        if(events_bundle_children_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::has_operation() const
{
    for (std::size_t index=0; index<events_bundle_children_member.size(); index++)
    {
        if(events_bundle_children_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundle-children-members";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bundle-children-member")
    {
        for(auto const & c : events_bundle_children_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::EventsBundleChildrenMember>();
        c->parent = this;
        events_bundle_children_member.push_back(std::move(c));
        children[segment_path] = events_bundle_children_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::get_children()
{
    for (auto const & c : events_bundle_children_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Events::EventsBundles::EventsBundle::EventsBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    events_bundle_ancestor(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor>())
	,events_bundle_children_members(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers>())
	,events_bundle_descendant(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant>())
	,events_bundle_item(std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem>())
{
    events_bundle_ancestor->parent = this;
    children["events-bundle-ancestor"] = events_bundle_ancestor.get();

    events_bundle_children_members->parent = this;
    children["events-bundle-children-members"] = events_bundle_children_members.get();

    events_bundle_descendant->parent = this;
    children["events-bundle-descendant"] = events_bundle_descendant.get();

    events_bundle_item->parent = this;
    children["events-bundle-item"] = events_bundle_item.get();

    yang_name = "events-bundle"; yang_parent_name = "events-bundles";
}

BundleInformation::Events::EventsBundles::EventsBundle::~EventsBundle()
{
}

bool BundleInformation::Events::EventsBundles::EventsBundle::has_data() const
{
    return bundle_interface.is_set
	|| (events_bundle_ancestor !=  nullptr && events_bundle_ancestor->has_data())
	|| (events_bundle_children_members !=  nullptr && events_bundle_children_members->has_data())
	|| (events_bundle_descendant !=  nullptr && events_bundle_descendant->has_data())
	|| (events_bundle_item !=  nullptr && events_bundle_item->has_data());
}

bool BundleInformation::Events::EventsBundles::EventsBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (events_bundle_ancestor !=  nullptr && events_bundle_ancestor->has_operation())
	|| (events_bundle_children_members !=  nullptr && events_bundle_children_members->has_operation())
	|| (events_bundle_descendant !=  nullptr && events_bundle_descendant->has_operation())
	|| (events_bundle_item !=  nullptr && events_bundle_item->has_operation());
}

std::string BundleInformation::Events::EventsBundles::EventsBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::EventsBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events/events-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::EventsBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bundle-ancestor")
    {
        if(events_bundle_ancestor != nullptr)
        {
            children["events-bundle-ancestor"] = events_bundle_ancestor.get();
        }
        else
        {
            events_bundle_ancestor = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleAncestor>();
            events_bundle_ancestor->parent = this;
            children["events-bundle-ancestor"] = events_bundle_ancestor.get();
        }
        return children.at("events-bundle-ancestor");
    }

    if(child_yang_name == "events-bundle-children-members")
    {
        if(events_bundle_children_members != nullptr)
        {
            children["events-bundle-children-members"] = events_bundle_children_members.get();
        }
        else
        {
            events_bundle_children_members = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleChildrenMembers>();
            events_bundle_children_members->parent = this;
            children["events-bundle-children-members"] = events_bundle_children_members.get();
        }
        return children.at("events-bundle-children-members");
    }

    if(child_yang_name == "events-bundle-descendant")
    {
        if(events_bundle_descendant != nullptr)
        {
            children["events-bundle-descendant"] = events_bundle_descendant.get();
        }
        else
        {
            events_bundle_descendant = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleDescendant>();
            events_bundle_descendant->parent = this;
            children["events-bundle-descendant"] = events_bundle_descendant.get();
        }
        return children.at("events-bundle-descendant");
    }

    if(child_yang_name == "events-bundle-item")
    {
        if(events_bundle_item != nullptr)
        {
            children["events-bundle-item"] = events_bundle_item.get();
        }
        else
        {
            events_bundle_item = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle::EventsBundleItem>();
            events_bundle_item->parent = this;
            children["events-bundle-item"] = events_bundle_item.get();
        }
        return children.at("events-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::EventsBundle::get_children()
{
    if(children.find("events-bundle-ancestor") == children.end())
    {
        if(events_bundle_ancestor != nullptr)
        {
            children["events-bundle-ancestor"] = events_bundle_ancestor.get();
        }
    }

    if(children.find("events-bundle-children-members") == children.end())
    {
        if(events_bundle_children_members != nullptr)
        {
            children["events-bundle-children-members"] = events_bundle_children_members.get();
        }
    }

    if(children.find("events-bundle-descendant") == children.end())
    {
        if(events_bundle_descendant != nullptr)
        {
            children["events-bundle-descendant"] = events_bundle_descendant.get();
        }
    }

    if(children.find("events-bundle-item") == children.end())
    {
        if(events_bundle_item != nullptr)
        {
            children["events-bundle-item"] = events_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::EventsBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::Events::EventsBundles::EventsBundles()
{
    yang_name = "events-bundles"; yang_parent_name = "events";
}

BundleInformation::Events::EventsBundles::~EventsBundles()
{
}

bool BundleInformation::Events::EventsBundles::has_data() const
{
    for (std::size_t index=0; index<events_bundle.size(); index++)
    {
        if(events_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::Events::EventsBundles::has_operation() const
{
    for (std::size_t index=0; index<events_bundle.size(); index++)
    {
        if(events_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::Events::EventsBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::EventsBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::EventsBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bundle")
    {
        for(auto const & c : events_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::Events::EventsBundles::EventsBundle>();
        c->parent = this;
        events_bundle.push_back(std::move(c));
        children[segment_path] = events_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::EventsBundles::get_children()
{
    for (auto const & c : events_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::Events::EventsBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::Events::Events()
    :
    events_bundles(std::make_unique<BundleInformation::Events::EventsBundles>())
	,events_members(std::make_unique<BundleInformation::Events::EventsMembers>())
{
    events_bundles->parent = this;
    children["events-bundles"] = events_bundles.get();

    events_members->parent = this;
    children["events-members"] = events_members.get();

    yang_name = "events"; yang_parent_name = "bundle-information";
}

BundleInformation::Events::~Events()
{
}

bool BundleInformation::Events::has_data() const
{
    return (events_bundles !=  nullptr && events_bundles->has_data())
	|| (events_members !=  nullptr && events_members->has_data());
}

bool BundleInformation::Events::has_operation() const
{
    return is_set(operation)
	|| (events_bundles !=  nullptr && events_bundles->has_operation())
	|| (events_members !=  nullptr && events_members->has_operation());
}

std::string BundleInformation::Events::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events";

    return path_buffer.str();

}

EntityPath BundleInformation::Events::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::Events::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bundles")
    {
        if(events_bundles != nullptr)
        {
            children["events-bundles"] = events_bundles.get();
        }
        else
        {
            events_bundles = std::make_unique<BundleInformation::Events::EventsBundles>();
            events_bundles->parent = this;
            children["events-bundles"] = events_bundles.get();
        }
        return children.at("events-bundles");
    }

    if(child_yang_name == "events-members")
    {
        if(events_members != nullptr)
        {
            children["events-members"] = events_members.get();
        }
        else
        {
            events_members = std::make_unique<BundleInformation::Events::EventsMembers>();
            events_members->parent = this;
            children["events-members"] = events_members.get();
        }
        return children.at("events-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::Events::get_children()
{
    if(children.find("events-bundles") == children.end())
    {
        if(events_bundles != nullptr)
        {
            children["events-bundles"] = events_bundles.get();
        }
    }

    if(children.find("events-members") == children.end())
    {
        if(events_members != nullptr)
        {
            children["events-members"] = events_members.get();
        }
    }

    return children;
}

void BundleInformation::Events::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-bdl-member-ancestor";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::~Items()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::EventsBdlMemberAncestor()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-bdl-member-ancestor"; yang_parent_name = "events-bdl-member";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::~EventsBdlMemberAncestor()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-member-ancestor";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    events_bdl_member_ancestor(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor>())
{
    events_bdl_member_ancestor->parent = this;
    children["events-bdl-member-ancestor"] = events_bdl_member_ancestor.get();

    yang_name = "events-bdl-member"; yang_parent_name = "events-bdl-members";
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::~EventsBdlMember()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::has_data() const
{
    return member_interface.is_set
	|| (events_bdl_member_ancestor !=  nullptr && events_bdl_member_ancestor->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (events_bdl_member_ancestor !=  nullptr && events_bdl_member_ancestor->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-bdl/events-bdl-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-member-ancestor")
    {
        if(events_bdl_member_ancestor != nullptr)
        {
            children["events-bdl-member-ancestor"] = events_bdl_member_ancestor.get();
        }
        else
        {
            events_bdl_member_ancestor = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::EventsBdlMemberAncestor>();
            events_bdl_member_ancestor->parent = this;
            children["events-bdl-member-ancestor"] = events_bdl_member_ancestor.get();
        }
        return children.at("events-bdl-member-ancestor");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::get_children()
{
    if(children.find("events-bdl-member-ancestor") == children.end())
    {
        if(events_bdl_member_ancestor != nullptr)
        {
            children["events-bdl-member-ancestor"] = events_bdl_member_ancestor.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMembers()
{
    yang_name = "events-bdl-members"; yang_parent_name = "events-bdl";
}

BundleInformation::EventsBdl::EventsBdlMembers::~EventsBdlMembers()
{
}

bool BundleInformation::EventsBdl::EventsBdlMembers::has_data() const
{
    for (std::size_t index=0; index<events_bdl_member.size(); index++)
    {
        if(events_bdl_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsBdl::EventsBdlMembers::has_operation() const
{
    for (std::size_t index=0; index<events_bdl_member.size(); index++)
    {
        if(events_bdl_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsBdl::EventsBdlMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-members";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-bdl/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-member")
    {
        for(auto const & c : events_bdl_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers::EventsBdlMember>();
        c->parent = this;
        events_bdl_member.push_back(std::move(c));
        children[segment_path] = events_bdl_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlMembers::get_children()
{
    for (auto const & c : events_bdl_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-bdl-bundle-item";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::~Items()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::EventsBdlBundleItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-bdl-bundle-item"; yang_parent_name = "events-bdl-bundle";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::~EventsBdlBundleItem()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    events_bdl_bundle_item(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem>())
{
    events_bdl_bundle_item->parent = this;
    children["events-bdl-bundle-item"] = events_bdl_bundle_item.get();

    yang_name = "events-bdl-bundle"; yang_parent_name = "events-bdl-bundles";
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::~EventsBdlBundle()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::has_data() const
{
    return bundle_interface.is_set
	|| (events_bdl_bundle_item !=  nullptr && events_bdl_bundle_item->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (events_bdl_bundle_item !=  nullptr && events_bdl_bundle_item->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-bdl/events-bdl-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-bundle-item")
    {
        if(events_bdl_bundle_item != nullptr)
        {
            children["events-bdl-bundle-item"] = events_bdl_bundle_item.get();
        }
        else
        {
            events_bdl_bundle_item = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::EventsBdlBundleItem>();
            events_bdl_bundle_item->parent = this;
            children["events-bdl-bundle-item"] = events_bdl_bundle_item.get();
        }
        return children.at("events-bdl-bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::get_children()
{
    if(children.find("events-bdl-bundle-item") == children.end())
    {
        if(events_bdl_bundle_item != nullptr)
        {
            children["events-bdl-bundle-item"] = events_bdl_bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundles()
{
    yang_name = "events-bdl-bundles"; yang_parent_name = "events-bdl";
}

BundleInformation::EventsBdl::EventsBdlBundles::~EventsBdlBundles()
{
}

bool BundleInformation::EventsBdl::EventsBdlBundles::has_data() const
{
    for (std::size_t index=0; index<events_bdl_bundle.size(); index++)
    {
        if(events_bdl_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsBdl::EventsBdlBundles::has_operation() const
{
    for (std::size_t index=0; index<events_bdl_bundle.size(); index++)
    {
        if(events_bdl_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsBdl::EventsBdlBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-bdl/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-bundle")
    {
        for(auto const & c : events_bdl_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles::EventsBdlBundle>();
        c->parent = this;
        events_bdl_bundle.push_back(std::move(c));
        children[segment_path] = events_bdl_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlBundles::get_children()
{
    for (auto const & c : events_bdl_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-item";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::~Items()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::EventsItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-item"; yang_parent_name = "events-bdl-bundle-descendant-iccp-group";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::~EventsItem()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-item";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsBdlBundleDescendantIccpGroup()
{
    yang_name = "events-bdl-bundle-descendant-iccp-group"; yang_parent_name = "events-bdl-iccp-group";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::~EventsBdlBundleDescendantIccpGroup()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::has_data() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::has_operation() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-bundle-descendant-iccp-group";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-item")
    {
        for(auto const & c : events_item)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::EventsItem>();
        c->parent = this;
        events_item.push_back(std::move(c));
        children[segment_path] = events_item.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::get_children()
{
    for (auto const & c : events_item)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlIccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    events_bdl_bundle_descendant_iccp_group(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup>())
{
    events_bdl_bundle_descendant_iccp_group->parent = this;
    children["events-bdl-bundle-descendant-iccp-group"] = events_bdl_bundle_descendant_iccp_group.get();

    yang_name = "events-bdl-iccp-group"; yang_parent_name = "events-bdl-iccp-groups";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::~EventsBdlIccpGroup()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (events_bdl_bundle_descendant_iccp_group !=  nullptr && events_bdl_bundle_descendant_iccp_group->has_data());
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (events_bdl_bundle_descendant_iccp_group !=  nullptr && events_bdl_bundle_descendant_iccp_group->has_operation());
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-bdl/events-bdl-iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-bundle-descendant-iccp-group")
    {
        if(events_bdl_bundle_descendant_iccp_group != nullptr)
        {
            children["events-bdl-bundle-descendant-iccp-group"] = events_bdl_bundle_descendant_iccp_group.get();
        }
        else
        {
            events_bdl_bundle_descendant_iccp_group = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::EventsBdlBundleDescendantIccpGroup>();
            events_bdl_bundle_descendant_iccp_group->parent = this;
            children["events-bdl-bundle-descendant-iccp-group"] = events_bdl_bundle_descendant_iccp_group.get();
        }
        return children.at("events-bdl-bundle-descendant-iccp-group");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::get_children()
{
    if(children.find("events-bdl-bundle-descendant-iccp-group") == children.end())
    {
        if(events_bdl_bundle_descendant_iccp_group != nullptr)
        {
            children["events-bdl-bundle-descendant-iccp-group"] = events_bdl_bundle_descendant_iccp_group.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroups()
{
    yang_name = "events-bdl-iccp-groups"; yang_parent_name = "events-bdl";
}

BundleInformation::EventsBdl::EventsBdlIccpGroups::~EventsBdlIccpGroups()
{
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::has_data() const
{
    for (std::size_t index=0; index<events_bdl_iccp_group.size(); index++)
    {
        if(events_bdl_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsBdl::EventsBdlIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<events_bdl_iccp_group.size(); index++)
    {
        if(events_bdl_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsBdl::EventsBdlIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::EventsBdlIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-bdl/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::EventsBdlIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-iccp-group")
    {
        for(auto const & c : events_bdl_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups::EventsBdlIccpGroup>();
        c->parent = this;
        events_bdl_iccp_group.push_back(std::move(c));
        children[segment_path] = events_bdl_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::EventsBdlIccpGroups::get_children()
{
    for (auto const & c : events_bdl_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::EventsBdlIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsBdl::EventsBdl()
    :
    events_bdl_bundles(std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles>())
	,events_bdl_iccp_groups(std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups>())
	,events_bdl_members(std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers>())
{
    events_bdl_bundles->parent = this;
    children["events-bdl-bundles"] = events_bdl_bundles.get();

    events_bdl_iccp_groups->parent = this;
    children["events-bdl-iccp-groups"] = events_bdl_iccp_groups.get();

    events_bdl_members->parent = this;
    children["events-bdl-members"] = events_bdl_members.get();

    yang_name = "events-bdl"; yang_parent_name = "bundle-information";
}

BundleInformation::EventsBdl::~EventsBdl()
{
}

bool BundleInformation::EventsBdl::has_data() const
{
    return (events_bdl_bundles !=  nullptr && events_bdl_bundles->has_data())
	|| (events_bdl_iccp_groups !=  nullptr && events_bdl_iccp_groups->has_data())
	|| (events_bdl_members !=  nullptr && events_bdl_members->has_data());
}

bool BundleInformation::EventsBdl::has_operation() const
{
    return is_set(operation)
	|| (events_bdl_bundles !=  nullptr && events_bdl_bundles->has_operation())
	|| (events_bdl_iccp_groups !=  nullptr && events_bdl_iccp_groups->has_operation())
	|| (events_bdl_members !=  nullptr && events_bdl_members->has_operation());
}

std::string BundleInformation::EventsBdl::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-bdl";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsBdl::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsBdl::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-bdl-bundles")
    {
        if(events_bdl_bundles != nullptr)
        {
            children["events-bdl-bundles"] = events_bdl_bundles.get();
        }
        else
        {
            events_bdl_bundles = std::make_unique<BundleInformation::EventsBdl::EventsBdlBundles>();
            events_bdl_bundles->parent = this;
            children["events-bdl-bundles"] = events_bdl_bundles.get();
        }
        return children.at("events-bdl-bundles");
    }

    if(child_yang_name == "events-bdl-iccp-groups")
    {
        if(events_bdl_iccp_groups != nullptr)
        {
            children["events-bdl-iccp-groups"] = events_bdl_iccp_groups.get();
        }
        else
        {
            events_bdl_iccp_groups = std::make_unique<BundleInformation::EventsBdl::EventsBdlIccpGroups>();
            events_bdl_iccp_groups->parent = this;
            children["events-bdl-iccp-groups"] = events_bdl_iccp_groups.get();
        }
        return children.at("events-bdl-iccp-groups");
    }

    if(child_yang_name == "events-bdl-members")
    {
        if(events_bdl_members != nullptr)
        {
            children["events-bdl-members"] = events_bdl_members.get();
        }
        else
        {
            events_bdl_members = std::make_unique<BundleInformation::EventsBdl::EventsBdlMembers>();
            events_bdl_members->parent = this;
            children["events-bdl-members"] = events_bdl_members.get();
        }
        return children.at("events-bdl-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsBdl::get_children()
{
    if(children.find("events-bdl-bundles") == children.end())
    {
        if(events_bdl_bundles != nullptr)
        {
            children["events-bdl-bundles"] = events_bdl_bundles.get();
        }
    }

    if(children.find("events-bdl-iccp-groups") == children.end())
    {
        if(events_bdl_iccp_groups != nullptr)
        {
            children["events-bdl-iccp-groups"] = events_bdl_iccp_groups.get();
        }
    }

    if(children.find("events-bdl-members") == children.end())
    {
        if(events_bdl_members != nullptr)
        {
            children["events-bdl-members"] = events_bdl_members.get();
        }
    }

    return children;
}

void BundleInformation::EventsBdl::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "bundle-brief-item";
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::~MacAddress()
{
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::has_data() const
{
    return address.is_set;
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::get_children()
{
    return children;
}

void BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "bundle-brief-item";
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::~BfdConfig()
{
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BundleBriefItem()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "bundle-brief-item"; yang_parent_name = "bundle-brief";
}

BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::~BundleBriefItem()
{
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-brief-item";

    return path_buffer.str();

}

EntityPath BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

BundleInformation::BundleBriefs::BundleBrief::BundleBrief()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    bundle_brief_item(std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem>())
{
    bundle_brief_item->parent = this;
    children["bundle-brief-item"] = bundle_brief_item.get();

    yang_name = "bundle-brief"; yang_parent_name = "bundle-briefs";
}

BundleInformation::BundleBriefs::BundleBrief::~BundleBrief()
{
}

bool BundleInformation::BundleBriefs::BundleBrief::has_data() const
{
    return bundle_interface.is_set
	|| (bundle_brief_item !=  nullptr && bundle_brief_item->has_data());
}

bool BundleInformation::BundleBriefs::BundleBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (bundle_brief_item !=  nullptr && bundle_brief_item->has_operation());
}

std::string BundleInformation::BundleBriefs::BundleBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-brief" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::BundleBriefs::BundleBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/bundle-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BundleBriefs::BundleBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-brief-item")
    {
        if(bundle_brief_item != nullptr)
        {
            children["bundle-brief-item"] = bundle_brief_item.get();
        }
        else
        {
            bundle_brief_item = std::make_unique<BundleInformation::BundleBriefs::BundleBrief::BundleBriefItem>();
            bundle_brief_item->parent = this;
            children["bundle-brief-item"] = bundle_brief_item.get();
        }
        return children.at("bundle-brief-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BundleBriefs::BundleBrief::get_children()
{
    if(children.find("bundle-brief-item") == children.end())
    {
        if(bundle_brief_item != nullptr)
        {
            children["bundle-brief-item"] = bundle_brief_item.get();
        }
    }

    return children;
}

void BundleInformation::BundleBriefs::BundleBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::BundleBriefs::BundleBriefs()
{
    yang_name = "bundle-briefs"; yang_parent_name = "bundle-information";
}

BundleInformation::BundleBriefs::~BundleBriefs()
{
}

bool BundleInformation::BundleBriefs::has_data() const
{
    for (std::size_t index=0; index<bundle_brief.size(); index++)
    {
        if(bundle_brief[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::BundleBriefs::has_operation() const
{
    for (std::size_t index=0; index<bundle_brief.size(); index++)
    {
        if(bundle_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::BundleBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-briefs";

    return path_buffer.str();

}

EntityPath BundleInformation::BundleBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::BundleBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-brief")
    {
        for(auto const & c : bundle_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::BundleBriefs::BundleBrief>();
        c->parent = this;
        bundle_brief.push_back(std::move(c));
        children[segment_path] = bundle_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::BundleBriefs::get_children()
{
    for (auto const & c : bundle_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::BundleBriefs::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-mbr-bundle-children-member";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::~Items()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::EventsMbrBundleChildrenMember()
    :
    	member_interface{YType::str, "member-interface"},
	 item_name{YType::str, "item-name"}
{
    yang_name = "events-mbr-bundle-children-member"; yang_parent_name = "events-mbr-bundle-children-members";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::~EventsMbrBundleChildrenMember()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return member_interface.is_set
	|| item_name.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle-children-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMembers()
{
    yang_name = "events-mbr-bundle-children-members"; yang_parent_name = "events-mbr-bundle";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::~EventsMbrBundleChildrenMembers()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::has_data() const
{
    for (std::size_t index=0; index<events_mbr_bundle_children_member.size(); index++)
    {
        if(events_mbr_bundle_children_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::has_operation() const
{
    for (std::size_t index=0; index<events_mbr_bundle_children_member.size(); index++)
    {
        if(events_mbr_bundle_children_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle-children-members";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-bundle-children-member")
    {
        for(auto const & c : events_mbr_bundle_children_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::EventsMbrBundleChildrenMember>();
        c->parent = this;
        events_mbr_bundle_children_member.push_back(std::move(c));
        children[segment_path] = events_mbr_bundle_children_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::get_children()
{
    for (auto const & c : events_mbr_bundle_children_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-item";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::~Items()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::EventsItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-item"; yang_parent_name = "events-mbr-bundle-descendant";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::~EventsItem()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-item";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsMbrBundleDescendant()
{
    yang_name = "events-mbr-bundle-descendant"; yang_parent_name = "events-mbr-bundle";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::~EventsMbrBundleDescendant()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::has_data() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::has_operation() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle-descendant";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-item")
    {
        for(auto const & c : events_item)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::EventsItem>();
        c->parent = this;
        events_item.push_back(std::move(c));
        children[segment_path] = events_item.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::get_children()
{
    for (auto const & c : events_item)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    events_mbr_bundle_children_members(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers>())
	,events_mbr_bundle_descendant(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant>())
{
    events_mbr_bundle_children_members->parent = this;
    children["events-mbr-bundle-children-members"] = events_mbr_bundle_children_members.get();

    events_mbr_bundle_descendant->parent = this;
    children["events-mbr-bundle-descendant"] = events_mbr_bundle_descendant.get();

    yang_name = "events-mbr-bundle"; yang_parent_name = "events-mbr-bundles";
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::~EventsMbrBundle()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::has_data() const
{
    return bundle_interface.is_set
	|| (events_mbr_bundle_children_members !=  nullptr && events_mbr_bundle_children_members->has_data())
	|| (events_mbr_bundle_descendant !=  nullptr && events_mbr_bundle_descendant->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (events_mbr_bundle_children_members !=  nullptr && events_mbr_bundle_children_members->has_operation())
	|| (events_mbr_bundle_descendant !=  nullptr && events_mbr_bundle_descendant->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-mbr/events-mbr-bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-bundle-children-members")
    {
        if(events_mbr_bundle_children_members != nullptr)
        {
            children["events-mbr-bundle-children-members"] = events_mbr_bundle_children_members.get();
        }
        else
        {
            events_mbr_bundle_children_members = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleChildrenMembers>();
            events_mbr_bundle_children_members->parent = this;
            children["events-mbr-bundle-children-members"] = events_mbr_bundle_children_members.get();
        }
        return children.at("events-mbr-bundle-children-members");
    }

    if(child_yang_name == "events-mbr-bundle-descendant")
    {
        if(events_mbr_bundle_descendant != nullptr)
        {
            children["events-mbr-bundle-descendant"] = events_mbr_bundle_descendant.get();
        }
        else
        {
            events_mbr_bundle_descendant = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::EventsMbrBundleDescendant>();
            events_mbr_bundle_descendant->parent = this;
            children["events-mbr-bundle-descendant"] = events_mbr_bundle_descendant.get();
        }
        return children.at("events-mbr-bundle-descendant");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::get_children()
{
    if(children.find("events-mbr-bundle-children-members") == children.end())
    {
        if(events_mbr_bundle_children_members != nullptr)
        {
            children["events-mbr-bundle-children-members"] = events_mbr_bundle_children_members.get();
        }
    }

    if(children.find("events-mbr-bundle-descendant") == children.end())
    {
        if(events_mbr_bundle_descendant != nullptr)
        {
            children["events-mbr-bundle-descendant"] = events_mbr_bundle_descendant.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundles()
{
    yang_name = "events-mbr-bundles"; yang_parent_name = "events-mbr";
}

BundleInformation::EventsMbr::EventsMbrBundles::~EventsMbrBundles()
{
}

bool BundleInformation::EventsMbr::EventsMbrBundles::has_data() const
{
    for (std::size_t index=0; index<events_mbr_bundle.size(); index++)
    {
        if(events_mbr_bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrBundles::has_operation() const
{
    for (std::size_t index=0; index<events_mbr_bundle.size(); index++)
    {
        if(events_mbr_bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrBundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrBundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-mbr/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrBundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-bundle")
    {
        for(auto const & c : events_mbr_bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles::EventsMbrBundle>();
        c->parent = this;
        events_mbr_bundle.push_back(std::move(c));
        children[segment_path] = events_mbr_bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrBundles::get_children()
{
    for (auto const & c : events_mbr_bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrBundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-mbr-member-item";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::~Items()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::EventsMbrMemberItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-mbr-member-item"; yang_parent_name = "events-mbr-member";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::~EventsMbrMemberItem()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-member-item";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMember()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    events_mbr_member_item(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem>())
{
    events_mbr_member_item->parent = this;
    children["events-mbr-member-item"] = events_mbr_member_item.get();

    yang_name = "events-mbr-member"; yang_parent_name = "events-mbr-members";
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::~EventsMbrMember()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::has_data() const
{
    return member_interface.is_set
	|| (events_mbr_member_item !=  nullptr && events_mbr_member_item->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (events_mbr_member_item !=  nullptr && events_mbr_member_item->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-mbr/events-mbr-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-member-item")
    {
        if(events_mbr_member_item != nullptr)
        {
            children["events-mbr-member-item"] = events_mbr_member_item.get();
        }
        else
        {
            events_mbr_member_item = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::EventsMbrMemberItem>();
            events_mbr_member_item->parent = this;
            children["events-mbr-member-item"] = events_mbr_member_item.get();
        }
        return children.at("events-mbr-member-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::get_children()
{
    if(children.find("events-mbr-member-item") == children.end())
    {
        if(events_mbr_member_item != nullptr)
        {
            children["events-mbr-member-item"] = events_mbr_member_item.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMembers()
{
    yang_name = "events-mbr-members"; yang_parent_name = "events-mbr";
}

BundleInformation::EventsMbr::EventsMbrMembers::~EventsMbrMembers()
{
}

bool BundleInformation::EventsMbr::EventsMbrMembers::has_data() const
{
    for (std::size_t index=0; index<events_mbr_member.size(); index++)
    {
        if(events_mbr_member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrMembers::has_operation() const
{
    for (std::size_t index=0; index<events_mbr_member.size(); index++)
    {
        if(events_mbr_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-members";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-mbr/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-member")
    {
        for(auto const & c : events_mbr_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers::EventsMbrMember>();
        c->parent = this;
        events_mbr_member.push_back(std::move(c));
        children[segment_path] = events_mbr_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrMembers::get_children()
{
    for (auto const & c : events_mbr_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrMembers::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-mbr-bundle-children-member-iccp-group";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::~Items()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::EventsMbrBundleChildrenMemberIccpGroup()
    :
    	member_interface{YType::str, "member-interface"},
	 item_name{YType::str, "item-name"}
{
    yang_name = "events-mbr-bundle-children-member-iccp-group"; yang_parent_name = "events-mbr-bundle-children-member-iccp-groups";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::~EventsMbrBundleChildrenMemberIccpGroup()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return member_interface.is_set
	|| item_name.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle-children-member-iccp-group" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroups()
{
    yang_name = "events-mbr-bundle-children-member-iccp-groups"; yang_parent_name = "events-mbr-iccp-group";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::~EventsMbrBundleChildrenMemberIccpGroups()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::has_data() const
{
    for (std::size_t index=0; index<events_mbr_bundle_children_member_iccp_group.size(); index++)
    {
        if(events_mbr_bundle_children_member_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<events_mbr_bundle_children_member_iccp_group.size(); index++)
    {
        if(events_mbr_bundle_children_member_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle-children-member-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-bundle-children-member-iccp-group")
    {
        for(auto const & c : events_mbr_bundle_children_member_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::EventsMbrBundleChildrenMemberIccpGroup>();
        c->parent = this;
        events_mbr_bundle_children_member_iccp_group.push_back(std::move(c));
        children[segment_path] = events_mbr_bundle_children_member_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::get_children()
{
    for (auto const & c : events_mbr_bundle_children_member_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "member-evt-info";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::MemberEvtInfo()
    :
    	member_event_type{YType::enumeration, "member-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "member-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::~MemberEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::has_data() const
{
    return member_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(member_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_event_type.is_set || is_set(member_event_type.operation)) leaf_name_data.push_back(member_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-event-type")
    {
        member_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "bundle-evt-info";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::BundleEvtInfo()
    :
    	bundle_event_type{YType::enumeration, "bundle-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "bundle-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::~BundleEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::has_data() const
{
    return bundle_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_event_type.is_set || is_set(bundle_event_type.operation)) leaf_name_data.push_back(bundle_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-event-type")
    {
        bundle_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::Data()
    :
    	data_type{YType::enumeration, "data-type"},
	 error{YType::uint32, "error"},
	 no_data{YType::uint8, "no-data"},
	 string_data{YType::str, "string-data"}
{
    yang_name = "data"; yang_parent_name = "rg-evt-info";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::~Data()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::has_data() const
{
    return data_type.is_set
	|| error.is_set
	|| no_data.is_set
	|| string_data.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(data_type.operation)
	|| is_set(error.operation)
	|| is_set(no_data.operation)
	|| is_set(string_data.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (data_type.is_set || is_set(data_type.operation)) leaf_name_data.push_back(data_type.get_name_leafdata());
    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (no_data.is_set || is_set(no_data.operation)) leaf_name_data.push_back(no_data.get_name_leafdata());
    if (string_data.is_set || is_set(string_data.operation)) leaf_name_data.push_back(string_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::get_children()
{
    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "data-type")
    {
        data_type = value;
    }
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "no-data")
    {
        no_data = value;
    }
    if(value_path == "string-data")
    {
        string_data = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::RgEvtInfo()
    :
    	rg_event_type{YType::enumeration, "rg-event-type"},
	 time_stamp{YType::uint64, "time-stamp"}
    	,
    data(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data>())
{
    data->parent = this;
    children["data"] = data.get();

    yang_name = "rg-evt-info"; yang_parent_name = "items";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::~RgEvtInfo()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::has_data() const
{
    return rg_event_type.is_set
	|| time_stamp.is_set
	|| (data !=  nullptr && data->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(rg_event_type.operation)
	|| is_set(time_stamp.operation)
	|| (data !=  nullptr && data->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "rg-evt-info";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (rg_event_type.is_set || is_set(rg_event_type.operation)) leaf_name_data.push_back(rg_event_type.get_name_leafdata());
    if (time_stamp.is_set || is_set(time_stamp.operation)) leaf_name_data.push_back(time_stamp.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "rg-event-type")
    {
        rg_event_type = value;
    }
    if(value_path == "time-stamp")
    {
        time_stamp = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::Items()
    :
    	event_type{YType::enumeration, "event-type"}
    	,
    bundle_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo>())
	,member_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo>())
	,rg_evt_info(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo>())
{
    bundle_evt_info->parent = this;
    children["bundle-evt-info"] = bundle_evt_info.get();

    member_evt_info->parent = this;
    children["member-evt-info"] = member_evt_info.get();

    rg_evt_info->parent = this;
    children["rg-evt-info"] = rg_evt_info.get();

    yang_name = "items"; yang_parent_name = "events-item";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::~Items()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::has_data() const
{
    return event_type.is_set
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_data())
	|| (member_evt_info !=  nullptr && member_evt_info->has_data())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::has_operation() const
{
    return is_set(operation)
	|| is_set(event_type.operation)
	|| (bundle_evt_info !=  nullptr && bundle_evt_info->has_operation())
	|| (member_evt_info !=  nullptr && member_evt_info->has_operation())
	|| (rg_evt_info !=  nullptr && rg_evt_info->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (event_type.is_set || is_set(event_type.operation)) leaf_name_data.push_back(event_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-evt-info")
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        else
        {
            bundle_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::BundleEvtInfo>();
            bundle_evt_info->parent = this;
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
        return children.at("bundle-evt-info");
    }

    if(child_yang_name == "member-evt-info")
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
        else
        {
            member_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::MemberEvtInfo>();
            member_evt_info->parent = this;
            children["member-evt-info"] = member_evt_info.get();
        }
        return children.at("member-evt-info");
    }

    if(child_yang_name == "rg-evt-info")
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
        else
        {
            rg_evt_info = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::RgEvtInfo>();
            rg_evt_info->parent = this;
            children["rg-evt-info"] = rg_evt_info.get();
        }
        return children.at("rg-evt-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::get_children()
{
    if(children.find("bundle-evt-info") == children.end())
    {
        if(bundle_evt_info != nullptr)
        {
            children["bundle-evt-info"] = bundle_evt_info.get();
        }
    }

    if(children.find("member-evt-info") == children.end())
    {
        if(member_evt_info != nullptr)
        {
            children["member-evt-info"] = member_evt_info.get();
        }
    }

    if(children.find("rg-evt-info") == children.end())
    {
        if(rg_evt_info != nullptr)
        {
            children["rg-evt-info"] = rg_evt_info.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "event-type")
    {
        event_type = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::EventsItem()
    :
    	item_name{YType::str, "item-name"}
{
    yang_name = "events-item"; yang_parent_name = "events-mbr-bundle-descendant-iccp-group";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::~EventsItem()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return item_name.is_set;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(item_name.operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-item";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (item_name.is_set || is_set(item_name.operation)) leaf_name_data.push_back(item_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "item-name")
    {
        item_name = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsMbrBundleDescendantIccpGroup()
{
    yang_name = "events-mbr-bundle-descendant-iccp-group"; yang_parent_name = "events-mbr-iccp-group";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::~EventsMbrBundleDescendantIccpGroup()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::has_data() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::has_operation() const
{
    for (std::size_t index=0; index<events_item.size(); index++)
    {
        if(events_item[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-bundle-descendant-iccp-group";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-item")
    {
        for(auto const & c : events_item)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::EventsItem>();
        c->parent = this;
        events_item.push_back(std::move(c));
        children[segment_path] = events_item.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::get_children()
{
    for (auto const & c : events_item)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrIccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    events_mbr_bundle_children_member_iccp_groups(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups>())
	,events_mbr_bundle_descendant_iccp_group(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup>())
{
    events_mbr_bundle_children_member_iccp_groups->parent = this;
    children["events-mbr-bundle-children-member-iccp-groups"] = events_mbr_bundle_children_member_iccp_groups.get();

    events_mbr_bundle_descendant_iccp_group->parent = this;
    children["events-mbr-bundle-descendant-iccp-group"] = events_mbr_bundle_descendant_iccp_group.get();

    yang_name = "events-mbr-iccp-group"; yang_parent_name = "events-mbr-iccp-groups";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::~EventsMbrIccpGroup()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (events_mbr_bundle_children_member_iccp_groups !=  nullptr && events_mbr_bundle_children_member_iccp_groups->has_data())
	|| (events_mbr_bundle_descendant_iccp_group !=  nullptr && events_mbr_bundle_descendant_iccp_group->has_data());
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (events_mbr_bundle_children_member_iccp_groups !=  nullptr && events_mbr_bundle_children_member_iccp_groups->has_operation())
	|| (events_mbr_bundle_descendant_iccp_group !=  nullptr && events_mbr_bundle_descendant_iccp_group->has_operation());
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-mbr/events-mbr-iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-bundle-children-member-iccp-groups")
    {
        if(events_mbr_bundle_children_member_iccp_groups != nullptr)
        {
            children["events-mbr-bundle-children-member-iccp-groups"] = events_mbr_bundle_children_member_iccp_groups.get();
        }
        else
        {
            events_mbr_bundle_children_member_iccp_groups = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleChildrenMemberIccpGroups>();
            events_mbr_bundle_children_member_iccp_groups->parent = this;
            children["events-mbr-bundle-children-member-iccp-groups"] = events_mbr_bundle_children_member_iccp_groups.get();
        }
        return children.at("events-mbr-bundle-children-member-iccp-groups");
    }

    if(child_yang_name == "events-mbr-bundle-descendant-iccp-group")
    {
        if(events_mbr_bundle_descendant_iccp_group != nullptr)
        {
            children["events-mbr-bundle-descendant-iccp-group"] = events_mbr_bundle_descendant_iccp_group.get();
        }
        else
        {
            events_mbr_bundle_descendant_iccp_group = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::EventsMbrBundleDescendantIccpGroup>();
            events_mbr_bundle_descendant_iccp_group->parent = this;
            children["events-mbr-bundle-descendant-iccp-group"] = events_mbr_bundle_descendant_iccp_group.get();
        }
        return children.at("events-mbr-bundle-descendant-iccp-group");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::get_children()
{
    if(children.find("events-mbr-bundle-children-member-iccp-groups") == children.end())
    {
        if(events_mbr_bundle_children_member_iccp_groups != nullptr)
        {
            children["events-mbr-bundle-children-member-iccp-groups"] = events_mbr_bundle_children_member_iccp_groups.get();
        }
    }

    if(children.find("events-mbr-bundle-descendant-iccp-group") == children.end())
    {
        if(events_mbr_bundle_descendant_iccp_group != nullptr)
        {
            children["events-mbr-bundle-descendant-iccp-group"] = events_mbr_bundle_descendant_iccp_group.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroups()
{
    yang_name = "events-mbr-iccp-groups"; yang_parent_name = "events-mbr";
}

BundleInformation::EventsMbr::EventsMbrIccpGroups::~EventsMbrIccpGroups()
{
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::has_data() const
{
    for (std::size_t index=0; index<events_mbr_iccp_group.size(); index++)
    {
        if(events_mbr_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::EventsMbr::EventsMbrIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<events_mbr_iccp_group.size(); index++)
    {
        if(events_mbr_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::EventsMbr::EventsMbrIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::EventsMbrIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/events-mbr/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::EventsMbrIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-iccp-group")
    {
        for(auto const & c : events_mbr_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups::EventsMbrIccpGroup>();
        c->parent = this;
        events_mbr_iccp_group.push_back(std::move(c));
        children[segment_path] = events_mbr_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::EventsMbrIccpGroups::get_children()
{
    for (auto const & c : events_mbr_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::EventsMbrIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::EventsMbr::EventsMbr()
    :
    events_mbr_bundles(std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles>())
	,events_mbr_iccp_groups(std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups>())
	,events_mbr_members(std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers>())
{
    events_mbr_bundles->parent = this;
    children["events-mbr-bundles"] = events_mbr_bundles.get();

    events_mbr_iccp_groups->parent = this;
    children["events-mbr-iccp-groups"] = events_mbr_iccp_groups.get();

    events_mbr_members->parent = this;
    children["events-mbr-members"] = events_mbr_members.get();

    yang_name = "events-mbr"; yang_parent_name = "bundle-information";
}

BundleInformation::EventsMbr::~EventsMbr()
{
}

bool BundleInformation::EventsMbr::has_data() const
{
    return (events_mbr_bundles !=  nullptr && events_mbr_bundles->has_data())
	|| (events_mbr_iccp_groups !=  nullptr && events_mbr_iccp_groups->has_data())
	|| (events_mbr_members !=  nullptr && events_mbr_members->has_data());
}

bool BundleInformation::EventsMbr::has_operation() const
{
    return is_set(operation)
	|| (events_mbr_bundles !=  nullptr && events_mbr_bundles->has_operation())
	|| (events_mbr_iccp_groups !=  nullptr && events_mbr_iccp_groups->has_operation())
	|| (events_mbr_members !=  nullptr && events_mbr_members->has_operation());
}

std::string BundleInformation::EventsMbr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events-mbr";

    return path_buffer.str();

}

EntityPath BundleInformation::EventsMbr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::EventsMbr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events-mbr-bundles")
    {
        if(events_mbr_bundles != nullptr)
        {
            children["events-mbr-bundles"] = events_mbr_bundles.get();
        }
        else
        {
            events_mbr_bundles = std::make_unique<BundleInformation::EventsMbr::EventsMbrBundles>();
            events_mbr_bundles->parent = this;
            children["events-mbr-bundles"] = events_mbr_bundles.get();
        }
        return children.at("events-mbr-bundles");
    }

    if(child_yang_name == "events-mbr-iccp-groups")
    {
        if(events_mbr_iccp_groups != nullptr)
        {
            children["events-mbr-iccp-groups"] = events_mbr_iccp_groups.get();
        }
        else
        {
            events_mbr_iccp_groups = std::make_unique<BundleInformation::EventsMbr::EventsMbrIccpGroups>();
            events_mbr_iccp_groups->parent = this;
            children["events-mbr-iccp-groups"] = events_mbr_iccp_groups.get();
        }
        return children.at("events-mbr-iccp-groups");
    }

    if(child_yang_name == "events-mbr-members")
    {
        if(events_mbr_members != nullptr)
        {
            children["events-mbr-members"] = events_mbr_members.get();
        }
        else
        {
            events_mbr_members = std::make_unique<BundleInformation::EventsMbr::EventsMbrMembers>();
            events_mbr_members->parent = this;
            children["events-mbr-members"] = events_mbr_members.get();
        }
        return children.at("events-mbr-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::EventsMbr::get_children()
{
    if(children.find("events-mbr-bundles") == children.end())
    {
        if(events_mbr_bundles != nullptr)
        {
            children["events-mbr-bundles"] = events_mbr_bundles.get();
        }
    }

    if(children.find("events-mbr-iccp-groups") == children.end())
    {
        if(events_mbr_iccp_groups != nullptr)
        {
            children["events-mbr-iccp-groups"] = events_mbr_iccp_groups.get();
        }
    }

    if(children.find("events-mbr-members") == children.end())
    {
        if(events_mbr_members != nullptr)
        {
            children["events-mbr-members"] = events_mbr_members.get();
        }
    }

    return children;
}

void BundleInformation::EventsMbr::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::Connection()
    :
    	iccp_config_connect_errors{YType::uint32, "iccp-config-connect-errors"},
	 iccp_count_connect_errors{YType::uint32, "iccp-count-connect-errors"},
	 iccp_invalid_connects{YType::uint32, "iccp-invalid-connects"},
	 iccp_invalid_disconnects{YType::uint32, "iccp-invalid-disconnects"},
	 received_connects{YType::uint32, "received-connects"},
	 received_disconnects{YType::uint32, "received-disconnects"},
	 received_wrong_versions{YType::uint32, "received-wrong-versions"},
	 sent_connects{YType::uint32, "sent-connects"},
	 sent_disconnects{YType::uint32, "sent-disconnects"},
	 sent_wrong_versions{YType::uint32, "sent-wrong-versions"}
{
    yang_name = "connection"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::~Connection()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::has_data() const
{
    return iccp_config_connect_errors.is_set
	|| iccp_count_connect_errors.is_set
	|| iccp_invalid_connects.is_set
	|| iccp_invalid_disconnects.is_set
	|| received_connects.is_set
	|| received_disconnects.is_set
	|| received_wrong_versions.is_set
	|| sent_connects.is_set
	|| sent_disconnects.is_set
	|| sent_wrong_versions.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_config_connect_errors.operation)
	|| is_set(iccp_count_connect_errors.operation)
	|| is_set(iccp_invalid_connects.operation)
	|| is_set(iccp_invalid_disconnects.operation)
	|| is_set(received_connects.operation)
	|| is_set(received_disconnects.operation)
	|| is_set(received_wrong_versions.operation)
	|| is_set(sent_connects.operation)
	|| is_set(sent_disconnects.operation)
	|| is_set(sent_wrong_versions.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connection";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_config_connect_errors.is_set || is_set(iccp_config_connect_errors.operation)) leaf_name_data.push_back(iccp_config_connect_errors.get_name_leafdata());
    if (iccp_count_connect_errors.is_set || is_set(iccp_count_connect_errors.operation)) leaf_name_data.push_back(iccp_count_connect_errors.get_name_leafdata());
    if (iccp_invalid_connects.is_set || is_set(iccp_invalid_connects.operation)) leaf_name_data.push_back(iccp_invalid_connects.get_name_leafdata());
    if (iccp_invalid_disconnects.is_set || is_set(iccp_invalid_disconnects.operation)) leaf_name_data.push_back(iccp_invalid_disconnects.get_name_leafdata());
    if (received_connects.is_set || is_set(received_connects.operation)) leaf_name_data.push_back(received_connects.get_name_leafdata());
    if (received_disconnects.is_set || is_set(received_disconnects.operation)) leaf_name_data.push_back(received_disconnects.get_name_leafdata());
    if (received_wrong_versions.is_set || is_set(received_wrong_versions.operation)) leaf_name_data.push_back(received_wrong_versions.get_name_leafdata());
    if (sent_connects.is_set || is_set(sent_connects.operation)) leaf_name_data.push_back(sent_connects.get_name_leafdata());
    if (sent_disconnects.is_set || is_set(sent_disconnects.operation)) leaf_name_data.push_back(sent_disconnects.get_name_leafdata());
    if (sent_wrong_versions.is_set || is_set(sent_wrong_versions.operation)) leaf_name_data.push_back(sent_wrong_versions.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-config-connect-errors")
    {
        iccp_config_connect_errors = value;
    }
    if(value_path == "iccp-count-connect-errors")
    {
        iccp_count_connect_errors = value;
    }
    if(value_path == "iccp-invalid-connects")
    {
        iccp_invalid_connects = value;
    }
    if(value_path == "iccp-invalid-disconnects")
    {
        iccp_invalid_disconnects = value;
    }
    if(value_path == "received-connects")
    {
        received_connects = value;
    }
    if(value_path == "received-disconnects")
    {
        received_disconnects = value;
    }
    if(value_path == "received-wrong-versions")
    {
        received_wrong_versions = value;
    }
    if(value_path == "sent-connects")
    {
        sent_connects = value;
    }
    if(value_path == "sent-disconnects")
    {
        sent_disconnects = value;
    }
    if(value_path == "sent-wrong-versions")
    {
        sent_wrong_versions = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::TlVs()
    :
    	received_config{YType::uint32, "received-config"},
	 received_config_sync_requests{YType::uint32, "received-config-sync-requests"},
	 received_na_ks{YType::uint32, "received-na-ks"},
	 received_solicited_sync_data{YType::uint32, "received-solicited-sync-data"},
	 received_state{YType::uint32, "received-state"},
	 received_state_sync_requests{YType::uint32, "received-state-sync-requests"},
	 received_sync_requests{YType::uint32, "received-sync-requests"},
	 received_unsolicited_sync_data{YType::uint32, "received-unsolicited-sync-data"},
	 sent_config{YType::uint32, "sent-config"},
	 sent_config_sync_requests{YType::uint32, "sent-config-sync-requests"},
	 sent_na_ks{YType::uint32, "sent-na-ks"},
	 sent_solicited_sync_data{YType::uint32, "sent-solicited-sync-data"},
	 sent_state{YType::uint32, "sent-state"},
	 sent_state_sync_requests{YType::uint32, "sent-state-sync-requests"},
	 sent_sync_requests{YType::uint32, "sent-sync-requests"},
	 sent_unsolicited_sync_data{YType::uint32, "sent-unsolicited-sync-data"}
{
    yang_name = "tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::~TlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::has_data() const
{
    return received_config.is_set
	|| received_config_sync_requests.is_set
	|| received_na_ks.is_set
	|| received_solicited_sync_data.is_set
	|| received_state.is_set
	|| received_state_sync_requests.is_set
	|| received_sync_requests.is_set
	|| received_unsolicited_sync_data.is_set
	|| sent_config.is_set
	|| sent_config_sync_requests.is_set
	|| sent_na_ks.is_set
	|| sent_solicited_sync_data.is_set
	|| sent_state.is_set
	|| sent_state_sync_requests.is_set
	|| sent_sync_requests.is_set
	|| sent_unsolicited_sync_data.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(received_config.operation)
	|| is_set(received_config_sync_requests.operation)
	|| is_set(received_na_ks.operation)
	|| is_set(received_solicited_sync_data.operation)
	|| is_set(received_state.operation)
	|| is_set(received_state_sync_requests.operation)
	|| is_set(received_sync_requests.operation)
	|| is_set(received_unsolicited_sync_data.operation)
	|| is_set(sent_config.operation)
	|| is_set(sent_config_sync_requests.operation)
	|| is_set(sent_na_ks.operation)
	|| is_set(sent_solicited_sync_data.operation)
	|| is_set(sent_state.operation)
	|| is_set(sent_state_sync_requests.operation)
	|| is_set(sent_sync_requests.operation)
	|| is_set(sent_unsolicited_sync_data.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_config.is_set || is_set(received_config.operation)) leaf_name_data.push_back(received_config.get_name_leafdata());
    if (received_config_sync_requests.is_set || is_set(received_config_sync_requests.operation)) leaf_name_data.push_back(received_config_sync_requests.get_name_leafdata());
    if (received_na_ks.is_set || is_set(received_na_ks.operation)) leaf_name_data.push_back(received_na_ks.get_name_leafdata());
    if (received_solicited_sync_data.is_set || is_set(received_solicited_sync_data.operation)) leaf_name_data.push_back(received_solicited_sync_data.get_name_leafdata());
    if (received_state.is_set || is_set(received_state.operation)) leaf_name_data.push_back(received_state.get_name_leafdata());
    if (received_state_sync_requests.is_set || is_set(received_state_sync_requests.operation)) leaf_name_data.push_back(received_state_sync_requests.get_name_leafdata());
    if (received_sync_requests.is_set || is_set(received_sync_requests.operation)) leaf_name_data.push_back(received_sync_requests.get_name_leafdata());
    if (received_unsolicited_sync_data.is_set || is_set(received_unsolicited_sync_data.operation)) leaf_name_data.push_back(received_unsolicited_sync_data.get_name_leafdata());
    if (sent_config.is_set || is_set(sent_config.operation)) leaf_name_data.push_back(sent_config.get_name_leafdata());
    if (sent_config_sync_requests.is_set || is_set(sent_config_sync_requests.operation)) leaf_name_data.push_back(sent_config_sync_requests.get_name_leafdata());
    if (sent_na_ks.is_set || is_set(sent_na_ks.operation)) leaf_name_data.push_back(sent_na_ks.get_name_leafdata());
    if (sent_solicited_sync_data.is_set || is_set(sent_solicited_sync_data.operation)) leaf_name_data.push_back(sent_solicited_sync_data.get_name_leafdata());
    if (sent_state.is_set || is_set(sent_state.operation)) leaf_name_data.push_back(sent_state.get_name_leafdata());
    if (sent_state_sync_requests.is_set || is_set(sent_state_sync_requests.operation)) leaf_name_data.push_back(sent_state_sync_requests.get_name_leafdata());
    if (sent_sync_requests.is_set || is_set(sent_sync_requests.operation)) leaf_name_data.push_back(sent_sync_requests.get_name_leafdata());
    if (sent_unsolicited_sync_data.is_set || is_set(sent_unsolicited_sync_data.operation)) leaf_name_data.push_back(sent_unsolicited_sync_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-config")
    {
        received_config = value;
    }
    if(value_path == "received-config-sync-requests")
    {
        received_config_sync_requests = value;
    }
    if(value_path == "received-na-ks")
    {
        received_na_ks = value;
    }
    if(value_path == "received-solicited-sync-data")
    {
        received_solicited_sync_data = value;
    }
    if(value_path == "received-state")
    {
        received_state = value;
    }
    if(value_path == "received-state-sync-requests")
    {
        received_state_sync_requests = value;
    }
    if(value_path == "received-sync-requests")
    {
        received_sync_requests = value;
    }
    if(value_path == "received-unsolicited-sync-data")
    {
        received_unsolicited_sync_data = value;
    }
    if(value_path == "sent-config")
    {
        sent_config = value;
    }
    if(value_path == "sent-config-sync-requests")
    {
        sent_config_sync_requests = value;
    }
    if(value_path == "sent-na-ks")
    {
        sent_na_ks = value;
    }
    if(value_path == "sent-solicited-sync-data")
    {
        sent_solicited_sync_data = value;
    }
    if(value_path == "sent-state")
    {
        sent_state = value;
    }
    if(value_path == "sent-state-sync-requests")
    {
        sent_state_sync_requests = value;
    }
    if(value_path == "sent-sync-requests")
    {
        sent_sync_requests = value;
    }
    if(value_path == "sent-unsolicited-sync-data")
    {
        sent_unsolicited_sync_data = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::InvalidTlVs()
    :
    	incorrect_length{YType::uint32, "incorrect-length"},
	 invalid_data{YType::uint32, "invalid-data"},
	 invalid_type{YType::uint32, "invalid-type"},
	 unknown_bundle{YType::uint32, "unknown-bundle"},
	 unknown_port{YType::uint32, "unknown-port"}
{
    yang_name = "invalid-tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::~InvalidTlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::has_data() const
{
    return incorrect_length.is_set
	|| invalid_data.is_set
	|| invalid_type.is_set
	|| unknown_bundle.is_set
	|| unknown_port.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(incorrect_length.operation)
	|| is_set(invalid_data.operation)
	|| is_set(invalid_type.operation)
	|| is_set(unknown_bundle.operation)
	|| is_set(unknown_port.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid-tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incorrect_length.is_set || is_set(incorrect_length.operation)) leaf_name_data.push_back(incorrect_length.get_name_leafdata());
    if (invalid_data.is_set || is_set(invalid_data.operation)) leaf_name_data.push_back(invalid_data.get_name_leafdata());
    if (invalid_type.is_set || is_set(invalid_type.operation)) leaf_name_data.push_back(invalid_type.get_name_leafdata());
    if (unknown_bundle.is_set || is_set(unknown_bundle.operation)) leaf_name_data.push_back(unknown_bundle.get_name_leafdata());
    if (unknown_port.is_set || is_set(unknown_port.operation)) leaf_name_data.push_back(unknown_port.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incorrect-length")
    {
        incorrect_length = value;
    }
    if(value_path == "invalid-data")
    {
        invalid_data = value;
    }
    if(value_path == "invalid-type")
    {
        invalid_type = value;
    }
    if(value_path == "unknown-bundle")
    {
        unknown_bundle = value;
    }
    if(value_path == "unknown-port")
    {
        unknown_port = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::IccpMessages()
    :
    	received_messages{YType::uint32, "received-messages"},
	 sent_buffer_messages{YType::uint32, "sent-buffer-messages"},
	 sent_messages{YType::uint32, "sent-messages"},
	 transmission_errors{YType::uint32, "transmission-errors"}
{
    yang_name = "iccp-messages"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::~IccpMessages()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::has_data() const
{
    return received_messages.is_set
	|| sent_buffer_messages.is_set
	|| sent_messages.is_set
	|| transmission_errors.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::has_operation() const
{
    return is_set(operation)
	|| is_set(received_messages.operation)
	|| is_set(sent_buffer_messages.operation)
	|| is_set(sent_messages.operation)
	|| is_set(transmission_errors.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-messages";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_messages.is_set || is_set(received_messages.operation)) leaf_name_data.push_back(received_messages.get_name_leafdata());
    if (sent_buffer_messages.is_set || is_set(sent_buffer_messages.operation)) leaf_name_data.push_back(sent_buffer_messages.get_name_leafdata());
    if (sent_messages.is_set || is_set(sent_messages.operation)) leaf_name_data.push_back(sent_messages.get_name_leafdata());
    if (transmission_errors.is_set || is_set(transmission_errors.operation)) leaf_name_data.push_back(transmission_errors.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-messages")
    {
        received_messages = value;
    }
    if(value_path == "sent-buffer-messages")
    {
        sent_buffer_messages = value;
    }
    if(value_path == "sent-messages")
    {
        sent_messages = value;
    }
    if(value_path == "transmission-errors")
    {
        transmission_errors = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::IccpEvents()
    :
    	configured_clear{YType::uint32, "configured-clear"},
	 configured_set{YType::uint32, "configured-set"},
	 member_status_down{YType::uint32, "member-status-down"},
	 member_status_up{YType::uint32, "member-status-up"},
	 pe_isolated{YType::uint32, "pe-isolated"},
	 pe_isolated_clear{YType::uint32, "pe-isolated-clear"},
	 reachability_cleared{YType::uint32, "reachability-cleared"},
	 reachability_set{YType::uint32, "reachability-set"},
	 transport_down{YType::uint32, "transport-down"},
	 transport_unavailable{YType::uint32, "transport-unavailable"},
	 transport_up{YType::uint32, "transport-up"}
{
    yang_name = "iccp-events"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::~IccpEvents()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::has_data() const
{
    return configured_clear.is_set
	|| configured_set.is_set
	|| member_status_down.is_set
	|| member_status_up.is_set
	|| pe_isolated.is_set
	|| pe_isolated_clear.is_set
	|| reachability_cleared.is_set
	|| reachability_set.is_set
	|| transport_down.is_set
	|| transport_unavailable.is_set
	|| transport_up.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_clear.operation)
	|| is_set(configured_set.operation)
	|| is_set(member_status_down.operation)
	|| is_set(member_status_up.operation)
	|| is_set(pe_isolated.operation)
	|| is_set(pe_isolated_clear.operation)
	|| is_set(reachability_cleared.operation)
	|| is_set(reachability_set.operation)
	|| is_set(transport_down.operation)
	|| is_set(transport_unavailable.operation)
	|| is_set(transport_up.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-events";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_clear.is_set || is_set(configured_clear.operation)) leaf_name_data.push_back(configured_clear.get_name_leafdata());
    if (configured_set.is_set || is_set(configured_set.operation)) leaf_name_data.push_back(configured_set.get_name_leafdata());
    if (member_status_down.is_set || is_set(member_status_down.operation)) leaf_name_data.push_back(member_status_down.get_name_leafdata());
    if (member_status_up.is_set || is_set(member_status_up.operation)) leaf_name_data.push_back(member_status_up.get_name_leafdata());
    if (pe_isolated.is_set || is_set(pe_isolated.operation)) leaf_name_data.push_back(pe_isolated.get_name_leafdata());
    if (pe_isolated_clear.is_set || is_set(pe_isolated_clear.operation)) leaf_name_data.push_back(pe_isolated_clear.get_name_leafdata());
    if (reachability_cleared.is_set || is_set(reachability_cleared.operation)) leaf_name_data.push_back(reachability_cleared.get_name_leafdata());
    if (reachability_set.is_set || is_set(reachability_set.operation)) leaf_name_data.push_back(reachability_set.get_name_leafdata());
    if (transport_down.is_set || is_set(transport_down.operation)) leaf_name_data.push_back(transport_down.get_name_leafdata());
    if (transport_unavailable.is_set || is_set(transport_unavailable.operation)) leaf_name_data.push_back(transport_unavailable.get_name_leafdata());
    if (transport_up.is_set || is_set(transport_up.operation)) leaf_name_data.push_back(transport_up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-clear")
    {
        configured_clear = value;
    }
    if(value_path == "configured-set")
    {
        configured_set = value;
    }
    if(value_path == "member-status-down")
    {
        member_status_down = value;
    }
    if(value_path == "member-status-up")
    {
        member_status_up = value;
    }
    if(value_path == "pe-isolated")
    {
        pe_isolated = value;
    }
    if(value_path == "pe-isolated-clear")
    {
        pe_isolated_clear = value;
    }
    if(value_path == "reachability-cleared")
    {
        reachability_cleared = value;
    }
    if(value_path == "reachability-set")
    {
        reachability_set = value;
    }
    if(value_path == "transport-down")
    {
        transport_down = value;
    }
    if(value_path == "transport-unavailable")
    {
        transport_unavailable = value;
    }
    if(value_path == "transport-up")
    {
        transport_up = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpGroupCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    connection(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection>())
	,iccp_events(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents>())
	,iccp_messages(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages>())
	,invalid_tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs>())
	,tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs>())
{
    connection->parent = this;
    children["connection"] = connection.get();

    iccp_events->parent = this;
    children["iccp-events"] = iccp_events.get();

    iccp_messages->parent = this;
    children["iccp-messages"] = iccp_messages.get();

    invalid_tl_vs->parent = this;
    children["invalid-tl-vs"] = invalid_tl_vs.get();

    tl_vs->parent = this;
    children["tl-vs"] = tl_vs.get();

    yang_name = "iccp-group-counters"; yang_parent_name = "iccp-group-ancestor-bundle";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::~IccpGroupCounters()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| time_since_cleared.is_set
	|| (connection !=  nullptr && connection->has_data())
	|| (iccp_events !=  nullptr && iccp_events->has_data())
	|| (iccp_messages !=  nullptr && iccp_messages->has_data())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_data())
	|| (tl_vs !=  nullptr && tl_vs->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(time_since_cleared.operation)
	|| (connection !=  nullptr && connection->has_operation())
	|| (iccp_events !=  nullptr && iccp_events->has_operation())
	|| (iccp_messages !=  nullptr && iccp_messages->has_operation())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_operation())
	|| (tl_vs !=  nullptr && tl_vs->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connection")
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
        else
        {
            connection = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::Connection>();
            connection->parent = this;
            children["connection"] = connection.get();
        }
        return children.at("connection");
    }

    if(child_yang_name == "iccp-events")
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
        else
        {
            iccp_events = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpEvents>();
            iccp_events->parent = this;
            children["iccp-events"] = iccp_events.get();
        }
        return children.at("iccp-events");
    }

    if(child_yang_name == "iccp-messages")
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
        else
        {
            iccp_messages = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::IccpMessages>();
            iccp_messages->parent = this;
            children["iccp-messages"] = iccp_messages.get();
        }
        return children.at("iccp-messages");
    }

    if(child_yang_name == "invalid-tl-vs")
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        else
        {
            invalid_tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::InvalidTlVs>();
            invalid_tl_vs->parent = this;
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        return children.at("invalid-tl-vs");
    }

    if(child_yang_name == "tl-vs")
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
        else
        {
            tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::TlVs>();
            tl_vs->parent = this;
            children["tl-vs"] = tl_vs.get();
        }
        return children.at("tl-vs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::get_children()
{
    if(children.find("connection") == children.end())
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
    }

    if(children.find("iccp-events") == children.end())
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
    }

    if(children.find("iccp-messages") == children.end())
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
    }

    if(children.find("invalid-tl-vs") == children.end())
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
    }

    if(children.find("tl-vs") == children.end())
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupAncestorBundle()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    iccp_group_counters(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters>())
{
    iccp_group_counters->parent = this;
    children["iccp-group-counters"] = iccp_group_counters.get();

    yang_name = "iccp-group-ancestor-bundle"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::~IccpGroupAncestorBundle()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::has_data() const
{
    return iccp_group_id.is_set
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-ancestor-bundle";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-counters")
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        else
        {
            iccp_group_counters = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::IccpGroupCounters>();
            iccp_group_counters->parent = this;
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        return children.at("iccp-group-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::get_children()
{
    if(children.find("iccp-group-counters") == children.end())
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::Connection()
    :
    	iccp_config_connect_errors{YType::uint32, "iccp-config-connect-errors"},
	 iccp_count_connect_errors{YType::uint32, "iccp-count-connect-errors"},
	 iccp_invalid_connects{YType::uint32, "iccp-invalid-connects"},
	 iccp_invalid_disconnects{YType::uint32, "iccp-invalid-disconnects"},
	 received_connects{YType::uint32, "received-connects"},
	 received_disconnects{YType::uint32, "received-disconnects"},
	 received_wrong_versions{YType::uint32, "received-wrong-versions"},
	 sent_connects{YType::uint32, "sent-connects"},
	 sent_disconnects{YType::uint32, "sent-disconnects"},
	 sent_wrong_versions{YType::uint32, "sent-wrong-versions"}
{
    yang_name = "connection"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::~Connection()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::has_data() const
{
    return iccp_config_connect_errors.is_set
	|| iccp_count_connect_errors.is_set
	|| iccp_invalid_connects.is_set
	|| iccp_invalid_disconnects.is_set
	|| received_connects.is_set
	|| received_disconnects.is_set
	|| received_wrong_versions.is_set
	|| sent_connects.is_set
	|| sent_disconnects.is_set
	|| sent_wrong_versions.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_config_connect_errors.operation)
	|| is_set(iccp_count_connect_errors.operation)
	|| is_set(iccp_invalid_connects.operation)
	|| is_set(iccp_invalid_disconnects.operation)
	|| is_set(received_connects.operation)
	|| is_set(received_disconnects.operation)
	|| is_set(received_wrong_versions.operation)
	|| is_set(sent_connects.operation)
	|| is_set(sent_disconnects.operation)
	|| is_set(sent_wrong_versions.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connection";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_config_connect_errors.is_set || is_set(iccp_config_connect_errors.operation)) leaf_name_data.push_back(iccp_config_connect_errors.get_name_leafdata());
    if (iccp_count_connect_errors.is_set || is_set(iccp_count_connect_errors.operation)) leaf_name_data.push_back(iccp_count_connect_errors.get_name_leafdata());
    if (iccp_invalid_connects.is_set || is_set(iccp_invalid_connects.operation)) leaf_name_data.push_back(iccp_invalid_connects.get_name_leafdata());
    if (iccp_invalid_disconnects.is_set || is_set(iccp_invalid_disconnects.operation)) leaf_name_data.push_back(iccp_invalid_disconnects.get_name_leafdata());
    if (received_connects.is_set || is_set(received_connects.operation)) leaf_name_data.push_back(received_connects.get_name_leafdata());
    if (received_disconnects.is_set || is_set(received_disconnects.operation)) leaf_name_data.push_back(received_disconnects.get_name_leafdata());
    if (received_wrong_versions.is_set || is_set(received_wrong_versions.operation)) leaf_name_data.push_back(received_wrong_versions.get_name_leafdata());
    if (sent_connects.is_set || is_set(sent_connects.operation)) leaf_name_data.push_back(sent_connects.get_name_leafdata());
    if (sent_disconnects.is_set || is_set(sent_disconnects.operation)) leaf_name_data.push_back(sent_disconnects.get_name_leafdata());
    if (sent_wrong_versions.is_set || is_set(sent_wrong_versions.operation)) leaf_name_data.push_back(sent_wrong_versions.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-config-connect-errors")
    {
        iccp_config_connect_errors = value;
    }
    if(value_path == "iccp-count-connect-errors")
    {
        iccp_count_connect_errors = value;
    }
    if(value_path == "iccp-invalid-connects")
    {
        iccp_invalid_connects = value;
    }
    if(value_path == "iccp-invalid-disconnects")
    {
        iccp_invalid_disconnects = value;
    }
    if(value_path == "received-connects")
    {
        received_connects = value;
    }
    if(value_path == "received-disconnects")
    {
        received_disconnects = value;
    }
    if(value_path == "received-wrong-versions")
    {
        received_wrong_versions = value;
    }
    if(value_path == "sent-connects")
    {
        sent_connects = value;
    }
    if(value_path == "sent-disconnects")
    {
        sent_disconnects = value;
    }
    if(value_path == "sent-wrong-versions")
    {
        sent_wrong_versions = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::TlVs()
    :
    	received_config{YType::uint32, "received-config"},
	 received_config_sync_requests{YType::uint32, "received-config-sync-requests"},
	 received_na_ks{YType::uint32, "received-na-ks"},
	 received_solicited_sync_data{YType::uint32, "received-solicited-sync-data"},
	 received_state{YType::uint32, "received-state"},
	 received_state_sync_requests{YType::uint32, "received-state-sync-requests"},
	 received_sync_requests{YType::uint32, "received-sync-requests"},
	 received_unsolicited_sync_data{YType::uint32, "received-unsolicited-sync-data"},
	 sent_config{YType::uint32, "sent-config"},
	 sent_config_sync_requests{YType::uint32, "sent-config-sync-requests"},
	 sent_na_ks{YType::uint32, "sent-na-ks"},
	 sent_solicited_sync_data{YType::uint32, "sent-solicited-sync-data"},
	 sent_state{YType::uint32, "sent-state"},
	 sent_state_sync_requests{YType::uint32, "sent-state-sync-requests"},
	 sent_sync_requests{YType::uint32, "sent-sync-requests"},
	 sent_unsolicited_sync_data{YType::uint32, "sent-unsolicited-sync-data"}
{
    yang_name = "tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::~TlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::has_data() const
{
    return received_config.is_set
	|| received_config_sync_requests.is_set
	|| received_na_ks.is_set
	|| received_solicited_sync_data.is_set
	|| received_state.is_set
	|| received_state_sync_requests.is_set
	|| received_sync_requests.is_set
	|| received_unsolicited_sync_data.is_set
	|| sent_config.is_set
	|| sent_config_sync_requests.is_set
	|| sent_na_ks.is_set
	|| sent_solicited_sync_data.is_set
	|| sent_state.is_set
	|| sent_state_sync_requests.is_set
	|| sent_sync_requests.is_set
	|| sent_unsolicited_sync_data.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(received_config.operation)
	|| is_set(received_config_sync_requests.operation)
	|| is_set(received_na_ks.operation)
	|| is_set(received_solicited_sync_data.operation)
	|| is_set(received_state.operation)
	|| is_set(received_state_sync_requests.operation)
	|| is_set(received_sync_requests.operation)
	|| is_set(received_unsolicited_sync_data.operation)
	|| is_set(sent_config.operation)
	|| is_set(sent_config_sync_requests.operation)
	|| is_set(sent_na_ks.operation)
	|| is_set(sent_solicited_sync_data.operation)
	|| is_set(sent_state.operation)
	|| is_set(sent_state_sync_requests.operation)
	|| is_set(sent_sync_requests.operation)
	|| is_set(sent_unsolicited_sync_data.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_config.is_set || is_set(received_config.operation)) leaf_name_data.push_back(received_config.get_name_leafdata());
    if (received_config_sync_requests.is_set || is_set(received_config_sync_requests.operation)) leaf_name_data.push_back(received_config_sync_requests.get_name_leafdata());
    if (received_na_ks.is_set || is_set(received_na_ks.operation)) leaf_name_data.push_back(received_na_ks.get_name_leafdata());
    if (received_solicited_sync_data.is_set || is_set(received_solicited_sync_data.operation)) leaf_name_data.push_back(received_solicited_sync_data.get_name_leafdata());
    if (received_state.is_set || is_set(received_state.operation)) leaf_name_data.push_back(received_state.get_name_leafdata());
    if (received_state_sync_requests.is_set || is_set(received_state_sync_requests.operation)) leaf_name_data.push_back(received_state_sync_requests.get_name_leafdata());
    if (received_sync_requests.is_set || is_set(received_sync_requests.operation)) leaf_name_data.push_back(received_sync_requests.get_name_leafdata());
    if (received_unsolicited_sync_data.is_set || is_set(received_unsolicited_sync_data.operation)) leaf_name_data.push_back(received_unsolicited_sync_data.get_name_leafdata());
    if (sent_config.is_set || is_set(sent_config.operation)) leaf_name_data.push_back(sent_config.get_name_leafdata());
    if (sent_config_sync_requests.is_set || is_set(sent_config_sync_requests.operation)) leaf_name_data.push_back(sent_config_sync_requests.get_name_leafdata());
    if (sent_na_ks.is_set || is_set(sent_na_ks.operation)) leaf_name_data.push_back(sent_na_ks.get_name_leafdata());
    if (sent_solicited_sync_data.is_set || is_set(sent_solicited_sync_data.operation)) leaf_name_data.push_back(sent_solicited_sync_data.get_name_leafdata());
    if (sent_state.is_set || is_set(sent_state.operation)) leaf_name_data.push_back(sent_state.get_name_leafdata());
    if (sent_state_sync_requests.is_set || is_set(sent_state_sync_requests.operation)) leaf_name_data.push_back(sent_state_sync_requests.get_name_leafdata());
    if (sent_sync_requests.is_set || is_set(sent_sync_requests.operation)) leaf_name_data.push_back(sent_sync_requests.get_name_leafdata());
    if (sent_unsolicited_sync_data.is_set || is_set(sent_unsolicited_sync_data.operation)) leaf_name_data.push_back(sent_unsolicited_sync_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-config")
    {
        received_config = value;
    }
    if(value_path == "received-config-sync-requests")
    {
        received_config_sync_requests = value;
    }
    if(value_path == "received-na-ks")
    {
        received_na_ks = value;
    }
    if(value_path == "received-solicited-sync-data")
    {
        received_solicited_sync_data = value;
    }
    if(value_path == "received-state")
    {
        received_state = value;
    }
    if(value_path == "received-state-sync-requests")
    {
        received_state_sync_requests = value;
    }
    if(value_path == "received-sync-requests")
    {
        received_sync_requests = value;
    }
    if(value_path == "received-unsolicited-sync-data")
    {
        received_unsolicited_sync_data = value;
    }
    if(value_path == "sent-config")
    {
        sent_config = value;
    }
    if(value_path == "sent-config-sync-requests")
    {
        sent_config_sync_requests = value;
    }
    if(value_path == "sent-na-ks")
    {
        sent_na_ks = value;
    }
    if(value_path == "sent-solicited-sync-data")
    {
        sent_solicited_sync_data = value;
    }
    if(value_path == "sent-state")
    {
        sent_state = value;
    }
    if(value_path == "sent-state-sync-requests")
    {
        sent_state_sync_requests = value;
    }
    if(value_path == "sent-sync-requests")
    {
        sent_sync_requests = value;
    }
    if(value_path == "sent-unsolicited-sync-data")
    {
        sent_unsolicited_sync_data = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::InvalidTlVs()
    :
    	incorrect_length{YType::uint32, "incorrect-length"},
	 invalid_data{YType::uint32, "invalid-data"},
	 invalid_type{YType::uint32, "invalid-type"},
	 unknown_bundle{YType::uint32, "unknown-bundle"},
	 unknown_port{YType::uint32, "unknown-port"}
{
    yang_name = "invalid-tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::~InvalidTlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::has_data() const
{
    return incorrect_length.is_set
	|| invalid_data.is_set
	|| invalid_type.is_set
	|| unknown_bundle.is_set
	|| unknown_port.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(incorrect_length.operation)
	|| is_set(invalid_data.operation)
	|| is_set(invalid_type.operation)
	|| is_set(unknown_bundle.operation)
	|| is_set(unknown_port.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid-tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incorrect_length.is_set || is_set(incorrect_length.operation)) leaf_name_data.push_back(incorrect_length.get_name_leafdata());
    if (invalid_data.is_set || is_set(invalid_data.operation)) leaf_name_data.push_back(invalid_data.get_name_leafdata());
    if (invalid_type.is_set || is_set(invalid_type.operation)) leaf_name_data.push_back(invalid_type.get_name_leafdata());
    if (unknown_bundle.is_set || is_set(unknown_bundle.operation)) leaf_name_data.push_back(unknown_bundle.get_name_leafdata());
    if (unknown_port.is_set || is_set(unknown_port.operation)) leaf_name_data.push_back(unknown_port.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incorrect-length")
    {
        incorrect_length = value;
    }
    if(value_path == "invalid-data")
    {
        invalid_data = value;
    }
    if(value_path == "invalid-type")
    {
        invalid_type = value;
    }
    if(value_path == "unknown-bundle")
    {
        unknown_bundle = value;
    }
    if(value_path == "unknown-port")
    {
        unknown_port = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::IccpMessages()
    :
    	received_messages{YType::uint32, "received-messages"},
	 sent_buffer_messages{YType::uint32, "sent-buffer-messages"},
	 sent_messages{YType::uint32, "sent-messages"},
	 transmission_errors{YType::uint32, "transmission-errors"}
{
    yang_name = "iccp-messages"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::~IccpMessages()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::has_data() const
{
    return received_messages.is_set
	|| sent_buffer_messages.is_set
	|| sent_messages.is_set
	|| transmission_errors.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::has_operation() const
{
    return is_set(operation)
	|| is_set(received_messages.operation)
	|| is_set(sent_buffer_messages.operation)
	|| is_set(sent_messages.operation)
	|| is_set(transmission_errors.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-messages";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_messages.is_set || is_set(received_messages.operation)) leaf_name_data.push_back(received_messages.get_name_leafdata());
    if (sent_buffer_messages.is_set || is_set(sent_buffer_messages.operation)) leaf_name_data.push_back(sent_buffer_messages.get_name_leafdata());
    if (sent_messages.is_set || is_set(sent_messages.operation)) leaf_name_data.push_back(sent_messages.get_name_leafdata());
    if (transmission_errors.is_set || is_set(transmission_errors.operation)) leaf_name_data.push_back(transmission_errors.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-messages")
    {
        received_messages = value;
    }
    if(value_path == "sent-buffer-messages")
    {
        sent_buffer_messages = value;
    }
    if(value_path == "sent-messages")
    {
        sent_messages = value;
    }
    if(value_path == "transmission-errors")
    {
        transmission_errors = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::IccpEvents()
    :
    	configured_clear{YType::uint32, "configured-clear"},
	 configured_set{YType::uint32, "configured-set"},
	 member_status_down{YType::uint32, "member-status-down"},
	 member_status_up{YType::uint32, "member-status-up"},
	 pe_isolated{YType::uint32, "pe-isolated"},
	 pe_isolated_clear{YType::uint32, "pe-isolated-clear"},
	 reachability_cleared{YType::uint32, "reachability-cleared"},
	 reachability_set{YType::uint32, "reachability-set"},
	 transport_down{YType::uint32, "transport-down"},
	 transport_unavailable{YType::uint32, "transport-unavailable"},
	 transport_up{YType::uint32, "transport-up"}
{
    yang_name = "iccp-events"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::~IccpEvents()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::has_data() const
{
    return configured_clear.is_set
	|| configured_set.is_set
	|| member_status_down.is_set
	|| member_status_up.is_set
	|| pe_isolated.is_set
	|| pe_isolated_clear.is_set
	|| reachability_cleared.is_set
	|| reachability_set.is_set
	|| transport_down.is_set
	|| transport_unavailable.is_set
	|| transport_up.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_clear.operation)
	|| is_set(configured_set.operation)
	|| is_set(member_status_down.operation)
	|| is_set(member_status_up.operation)
	|| is_set(pe_isolated.operation)
	|| is_set(pe_isolated_clear.operation)
	|| is_set(reachability_cleared.operation)
	|| is_set(reachability_set.operation)
	|| is_set(transport_down.operation)
	|| is_set(transport_unavailable.operation)
	|| is_set(transport_up.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-events";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_clear.is_set || is_set(configured_clear.operation)) leaf_name_data.push_back(configured_clear.get_name_leafdata());
    if (configured_set.is_set || is_set(configured_set.operation)) leaf_name_data.push_back(configured_set.get_name_leafdata());
    if (member_status_down.is_set || is_set(member_status_down.operation)) leaf_name_data.push_back(member_status_down.get_name_leafdata());
    if (member_status_up.is_set || is_set(member_status_up.operation)) leaf_name_data.push_back(member_status_up.get_name_leafdata());
    if (pe_isolated.is_set || is_set(pe_isolated.operation)) leaf_name_data.push_back(pe_isolated.get_name_leafdata());
    if (pe_isolated_clear.is_set || is_set(pe_isolated_clear.operation)) leaf_name_data.push_back(pe_isolated_clear.get_name_leafdata());
    if (reachability_cleared.is_set || is_set(reachability_cleared.operation)) leaf_name_data.push_back(reachability_cleared.get_name_leafdata());
    if (reachability_set.is_set || is_set(reachability_set.operation)) leaf_name_data.push_back(reachability_set.get_name_leafdata());
    if (transport_down.is_set || is_set(transport_down.operation)) leaf_name_data.push_back(transport_down.get_name_leafdata());
    if (transport_unavailable.is_set || is_set(transport_unavailable.operation)) leaf_name_data.push_back(transport_unavailable.get_name_leafdata());
    if (transport_up.is_set || is_set(transport_up.operation)) leaf_name_data.push_back(transport_up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-clear")
    {
        configured_clear = value;
    }
    if(value_path == "configured-set")
    {
        configured_set = value;
    }
    if(value_path == "member-status-down")
    {
        member_status_down = value;
    }
    if(value_path == "member-status-up")
    {
        member_status_up = value;
    }
    if(value_path == "pe-isolated")
    {
        pe_isolated = value;
    }
    if(value_path == "pe-isolated-clear")
    {
        pe_isolated_clear = value;
    }
    if(value_path == "reachability-cleared")
    {
        reachability_cleared = value;
    }
    if(value_path == "reachability-set")
    {
        reachability_set = value;
    }
    if(value_path == "transport-down")
    {
        transport_down = value;
    }
    if(value_path == "transport-unavailable")
    {
        transport_unavailable = value;
    }
    if(value_path == "transport-up")
    {
        transport_up = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpGroupCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    connection(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection>())
	,iccp_events(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents>())
	,iccp_messages(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages>())
	,invalid_tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs>())
	,tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs>())
{
    connection->parent = this;
    children["connection"] = connection.get();

    iccp_events->parent = this;
    children["iccp-events"] = iccp_events.get();

    iccp_messages->parent = this;
    children["iccp-messages"] = iccp_messages.get();

    invalid_tl_vs->parent = this;
    children["invalid-tl-vs"] = invalid_tl_vs.get();

    tl_vs->parent = this;
    children["tl-vs"] = tl_vs.get();

    yang_name = "iccp-group-counters"; yang_parent_name = "iccp-group-ancestor-member";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::~IccpGroupCounters()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| time_since_cleared.is_set
	|| (connection !=  nullptr && connection->has_data())
	|| (iccp_events !=  nullptr && iccp_events->has_data())
	|| (iccp_messages !=  nullptr && iccp_messages->has_data())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_data())
	|| (tl_vs !=  nullptr && tl_vs->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(time_since_cleared.operation)
	|| (connection !=  nullptr && connection->has_operation())
	|| (iccp_events !=  nullptr && iccp_events->has_operation())
	|| (iccp_messages !=  nullptr && iccp_messages->has_operation())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_operation())
	|| (tl_vs !=  nullptr && tl_vs->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connection")
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
        else
        {
            connection = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::Connection>();
            connection->parent = this;
            children["connection"] = connection.get();
        }
        return children.at("connection");
    }

    if(child_yang_name == "iccp-events")
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
        else
        {
            iccp_events = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpEvents>();
            iccp_events->parent = this;
            children["iccp-events"] = iccp_events.get();
        }
        return children.at("iccp-events");
    }

    if(child_yang_name == "iccp-messages")
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
        else
        {
            iccp_messages = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::IccpMessages>();
            iccp_messages->parent = this;
            children["iccp-messages"] = iccp_messages.get();
        }
        return children.at("iccp-messages");
    }

    if(child_yang_name == "invalid-tl-vs")
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        else
        {
            invalid_tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::InvalidTlVs>();
            invalid_tl_vs->parent = this;
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        return children.at("invalid-tl-vs");
    }

    if(child_yang_name == "tl-vs")
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
        else
        {
            tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::TlVs>();
            tl_vs->parent = this;
            children["tl-vs"] = tl_vs.get();
        }
        return children.at("tl-vs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::get_children()
{
    if(children.find("connection") == children.end())
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
    }

    if(children.find("iccp-events") == children.end())
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
    }

    if(children.find("iccp-messages") == children.end())
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
    }

    if(children.find("invalid-tl-vs") == children.end())
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
    }

    if(children.find("tl-vs") == children.end())
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupAncestorMember()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    iccp_group_counters(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters>())
{
    iccp_group_counters->parent = this;
    children["iccp-group-counters"] = iccp_group_counters.get();

    yang_name = "iccp-group-ancestor-member"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::~IccpGroupAncestorMember()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::has_data() const
{
    return iccp_group_id.is_set
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-ancestor-member";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-counters")
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        else
        {
            iccp_group_counters = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::IccpGroupCounters>();
            iccp_group_counters->parent = this;
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        return children.at("iccp-group-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::get_children()
{
    if(children.find("iccp-group-counters") == children.end())
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::Connection()
    :
    	iccp_config_connect_errors{YType::uint32, "iccp-config-connect-errors"},
	 iccp_count_connect_errors{YType::uint32, "iccp-count-connect-errors"},
	 iccp_invalid_connects{YType::uint32, "iccp-invalid-connects"},
	 iccp_invalid_disconnects{YType::uint32, "iccp-invalid-disconnects"},
	 received_connects{YType::uint32, "received-connects"},
	 received_disconnects{YType::uint32, "received-disconnects"},
	 received_wrong_versions{YType::uint32, "received-wrong-versions"},
	 sent_connects{YType::uint32, "sent-connects"},
	 sent_disconnects{YType::uint32, "sent-disconnects"},
	 sent_wrong_versions{YType::uint32, "sent-wrong-versions"}
{
    yang_name = "connection"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::~Connection()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::has_data() const
{
    return iccp_config_connect_errors.is_set
	|| iccp_count_connect_errors.is_set
	|| iccp_invalid_connects.is_set
	|| iccp_invalid_disconnects.is_set
	|| received_connects.is_set
	|| received_disconnects.is_set
	|| received_wrong_versions.is_set
	|| sent_connects.is_set
	|| sent_disconnects.is_set
	|| sent_wrong_versions.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_config_connect_errors.operation)
	|| is_set(iccp_count_connect_errors.operation)
	|| is_set(iccp_invalid_connects.operation)
	|| is_set(iccp_invalid_disconnects.operation)
	|| is_set(received_connects.operation)
	|| is_set(received_disconnects.operation)
	|| is_set(received_wrong_versions.operation)
	|| is_set(sent_connects.operation)
	|| is_set(sent_disconnects.operation)
	|| is_set(sent_wrong_versions.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connection";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_config_connect_errors.is_set || is_set(iccp_config_connect_errors.operation)) leaf_name_data.push_back(iccp_config_connect_errors.get_name_leafdata());
    if (iccp_count_connect_errors.is_set || is_set(iccp_count_connect_errors.operation)) leaf_name_data.push_back(iccp_count_connect_errors.get_name_leafdata());
    if (iccp_invalid_connects.is_set || is_set(iccp_invalid_connects.operation)) leaf_name_data.push_back(iccp_invalid_connects.get_name_leafdata());
    if (iccp_invalid_disconnects.is_set || is_set(iccp_invalid_disconnects.operation)) leaf_name_data.push_back(iccp_invalid_disconnects.get_name_leafdata());
    if (received_connects.is_set || is_set(received_connects.operation)) leaf_name_data.push_back(received_connects.get_name_leafdata());
    if (received_disconnects.is_set || is_set(received_disconnects.operation)) leaf_name_data.push_back(received_disconnects.get_name_leafdata());
    if (received_wrong_versions.is_set || is_set(received_wrong_versions.operation)) leaf_name_data.push_back(received_wrong_versions.get_name_leafdata());
    if (sent_connects.is_set || is_set(sent_connects.operation)) leaf_name_data.push_back(sent_connects.get_name_leafdata());
    if (sent_disconnects.is_set || is_set(sent_disconnects.operation)) leaf_name_data.push_back(sent_disconnects.get_name_leafdata());
    if (sent_wrong_versions.is_set || is_set(sent_wrong_versions.operation)) leaf_name_data.push_back(sent_wrong_versions.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-config-connect-errors")
    {
        iccp_config_connect_errors = value;
    }
    if(value_path == "iccp-count-connect-errors")
    {
        iccp_count_connect_errors = value;
    }
    if(value_path == "iccp-invalid-connects")
    {
        iccp_invalid_connects = value;
    }
    if(value_path == "iccp-invalid-disconnects")
    {
        iccp_invalid_disconnects = value;
    }
    if(value_path == "received-connects")
    {
        received_connects = value;
    }
    if(value_path == "received-disconnects")
    {
        received_disconnects = value;
    }
    if(value_path == "received-wrong-versions")
    {
        received_wrong_versions = value;
    }
    if(value_path == "sent-connects")
    {
        sent_connects = value;
    }
    if(value_path == "sent-disconnects")
    {
        sent_disconnects = value;
    }
    if(value_path == "sent-wrong-versions")
    {
        sent_wrong_versions = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::TlVs()
    :
    	received_config{YType::uint32, "received-config"},
	 received_config_sync_requests{YType::uint32, "received-config-sync-requests"},
	 received_na_ks{YType::uint32, "received-na-ks"},
	 received_solicited_sync_data{YType::uint32, "received-solicited-sync-data"},
	 received_state{YType::uint32, "received-state"},
	 received_state_sync_requests{YType::uint32, "received-state-sync-requests"},
	 received_sync_requests{YType::uint32, "received-sync-requests"},
	 received_unsolicited_sync_data{YType::uint32, "received-unsolicited-sync-data"},
	 sent_config{YType::uint32, "sent-config"},
	 sent_config_sync_requests{YType::uint32, "sent-config-sync-requests"},
	 sent_na_ks{YType::uint32, "sent-na-ks"},
	 sent_solicited_sync_data{YType::uint32, "sent-solicited-sync-data"},
	 sent_state{YType::uint32, "sent-state"},
	 sent_state_sync_requests{YType::uint32, "sent-state-sync-requests"},
	 sent_sync_requests{YType::uint32, "sent-sync-requests"},
	 sent_unsolicited_sync_data{YType::uint32, "sent-unsolicited-sync-data"}
{
    yang_name = "tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::~TlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::has_data() const
{
    return received_config.is_set
	|| received_config_sync_requests.is_set
	|| received_na_ks.is_set
	|| received_solicited_sync_data.is_set
	|| received_state.is_set
	|| received_state_sync_requests.is_set
	|| received_sync_requests.is_set
	|| received_unsolicited_sync_data.is_set
	|| sent_config.is_set
	|| sent_config_sync_requests.is_set
	|| sent_na_ks.is_set
	|| sent_solicited_sync_data.is_set
	|| sent_state.is_set
	|| sent_state_sync_requests.is_set
	|| sent_sync_requests.is_set
	|| sent_unsolicited_sync_data.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(received_config.operation)
	|| is_set(received_config_sync_requests.operation)
	|| is_set(received_na_ks.operation)
	|| is_set(received_solicited_sync_data.operation)
	|| is_set(received_state.operation)
	|| is_set(received_state_sync_requests.operation)
	|| is_set(received_sync_requests.operation)
	|| is_set(received_unsolicited_sync_data.operation)
	|| is_set(sent_config.operation)
	|| is_set(sent_config_sync_requests.operation)
	|| is_set(sent_na_ks.operation)
	|| is_set(sent_solicited_sync_data.operation)
	|| is_set(sent_state.operation)
	|| is_set(sent_state_sync_requests.operation)
	|| is_set(sent_sync_requests.operation)
	|| is_set(sent_unsolicited_sync_data.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_config.is_set || is_set(received_config.operation)) leaf_name_data.push_back(received_config.get_name_leafdata());
    if (received_config_sync_requests.is_set || is_set(received_config_sync_requests.operation)) leaf_name_data.push_back(received_config_sync_requests.get_name_leafdata());
    if (received_na_ks.is_set || is_set(received_na_ks.operation)) leaf_name_data.push_back(received_na_ks.get_name_leafdata());
    if (received_solicited_sync_data.is_set || is_set(received_solicited_sync_data.operation)) leaf_name_data.push_back(received_solicited_sync_data.get_name_leafdata());
    if (received_state.is_set || is_set(received_state.operation)) leaf_name_data.push_back(received_state.get_name_leafdata());
    if (received_state_sync_requests.is_set || is_set(received_state_sync_requests.operation)) leaf_name_data.push_back(received_state_sync_requests.get_name_leafdata());
    if (received_sync_requests.is_set || is_set(received_sync_requests.operation)) leaf_name_data.push_back(received_sync_requests.get_name_leafdata());
    if (received_unsolicited_sync_data.is_set || is_set(received_unsolicited_sync_data.operation)) leaf_name_data.push_back(received_unsolicited_sync_data.get_name_leafdata());
    if (sent_config.is_set || is_set(sent_config.operation)) leaf_name_data.push_back(sent_config.get_name_leafdata());
    if (sent_config_sync_requests.is_set || is_set(sent_config_sync_requests.operation)) leaf_name_data.push_back(sent_config_sync_requests.get_name_leafdata());
    if (sent_na_ks.is_set || is_set(sent_na_ks.operation)) leaf_name_data.push_back(sent_na_ks.get_name_leafdata());
    if (sent_solicited_sync_data.is_set || is_set(sent_solicited_sync_data.operation)) leaf_name_data.push_back(sent_solicited_sync_data.get_name_leafdata());
    if (sent_state.is_set || is_set(sent_state.operation)) leaf_name_data.push_back(sent_state.get_name_leafdata());
    if (sent_state_sync_requests.is_set || is_set(sent_state_sync_requests.operation)) leaf_name_data.push_back(sent_state_sync_requests.get_name_leafdata());
    if (sent_sync_requests.is_set || is_set(sent_sync_requests.operation)) leaf_name_data.push_back(sent_sync_requests.get_name_leafdata());
    if (sent_unsolicited_sync_data.is_set || is_set(sent_unsolicited_sync_data.operation)) leaf_name_data.push_back(sent_unsolicited_sync_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-config")
    {
        received_config = value;
    }
    if(value_path == "received-config-sync-requests")
    {
        received_config_sync_requests = value;
    }
    if(value_path == "received-na-ks")
    {
        received_na_ks = value;
    }
    if(value_path == "received-solicited-sync-data")
    {
        received_solicited_sync_data = value;
    }
    if(value_path == "received-state")
    {
        received_state = value;
    }
    if(value_path == "received-state-sync-requests")
    {
        received_state_sync_requests = value;
    }
    if(value_path == "received-sync-requests")
    {
        received_sync_requests = value;
    }
    if(value_path == "received-unsolicited-sync-data")
    {
        received_unsolicited_sync_data = value;
    }
    if(value_path == "sent-config")
    {
        sent_config = value;
    }
    if(value_path == "sent-config-sync-requests")
    {
        sent_config_sync_requests = value;
    }
    if(value_path == "sent-na-ks")
    {
        sent_na_ks = value;
    }
    if(value_path == "sent-solicited-sync-data")
    {
        sent_solicited_sync_data = value;
    }
    if(value_path == "sent-state")
    {
        sent_state = value;
    }
    if(value_path == "sent-state-sync-requests")
    {
        sent_state_sync_requests = value;
    }
    if(value_path == "sent-sync-requests")
    {
        sent_sync_requests = value;
    }
    if(value_path == "sent-unsolicited-sync-data")
    {
        sent_unsolicited_sync_data = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::InvalidTlVs()
    :
    	incorrect_length{YType::uint32, "incorrect-length"},
	 invalid_data{YType::uint32, "invalid-data"},
	 invalid_type{YType::uint32, "invalid-type"},
	 unknown_bundle{YType::uint32, "unknown-bundle"},
	 unknown_port{YType::uint32, "unknown-port"}
{
    yang_name = "invalid-tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::~InvalidTlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::has_data() const
{
    return incorrect_length.is_set
	|| invalid_data.is_set
	|| invalid_type.is_set
	|| unknown_bundle.is_set
	|| unknown_port.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(incorrect_length.operation)
	|| is_set(invalid_data.operation)
	|| is_set(invalid_type.operation)
	|| is_set(unknown_bundle.operation)
	|| is_set(unknown_port.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid-tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incorrect_length.is_set || is_set(incorrect_length.operation)) leaf_name_data.push_back(incorrect_length.get_name_leafdata());
    if (invalid_data.is_set || is_set(invalid_data.operation)) leaf_name_data.push_back(invalid_data.get_name_leafdata());
    if (invalid_type.is_set || is_set(invalid_type.operation)) leaf_name_data.push_back(invalid_type.get_name_leafdata());
    if (unknown_bundle.is_set || is_set(unknown_bundle.operation)) leaf_name_data.push_back(unknown_bundle.get_name_leafdata());
    if (unknown_port.is_set || is_set(unknown_port.operation)) leaf_name_data.push_back(unknown_port.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incorrect-length")
    {
        incorrect_length = value;
    }
    if(value_path == "invalid-data")
    {
        invalid_data = value;
    }
    if(value_path == "invalid-type")
    {
        invalid_type = value;
    }
    if(value_path == "unknown-bundle")
    {
        unknown_bundle = value;
    }
    if(value_path == "unknown-port")
    {
        unknown_port = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::IccpMessages()
    :
    	received_messages{YType::uint32, "received-messages"},
	 sent_buffer_messages{YType::uint32, "sent-buffer-messages"},
	 sent_messages{YType::uint32, "sent-messages"},
	 transmission_errors{YType::uint32, "transmission-errors"}
{
    yang_name = "iccp-messages"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::~IccpMessages()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::has_data() const
{
    return received_messages.is_set
	|| sent_buffer_messages.is_set
	|| sent_messages.is_set
	|| transmission_errors.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::has_operation() const
{
    return is_set(operation)
	|| is_set(received_messages.operation)
	|| is_set(sent_buffer_messages.operation)
	|| is_set(sent_messages.operation)
	|| is_set(transmission_errors.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-messages";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_messages.is_set || is_set(received_messages.operation)) leaf_name_data.push_back(received_messages.get_name_leafdata());
    if (sent_buffer_messages.is_set || is_set(sent_buffer_messages.operation)) leaf_name_data.push_back(sent_buffer_messages.get_name_leafdata());
    if (sent_messages.is_set || is_set(sent_messages.operation)) leaf_name_data.push_back(sent_messages.get_name_leafdata());
    if (transmission_errors.is_set || is_set(transmission_errors.operation)) leaf_name_data.push_back(transmission_errors.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-messages")
    {
        received_messages = value;
    }
    if(value_path == "sent-buffer-messages")
    {
        sent_buffer_messages = value;
    }
    if(value_path == "sent-messages")
    {
        sent_messages = value;
    }
    if(value_path == "transmission-errors")
    {
        transmission_errors = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::IccpEvents()
    :
    	configured_clear{YType::uint32, "configured-clear"},
	 configured_set{YType::uint32, "configured-set"},
	 member_status_down{YType::uint32, "member-status-down"},
	 member_status_up{YType::uint32, "member-status-up"},
	 pe_isolated{YType::uint32, "pe-isolated"},
	 pe_isolated_clear{YType::uint32, "pe-isolated-clear"},
	 reachability_cleared{YType::uint32, "reachability-cleared"},
	 reachability_set{YType::uint32, "reachability-set"},
	 transport_down{YType::uint32, "transport-down"},
	 transport_unavailable{YType::uint32, "transport-unavailable"},
	 transport_up{YType::uint32, "transport-up"}
{
    yang_name = "iccp-events"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::~IccpEvents()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::has_data() const
{
    return configured_clear.is_set
	|| configured_set.is_set
	|| member_status_down.is_set
	|| member_status_up.is_set
	|| pe_isolated.is_set
	|| pe_isolated_clear.is_set
	|| reachability_cleared.is_set
	|| reachability_set.is_set
	|| transport_down.is_set
	|| transport_unavailable.is_set
	|| transport_up.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_clear.operation)
	|| is_set(configured_set.operation)
	|| is_set(member_status_down.operation)
	|| is_set(member_status_up.operation)
	|| is_set(pe_isolated.operation)
	|| is_set(pe_isolated_clear.operation)
	|| is_set(reachability_cleared.operation)
	|| is_set(reachability_set.operation)
	|| is_set(transport_down.operation)
	|| is_set(transport_unavailable.operation)
	|| is_set(transport_up.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-events";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_clear.is_set || is_set(configured_clear.operation)) leaf_name_data.push_back(configured_clear.get_name_leafdata());
    if (configured_set.is_set || is_set(configured_set.operation)) leaf_name_data.push_back(configured_set.get_name_leafdata());
    if (member_status_down.is_set || is_set(member_status_down.operation)) leaf_name_data.push_back(member_status_down.get_name_leafdata());
    if (member_status_up.is_set || is_set(member_status_up.operation)) leaf_name_data.push_back(member_status_up.get_name_leafdata());
    if (pe_isolated.is_set || is_set(pe_isolated.operation)) leaf_name_data.push_back(pe_isolated.get_name_leafdata());
    if (pe_isolated_clear.is_set || is_set(pe_isolated_clear.operation)) leaf_name_data.push_back(pe_isolated_clear.get_name_leafdata());
    if (reachability_cleared.is_set || is_set(reachability_cleared.operation)) leaf_name_data.push_back(reachability_cleared.get_name_leafdata());
    if (reachability_set.is_set || is_set(reachability_set.operation)) leaf_name_data.push_back(reachability_set.get_name_leafdata());
    if (transport_down.is_set || is_set(transport_down.operation)) leaf_name_data.push_back(transport_down.get_name_leafdata());
    if (transport_unavailable.is_set || is_set(transport_unavailable.operation)) leaf_name_data.push_back(transport_unavailable.get_name_leafdata());
    if (transport_up.is_set || is_set(transport_up.operation)) leaf_name_data.push_back(transport_up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-clear")
    {
        configured_clear = value;
    }
    if(value_path == "configured-set")
    {
        configured_set = value;
    }
    if(value_path == "member-status-down")
    {
        member_status_down = value;
    }
    if(value_path == "member-status-up")
    {
        member_status_up = value;
    }
    if(value_path == "pe-isolated")
    {
        pe_isolated = value;
    }
    if(value_path == "pe-isolated-clear")
    {
        pe_isolated_clear = value;
    }
    if(value_path == "reachability-cleared")
    {
        reachability_cleared = value;
    }
    if(value_path == "reachability-set")
    {
        reachability_set = value;
    }
    if(value_path == "transport-down")
    {
        transport_down = value;
    }
    if(value_path == "transport-unavailable")
    {
        transport_unavailable = value;
    }
    if(value_path == "transport-up")
    {
        transport_up = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpGroupCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    connection(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection>())
	,iccp_events(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents>())
	,iccp_messages(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages>())
	,invalid_tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs>())
	,tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs>())
{
    connection->parent = this;
    children["connection"] = connection.get();

    iccp_events->parent = this;
    children["iccp-events"] = iccp_events.get();

    iccp_messages->parent = this;
    children["iccp-messages"] = iccp_messages.get();

    invalid_tl_vs->parent = this;
    children["invalid-tl-vs"] = invalid_tl_vs.get();

    tl_vs->parent = this;
    children["tl-vs"] = tl_vs.get();

    yang_name = "iccp-group-counters"; yang_parent_name = "iccp-group-ancestor-node";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::~IccpGroupCounters()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| time_since_cleared.is_set
	|| (connection !=  nullptr && connection->has_data())
	|| (iccp_events !=  nullptr && iccp_events->has_data())
	|| (iccp_messages !=  nullptr && iccp_messages->has_data())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_data())
	|| (tl_vs !=  nullptr && tl_vs->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(time_since_cleared.operation)
	|| (connection !=  nullptr && connection->has_operation())
	|| (iccp_events !=  nullptr && iccp_events->has_operation())
	|| (iccp_messages !=  nullptr && iccp_messages->has_operation())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_operation())
	|| (tl_vs !=  nullptr && tl_vs->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connection")
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
        else
        {
            connection = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::Connection>();
            connection->parent = this;
            children["connection"] = connection.get();
        }
        return children.at("connection");
    }

    if(child_yang_name == "iccp-events")
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
        else
        {
            iccp_events = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpEvents>();
            iccp_events->parent = this;
            children["iccp-events"] = iccp_events.get();
        }
        return children.at("iccp-events");
    }

    if(child_yang_name == "iccp-messages")
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
        else
        {
            iccp_messages = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::IccpMessages>();
            iccp_messages->parent = this;
            children["iccp-messages"] = iccp_messages.get();
        }
        return children.at("iccp-messages");
    }

    if(child_yang_name == "invalid-tl-vs")
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        else
        {
            invalid_tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::InvalidTlVs>();
            invalid_tl_vs->parent = this;
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        return children.at("invalid-tl-vs");
    }

    if(child_yang_name == "tl-vs")
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
        else
        {
            tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::TlVs>();
            tl_vs->parent = this;
            children["tl-vs"] = tl_vs.get();
        }
        return children.at("tl-vs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::get_children()
{
    if(children.find("connection") == children.end())
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
    }

    if(children.find("iccp-events") == children.end())
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
    }

    if(children.find("iccp-messages") == children.end())
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
    }

    if(children.find("invalid-tl-vs") == children.end())
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
    }

    if(children.find("tl-vs") == children.end())
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupAncestorNode()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    iccp_group_counters(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters>())
{
    iccp_group_counters->parent = this;
    children["iccp-group-counters"] = iccp_group_counters.get();

    yang_name = "iccp-group-ancestor-node"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::~IccpGroupAncestorNode()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::has_data() const
{
    return iccp_group_id.is_set
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-ancestor-node";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-counters")
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        else
        {
            iccp_group_counters = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::IccpGroupCounters>();
            iccp_group_counters->parent = this;
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        return children.at("iccp-group-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::get_children()
{
    if(children.find("iccp-group-counters") == children.end())
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::Connection()
    :
    	iccp_config_connect_errors{YType::uint32, "iccp-config-connect-errors"},
	 iccp_count_connect_errors{YType::uint32, "iccp-count-connect-errors"},
	 iccp_invalid_connects{YType::uint32, "iccp-invalid-connects"},
	 iccp_invalid_disconnects{YType::uint32, "iccp-invalid-disconnects"},
	 received_connects{YType::uint32, "received-connects"},
	 received_disconnects{YType::uint32, "received-disconnects"},
	 received_wrong_versions{YType::uint32, "received-wrong-versions"},
	 sent_connects{YType::uint32, "sent-connects"},
	 sent_disconnects{YType::uint32, "sent-disconnects"},
	 sent_wrong_versions{YType::uint32, "sent-wrong-versions"}
{
    yang_name = "connection"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::~Connection()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::has_data() const
{
    return iccp_config_connect_errors.is_set
	|| iccp_count_connect_errors.is_set
	|| iccp_invalid_connects.is_set
	|| iccp_invalid_disconnects.is_set
	|| received_connects.is_set
	|| received_disconnects.is_set
	|| received_wrong_versions.is_set
	|| sent_connects.is_set
	|| sent_disconnects.is_set
	|| sent_wrong_versions.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_config_connect_errors.operation)
	|| is_set(iccp_count_connect_errors.operation)
	|| is_set(iccp_invalid_connects.operation)
	|| is_set(iccp_invalid_disconnects.operation)
	|| is_set(received_connects.operation)
	|| is_set(received_disconnects.operation)
	|| is_set(received_wrong_versions.operation)
	|| is_set(sent_connects.operation)
	|| is_set(sent_disconnects.operation)
	|| is_set(sent_wrong_versions.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "connection";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_config_connect_errors.is_set || is_set(iccp_config_connect_errors.operation)) leaf_name_data.push_back(iccp_config_connect_errors.get_name_leafdata());
    if (iccp_count_connect_errors.is_set || is_set(iccp_count_connect_errors.operation)) leaf_name_data.push_back(iccp_count_connect_errors.get_name_leafdata());
    if (iccp_invalid_connects.is_set || is_set(iccp_invalid_connects.operation)) leaf_name_data.push_back(iccp_invalid_connects.get_name_leafdata());
    if (iccp_invalid_disconnects.is_set || is_set(iccp_invalid_disconnects.operation)) leaf_name_data.push_back(iccp_invalid_disconnects.get_name_leafdata());
    if (received_connects.is_set || is_set(received_connects.operation)) leaf_name_data.push_back(received_connects.get_name_leafdata());
    if (received_disconnects.is_set || is_set(received_disconnects.operation)) leaf_name_data.push_back(received_disconnects.get_name_leafdata());
    if (received_wrong_versions.is_set || is_set(received_wrong_versions.operation)) leaf_name_data.push_back(received_wrong_versions.get_name_leafdata());
    if (sent_connects.is_set || is_set(sent_connects.operation)) leaf_name_data.push_back(sent_connects.get_name_leafdata());
    if (sent_disconnects.is_set || is_set(sent_disconnects.operation)) leaf_name_data.push_back(sent_disconnects.get_name_leafdata());
    if (sent_wrong_versions.is_set || is_set(sent_wrong_versions.operation)) leaf_name_data.push_back(sent_wrong_versions.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-config-connect-errors")
    {
        iccp_config_connect_errors = value;
    }
    if(value_path == "iccp-count-connect-errors")
    {
        iccp_count_connect_errors = value;
    }
    if(value_path == "iccp-invalid-connects")
    {
        iccp_invalid_connects = value;
    }
    if(value_path == "iccp-invalid-disconnects")
    {
        iccp_invalid_disconnects = value;
    }
    if(value_path == "received-connects")
    {
        received_connects = value;
    }
    if(value_path == "received-disconnects")
    {
        received_disconnects = value;
    }
    if(value_path == "received-wrong-versions")
    {
        received_wrong_versions = value;
    }
    if(value_path == "sent-connects")
    {
        sent_connects = value;
    }
    if(value_path == "sent-disconnects")
    {
        sent_disconnects = value;
    }
    if(value_path == "sent-wrong-versions")
    {
        sent_wrong_versions = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::TlVs()
    :
    	received_config{YType::uint32, "received-config"},
	 received_config_sync_requests{YType::uint32, "received-config-sync-requests"},
	 received_na_ks{YType::uint32, "received-na-ks"},
	 received_solicited_sync_data{YType::uint32, "received-solicited-sync-data"},
	 received_state{YType::uint32, "received-state"},
	 received_state_sync_requests{YType::uint32, "received-state-sync-requests"},
	 received_sync_requests{YType::uint32, "received-sync-requests"},
	 received_unsolicited_sync_data{YType::uint32, "received-unsolicited-sync-data"},
	 sent_config{YType::uint32, "sent-config"},
	 sent_config_sync_requests{YType::uint32, "sent-config-sync-requests"},
	 sent_na_ks{YType::uint32, "sent-na-ks"},
	 sent_solicited_sync_data{YType::uint32, "sent-solicited-sync-data"},
	 sent_state{YType::uint32, "sent-state"},
	 sent_state_sync_requests{YType::uint32, "sent-state-sync-requests"},
	 sent_sync_requests{YType::uint32, "sent-sync-requests"},
	 sent_unsolicited_sync_data{YType::uint32, "sent-unsolicited-sync-data"}
{
    yang_name = "tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::~TlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::has_data() const
{
    return received_config.is_set
	|| received_config_sync_requests.is_set
	|| received_na_ks.is_set
	|| received_solicited_sync_data.is_set
	|| received_state.is_set
	|| received_state_sync_requests.is_set
	|| received_sync_requests.is_set
	|| received_unsolicited_sync_data.is_set
	|| sent_config.is_set
	|| sent_config_sync_requests.is_set
	|| sent_na_ks.is_set
	|| sent_solicited_sync_data.is_set
	|| sent_state.is_set
	|| sent_state_sync_requests.is_set
	|| sent_sync_requests.is_set
	|| sent_unsolicited_sync_data.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(received_config.operation)
	|| is_set(received_config_sync_requests.operation)
	|| is_set(received_na_ks.operation)
	|| is_set(received_solicited_sync_data.operation)
	|| is_set(received_state.operation)
	|| is_set(received_state_sync_requests.operation)
	|| is_set(received_sync_requests.operation)
	|| is_set(received_unsolicited_sync_data.operation)
	|| is_set(sent_config.operation)
	|| is_set(sent_config_sync_requests.operation)
	|| is_set(sent_na_ks.operation)
	|| is_set(sent_solicited_sync_data.operation)
	|| is_set(sent_state.operation)
	|| is_set(sent_state_sync_requests.operation)
	|| is_set(sent_sync_requests.operation)
	|| is_set(sent_unsolicited_sync_data.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_config.is_set || is_set(received_config.operation)) leaf_name_data.push_back(received_config.get_name_leafdata());
    if (received_config_sync_requests.is_set || is_set(received_config_sync_requests.operation)) leaf_name_data.push_back(received_config_sync_requests.get_name_leafdata());
    if (received_na_ks.is_set || is_set(received_na_ks.operation)) leaf_name_data.push_back(received_na_ks.get_name_leafdata());
    if (received_solicited_sync_data.is_set || is_set(received_solicited_sync_data.operation)) leaf_name_data.push_back(received_solicited_sync_data.get_name_leafdata());
    if (received_state.is_set || is_set(received_state.operation)) leaf_name_data.push_back(received_state.get_name_leafdata());
    if (received_state_sync_requests.is_set || is_set(received_state_sync_requests.operation)) leaf_name_data.push_back(received_state_sync_requests.get_name_leafdata());
    if (received_sync_requests.is_set || is_set(received_sync_requests.operation)) leaf_name_data.push_back(received_sync_requests.get_name_leafdata());
    if (received_unsolicited_sync_data.is_set || is_set(received_unsolicited_sync_data.operation)) leaf_name_data.push_back(received_unsolicited_sync_data.get_name_leafdata());
    if (sent_config.is_set || is_set(sent_config.operation)) leaf_name_data.push_back(sent_config.get_name_leafdata());
    if (sent_config_sync_requests.is_set || is_set(sent_config_sync_requests.operation)) leaf_name_data.push_back(sent_config_sync_requests.get_name_leafdata());
    if (sent_na_ks.is_set || is_set(sent_na_ks.operation)) leaf_name_data.push_back(sent_na_ks.get_name_leafdata());
    if (sent_solicited_sync_data.is_set || is_set(sent_solicited_sync_data.operation)) leaf_name_data.push_back(sent_solicited_sync_data.get_name_leafdata());
    if (sent_state.is_set || is_set(sent_state.operation)) leaf_name_data.push_back(sent_state.get_name_leafdata());
    if (sent_state_sync_requests.is_set || is_set(sent_state_sync_requests.operation)) leaf_name_data.push_back(sent_state_sync_requests.get_name_leafdata());
    if (sent_sync_requests.is_set || is_set(sent_sync_requests.operation)) leaf_name_data.push_back(sent_sync_requests.get_name_leafdata());
    if (sent_unsolicited_sync_data.is_set || is_set(sent_unsolicited_sync_data.operation)) leaf_name_data.push_back(sent_unsolicited_sync_data.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-config")
    {
        received_config = value;
    }
    if(value_path == "received-config-sync-requests")
    {
        received_config_sync_requests = value;
    }
    if(value_path == "received-na-ks")
    {
        received_na_ks = value;
    }
    if(value_path == "received-solicited-sync-data")
    {
        received_solicited_sync_data = value;
    }
    if(value_path == "received-state")
    {
        received_state = value;
    }
    if(value_path == "received-state-sync-requests")
    {
        received_state_sync_requests = value;
    }
    if(value_path == "received-sync-requests")
    {
        received_sync_requests = value;
    }
    if(value_path == "received-unsolicited-sync-data")
    {
        received_unsolicited_sync_data = value;
    }
    if(value_path == "sent-config")
    {
        sent_config = value;
    }
    if(value_path == "sent-config-sync-requests")
    {
        sent_config_sync_requests = value;
    }
    if(value_path == "sent-na-ks")
    {
        sent_na_ks = value;
    }
    if(value_path == "sent-solicited-sync-data")
    {
        sent_solicited_sync_data = value;
    }
    if(value_path == "sent-state")
    {
        sent_state = value;
    }
    if(value_path == "sent-state-sync-requests")
    {
        sent_state_sync_requests = value;
    }
    if(value_path == "sent-sync-requests")
    {
        sent_sync_requests = value;
    }
    if(value_path == "sent-unsolicited-sync-data")
    {
        sent_unsolicited_sync_data = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::InvalidTlVs()
    :
    	incorrect_length{YType::uint32, "incorrect-length"},
	 invalid_data{YType::uint32, "invalid-data"},
	 invalid_type{YType::uint32, "invalid-type"},
	 unknown_bundle{YType::uint32, "unknown-bundle"},
	 unknown_port{YType::uint32, "unknown-port"}
{
    yang_name = "invalid-tl-vs"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::~InvalidTlVs()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::has_data() const
{
    return incorrect_length.is_set
	|| invalid_data.is_set
	|| invalid_type.is_set
	|| unknown_bundle.is_set
	|| unknown_port.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::has_operation() const
{
    return is_set(operation)
	|| is_set(incorrect_length.operation)
	|| is_set(invalid_data.operation)
	|| is_set(invalid_type.operation)
	|| is_set(unknown_bundle.operation)
	|| is_set(unknown_port.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalid-tl-vs";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incorrect_length.is_set || is_set(incorrect_length.operation)) leaf_name_data.push_back(incorrect_length.get_name_leafdata());
    if (invalid_data.is_set || is_set(invalid_data.operation)) leaf_name_data.push_back(invalid_data.get_name_leafdata());
    if (invalid_type.is_set || is_set(invalid_type.operation)) leaf_name_data.push_back(invalid_type.get_name_leafdata());
    if (unknown_bundle.is_set || is_set(unknown_bundle.operation)) leaf_name_data.push_back(unknown_bundle.get_name_leafdata());
    if (unknown_port.is_set || is_set(unknown_port.operation)) leaf_name_data.push_back(unknown_port.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incorrect-length")
    {
        incorrect_length = value;
    }
    if(value_path == "invalid-data")
    {
        invalid_data = value;
    }
    if(value_path == "invalid-type")
    {
        invalid_type = value;
    }
    if(value_path == "unknown-bundle")
    {
        unknown_bundle = value;
    }
    if(value_path == "unknown-port")
    {
        unknown_port = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::IccpMessages()
    :
    	received_messages{YType::uint32, "received-messages"},
	 sent_buffer_messages{YType::uint32, "sent-buffer-messages"},
	 sent_messages{YType::uint32, "sent-messages"},
	 transmission_errors{YType::uint32, "transmission-errors"}
{
    yang_name = "iccp-messages"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::~IccpMessages()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::has_data() const
{
    return received_messages.is_set
	|| sent_buffer_messages.is_set
	|| sent_messages.is_set
	|| transmission_errors.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::has_operation() const
{
    return is_set(operation)
	|| is_set(received_messages.operation)
	|| is_set(sent_buffer_messages.operation)
	|| is_set(sent_messages.operation)
	|| is_set(transmission_errors.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-messages";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (received_messages.is_set || is_set(received_messages.operation)) leaf_name_data.push_back(received_messages.get_name_leafdata());
    if (sent_buffer_messages.is_set || is_set(sent_buffer_messages.operation)) leaf_name_data.push_back(sent_buffer_messages.get_name_leafdata());
    if (sent_messages.is_set || is_set(sent_messages.operation)) leaf_name_data.push_back(sent_messages.get_name_leafdata());
    if (transmission_errors.is_set || is_set(transmission_errors.operation)) leaf_name_data.push_back(transmission_errors.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "received-messages")
    {
        received_messages = value;
    }
    if(value_path == "sent-buffer-messages")
    {
        sent_buffer_messages = value;
    }
    if(value_path == "sent-messages")
    {
        sent_messages = value;
    }
    if(value_path == "transmission-errors")
    {
        transmission_errors = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::IccpEvents()
    :
    	configured_clear{YType::uint32, "configured-clear"},
	 configured_set{YType::uint32, "configured-set"},
	 member_status_down{YType::uint32, "member-status-down"},
	 member_status_up{YType::uint32, "member-status-up"},
	 pe_isolated{YType::uint32, "pe-isolated"},
	 pe_isolated_clear{YType::uint32, "pe-isolated-clear"},
	 reachability_cleared{YType::uint32, "reachability-cleared"},
	 reachability_set{YType::uint32, "reachability-set"},
	 transport_down{YType::uint32, "transport-down"},
	 transport_unavailable{YType::uint32, "transport-unavailable"},
	 transport_up{YType::uint32, "transport-up"}
{
    yang_name = "iccp-events"; yang_parent_name = "iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::~IccpEvents()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::has_data() const
{
    return configured_clear.is_set
	|| configured_set.is_set
	|| member_status_down.is_set
	|| member_status_up.is_set
	|| pe_isolated.is_set
	|| pe_isolated_clear.is_set
	|| reachability_cleared.is_set
	|| reachability_set.is_set
	|| transport_down.is_set
	|| transport_unavailable.is_set
	|| transport_up.is_set;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::has_operation() const
{
    return is_set(operation)
	|| is_set(configured_clear.operation)
	|| is_set(configured_set.operation)
	|| is_set(member_status_down.operation)
	|| is_set(member_status_up.operation)
	|| is_set(pe_isolated.operation)
	|| is_set(pe_isolated_clear.operation)
	|| is_set(reachability_cleared.operation)
	|| is_set(reachability_set.operation)
	|| is_set(transport_down.operation)
	|| is_set(transport_unavailable.operation)
	|| is_set(transport_up.operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-events";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (configured_clear.is_set || is_set(configured_clear.operation)) leaf_name_data.push_back(configured_clear.get_name_leafdata());
    if (configured_set.is_set || is_set(configured_set.operation)) leaf_name_data.push_back(configured_set.get_name_leafdata());
    if (member_status_down.is_set || is_set(member_status_down.operation)) leaf_name_data.push_back(member_status_down.get_name_leafdata());
    if (member_status_up.is_set || is_set(member_status_up.operation)) leaf_name_data.push_back(member_status_up.get_name_leafdata());
    if (pe_isolated.is_set || is_set(pe_isolated.operation)) leaf_name_data.push_back(pe_isolated.get_name_leafdata());
    if (pe_isolated_clear.is_set || is_set(pe_isolated_clear.operation)) leaf_name_data.push_back(pe_isolated_clear.get_name_leafdata());
    if (reachability_cleared.is_set || is_set(reachability_cleared.operation)) leaf_name_data.push_back(reachability_cleared.get_name_leafdata());
    if (reachability_set.is_set || is_set(reachability_set.operation)) leaf_name_data.push_back(reachability_set.get_name_leafdata());
    if (transport_down.is_set || is_set(transport_down.operation)) leaf_name_data.push_back(transport_down.get_name_leafdata());
    if (transport_unavailable.is_set || is_set(transport_unavailable.operation)) leaf_name_data.push_back(transport_unavailable.get_name_leafdata());
    if (transport_up.is_set || is_set(transport_up.operation)) leaf_name_data.push_back(transport_up.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::get_children()
{
    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "configured-clear")
    {
        configured_clear = value;
    }
    if(value_path == "configured-set")
    {
        configured_set = value;
    }
    if(value_path == "member-status-down")
    {
        member_status_down = value;
    }
    if(value_path == "member-status-up")
    {
        member_status_up = value;
    }
    if(value_path == "pe-isolated")
    {
        pe_isolated = value;
    }
    if(value_path == "pe-isolated-clear")
    {
        pe_isolated_clear = value;
    }
    if(value_path == "reachability-cleared")
    {
        reachability_cleared = value;
    }
    if(value_path == "reachability-set")
    {
        reachability_set = value;
    }
    if(value_path == "transport-down")
    {
        transport_down = value;
    }
    if(value_path == "transport-unavailable")
    {
        transport_unavailable = value;
    }
    if(value_path == "transport-up")
    {
        transport_up = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpGroupCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    connection(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection>())
	,iccp_events(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents>())
	,iccp_messages(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages>())
	,invalid_tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs>())
	,tl_vs(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs>())
{
    connection->parent = this;
    children["connection"] = connection.get();

    iccp_events->parent = this;
    children["iccp-events"] = iccp_events.get();

    iccp_messages->parent = this;
    children["iccp-messages"] = iccp_messages.get();

    invalid_tl_vs->parent = this;
    children["invalid-tl-vs"] = invalid_tl_vs.get();

    tl_vs->parent = this;
    children["tl-vs"] = tl_vs.get();

    yang_name = "iccp-group-counters"; yang_parent_name = "iccp-group-item";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::~IccpGroupCounters()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| time_since_cleared.is_set
	|| (connection !=  nullptr && connection->has_data())
	|| (iccp_events !=  nullptr && iccp_events->has_data())
	|| (iccp_messages !=  nullptr && iccp_messages->has_data())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_data())
	|| (tl_vs !=  nullptr && tl_vs->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(time_since_cleared.operation)
	|| (connection !=  nullptr && connection->has_operation())
	|| (iccp_events !=  nullptr && iccp_events->has_operation())
	|| (iccp_messages !=  nullptr && iccp_messages->has_operation())
	|| (invalid_tl_vs !=  nullptr && invalid_tl_vs->has_operation())
	|| (tl_vs !=  nullptr && tl_vs->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "connection")
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
        else
        {
            connection = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::Connection>();
            connection->parent = this;
            children["connection"] = connection.get();
        }
        return children.at("connection");
    }

    if(child_yang_name == "iccp-events")
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
        else
        {
            iccp_events = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpEvents>();
            iccp_events->parent = this;
            children["iccp-events"] = iccp_events.get();
        }
        return children.at("iccp-events");
    }

    if(child_yang_name == "iccp-messages")
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
        else
        {
            iccp_messages = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::IccpMessages>();
            iccp_messages->parent = this;
            children["iccp-messages"] = iccp_messages.get();
        }
        return children.at("iccp-messages");
    }

    if(child_yang_name == "invalid-tl-vs")
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        else
        {
            invalid_tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::InvalidTlVs>();
            invalid_tl_vs->parent = this;
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
        return children.at("invalid-tl-vs");
    }

    if(child_yang_name == "tl-vs")
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
        else
        {
            tl_vs = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::TlVs>();
            tl_vs->parent = this;
            children["tl-vs"] = tl_vs.get();
        }
        return children.at("tl-vs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::get_children()
{
    if(children.find("connection") == children.end())
    {
        if(connection != nullptr)
        {
            children["connection"] = connection.get();
        }
    }

    if(children.find("iccp-events") == children.end())
    {
        if(iccp_events != nullptr)
        {
            children["iccp-events"] = iccp_events.get();
        }
    }

    if(children.find("iccp-messages") == children.end())
    {
        if(iccp_messages != nullptr)
        {
            children["iccp-messages"] = iccp_messages.get();
        }
    }

    if(children.find("invalid-tl-vs") == children.end())
    {
        if(invalid_tl_vs != nullptr)
        {
            children["invalid-tl-vs"] = invalid_tl_vs.get();
        }
    }

    if(children.find("tl-vs") == children.end())
    {
        if(tl_vs != nullptr)
        {
            children["tl-vs"] = tl_vs.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupItem()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    iccp_group_counters(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters>())
{
    iccp_group_counters->parent = this;
    children["iccp-group-counters"] = iccp_group_counters.get();

    yang_name = "iccp-group-item"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::~IccpGroupItem()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::has_data() const
{
    return iccp_group_id.is_set
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| (iccp_group_counters !=  nullptr && iccp_group_counters->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-counters")
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        else
        {
            iccp_group_counters = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupCounters>();
            iccp_group_counters->parent = this;
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
        return children.at("iccp-group-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::get_children()
{
    if(children.find("iccp-group-counters") == children.end())
    {
        if(iccp_group_counters != nullptr)
        {
            children["iccp-group-counters"] = iccp_group_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    iccp_group_ancestor_bundle(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle>())
	,iccp_group_ancestor_member(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember>())
	,iccp_group_ancestor_node(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode>())
	,iccp_group_item(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem>())
{
    iccp_group_ancestor_bundle->parent = this;
    children["iccp-group-ancestor-bundle"] = iccp_group_ancestor_bundle.get();

    iccp_group_ancestor_member->parent = this;
    children["iccp-group-ancestor-member"] = iccp_group_ancestor_member.get();

    iccp_group_ancestor_node->parent = this;
    children["iccp-group-ancestor-node"] = iccp_group_ancestor_node.get();

    iccp_group_item->parent = this;
    children["iccp-group-item"] = iccp_group_item.get();

    yang_name = "iccp-group"; yang_parent_name = "iccp-groups";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::~IccpGroup()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (iccp_group_ancestor_bundle !=  nullptr && iccp_group_ancestor_bundle->has_data())
	|| (iccp_group_ancestor_member !=  nullptr && iccp_group_ancestor_member->has_data())
	|| (iccp_group_ancestor_node !=  nullptr && iccp_group_ancestor_node->has_data())
	|| (iccp_group_item !=  nullptr && iccp_group_item->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (iccp_group_ancestor_bundle !=  nullptr && iccp_group_ancestor_bundle->has_operation())
	|| (iccp_group_ancestor_member !=  nullptr && iccp_group_ancestor_member->has_operation())
	|| (iccp_group_ancestor_node !=  nullptr && iccp_group_ancestor_node->has_operation())
	|| (iccp_group_item !=  nullptr && iccp_group_item->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-iccp-group-counters/iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-ancestor-bundle")
    {
        if(iccp_group_ancestor_bundle != nullptr)
        {
            children["iccp-group-ancestor-bundle"] = iccp_group_ancestor_bundle.get();
        }
        else
        {
            iccp_group_ancestor_bundle = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorBundle>();
            iccp_group_ancestor_bundle->parent = this;
            children["iccp-group-ancestor-bundle"] = iccp_group_ancestor_bundle.get();
        }
        return children.at("iccp-group-ancestor-bundle");
    }

    if(child_yang_name == "iccp-group-ancestor-member")
    {
        if(iccp_group_ancestor_member != nullptr)
        {
            children["iccp-group-ancestor-member"] = iccp_group_ancestor_member.get();
        }
        else
        {
            iccp_group_ancestor_member = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorMember>();
            iccp_group_ancestor_member->parent = this;
            children["iccp-group-ancestor-member"] = iccp_group_ancestor_member.get();
        }
        return children.at("iccp-group-ancestor-member");
    }

    if(child_yang_name == "iccp-group-ancestor-node")
    {
        if(iccp_group_ancestor_node != nullptr)
        {
            children["iccp-group-ancestor-node"] = iccp_group_ancestor_node.get();
        }
        else
        {
            iccp_group_ancestor_node = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupAncestorNode>();
            iccp_group_ancestor_node->parent = this;
            children["iccp-group-ancestor-node"] = iccp_group_ancestor_node.get();
        }
        return children.at("iccp-group-ancestor-node");
    }

    if(child_yang_name == "iccp-group-item")
    {
        if(iccp_group_item != nullptr)
        {
            children["iccp-group-item"] = iccp_group_item.get();
        }
        else
        {
            iccp_group_item = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::IccpGroupItem>();
            iccp_group_item->parent = this;
            children["iccp-group-item"] = iccp_group_item.get();
        }
        return children.at("iccp-group-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::get_children()
{
    if(children.find("iccp-group-ancestor-bundle") == children.end())
    {
        if(iccp_group_ancestor_bundle != nullptr)
        {
            children["iccp-group-ancestor-bundle"] = iccp_group_ancestor_bundle.get();
        }
    }

    if(children.find("iccp-group-ancestor-member") == children.end())
    {
        if(iccp_group_ancestor_member != nullptr)
        {
            children["iccp-group-ancestor-member"] = iccp_group_ancestor_member.get();
        }
    }

    if(children.find("iccp-group-ancestor-node") == children.end())
    {
        if(iccp_group_ancestor_node != nullptr)
        {
            children["iccp-group-ancestor-node"] = iccp_group_ancestor_node.get();
        }
    }

    if(children.find("iccp-group-item") == children.end())
    {
        if(iccp_group_item != nullptr)
        {
            children["iccp-group-item"] = iccp_group_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroups()
{
    yang_name = "iccp-groups"; yang_parent_name = "mlacp-iccp-group-counters";
}

BundleInformation::MlacpIccpGroupCounters::IccpGroups::~IccpGroups()
{
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::has_data() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpIccpGroupCounters::IccpGroups::has_operation() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpIccpGroupCounters::IccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::IccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-iccp-group-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::IccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group")
    {
        for(auto const & c : iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups::IccpGroup>();
        c->parent = this;
        iccp_group.push_back(std::move(c));
        children[segment_path] = iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::IccpGroups::get_children()
{
    for (auto const & c : iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::IccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpIccpGroupCounters::MlacpIccpGroupCounters()
    :
    iccp_groups(std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups>())
{
    iccp_groups->parent = this;
    children["iccp-groups"] = iccp_groups.get();

    yang_name = "mlacp-iccp-group-counters"; yang_parent_name = "bundle-information";
}

BundleInformation::MlacpIccpGroupCounters::~MlacpIccpGroupCounters()
{
}

bool BundleInformation::MlacpIccpGroupCounters::has_data() const
{
    return (iccp_groups !=  nullptr && iccp_groups->has_data());
}

bool BundleInformation::MlacpIccpGroupCounters::has_operation() const
{
    return is_set(operation)
	|| (iccp_groups !=  nullptr && iccp_groups->has_operation());
}

std::string BundleInformation::MlacpIccpGroupCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-iccp-group-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpIccpGroupCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpIccpGroupCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-groups")
    {
        if(iccp_groups != nullptr)
        {
            children["iccp-groups"] = iccp_groups.get();
        }
        else
        {
            iccp_groups = std::make_unique<BundleInformation::MlacpIccpGroupCounters::IccpGroups>();
            iccp_groups->parent = this;
            children["iccp-groups"] = iccp_groups.get();
        }
        return children.at("iccp-groups");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpIccpGroupCounters::get_children()
{
    if(children.find("iccp-groups") == children.end())
    {
        if(iccp_groups != nullptr)
        {
            children["iccp-groups"] = iccp_groups.get();
        }
    }

    return children;
}

void BundleInformation::MlacpIccpGroupCounters::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/system-id/system-id-global/system-id-global-item/system-id/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemId_()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "system-id-global-item";
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::~SystemId_()
{
}

bool BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/system-id/system-id-global/system-id-global-item/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemIdGlobalItem()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 system_mac_address{YType::str, "system-mac-address"},
	 system_priority{YType::uint16, "system-priority"}
    	,
    system_id(std::make_unique<BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "system-id-global-item"; yang_parent_name = "system-id-global";
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::~SystemIdGlobalItem()
{
}

bool BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::has_data() const
{
    return iccp_group_id.is_set
	|| system_mac_address.is_set
	|| system_priority.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(system_mac_address.operation)
	|| is_set(system_priority.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id-global-item";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/system-id/system-id-global/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (system_mac_address.is_set || is_set(system_mac_address.operation)) leaf_name_data.push_back(system_mac_address.get_name_leafdata());
    if (system_priority.is_set || is_set(system_priority.operation)) leaf_name_data.push_back(system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::SystemId_>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "system-mac-address")
    {
        system_mac_address = value;
    }
    if(value_path == "system-priority")
    {
        system_priority = value;
    }
}

BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobal()
    :
    system_id_global_item(std::make_unique<BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem>())
{
    system_id_global_item->parent = this;
    children["system-id-global-item"] = system_id_global_item.get();

    yang_name = "system-id-global"; yang_parent_name = "system-id";
}

BundleInformation::SystemId::SystemIdGlobal::~SystemIdGlobal()
{
}

bool BundleInformation::SystemId::SystemIdGlobal::has_data() const
{
    return (system_id_global_item !=  nullptr && system_id_global_item->has_data());
}

bool BundleInformation::SystemId::SystemIdGlobal::has_operation() const
{
    return is_set(operation)
	|| (system_id_global_item !=  nullptr && system_id_global_item->has_operation());
}

std::string BundleInformation::SystemId::SystemIdGlobal::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id-global";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdGlobal::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/system-id/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdGlobal::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id-global-item")
    {
        if(system_id_global_item != nullptr)
        {
            children["system-id-global-item"] = system_id_global_item.get();
        }
        else
        {
            system_id_global_item = std::make_unique<BundleInformation::SystemId::SystemIdGlobal::SystemIdGlobalItem>();
            system_id_global_item->parent = this;
            children["system-id-global-item"] = system_id_global_item.get();
        }
        return children.at("system-id-global-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdGlobal::get_children()
{
    if(children.find("system-id-global-item") == children.end())
    {
        if(system_id_global_item != nullptr)
        {
            children["system-id-global-item"] = system_id_global_item.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdGlobal::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::~SystemMacAddr()
{
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::get_children()
{
    return children;
}

void BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemId_()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "system-id-iccp-group-item";
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::~SystemId_()
{
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemIdIccpGroupItem()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 system_mac_address{YType::str, "system-mac-address"},
	 system_priority{YType::uint16, "system-priority"}
    	,
    system_id(std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "system-id-iccp-group-item"; yang_parent_name = "system-id-iccp-group";
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::~SystemIdIccpGroupItem()
{
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::has_data() const
{
    return iccp_group_id.is_set
	|| system_mac_address.is_set
	|| system_priority.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(system_mac_address.operation)
	|| is_set(system_priority.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id-iccp-group-item";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (system_mac_address.is_set || is_set(system_mac_address.operation)) leaf_name_data.push_back(system_mac_address.get_name_leafdata());
    if (system_priority.is_set || is_set(system_priority.operation)) leaf_name_data.push_back(system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::SystemId_>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "system-mac-address")
    {
        system_mac_address = value;
    }
    if(value_path == "system-priority")
    {
        system_priority = value;
    }
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    system_id_iccp_group_item(std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem>())
{
    system_id_iccp_group_item->parent = this;
    children["system-id-iccp-group-item"] = system_id_iccp_group_item.get();

    yang_name = "system-id-iccp-group"; yang_parent_name = "system-id-iccp-groups";
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::~SystemIdIccpGroup()
{
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (system_id_iccp_group_item !=  nullptr && system_id_iccp_group_item->has_data());
}

bool BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (system_id_iccp_group_item !=  nullptr && system_id_iccp_group_item->has_operation());
}

std::string BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id-iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/system-id/system-id-iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id-iccp-group-item")
    {
        if(system_id_iccp_group_item != nullptr)
        {
            children["system-id-iccp-group-item"] = system_id_iccp_group_item.get();
        }
        else
        {
            system_id_iccp_group_item = std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::SystemIdIccpGroupItem>();
            system_id_iccp_group_item->parent = this;
            children["system-id-iccp-group-item"] = system_id_iccp_group_item.get();
        }
        return children.at("system-id-iccp-group-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::get_children()
{
    if(children.find("system-id-iccp-group-item") == children.end())
    {
        if(system_id_iccp_group_item != nullptr)
        {
            children["system-id-iccp-group-item"] = system_id_iccp_group_item.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroups()
{
    yang_name = "system-id-iccp-groups"; yang_parent_name = "system-id";
}

BundleInformation::SystemId::SystemIdIccpGroups::~SystemIdIccpGroups()
{
}

bool BundleInformation::SystemId::SystemIdIccpGroups::has_data() const
{
    for (std::size_t index=0; index<system_id_iccp_group.size(); index++)
    {
        if(system_id_iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::SystemId::SystemIdIccpGroups::has_operation() const
{
    for (std::size_t index=0; index<system_id_iccp_group.size(); index++)
    {
        if(system_id_iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::SystemId::SystemIdIccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id-iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::SystemIdIccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/system-id/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::SystemIdIccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id-iccp-group")
    {
        for(auto const & c : system_id_iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups::SystemIdIccpGroup>();
        c->parent = this;
        system_id_iccp_group.push_back(std::move(c));
        children[segment_path] = system_id_iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::SystemIdIccpGroups::get_children()
{
    for (auto const & c : system_id_iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::SystemIdIccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::SystemId::SystemId()
    :
    system_id_global(std::make_unique<BundleInformation::SystemId::SystemIdGlobal>())
	,system_id_iccp_groups(std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups>())
{
    system_id_global->parent = this;
    children["system-id-global"] = system_id_global.get();

    system_id_iccp_groups->parent = this;
    children["system-id-iccp-groups"] = system_id_iccp_groups.get();

    yang_name = "system-id"; yang_parent_name = "bundle-information";
}

BundleInformation::SystemId::~SystemId()
{
}

bool BundleInformation::SystemId::has_data() const
{
    return (system_id_global !=  nullptr && system_id_global->has_data())
	|| (system_id_iccp_groups !=  nullptr && system_id_iccp_groups->has_data());
}

bool BundleInformation::SystemId::has_operation() const
{
    return is_set(operation)
	|| (system_id_global !=  nullptr && system_id_global->has_operation())
	|| (system_id_iccp_groups !=  nullptr && system_id_iccp_groups->has_operation());
}

std::string BundleInformation::SystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath BundleInformation::SystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::SystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id-global")
    {
        if(system_id_global != nullptr)
        {
            children["system-id-global"] = system_id_global.get();
        }
        else
        {
            system_id_global = std::make_unique<BundleInformation::SystemId::SystemIdGlobal>();
            system_id_global->parent = this;
            children["system-id-global"] = system_id_global.get();
        }
        return children.at("system-id-global");
    }

    if(child_yang_name == "system-id-iccp-groups")
    {
        if(system_id_iccp_groups != nullptr)
        {
            children["system-id-iccp-groups"] = system_id_iccp_groups.get();
        }
        else
        {
            system_id_iccp_groups = std::make_unique<BundleInformation::SystemId::SystemIdIccpGroups>();
            system_id_iccp_groups->parent = this;
            children["system-id-iccp-groups"] = system_id_iccp_groups.get();
        }
        return children.at("system-id-iccp-groups");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::SystemId::get_children()
{
    if(children.find("system-id-global") == children.end())
    {
        if(system_id_global != nullptr)
        {
            children["system-id-global"] = system_id_global.get();
        }
    }

    if(children.find("system-id-iccp-groups") == children.end())
    {
        if(system_id_iccp_groups != nullptr)
        {
            children["system-id-iccp-groups"] = system_id_iccp_groups.get();
        }
    }

    return children;
}

void BundleInformation::SystemId::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"},
	 iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "bundle-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::has_data() const
{
    return bundle_name.is_set
	|| iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::NodeData_()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 node_id{YType::uint32, "node-id"}
{
    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::has_data() const
{
    return iccp_group_id.is_set
	|| node_id.is_set;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(node_id.operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData()
    :
    mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts>())
	,node_data(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_>())
{
    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data())
	|| (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation())
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::get_children()
{
    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::Items()
    :
    bundle_data(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "items"; yang_parent_name = "iccp-group-item";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::~Items()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::IccpGroupItem()
{
    yang_name = "iccp-group-item"; yang_parent_name = "iccp-group";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::~IccpGroupItem()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroup()
    :
    	iccp_group{YType::uint32, "iccp-group"}
    	,
    iccp_group_item(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem>())
{
    iccp_group_item->parent = this;
    children["iccp-group-item"] = iccp_group_item.get();

    yang_name = "iccp-group"; yang_parent_name = "iccp-groups";
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::~IccpGroup()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::has_data() const
{
    return iccp_group.is_set
	|| (iccp_group_item !=  nullptr && iccp_group_item->has_data());
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group.operation)
	|| (iccp_group_item !=  nullptr && iccp_group_item->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-group" <<"[iccp-group='" <<iccp_group.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/iccp-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group.is_set || is_set(iccp_group.operation)) leaf_name_data.push_back(iccp_group.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group-item")
    {
        if(iccp_group_item != nullptr)
        {
            children["iccp-group-item"] = iccp_group_item.get();
        }
        else
        {
            iccp_group_item = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::IccpGroupItem>();
            iccp_group_item->parent = this;
            children["iccp-group-item"] = iccp_group_item.get();
        }
        return children.at("iccp-group-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::get_children()
{
    if(children.find("iccp-group-item") == children.end())
    {
        if(iccp_group_item != nullptr)
        {
            children["iccp-group-item"] = iccp_group_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group")
    {
        iccp_group = value;
    }
}

BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroups()
{
    yang_name = "iccp-groups"; yang_parent_name = "mlacp-member-counters";
}

BundleInformation::MlacpMemberCounters::IccpGroups::~IccpGroups()
{
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::has_data() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::IccpGroups::has_operation() const
{
    for (std::size_t index=0; index<iccp_group.size(); index++)
    {
        if(iccp_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::IccpGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "iccp-groups";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::IccpGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::IccpGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "iccp-group")
    {
        for(auto const & c : iccp_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups::IccpGroup>();
        c->parent = this;
        iccp_group.push_back(std::move(c));
        children[segment_path] = iccp_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::IccpGroups::get_children()
{
    for (auto const & c : iccp_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::IccpGroups::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"},
	 iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "bundle-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::has_data() const
{
    return bundle_name.is_set
	|| iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::NodeData_()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 node_id{YType::uint32, "node-id"}
{
    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::has_data() const
{
    return iccp_group_id.is_set
	|| node_id.is_set;
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(node_id.operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData()
    :
    mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts>())
	,node_data(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_>())
{
    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data())
	|| (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation())
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::get_children()
{
    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::Items()
    :
    bundle_data(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "items"; yang_parent_name = "member-item";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::~Items()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::MemberItem()
{
    yang_name = "member-item"; yang_parent_name = "member";
}

BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::~MemberItem()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::MemberItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Members::Member::Member()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    member_item(std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem>())
{
    member_item->parent = this;
    children["member-item"] = member_item.get();

    yang_name = "member"; yang_parent_name = "members";
}

BundleInformation::MlacpMemberCounters::Members::Member::~Member()
{
}

bool BundleInformation::MlacpMemberCounters::Members::Member::has_data() const
{
    return member_interface.is_set
	|| (member_item !=  nullptr && member_item->has_data());
}

bool BundleInformation::MlacpMemberCounters::Members::Member::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (member_item !=  nullptr && member_item->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Members::Member::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::Member::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::Member::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-item")
    {
        if(member_item != nullptr)
        {
            children["member-item"] = member_item.get();
        }
        else
        {
            member_item = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member::MemberItem>();
            member_item->parent = this;
            children["member-item"] = member_item.get();
        }
        return children.at("member-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::Member::get_children()
{
    if(children.find("member-item") == children.end())
    {
        if(member_item != nullptr)
        {
            children["member-item"] = member_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::Member::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

BundleInformation::MlacpMemberCounters::Members::Members()
{
    yang_name = "members"; yang_parent_name = "mlacp-member-counters";
}

BundleInformation::MlacpMemberCounters::Members::~Members()
{
}

bool BundleInformation::MlacpMemberCounters::Members::has_data() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::Members::has_operation() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::Members::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "members";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Members::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Members::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member")
    {
        for(auto const & c : member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Members::Member>();
        c->parent = this;
        member.push_back(std::move(c));
        children[segment_path] = member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Members::get_children()
{
    for (auto const & c : member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Members::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"},
	 iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "bundle-data"; yang_parent_name = "bundle-item";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::has_data() const
{
    return bundle_name.is_set
	|| iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::NodeData_()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 node_id{YType::uint32, "node-id"}
{
    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::has_data() const
{
    return iccp_group_id.is_set
	|| node_id.is_set;
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(node_id.operation);
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData()
    :
    mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts>())
	,node_data(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_>())
{
    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "bundle-item";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data())
	|| (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation())
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::get_children()
{
    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "bundle-item";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleItem()
    :
    bundle_data(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "bundle-item"; yang_parent_name = "bundle";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::~BundleItem()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::Bundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    bundle_item(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem>())
{
    bundle_item->parent = this;
    children["bundle-item"] = bundle_item.get();

    yang_name = "bundle"; yang_parent_name = "bundles";
}

BundleInformation::MlacpMemberCounters::Bundles::Bundle::~Bundle()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::has_data() const
{
    return bundle_interface.is_set
	|| (bundle_item !=  nullptr && bundle_item->has_data());
}

bool BundleInformation::MlacpMemberCounters::Bundles::Bundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (bundle_item !=  nullptr && bundle_item->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Bundles::Bundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::Bundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::Bundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-item")
    {
        if(bundle_item != nullptr)
        {
            children["bundle-item"] = bundle_item.get();
        }
        else
        {
            bundle_item = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle::BundleItem>();
            bundle_item->parent = this;
            children["bundle-item"] = bundle_item.get();
        }
        return children.at("bundle-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::Bundle::get_children()
{
    if(children.find("bundle-item") == children.end())
    {
        if(bundle_item != nullptr)
        {
            children["bundle-item"] = bundle_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::Bundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

BundleInformation::MlacpMemberCounters::Bundles::Bundles()
{
    yang_name = "bundles"; yang_parent_name = "mlacp-member-counters";
}

BundleInformation::MlacpMemberCounters::Bundles::~Bundles()
{
}

bool BundleInformation::MlacpMemberCounters::Bundles::has_data() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::Bundles::has_operation() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::Bundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundles";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Bundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Bundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle")
    {
        for(auto const & c : bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles::Bundle>();
        c->parent = this;
        bundle.push_back(std::move(c));
        children[segment_path] = bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Bundles::get_children()
{
    for (auto const & c : bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Bundles::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-local-ports";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::MlacpSyncRequestsOnAllLocalPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-local-ports"; yang_parent_name = "bundle-data";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::~MlacpSyncRequestsOnAllLocalPorts()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-local-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::BundleData()
    :
    	bundle_name{YType::str, "bundle-name"},
	 iccp_group_id{YType::uint32, "iccp-group-id"}
    	,
    mlacp_sync_requests_on_all_local_ports(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts>())
{
    mlacp_sync_requests_on_all_local_ports->parent = this;
    children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();

    yang_name = "bundle-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::~BundleData()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::has_data() const
{
    return bundle_name.is_set
	|| iccp_group_id.is_set
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| is_set(iccp_group_id.operation)
	|| (mlacp_sync_requests_on_all_local_ports !=  nullptr && mlacp_sync_requests_on_all_local_ports->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-local-ports")
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_local_ports = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::MlacpSyncRequestsOnAllLocalPorts>();
            mlacp_sync_requests_on_all_local_ports->parent = this;
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-local-ports");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::get_children()
{
    if(children.find("mlacp-sync-requests-on-all-local-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_local_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-local-ports"] = mlacp_sync_requests_on_all_local_ports.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::NodeData_()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 node_id{YType::uint32, "node-id"}
{
    yang_name = "node-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::~NodeData_()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::has_data() const
{
    return iccp_group_id.is_set
	|| node_id.is_set;
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(node_id.operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-sync-requests-on-all-foreign-ports";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::MlacpSyncRequestsOnAllForeignPorts()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-sync-requests-on-all-foreign-ports"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::~MlacpSyncRequestsOnAllForeignPorts()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_data() const
{
    return last_time_cleared.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-sync-requests-on-all-foreign-ports";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "node-data";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData()
    :
    mlacp_sync_requests_on_all_foreign_ports(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts>())
	,node_data(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_>())
{
    mlacp_sync_requests_on_all_foreign_ports->parent = this;
    children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();

    node_data->parent = this;
    children["node-data"] = node_data.get();

    yang_name = "node-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::~NodeData()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    return (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_data())
	|| (node_data !=  nullptr && node_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (mlacp_sync_requests_on_all_foreign_ports !=  nullptr && mlacp_sync_requests_on_all_foreign_ports->has_operation())
	|| (node_data !=  nullptr && node_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-sync-requests-on-all-foreign-ports")
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        else
        {
            mlacp_sync_requests_on_all_foreign_ports = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::MlacpSyncRequestsOnAllForeignPorts>();
            mlacp_sync_requests_on_all_foreign_ports->parent = this;
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
        return children.at("mlacp-sync-requests-on-all-foreign-ports");
    }

    if(child_yang_name == "node-data")
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
        else
        {
            node_data = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::NodeData_>();
            node_data->parent = this;
            children["node-data"] = node_data.get();
        }
        return children.at("node-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::get_children()
{
    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mlacp-sync-requests-on-all-foreign-ports") == children.end())
    {
        if(mlacp_sync_requests_on_all_foreign_ports != nullptr)
        {
            children["mlacp-sync-requests-on-all-foreign-ports"] = mlacp_sync_requests_on_all_foreign_ports.get();
        }
    }

    if(children.find("node-data") == children.end())
    {
        if(node_data != nullptr)
        {
            children["node-data"] = node_data.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::ReceivedSyncRequests()
    :
    	all_syncs{YType::uint32, "all-syncs"},
	 config_syncs{YType::uint32, "config-syncs"},
	 state_syncs{YType::uint32, "state-syncs"}
{
    yang_name = "received-sync-requests"; yang_parent_name = "mlacp-tlv-counters";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::~ReceivedSyncRequests()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_data() const
{
    return all_syncs.is_set
	|| config_syncs.is_set
	|| state_syncs.is_set;
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::has_operation() const
{
    return is_set(operation)
	|| is_set(all_syncs.operation)
	|| is_set(config_syncs.operation)
	|| is_set(state_syncs.operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "received-sync-requests";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all_syncs.is_set || is_set(all_syncs.operation)) leaf_name_data.push_back(all_syncs.get_name_leafdata());
    if (config_syncs.is_set || is_set(config_syncs.operation)) leaf_name_data.push_back(config_syncs.get_name_leafdata());
    if (state_syncs.is_set || is_set(state_syncs.operation)) leaf_name_data.push_back(state_syncs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::get_children()
{
    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all-syncs")
    {
        all_syncs = value;
    }
    if(value_path == "config-syncs")
    {
        config_syncs = value;
    }
    if(value_path == "state-syncs")
    {
        state_syncs = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::MlacpTlvCounters()
    :
    	last_time_cleared{YType::uint64, "last-time-cleared"},
	 last_unexpected_event{YType::uint64, "last-unexpected-event"},
	 received_nak_tl_vs{YType::uint32, "received-nak-tl-vs"},
	 received_priority_tl_vs{YType::uint32, "received-priority-tl-vs"},
	 sent_config_tl_vs{YType::uint32, "sent-config-tl-vs"},
	 sent_priority_tl_vs{YType::uint32, "sent-priority-tl-vs"},
	 sent_state_tl_vs{YType::uint32, "sent-state-tl-vs"},
	 time_since_cleared{YType::uint64, "time-since-cleared"}
    	,
    received_sync_requests(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests>())
{
    received_sync_requests->parent = this;
    children["received-sync-requests"] = received_sync_requests.get();

    yang_name = "mlacp-tlv-counters"; yang_parent_name = "member-data";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::~MlacpTlvCounters()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::has_data() const
{
    return last_time_cleared.is_set
	|| last_unexpected_event.is_set
	|| received_nak_tl_vs.is_set
	|| received_priority_tl_vs.is_set
	|| sent_config_tl_vs.is_set
	|| sent_priority_tl_vs.is_set
	|| sent_state_tl_vs.is_set
	|| time_since_cleared.is_set
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_time_cleared.operation)
	|| is_set(last_unexpected_event.operation)
	|| is_set(received_nak_tl_vs.operation)
	|| is_set(received_priority_tl_vs.operation)
	|| is_set(sent_config_tl_vs.operation)
	|| is_set(sent_priority_tl_vs.operation)
	|| is_set(sent_state_tl_vs.operation)
	|| is_set(time_since_cleared.operation)
	|| (received_sync_requests !=  nullptr && received_sync_requests->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-tlv-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_time_cleared.is_set || is_set(last_time_cleared.operation)) leaf_name_data.push_back(last_time_cleared.get_name_leafdata());
    if (last_unexpected_event.is_set || is_set(last_unexpected_event.operation)) leaf_name_data.push_back(last_unexpected_event.get_name_leafdata());
    if (received_nak_tl_vs.is_set || is_set(received_nak_tl_vs.operation)) leaf_name_data.push_back(received_nak_tl_vs.get_name_leafdata());
    if (received_priority_tl_vs.is_set || is_set(received_priority_tl_vs.operation)) leaf_name_data.push_back(received_priority_tl_vs.get_name_leafdata());
    if (sent_config_tl_vs.is_set || is_set(sent_config_tl_vs.operation)) leaf_name_data.push_back(sent_config_tl_vs.get_name_leafdata());
    if (sent_priority_tl_vs.is_set || is_set(sent_priority_tl_vs.operation)) leaf_name_data.push_back(sent_priority_tl_vs.get_name_leafdata());
    if (sent_state_tl_vs.is_set || is_set(sent_state_tl_vs.operation)) leaf_name_data.push_back(sent_state_tl_vs.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "received-sync-requests")
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
        else
        {
            received_sync_requests = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::ReceivedSyncRequests>();
            received_sync_requests->parent = this;
            children["received-sync-requests"] = received_sync_requests.get();
        }
        return children.at("received-sync-requests");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::get_children()
{
    if(children.find("received-sync-requests") == children.end())
    {
        if(received_sync_requests != nullptr)
        {
            children["received-sync-requests"] = received_sync_requests.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-time-cleared")
    {
        last_time_cleared = value;
    }
    if(value_path == "last-unexpected-event")
    {
        last_unexpected_event = value;
    }
    if(value_path == "received-nak-tl-vs")
    {
        received_nak_tl_vs = value;
    }
    if(value_path == "received-priority-tl-vs")
    {
        received_priority_tl_vs = value;
    }
    if(value_path == "sent-config-tl-vs")
    {
        sent_config_tl_vs = value;
    }
    if(value_path == "sent-priority-tl-vs")
    {
        sent_priority_tl_vs = value;
    }
    if(value_path == "sent-state-tl-vs")
    {
        sent_state_tl_vs = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MemberData()
    :
    	port_name{YType::str, "port-name"}
    	,
    mlacp_tlv_counters(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters>())
{
    mlacp_tlv_counters->parent = this;
    children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();

    yang_name = "member-data"; yang_parent_name = "items";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::~MemberData()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::has_data() const
{
    return port_name.is_set
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::has_operation() const
{
    return is_set(operation)
	|| is_set(port_name.operation)
	|| (mlacp_tlv_counters !=  nullptr && mlacp_tlv_counters->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-data";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (port_name.is_set || is_set(port_name.operation)) leaf_name_data.push_back(port_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mlacp-tlv-counters")
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        else
        {
            mlacp_tlv_counters = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::MlacpTlvCounters>();
            mlacp_tlv_counters->parent = this;
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
        return children.at("mlacp-tlv-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::get_children()
{
    if(children.find("mlacp-tlv-counters") == children.end())
    {
        if(mlacp_tlv_counters != nullptr)
        {
            children["mlacp-tlv-counters"] = mlacp_tlv_counters.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "port-name")
    {
        port_name = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::Items()
    :
    bundle_data(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData>())
{
    bundle_data->parent = this;
    children["bundle-data"] = bundle_data.get();

    yang_name = "items"; yang_parent_name = "node-item";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::~Items()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::has_data() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_data())
            return true;
    }
    return (bundle_data !=  nullptr && bundle_data->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::has_operation() const
{
    for (std::size_t index=0; index<member_data.size(); index++)
    {
        if(member_data[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<node_data.size(); index++)
    {
        if(node_data[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| (bundle_data !=  nullptr && bundle_data->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "items";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
        else
        {
            bundle_data = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::BundleData>();
            bundle_data->parent = this;
            children["bundle-data"] = bundle_data.get();
        }
        return children.at("bundle-data");
    }

    if(child_yang_name == "member-data")
    {
        for(auto const & c : member_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::MemberData>();
        c->parent = this;
        member_data.push_back(std::move(c));
        children[segment_path] = member_data.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "node-data")
    {
        for(auto const & c : node_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::NodeData>();
        c->parent = this;
        node_data.push_back(std::move(c));
        children[segment_path] = node_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::get_children()
{
    if(children.find("bundle-data") == children.end())
    {
        if(bundle_data != nullptr)
        {
            children["bundle-data"] = bundle_data.get();
        }
    }

    for (auto const & c : member_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : node_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::NodeItem()
{
    yang_name = "node-item"; yang_parent_name = "node";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::~NodeItem()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::has_data() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::has_operation() const
{
    for (std::size_t index=0; index<items.size(); index++)
    {
        if(items[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node-item";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "items")
    {
        for(auto const & c : items)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::Items>();
        c->parent = this;
        items.push_back(std::move(c));
        children[segment_path] = items.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::get_children()
{
    for (auto const & c : items)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::Nodes::Node::Node()
    :
    	node{YType::str, "node"}
    	,
    node_item(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem>())
{
    node_item->parent = this;
    children["node-item"] = node_item.get();

    yang_name = "node"; yang_parent_name = "nodes";
}

BundleInformation::MlacpMemberCounters::Nodes::Node::~Node()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::has_data() const
{
    return node.is_set
	|| (node_item !=  nullptr && node_item->has_data());
}

bool BundleInformation::MlacpMemberCounters::Nodes::Node::has_operation() const
{
    return is_set(operation)
	|| is_set(node.operation)
	|| (node_item !=  nullptr && node_item->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::Nodes::Node::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node" <<"[node='" <<node.get() <<"']";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::Node::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/nodes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node.is_set || is_set(node.operation)) leaf_name_data.push_back(node.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::Node::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node-item")
    {
        if(node_item != nullptr)
        {
            children["node-item"] = node_item.get();
        }
        else
        {
            node_item = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node::NodeItem>();
            node_item->parent = this;
            children["node-item"] = node_item.get();
        }
        return children.at("node-item");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::Node::get_children()
{
    if(children.find("node-item") == children.end())
    {
        if(node_item != nullptr)
        {
            children["node-item"] = node_item.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::Node::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node")
    {
        node = value;
    }
}

BundleInformation::MlacpMemberCounters::Nodes::Nodes()
{
    yang_name = "nodes"; yang_parent_name = "mlacp-member-counters";
}

BundleInformation::MlacpMemberCounters::Nodes::~Nodes()
{
}

bool BundleInformation::MlacpMemberCounters::Nodes::has_data() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_data())
            return true;
    }
    return false;
}

bool BundleInformation::MlacpMemberCounters::Nodes::has_operation() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundleInformation::MlacpMemberCounters::Nodes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodes";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::Nodes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/mlacp-member-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::Nodes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node")
    {
        for(auto const & c : node)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes::Node>();
        c->parent = this;
        node.push_back(std::move(c));
        children[segment_path] = node.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::Nodes::get_children()
{
    for (auto const & c : node)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::Nodes::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::MlacpMemberCounters::MlacpMemberCounters()
    :
    bundles(std::make_unique<BundleInformation::MlacpMemberCounters::Bundles>())
	,iccp_groups(std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups>())
	,members(std::make_unique<BundleInformation::MlacpMemberCounters::Members>())
	,nodes(std::make_unique<BundleInformation::MlacpMemberCounters::Nodes>())
{
    bundles->parent = this;
    children["bundles"] = bundles.get();

    iccp_groups->parent = this;
    children["iccp-groups"] = iccp_groups.get();

    members->parent = this;
    children["members"] = members.get();

    nodes->parent = this;
    children["nodes"] = nodes.get();

    yang_name = "mlacp-member-counters"; yang_parent_name = "bundle-information";
}

BundleInformation::MlacpMemberCounters::~MlacpMemberCounters()
{
}

bool BundleInformation::MlacpMemberCounters::has_data() const
{
    return (bundles !=  nullptr && bundles->has_data())
	|| (iccp_groups !=  nullptr && iccp_groups->has_data())
	|| (members !=  nullptr && members->has_data())
	|| (nodes !=  nullptr && nodes->has_data());
}

bool BundleInformation::MlacpMemberCounters::has_operation() const
{
    return is_set(operation)
	|| (bundles !=  nullptr && bundles->has_operation())
	|| (iccp_groups !=  nullptr && iccp_groups->has_operation())
	|| (members !=  nullptr && members->has_operation())
	|| (nodes !=  nullptr && nodes->has_operation());
}

std::string BundleInformation::MlacpMemberCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mlacp-member-counters";

    return path_buffer.str();

}

EntityPath BundleInformation::MlacpMemberCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::MlacpMemberCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundles")
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
        else
        {
            bundles = std::make_unique<BundleInformation::MlacpMemberCounters::Bundles>();
            bundles->parent = this;
            children["bundles"] = bundles.get();
        }
        return children.at("bundles");
    }

    if(child_yang_name == "iccp-groups")
    {
        if(iccp_groups != nullptr)
        {
            children["iccp-groups"] = iccp_groups.get();
        }
        else
        {
            iccp_groups = std::make_unique<BundleInformation::MlacpMemberCounters::IccpGroups>();
            iccp_groups->parent = this;
            children["iccp-groups"] = iccp_groups.get();
        }
        return children.at("iccp-groups");
    }

    if(child_yang_name == "members")
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
        else
        {
            members = std::make_unique<BundleInformation::MlacpMemberCounters::Members>();
            members->parent = this;
            children["members"] = members.get();
        }
        return children.at("members");
    }

    if(child_yang_name == "nodes")
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
        else
        {
            nodes = std::make_unique<BundleInformation::MlacpMemberCounters::Nodes>();
            nodes->parent = this;
            children["nodes"] = nodes.get();
        }
        return children.at("nodes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::MlacpMemberCounters::get_children()
{
    if(children.find("bundles") == children.end())
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
    }

    if(children.find("iccp-groups") == children.end())
    {
        if(iccp_groups != nullptr)
        {
            children["iccp-groups"] = iccp_groups.get();
        }
    }

    if(children.find("members") == children.end())
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
    }

    if(children.find("nodes") == children.end())
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
    }

    return children;
}

void BundleInformation::MlacpMemberCounters::set_value(const std::string & value_path, std::string value)
{
}

BundleInformation::BundleInformation()
    :
    bfd_counters(std::make_unique<BundleInformation::BfdCounters>())
	,bundle(std::make_unique<BundleInformation::Bundle>())
	,bundle_briefs(std::make_unique<BundleInformation::BundleBriefs>())
	,events(std::make_unique<BundleInformation::Events>())
	,events_bdl(std::make_unique<BundleInformation::EventsBdl>())
	,events_mbr(std::make_unique<BundleInformation::EventsMbr>())
	,events_rg(std::make_unique<BundleInformation::EventsRg>())
	,lacp(std::make_unique<BundleInformation::Lacp>())
	,mac_allocation(std::make_unique<BundleInformation::MacAllocation>())
	,mlacp(std::make_unique<BundleInformation::Mlacp>())
	,mlacp_brief(std::make_unique<BundleInformation::MlacpBrief>())
	,mlacp_bundle_counters(std::make_unique<BundleInformation::MlacpBundleCounters>())
	,mlacp_iccp_group_counters(std::make_unique<BundleInformation::MlacpIccpGroupCounters>())
	,mlacp_member_counters(std::make_unique<BundleInformation::MlacpMemberCounters>())
	,protect(std::make_unique<BundleInformation::Protect>())
	,scheduled_actions(std::make_unique<BundleInformation::ScheduledActions>())
	,system_id(std::make_unique<BundleInformation::SystemId>())
{
    bfd_counters->parent = this;
    children["bfd-counters"] = bfd_counters.get();

    bundle->parent = this;
    children["bundle"] = bundle.get();

    bundle_briefs->parent = this;
    children["bundle-briefs"] = bundle_briefs.get();

    events->parent = this;
    children["events"] = events.get();

    events_bdl->parent = this;
    children["events-bdl"] = events_bdl.get();

    events_mbr->parent = this;
    children["events-mbr"] = events_mbr.get();

    events_rg->parent = this;
    children["events-rg"] = events_rg.get();

    lacp->parent = this;
    children["lacp"] = lacp.get();

    mac_allocation->parent = this;
    children["mac-allocation"] = mac_allocation.get();

    mlacp->parent = this;
    children["mlacp"] = mlacp.get();

    mlacp_brief->parent = this;
    children["mlacp-brief"] = mlacp_brief.get();

    mlacp_bundle_counters->parent = this;
    children["mlacp-bundle-counters"] = mlacp_bundle_counters.get();

    mlacp_iccp_group_counters->parent = this;
    children["mlacp-iccp-group-counters"] = mlacp_iccp_group_counters.get();

    mlacp_member_counters->parent = this;
    children["mlacp-member-counters"] = mlacp_member_counters.get();

    protect->parent = this;
    children["protect"] = protect.get();

    scheduled_actions->parent = this;
    children["scheduled-actions"] = scheduled_actions.get();

    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "bundle-information"; yang_parent_name = "Cisco-IOS-XR-bundlemgr-oper";
}

BundleInformation::~BundleInformation()
{
}

bool BundleInformation::has_data() const
{
    return (bfd_counters !=  nullptr && bfd_counters->has_data())
	|| (bundle !=  nullptr && bundle->has_data())
	|| (bundle_briefs !=  nullptr && bundle_briefs->has_data())
	|| (events !=  nullptr && events->has_data())
	|| (events_bdl !=  nullptr && events_bdl->has_data())
	|| (events_mbr !=  nullptr && events_mbr->has_data())
	|| (events_rg !=  nullptr && events_rg->has_data())
	|| (lacp !=  nullptr && lacp->has_data())
	|| (mac_allocation !=  nullptr && mac_allocation->has_data())
	|| (mlacp !=  nullptr && mlacp->has_data())
	|| (mlacp_brief !=  nullptr && mlacp_brief->has_data())
	|| (mlacp_bundle_counters !=  nullptr && mlacp_bundle_counters->has_data())
	|| (mlacp_iccp_group_counters !=  nullptr && mlacp_iccp_group_counters->has_data())
	|| (mlacp_member_counters !=  nullptr && mlacp_member_counters->has_data())
	|| (protect !=  nullptr && protect->has_data())
	|| (scheduled_actions !=  nullptr && scheduled_actions->has_data())
	|| (system_id !=  nullptr && system_id->has_data());
}

bool BundleInformation::has_operation() const
{
    return is_set(operation)
	|| (bfd_counters !=  nullptr && bfd_counters->has_operation())
	|| (bundle !=  nullptr && bundle->has_operation())
	|| (bundle_briefs !=  nullptr && bundle_briefs->has_operation())
	|| (events !=  nullptr && events->has_operation())
	|| (events_bdl !=  nullptr && events_bdl->has_operation())
	|| (events_mbr !=  nullptr && events_mbr->has_operation())
	|| (events_rg !=  nullptr && events_rg->has_operation())
	|| (lacp !=  nullptr && lacp->has_operation())
	|| (mac_allocation !=  nullptr && mac_allocation->has_operation())
	|| (mlacp !=  nullptr && mlacp->has_operation())
	|| (mlacp_brief !=  nullptr && mlacp_brief->has_operation())
	|| (mlacp_bundle_counters !=  nullptr && mlacp_bundle_counters->has_operation())
	|| (mlacp_iccp_group_counters !=  nullptr && mlacp_iccp_group_counters->has_operation())
	|| (mlacp_member_counters !=  nullptr && mlacp_member_counters->has_operation())
	|| (protect !=  nullptr && protect->has_operation())
	|| (scheduled_actions !=  nullptr && scheduled_actions->has_operation())
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string BundleInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundle-information";

    return path_buffer.str();

}

EntityPath BundleInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundleInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-counters")
    {
        if(bfd_counters != nullptr)
        {
            children["bfd-counters"] = bfd_counters.get();
        }
        else
        {
            bfd_counters = std::make_unique<BundleInformation::BfdCounters>();
            bfd_counters->parent = this;
            children["bfd-counters"] = bfd_counters.get();
        }
        return children.at("bfd-counters");
    }

    if(child_yang_name == "bundle")
    {
        if(bundle != nullptr)
        {
            children["bundle"] = bundle.get();
        }
        else
        {
            bundle = std::make_unique<BundleInformation::Bundle>();
            bundle->parent = this;
            children["bundle"] = bundle.get();
        }
        return children.at("bundle");
    }

    if(child_yang_name == "bundle-briefs")
    {
        if(bundle_briefs != nullptr)
        {
            children["bundle-briefs"] = bundle_briefs.get();
        }
        else
        {
            bundle_briefs = std::make_unique<BundleInformation::BundleBriefs>();
            bundle_briefs->parent = this;
            children["bundle-briefs"] = bundle_briefs.get();
        }
        return children.at("bundle-briefs");
    }

    if(child_yang_name == "events")
    {
        if(events != nullptr)
        {
            children["events"] = events.get();
        }
        else
        {
            events = std::make_unique<BundleInformation::Events>();
            events->parent = this;
            children["events"] = events.get();
        }
        return children.at("events");
    }

    if(child_yang_name == "events-bdl")
    {
        if(events_bdl != nullptr)
        {
            children["events-bdl"] = events_bdl.get();
        }
        else
        {
            events_bdl = std::make_unique<BundleInformation::EventsBdl>();
            events_bdl->parent = this;
            children["events-bdl"] = events_bdl.get();
        }
        return children.at("events-bdl");
    }

    if(child_yang_name == "events-mbr")
    {
        if(events_mbr != nullptr)
        {
            children["events-mbr"] = events_mbr.get();
        }
        else
        {
            events_mbr = std::make_unique<BundleInformation::EventsMbr>();
            events_mbr->parent = this;
            children["events-mbr"] = events_mbr.get();
        }
        return children.at("events-mbr");
    }

    if(child_yang_name == "events-rg")
    {
        if(events_rg != nullptr)
        {
            children["events-rg"] = events_rg.get();
        }
        else
        {
            events_rg = std::make_unique<BundleInformation::EventsRg>();
            events_rg->parent = this;
            children["events-rg"] = events_rg.get();
        }
        return children.at("events-rg");
    }

    if(child_yang_name == "lacp")
    {
        if(lacp != nullptr)
        {
            children["lacp"] = lacp.get();
        }
        else
        {
            lacp = std::make_unique<BundleInformation::Lacp>();
            lacp->parent = this;
            children["lacp"] = lacp.get();
        }
        return children.at("lacp");
    }

    if(child_yang_name == "mac-allocation")
    {
        if(mac_allocation != nullptr)
        {
            children["mac-allocation"] = mac_allocation.get();
        }
        else
        {
            mac_allocation = std::make_unique<BundleInformation::MacAllocation>();
            mac_allocation->parent = this;
            children["mac-allocation"] = mac_allocation.get();
        }
        return children.at("mac-allocation");
    }

    if(child_yang_name == "mlacp")
    {
        if(mlacp != nullptr)
        {
            children["mlacp"] = mlacp.get();
        }
        else
        {
            mlacp = std::make_unique<BundleInformation::Mlacp>();
            mlacp->parent = this;
            children["mlacp"] = mlacp.get();
        }
        return children.at("mlacp");
    }

    if(child_yang_name == "mlacp-brief")
    {
        if(mlacp_brief != nullptr)
        {
            children["mlacp-brief"] = mlacp_brief.get();
        }
        else
        {
            mlacp_brief = std::make_unique<BundleInformation::MlacpBrief>();
            mlacp_brief->parent = this;
            children["mlacp-brief"] = mlacp_brief.get();
        }
        return children.at("mlacp-brief");
    }

    if(child_yang_name == "mlacp-bundle-counters")
    {
        if(mlacp_bundle_counters != nullptr)
        {
            children["mlacp-bundle-counters"] = mlacp_bundle_counters.get();
        }
        else
        {
            mlacp_bundle_counters = std::make_unique<BundleInformation::MlacpBundleCounters>();
            mlacp_bundle_counters->parent = this;
            children["mlacp-bundle-counters"] = mlacp_bundle_counters.get();
        }
        return children.at("mlacp-bundle-counters");
    }

    if(child_yang_name == "mlacp-iccp-group-counters")
    {
        if(mlacp_iccp_group_counters != nullptr)
        {
            children["mlacp-iccp-group-counters"] = mlacp_iccp_group_counters.get();
        }
        else
        {
            mlacp_iccp_group_counters = std::make_unique<BundleInformation::MlacpIccpGroupCounters>();
            mlacp_iccp_group_counters->parent = this;
            children["mlacp-iccp-group-counters"] = mlacp_iccp_group_counters.get();
        }
        return children.at("mlacp-iccp-group-counters");
    }

    if(child_yang_name == "mlacp-member-counters")
    {
        if(mlacp_member_counters != nullptr)
        {
            children["mlacp-member-counters"] = mlacp_member_counters.get();
        }
        else
        {
            mlacp_member_counters = std::make_unique<BundleInformation::MlacpMemberCounters>();
            mlacp_member_counters->parent = this;
            children["mlacp-member-counters"] = mlacp_member_counters.get();
        }
        return children.at("mlacp-member-counters");
    }

    if(child_yang_name == "protect")
    {
        if(protect != nullptr)
        {
            children["protect"] = protect.get();
        }
        else
        {
            protect = std::make_unique<BundleInformation::Protect>();
            protect->parent = this;
            children["protect"] = protect.get();
        }
        return children.at("protect");
    }

    if(child_yang_name == "scheduled-actions")
    {
        if(scheduled_actions != nullptr)
        {
            children["scheduled-actions"] = scheduled_actions.get();
        }
        else
        {
            scheduled_actions = std::make_unique<BundleInformation::ScheduledActions>();
            scheduled_actions->parent = this;
            children["scheduled-actions"] = scheduled_actions.get();
        }
        return children.at("scheduled-actions");
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<BundleInformation::SystemId>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundleInformation::get_children()
{
    if(children.find("bfd-counters") == children.end())
    {
        if(bfd_counters != nullptr)
        {
            children["bfd-counters"] = bfd_counters.get();
        }
    }

    if(children.find("bundle") == children.end())
    {
        if(bundle != nullptr)
        {
            children["bundle"] = bundle.get();
        }
    }

    if(children.find("bundle-briefs") == children.end())
    {
        if(bundle_briefs != nullptr)
        {
            children["bundle-briefs"] = bundle_briefs.get();
        }
    }

    if(children.find("events") == children.end())
    {
        if(events != nullptr)
        {
            children["events"] = events.get();
        }
    }

    if(children.find("events-bdl") == children.end())
    {
        if(events_bdl != nullptr)
        {
            children["events-bdl"] = events_bdl.get();
        }
    }

    if(children.find("events-mbr") == children.end())
    {
        if(events_mbr != nullptr)
        {
            children["events-mbr"] = events_mbr.get();
        }
    }

    if(children.find("events-rg") == children.end())
    {
        if(events_rg != nullptr)
        {
            children["events-rg"] = events_rg.get();
        }
    }

    if(children.find("lacp") == children.end())
    {
        if(lacp != nullptr)
        {
            children["lacp"] = lacp.get();
        }
    }

    if(children.find("mac-allocation") == children.end())
    {
        if(mac_allocation != nullptr)
        {
            children["mac-allocation"] = mac_allocation.get();
        }
    }

    if(children.find("mlacp") == children.end())
    {
        if(mlacp != nullptr)
        {
            children["mlacp"] = mlacp.get();
        }
    }

    if(children.find("mlacp-brief") == children.end())
    {
        if(mlacp_brief != nullptr)
        {
            children["mlacp-brief"] = mlacp_brief.get();
        }
    }

    if(children.find("mlacp-bundle-counters") == children.end())
    {
        if(mlacp_bundle_counters != nullptr)
        {
            children["mlacp-bundle-counters"] = mlacp_bundle_counters.get();
        }
    }

    if(children.find("mlacp-iccp-group-counters") == children.end())
    {
        if(mlacp_iccp_group_counters != nullptr)
        {
            children["mlacp-iccp-group-counters"] = mlacp_iccp_group_counters.get();
        }
    }

    if(children.find("mlacp-member-counters") == children.end())
    {
        if(mlacp_member_counters != nullptr)
        {
            children["mlacp-member-counters"] = mlacp_member_counters.get();
        }
    }

    if(children.find("protect") == children.end())
    {
        if(protect != nullptr)
        {
            children["protect"] = protect.get();
        }
    }

    if(children.find("scheduled-actions") == children.end())
    {
        if(scheduled_actions != nullptr)
        {
            children["scheduled-actions"] = scheduled_actions.get();
        }
    }

    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void BundleInformation::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> BundleInformation::clone_ptr()
{
    return std::make_unique<BundleInformation>();
}
LacpData::Global::SystemId::SystemId_::SystemMacAddr::SystemMacAddr()
    :
    	macaddr{YType::str, "macaddr"}
{
    yang_name = "system-mac-addr"; yang_parent_name = "system-id";
}

LacpData::Global::SystemId::SystemId_::SystemMacAddr::~SystemMacAddr()
{
}

bool LacpData::Global::SystemId::SystemId_::SystemMacAddr::has_data() const
{
    return macaddr.is_set;
}

bool LacpData::Global::SystemId::SystemId_::SystemMacAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(macaddr.operation);
}

std::string LacpData::Global::SystemId::SystemId_::SystemMacAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-mac-addr";

    return path_buffer.str();

}

EntityPath LacpData::Global::SystemId::SystemId_::SystemMacAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-data/global/system-id/system-id/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (macaddr.is_set || is_set(macaddr.operation)) leaf_name_data.push_back(macaddr.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpData::Global::SystemId::SystemId_::SystemMacAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpData::Global::SystemId::SystemId_::SystemMacAddr::get_children()
{
    return children;
}

void LacpData::Global::SystemId::SystemId_::SystemMacAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "macaddr")
    {
        macaddr = value;
    }
}

LacpData::Global::SystemId::SystemId_::SystemId_()
    :
    	system_prio{YType::uint16, "system-prio"}
    	,
    system_mac_addr(std::make_unique<LacpData::Global::SystemId::SystemId_::SystemMacAddr>())
{
    system_mac_addr->parent = this;
    children["system-mac-addr"] = system_mac_addr.get();

    yang_name = "system-id"; yang_parent_name = "system-id";
}

LacpData::Global::SystemId::SystemId_::~SystemId_()
{
}

bool LacpData::Global::SystemId::SystemId_::has_data() const
{
    return system_prio.is_set
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_data());
}

bool LacpData::Global::SystemId::SystemId_::has_operation() const
{
    return is_set(operation)
	|| is_set(system_prio.operation)
	|| (system_mac_addr !=  nullptr && system_mac_addr->has_operation());
}

std::string LacpData::Global::SystemId::SystemId_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath LacpData::Global::SystemId::SystemId_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-data/global/system-id/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (system_prio.is_set || is_set(system_prio.operation)) leaf_name_data.push_back(system_prio.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpData::Global::SystemId::SystemId_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-mac-addr")
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
        else
        {
            system_mac_addr = std::make_unique<LacpData::Global::SystemId::SystemId_::SystemMacAddr>();
            system_mac_addr->parent = this;
            children["system-mac-addr"] = system_mac_addr.get();
        }
        return children.at("system-mac-addr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpData::Global::SystemId::SystemId_::get_children()
{
    if(children.find("system-mac-addr") == children.end())
    {
        if(system_mac_addr != nullptr)
        {
            children["system-mac-addr"] = system_mac_addr.get();
        }
    }

    return children;
}

void LacpData::Global::SystemId::SystemId_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "system-prio")
    {
        system_prio = value;
    }
}

LacpData::Global::SystemId::SystemId()
    :
    	iccp_group_id{YType::uint32, "iccp-group-id"},
	 system_mac_address{YType::str, "system-mac-address"},
	 system_priority{YType::uint16, "system-priority"}
    	,
    system_id(std::make_unique<LacpData::Global::SystemId::SystemId_>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "system-id"; yang_parent_name = "global";
}

LacpData::Global::SystemId::~SystemId()
{
}

bool LacpData::Global::SystemId::has_data() const
{
    return iccp_group_id.is_set
	|| system_mac_address.is_set
	|| system_priority.is_set
	|| (system_id !=  nullptr && system_id->has_data());
}

bool LacpData::Global::SystemId::has_operation() const
{
    return is_set(operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(system_mac_address.operation)
	|| is_set(system_priority.operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string LacpData::Global::SystemId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "system-id";

    return path_buffer.str();

}

EntityPath LacpData::Global::SystemId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-data/global/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (system_mac_address.is_set || is_set(system_mac_address.operation)) leaf_name_data.push_back(system_mac_address.get_name_leafdata());
    if (system_priority.is_set || is_set(system_priority.operation)) leaf_name_data.push_back(system_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpData::Global::SystemId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<LacpData::Global::SystemId::SystemId_>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpData::Global::SystemId::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void LacpData::Global::SystemId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "system-mac-address")
    {
        system_mac_address = value;
    }
    if(value_path == "system-priority")
    {
        system_priority = value;
    }
}

LacpData::Global::Global()
    :
    system_id(std::make_unique<LacpData::Global::SystemId>())
{
    system_id->parent = this;
    children["system-id"] = system_id.get();

    yang_name = "global"; yang_parent_name = "lacp-data";
}

LacpData::Global::~Global()
{
}

bool LacpData::Global::has_data() const
{
    return (system_id !=  nullptr && system_id->has_data());
}

bool LacpData::Global::has_operation() const
{
    return is_set(operation)
	|| (system_id !=  nullptr && system_id->has_operation());
}

std::string LacpData::Global::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "global";

    return path_buffer.str();

}

EntityPath LacpData::Global::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-data/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpData::Global::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "system-id")
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
        else
        {
            system_id = std::make_unique<LacpData::Global::SystemId>();
            system_id->parent = this;
            children["system-id"] = system_id.get();
        }
        return children.at("system-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpData::Global::get_children()
{
    if(children.find("system-id") == children.end())
    {
        if(system_id != nullptr)
        {
            children["system-id"] = system_id.get();
        }
    }

    return children;
}

void LacpData::Global::set_value(const std::string & value_path, std::string value)
{
}

LacpData::LacpData()
    :
    global(std::make_unique<LacpData::Global>())
{
    global->parent = this;
    children["global"] = global.get();

    yang_name = "lacp-data"; yang_parent_name = "Cisco-IOS-XR-bundlemgr-oper";
}

LacpData::~LacpData()
{
}

bool LacpData::has_data() const
{
    return (global !=  nullptr && global->has_data());
}

bool LacpData::has_operation() const
{
    return is_set(operation)
	|| (global !=  nullptr && global->has_operation());
}

std::string LacpData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-data";

    return path_buffer.str();

}

EntityPath LacpData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "global")
    {
        if(global != nullptr)
        {
            children["global"] = global.get();
        }
        else
        {
            global = std::make_unique<LacpData::Global>();
            global->parent = this;
            children["global"] = global.get();
        }
        return children.at("global");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpData::get_children()
{
    if(children.find("global") == children.end())
    {
        if(global != nullptr)
        {
            children["global"] = global.get();
        }
    }

    return children;
}

void LacpData::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> LacpData::clone_ptr()
{
    return std::make_unique<LacpData>();
}
Bundles::Bundles_::Bundle::Data::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "data";
}

Bundles::Bundles_::Bundle::Data::MacAddress::~MacAddress()
{
}

bool Bundles::Bundles_::Bundle::Data::MacAddress::has_data() const
{
    return address.is_set;
}

bool Bundles::Bundles_::Bundle::Data::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string Bundles::Bundles_::Bundle::Data::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Data::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Data::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Data::MacAddress::get_children()
{
    return children;
}

void Bundles::Bundles_::Bundle::Data::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::DestinationAddress()
    :
    	af{YType::enumeration, "af"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "destination-address"; yang_parent_name = "bfd-config";
}

Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::~DestinationAddress()
{
}

bool Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::has_data() const
{
    return af.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(af.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-address";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (af.is_set || is_set(af.operation)) leaf_name_data.push_back(af.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::get_children()
{
    return children;
}

void Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "af")
    {
        af = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bundles::Bundles_::Bundle::Data::BfdConfig::BfdConfig()
    :
    	bundle_status{YType::enumeration, "bundle-status"},
	 fast_detect{YType::boolean, "fast-detect"},
	 mode_info{YType::uint32, "mode-info"},
	 nbr_unconfig_timer{YType::uint32, "nbr-unconfig-timer"},
	 pref_echo_min_interval{YType::uint32, "pref-echo-min-interval"},
	 pref_min_interval{YType::uint32, "pref-min-interval"},
	 pref_multiplier{YType::uint16, "pref-multiplier"},
	 start_timer{YType::uint32, "start-timer"}
    	,
    destination_address(std::make_unique<Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress>())
{
    destination_address->parent = this;
    children["destination-address"] = destination_address.get();

    yang_name = "bfd-config"; yang_parent_name = "data";
}

Bundles::Bundles_::Bundle::Data::BfdConfig::~BfdConfig()
{
}

bool Bundles::Bundles_::Bundle::Data::BfdConfig::has_data() const
{
    return bundle_status.is_set
	|| fast_detect.is_set
	|| mode_info.is_set
	|| nbr_unconfig_timer.is_set
	|| pref_echo_min_interval.is_set
	|| pref_min_interval.is_set
	|| pref_multiplier.is_set
	|| start_timer.is_set
	|| (destination_address !=  nullptr && destination_address->has_data());
}

bool Bundles::Bundles_::Bundle::Data::BfdConfig::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_status.operation)
	|| is_set(fast_detect.operation)
	|| is_set(mode_info.operation)
	|| is_set(nbr_unconfig_timer.operation)
	|| is_set(pref_echo_min_interval.operation)
	|| is_set(pref_min_interval.operation)
	|| is_set(pref_multiplier.operation)
	|| is_set(start_timer.operation)
	|| (destination_address !=  nullptr && destination_address->has_operation());
}

std::string Bundles::Bundles_::Bundle::Data::BfdConfig::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-config";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Data::BfdConfig::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (fast_detect.is_set || is_set(fast_detect.operation)) leaf_name_data.push_back(fast_detect.get_name_leafdata());
    if (mode_info.is_set || is_set(mode_info.operation)) leaf_name_data.push_back(mode_info.get_name_leafdata());
    if (nbr_unconfig_timer.is_set || is_set(nbr_unconfig_timer.operation)) leaf_name_data.push_back(nbr_unconfig_timer.get_name_leafdata());
    if (pref_echo_min_interval.is_set || is_set(pref_echo_min_interval.operation)) leaf_name_data.push_back(pref_echo_min_interval.get_name_leafdata());
    if (pref_min_interval.is_set || is_set(pref_min_interval.operation)) leaf_name_data.push_back(pref_min_interval.get_name_leafdata());
    if (pref_multiplier.is_set || is_set(pref_multiplier.operation)) leaf_name_data.push_back(pref_multiplier.get_name_leafdata());
    if (start_timer.is_set || is_set(start_timer.operation)) leaf_name_data.push_back(start_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Data::BfdConfig::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination-address")
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
        else
        {
            destination_address = std::make_unique<Bundles::Bundles_::Bundle::Data::BfdConfig::DestinationAddress>();
            destination_address->parent = this;
            children["destination-address"] = destination_address.get();
        }
        return children.at("destination-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Data::BfdConfig::get_children()
{
    if(children.find("destination-address") == children.end())
    {
        if(destination_address != nullptr)
        {
            children["destination-address"] = destination_address.get();
        }
    }

    return children;
}

void Bundles::Bundles_::Bundle::Data::BfdConfig::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "fast-detect")
    {
        fast_detect = value;
    }
    if(value_path == "mode-info")
    {
        mode_info = value;
    }
    if(value_path == "nbr-unconfig-timer")
    {
        nbr_unconfig_timer = value;
    }
    if(value_path == "pref-echo-min-interval")
    {
        pref_echo_min_interval = value;
    }
    if(value_path == "pref-min-interval")
    {
        pref_min_interval = value;
    }
    if(value_path == "pref-multiplier")
    {
        pref_multiplier = value;
    }
    if(value_path == "start-timer")
    {
        start_timer = value;
    }
}

Bundles::Bundles_::Bundle::Data::Data()
    :
    	active_foreign_member_count{YType::uint16, "active-foreign-member-count"},
	 active_member_count{YType::uint16, "active-member-count"},
	 available_bandwidth{YType::uint32, "available-bandwidth"},
	 bundle_interface_name{YType::str, "bundle-interface-name"},
	 bundle_status{YType::enumeration, "bundle-status"},
	 cisco_extensions{YType::boolean, "cisco-extensions"},
	 collector_max_delay{YType::uint16, "collector-max-delay"},
	 configured_bandwidth{YType::uint32, "configured-bandwidth"},
	 configured_foreign_member_count{YType::uint16, "configured-foreign-member-count"},
	 configured_member_count{YType::uint16, "configured-member-count"},
	 effective_bandwidth{YType::uint32, "effective-bandwidth"},
	 iccp_group_id{YType::uint32, "iccp-group-id"},
	 inter_chassis{YType::boolean, "inter-chassis"},
	 ipv4bfd_status{YType::enumeration, "ipv4bfd-status"},
	 ipv6bfd_status{YType::enumeration, "ipv6bfd-status"},
	 is_active{YType::boolean, "is-active"},
	 lacp_nonrevertive{YType::boolean, "lacp-nonrevertive"},
	 lacp_status{YType::enumeration, "lacp-status"},
	 link_order_status{YType::enumeration, "link-order-status"},
	 load_balance_hash_type{YType::str, "load-balance-hash-type"},
	 load_balance_locality_threshold{YType::uint16, "load-balance-locality-threshold"},
	 mac_source{YType::enumeration, "mac-source"},
	 mac_source_member{YType::str, "mac-source-member"},
	 maximize_threshold_value_band_width{YType::uint32, "maximize-threshold-value-band-width"},
	 maximize_threshold_value_links{YType::uint32, "maximize-threshold-value-links"},
	 maximum_active_links{YType::uint8, "maximum-active-links"},
	 maximum_active_links_source{YType::enumeration, "maximum-active-links-source"},
	 minimum_active_links{YType::uint8, "minimum-active-links"},
	 minimum_bandwidth{YType::uint32, "minimum-bandwidth"},
	 mlacp_mode{YType::enumeration, "mlacp-mode"},
	 mlacp_status{YType::enumeration, "mlacp-status"},
	 primary_member{YType::str, "primary-member"},
	 recovery_delay{YType::uint16, "recovery-delay"},
	 singleton{YType::boolean, "singleton"},
	 standby_member_count{YType::uint16, "standby-member-count"},
	 suppression_timer{YType::uint16, "suppression-timer"},
	 switchover_type{YType::enumeration, "switchover-type"},
	 wait_while_timer{YType::uint16, "wait-while-timer"}
    	,
    mac_address(std::make_unique<Bundles::Bundles_::Bundle::Data::MacAddress>())
{
    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    yang_name = "data"; yang_parent_name = "bundle";
}

Bundles::Bundles_::Bundle::Data::~Data()
{
}

bool Bundles::Bundles_::Bundle::Data::has_data() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_data())
            return true;
    }
    return active_foreign_member_count.is_set
	|| active_member_count.is_set
	|| available_bandwidth.is_set
	|| bundle_interface_name.is_set
	|| bundle_status.is_set
	|| cisco_extensions.is_set
	|| collector_max_delay.is_set
	|| configured_bandwidth.is_set
	|| configured_foreign_member_count.is_set
	|| configured_member_count.is_set
	|| effective_bandwidth.is_set
	|| iccp_group_id.is_set
	|| inter_chassis.is_set
	|| ipv4bfd_status.is_set
	|| ipv6bfd_status.is_set
	|| is_active.is_set
	|| lacp_nonrevertive.is_set
	|| lacp_status.is_set
	|| link_order_status.is_set
	|| load_balance_hash_type.is_set
	|| load_balance_locality_threshold.is_set
	|| mac_source.is_set
	|| mac_source_member.is_set
	|| maximize_threshold_value_band_width.is_set
	|| maximize_threshold_value_links.is_set
	|| maximum_active_links.is_set
	|| maximum_active_links_source.is_set
	|| minimum_active_links.is_set
	|| minimum_bandwidth.is_set
	|| mlacp_mode.is_set
	|| mlacp_status.is_set
	|| primary_member.is_set
	|| recovery_delay.is_set
	|| singleton.is_set
	|| standby_member_count.is_set
	|| suppression_timer.is_set
	|| switchover_type.is_set
	|| wait_while_timer.is_set
	|| (mac_address !=  nullptr && mac_address->has_data());
}

bool Bundles::Bundles_::Bundle::Data::has_operation() const
{
    for (std::size_t index=0; index<bfd_config.size(); index++)
    {
        if(bfd_config[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(active_foreign_member_count.operation)
	|| is_set(active_member_count.operation)
	|| is_set(available_bandwidth.operation)
	|| is_set(bundle_interface_name.operation)
	|| is_set(bundle_status.operation)
	|| is_set(cisco_extensions.operation)
	|| is_set(collector_max_delay.operation)
	|| is_set(configured_bandwidth.operation)
	|| is_set(configured_foreign_member_count.operation)
	|| is_set(configured_member_count.operation)
	|| is_set(effective_bandwidth.operation)
	|| is_set(iccp_group_id.operation)
	|| is_set(inter_chassis.operation)
	|| is_set(ipv4bfd_status.operation)
	|| is_set(ipv6bfd_status.operation)
	|| is_set(is_active.operation)
	|| is_set(lacp_nonrevertive.operation)
	|| is_set(lacp_status.operation)
	|| is_set(link_order_status.operation)
	|| is_set(load_balance_hash_type.operation)
	|| is_set(load_balance_locality_threshold.operation)
	|| is_set(mac_source.operation)
	|| is_set(mac_source_member.operation)
	|| is_set(maximize_threshold_value_band_width.operation)
	|| is_set(maximize_threshold_value_links.operation)
	|| is_set(maximum_active_links.operation)
	|| is_set(maximum_active_links_source.operation)
	|| is_set(minimum_active_links.operation)
	|| is_set(minimum_bandwidth.operation)
	|| is_set(mlacp_mode.operation)
	|| is_set(mlacp_status.operation)
	|| is_set(primary_member.operation)
	|| is_set(recovery_delay.operation)
	|| is_set(singleton.operation)
	|| is_set(standby_member_count.operation)
	|| is_set(suppression_timer.operation)
	|| is_set(switchover_type.operation)
	|| is_set(wait_while_timer.operation)
	|| (mac_address !=  nullptr && mac_address->has_operation());
}

std::string Bundles::Bundles_::Bundle::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_foreign_member_count.is_set || is_set(active_foreign_member_count.operation)) leaf_name_data.push_back(active_foreign_member_count.get_name_leafdata());
    if (active_member_count.is_set || is_set(active_member_count.operation)) leaf_name_data.push_back(active_member_count.get_name_leafdata());
    if (available_bandwidth.is_set || is_set(available_bandwidth.operation)) leaf_name_data.push_back(available_bandwidth.get_name_leafdata());
    if (bundle_interface_name.is_set || is_set(bundle_interface_name.operation)) leaf_name_data.push_back(bundle_interface_name.get_name_leafdata());
    if (bundle_status.is_set || is_set(bundle_status.operation)) leaf_name_data.push_back(bundle_status.get_name_leafdata());
    if (cisco_extensions.is_set || is_set(cisco_extensions.operation)) leaf_name_data.push_back(cisco_extensions.get_name_leafdata());
    if (collector_max_delay.is_set || is_set(collector_max_delay.operation)) leaf_name_data.push_back(collector_max_delay.get_name_leafdata());
    if (configured_bandwidth.is_set || is_set(configured_bandwidth.operation)) leaf_name_data.push_back(configured_bandwidth.get_name_leafdata());
    if (configured_foreign_member_count.is_set || is_set(configured_foreign_member_count.operation)) leaf_name_data.push_back(configured_foreign_member_count.get_name_leafdata());
    if (configured_member_count.is_set || is_set(configured_member_count.operation)) leaf_name_data.push_back(configured_member_count.get_name_leafdata());
    if (effective_bandwidth.is_set || is_set(effective_bandwidth.operation)) leaf_name_data.push_back(effective_bandwidth.get_name_leafdata());
    if (iccp_group_id.is_set || is_set(iccp_group_id.operation)) leaf_name_data.push_back(iccp_group_id.get_name_leafdata());
    if (inter_chassis.is_set || is_set(inter_chassis.operation)) leaf_name_data.push_back(inter_chassis.get_name_leafdata());
    if (ipv4bfd_status.is_set || is_set(ipv4bfd_status.operation)) leaf_name_data.push_back(ipv4bfd_status.get_name_leafdata());
    if (ipv6bfd_status.is_set || is_set(ipv6bfd_status.operation)) leaf_name_data.push_back(ipv6bfd_status.get_name_leafdata());
    if (is_active.is_set || is_set(is_active.operation)) leaf_name_data.push_back(is_active.get_name_leafdata());
    if (lacp_nonrevertive.is_set || is_set(lacp_nonrevertive.operation)) leaf_name_data.push_back(lacp_nonrevertive.get_name_leafdata());
    if (lacp_status.is_set || is_set(lacp_status.operation)) leaf_name_data.push_back(lacp_status.get_name_leafdata());
    if (link_order_status.is_set || is_set(link_order_status.operation)) leaf_name_data.push_back(link_order_status.get_name_leafdata());
    if (load_balance_hash_type.is_set || is_set(load_balance_hash_type.operation)) leaf_name_data.push_back(load_balance_hash_type.get_name_leafdata());
    if (load_balance_locality_threshold.is_set || is_set(load_balance_locality_threshold.operation)) leaf_name_data.push_back(load_balance_locality_threshold.get_name_leafdata());
    if (mac_source.is_set || is_set(mac_source.operation)) leaf_name_data.push_back(mac_source.get_name_leafdata());
    if (mac_source_member.is_set || is_set(mac_source_member.operation)) leaf_name_data.push_back(mac_source_member.get_name_leafdata());
    if (maximize_threshold_value_band_width.is_set || is_set(maximize_threshold_value_band_width.operation)) leaf_name_data.push_back(maximize_threshold_value_band_width.get_name_leafdata());
    if (maximize_threshold_value_links.is_set || is_set(maximize_threshold_value_links.operation)) leaf_name_data.push_back(maximize_threshold_value_links.get_name_leafdata());
    if (maximum_active_links.is_set || is_set(maximum_active_links.operation)) leaf_name_data.push_back(maximum_active_links.get_name_leafdata());
    if (maximum_active_links_source.is_set || is_set(maximum_active_links_source.operation)) leaf_name_data.push_back(maximum_active_links_source.get_name_leafdata());
    if (minimum_active_links.is_set || is_set(minimum_active_links.operation)) leaf_name_data.push_back(minimum_active_links.get_name_leafdata());
    if (minimum_bandwidth.is_set || is_set(minimum_bandwidth.operation)) leaf_name_data.push_back(minimum_bandwidth.get_name_leafdata());
    if (mlacp_mode.is_set || is_set(mlacp_mode.operation)) leaf_name_data.push_back(mlacp_mode.get_name_leafdata());
    if (mlacp_status.is_set || is_set(mlacp_status.operation)) leaf_name_data.push_back(mlacp_status.get_name_leafdata());
    if (primary_member.is_set || is_set(primary_member.operation)) leaf_name_data.push_back(primary_member.get_name_leafdata());
    if (recovery_delay.is_set || is_set(recovery_delay.operation)) leaf_name_data.push_back(recovery_delay.get_name_leafdata());
    if (singleton.is_set || is_set(singleton.operation)) leaf_name_data.push_back(singleton.get_name_leafdata());
    if (standby_member_count.is_set || is_set(standby_member_count.operation)) leaf_name_data.push_back(standby_member_count.get_name_leafdata());
    if (suppression_timer.is_set || is_set(suppression_timer.operation)) leaf_name_data.push_back(suppression_timer.get_name_leafdata());
    if (switchover_type.is_set || is_set(switchover_type.operation)) leaf_name_data.push_back(switchover_type.get_name_leafdata());
    if (wait_while_timer.is_set || is_set(wait_while_timer.operation)) leaf_name_data.push_back(wait_while_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd-config")
    {
        for(auto const & c : bfd_config)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bundles::Bundles_::Bundle::Data::BfdConfig>();
        c->parent = this;
        bfd_config.push_back(std::move(c));
        children[segment_path] = bfd_config.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<Bundles::Bundles_::Bundle::Data::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Data::get_children()
{
    for (auto const & c : bfd_config)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    return children;
}

void Bundles::Bundles_::Bundle::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-foreign-member-count")
    {
        active_foreign_member_count = value;
    }
    if(value_path == "active-member-count")
    {
        active_member_count = value;
    }
    if(value_path == "available-bandwidth")
    {
        available_bandwidth = value;
    }
    if(value_path == "bundle-interface-name")
    {
        bundle_interface_name = value;
    }
    if(value_path == "bundle-status")
    {
        bundle_status = value;
    }
    if(value_path == "cisco-extensions")
    {
        cisco_extensions = value;
    }
    if(value_path == "collector-max-delay")
    {
        collector_max_delay = value;
    }
    if(value_path == "configured-bandwidth")
    {
        configured_bandwidth = value;
    }
    if(value_path == "configured-foreign-member-count")
    {
        configured_foreign_member_count = value;
    }
    if(value_path == "configured-member-count")
    {
        configured_member_count = value;
    }
    if(value_path == "effective-bandwidth")
    {
        effective_bandwidth = value;
    }
    if(value_path == "iccp-group-id")
    {
        iccp_group_id = value;
    }
    if(value_path == "inter-chassis")
    {
        inter_chassis = value;
    }
    if(value_path == "ipv4bfd-status")
    {
        ipv4bfd_status = value;
    }
    if(value_path == "ipv6bfd-status")
    {
        ipv6bfd_status = value;
    }
    if(value_path == "is-active")
    {
        is_active = value;
    }
    if(value_path == "lacp-nonrevertive")
    {
        lacp_nonrevertive = value;
    }
    if(value_path == "lacp-status")
    {
        lacp_status = value;
    }
    if(value_path == "link-order-status")
    {
        link_order_status = value;
    }
    if(value_path == "load-balance-hash-type")
    {
        load_balance_hash_type = value;
    }
    if(value_path == "load-balance-locality-threshold")
    {
        load_balance_locality_threshold = value;
    }
    if(value_path == "mac-source")
    {
        mac_source = value;
    }
    if(value_path == "mac-source-member")
    {
        mac_source_member = value;
    }
    if(value_path == "maximize-threshold-value-band-width")
    {
        maximize_threshold_value_band_width = value;
    }
    if(value_path == "maximize-threshold-value-links")
    {
        maximize_threshold_value_links = value;
    }
    if(value_path == "maximum-active-links")
    {
        maximum_active_links = value;
    }
    if(value_path == "maximum-active-links-source")
    {
        maximum_active_links_source = value;
    }
    if(value_path == "minimum-active-links")
    {
        minimum_active_links = value;
    }
    if(value_path == "minimum-bandwidth")
    {
        minimum_bandwidth = value;
    }
    if(value_path == "mlacp-mode")
    {
        mlacp_mode = value;
    }
    if(value_path == "mlacp-status")
    {
        mlacp_status = value;
    }
    if(value_path == "primary-member")
    {
        primary_member = value;
    }
    if(value_path == "recovery-delay")
    {
        recovery_delay = value;
    }
    if(value_path == "singleton")
    {
        singleton = value;
    }
    if(value_path == "standby-member-count")
    {
        standby_member_count = value;
    }
    if(value_path == "suppression-timer")
    {
        suppression_timer = value;
    }
    if(value_path == "switchover-type")
    {
        switchover_type = value;
    }
    if(value_path == "wait-while-timer")
    {
        wait_while_timer = value;
    }
}

Bundles::Bundles_::Bundle::Members::Member::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"}
{
    yang_name = "counters"; yang_parent_name = "member";
}

Bundles::Bundles_::Bundle::Members::Member::Counters::~Counters()
{
}

bool Bundles::Bundles_::Bundle::Members::Member::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set;
}

bool Bundles::Bundles_::Bundle::Members::Member::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation);
}

std::string Bundles::Bundles_::Bundle::Members::Member::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::Member::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::Member::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::Member::Counters::get_children()
{
    return children;
}

void Bundles::Bundles_::Bundle::Members::Member::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
}

Bundles::Bundles_::Bundle::Members::Member::LinkData::LinkData()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "link-data"; yang_parent_name = "member";
}

Bundles::Bundles_::Bundle::Members::Member::LinkData::~LinkData()
{
}

bool Bundles::Bundles_::Bundle::Members::Member::LinkData::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool Bundles::Bundles_::Bundle::Members::Member::LinkData::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string Bundles::Bundles_::Bundle::Members::Member::LinkData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-data";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::Member::LinkData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::Member::LinkData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::Member::LinkData::get_children()
{
    return children;
}

void Bundles::Bundles_::Bundle::Members::Member::LinkData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::MemberMuxStateReasonData()
    :
    	reason_type{YType::enumeration, "reason-type"},
	 severity{YType::enumeration, "severity"}
{
    yang_name = "member-mux-state-reason-data"; yang_parent_name = "member-mux-data";
}

Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::~MemberMuxStateReasonData()
{
}

bool Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::has_data() const
{
    return reason_type.is_set
	|| severity.is_set;
}

bool Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::has_operation() const
{
    return is_set(operation)
	|| is_set(reason_type.operation)
	|| is_set(severity.operation);
}

std::string Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-state-reason-data";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reason_type.is_set || is_set(reason_type.operation)) leaf_name_data.push_back(reason_type.get_name_leafdata());
    if (severity.is_set || is_set(severity.operation)) leaf_name_data.push_back(severity.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::get_children()
{
    return children;
}

void Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reason-type")
    {
        reason_type = value;
    }
    if(value_path == "severity")
    {
        severity = value;
    }
}

Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxData()
    :
    	error{YType::uint32, "error"},
	 member_mux_state_reason{YType::enumeration, "member-mux-state-reason"},
	 member_state{YType::enumeration, "member-state"},
	 mux_state{YType::enumeration, "mux-state"},
	 mux_state_reason{YType::enumeration, "mux-state-reason"}
    	,
    member_mux_state_reason_data(std::make_unique<Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData>())
{
    member_mux_state_reason_data->parent = this;
    children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();

    yang_name = "member-mux-data"; yang_parent_name = "member";
}

Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::~MemberMuxData()
{
}

bool Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::has_data() const
{
    return error.is_set
	|| member_mux_state_reason.is_set
	|| member_state.is_set
	|| mux_state.is_set
	|| mux_state_reason.is_set
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_data());
}

bool Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::has_operation() const
{
    return is_set(operation)
	|| is_set(error.operation)
	|| is_set(member_mux_state_reason.operation)
	|| is_set(member_state.operation)
	|| is_set(mux_state.operation)
	|| is_set(mux_state_reason.operation)
	|| (member_mux_state_reason_data !=  nullptr && member_mux_state_reason_data->has_operation());
}

std::string Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member-mux-data";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (error.is_set || is_set(error.operation)) leaf_name_data.push_back(error.get_name_leafdata());
    if (member_mux_state_reason.is_set || is_set(member_mux_state_reason.operation)) leaf_name_data.push_back(member_mux_state_reason.get_name_leafdata());
    if (member_state.is_set || is_set(member_state.operation)) leaf_name_data.push_back(member_state.get_name_leafdata());
    if (mux_state.is_set || is_set(mux_state.operation)) leaf_name_data.push_back(mux_state.get_name_leafdata());
    if (mux_state_reason.is_set || is_set(mux_state_reason.operation)) leaf_name_data.push_back(mux_state_reason.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member-mux-state-reason-data")
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        else
        {
            member_mux_state_reason_data = std::make_unique<Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::MemberMuxStateReasonData>();
            member_mux_state_reason_data->parent = this;
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
        return children.at("member-mux-state-reason-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::get_children()
{
    if(children.find("member-mux-state-reason-data") == children.end())
    {
        if(member_mux_state_reason_data != nullptr)
        {
            children["member-mux-state-reason-data"] = member_mux_state_reason_data.get();
        }
    }

    return children;
}

void Bundles::Bundles_::Bundle::Members::Member::MemberMuxData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "error")
    {
        error = value;
    }
    if(value_path == "member-mux-state-reason")
    {
        member_mux_state_reason = value;
    }
    if(value_path == "member-state")
    {
        member_state = value;
    }
    if(value_path == "mux-state")
    {
        mux_state = value;
    }
    if(value_path == "mux-state-reason")
    {
        mux_state_reason = value;
    }
}

Bundles::Bundles_::Bundle::Members::Member::MacAddress::MacAddress()
    :
    	address{YType::str, "address"}
{
    yang_name = "mac-address"; yang_parent_name = "member";
}

Bundles::Bundles_::Bundle::Members::Member::MacAddress::~MacAddress()
{
}

bool Bundles::Bundles_::Bundle::Members::Member::MacAddress::has_data() const
{
    return address.is_set;
}

bool Bundles::Bundles_::Bundle::Members::Member::MacAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation);
}

std::string Bundles::Bundles_::Bundle::Members::Member::MacAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mac-address";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::Member::MacAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::Member::MacAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::Member::MacAddress::get_children()
{
    return children;
}

void Bundles::Bundles_::Bundle::Members::Member::MacAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

Bundles::Bundles_::Bundle::Members::Member::Member()
    :
    	member_interface{YType::str, "member-interface"},
	 bandwidth{YType::uint32, "bandwidth"},
	 iccp_node{YType::uint32, "iccp-node"},
	 interface_name{YType::str, "interface-name"},
	 link_order_number{YType::uint16, "link-order-number"},
	 member_name{YType::str, "member-name"},
	 member_type{YType::enumeration, "member-type"},
	 port_number{YType::uint16, "port-number"},
	 port_priority{YType::uint16, "port-priority"},
	 underlying_link_id{YType::uint16, "underlying-link-id"}
    	,
    counters(std::make_unique<Bundles::Bundles_::Bundle::Members::Member::Counters>())
	,link_data(std::make_unique<Bundles::Bundles_::Bundle::Members::Member::LinkData>())
	,mac_address(std::make_unique<Bundles::Bundles_::Bundle::Members::Member::MacAddress>())
	,member_mux_data(std::make_unique<Bundles::Bundles_::Bundle::Members::Member::MemberMuxData>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    link_data->parent = this;
    children["link-data"] = link_data.get();

    mac_address->parent = this;
    children["mac-address"] = mac_address.get();

    member_mux_data->parent = this;
    children["member-mux-data"] = member_mux_data.get();

    yang_name = "member"; yang_parent_name = "members";
}

Bundles::Bundles_::Bundle::Members::Member::~Member()
{
}

bool Bundles::Bundles_::Bundle::Members::Member::has_data() const
{
    return member_interface.is_set
	|| bandwidth.is_set
	|| iccp_node.is_set
	|| interface_name.is_set
	|| link_order_number.is_set
	|| member_name.is_set
	|| member_type.is_set
	|| port_number.is_set
	|| port_priority.is_set
	|| underlying_link_id.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (link_data !=  nullptr && link_data->has_data())
	|| (mac_address !=  nullptr && mac_address->has_data())
	|| (member_mux_data !=  nullptr && member_mux_data->has_data());
}

bool Bundles::Bundles_::Bundle::Members::Member::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| is_set(bandwidth.operation)
	|| is_set(iccp_node.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_order_number.operation)
	|| is_set(member_name.operation)
	|| is_set(member_type.operation)
	|| is_set(port_number.operation)
	|| is_set(port_priority.operation)
	|| is_set(underlying_link_id.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (link_data !=  nullptr && link_data->has_operation())
	|| (mac_address !=  nullptr && mac_address->has_operation())
	|| (member_mux_data !=  nullptr && member_mux_data->has_operation());
}

std::string Bundles::Bundles_::Bundle::Members::Member::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::Member::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());
    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (iccp_node.is_set || is_set(iccp_node.operation)) leaf_name_data.push_back(iccp_node.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());
    if (member_name.is_set || is_set(member_name.operation)) leaf_name_data.push_back(member_name.get_name_leafdata());
    if (member_type.is_set || is_set(member_type.operation)) leaf_name_data.push_back(member_type.get_name_leafdata());
    if (port_number.is_set || is_set(port_number.operation)) leaf_name_data.push_back(port_number.get_name_leafdata());
    if (port_priority.is_set || is_set(port_priority.operation)) leaf_name_data.push_back(port_priority.get_name_leafdata());
    if (underlying_link_id.is_set || is_set(underlying_link_id.operation)) leaf_name_data.push_back(underlying_link_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::Member::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<Bundles::Bundles_::Bundle::Members::Member::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "link-data")
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
        else
        {
            link_data = std::make_unique<Bundles::Bundles_::Bundle::Members::Member::LinkData>();
            link_data->parent = this;
            children["link-data"] = link_data.get();
        }
        return children.at("link-data");
    }

    if(child_yang_name == "mac-address")
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
        else
        {
            mac_address = std::make_unique<Bundles::Bundles_::Bundle::Members::Member::MacAddress>();
            mac_address->parent = this;
            children["mac-address"] = mac_address.get();
        }
        return children.at("mac-address");
    }

    if(child_yang_name == "member-mux-data")
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
        else
        {
            member_mux_data = std::make_unique<Bundles::Bundles_::Bundle::Members::Member::MemberMuxData>();
            member_mux_data->parent = this;
            children["member-mux-data"] = member_mux_data.get();
        }
        return children.at("member-mux-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::Member::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("link-data") == children.end())
    {
        if(link_data != nullptr)
        {
            children["link-data"] = link_data.get();
        }
    }

    if(children.find("mac-address") == children.end())
    {
        if(mac_address != nullptr)
        {
            children["mac-address"] = mac_address.get();
        }
    }

    if(children.find("member-mux-data") == children.end())
    {
        if(member_mux_data != nullptr)
        {
            children["member-mux-data"] = member_mux_data.get();
        }
    }

    return children;
}

void Bundles::Bundles_::Bundle::Members::Member::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "iccp-node")
    {
        iccp_node = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
    if(value_path == "member-name")
    {
        member_name = value;
    }
    if(value_path == "member-type")
    {
        member_type = value;
    }
    if(value_path == "port-number")
    {
        port_number = value;
    }
    if(value_path == "port-priority")
    {
        port_priority = value;
    }
    if(value_path == "underlying-link-id")
    {
        underlying_link_id = value;
    }
}

Bundles::Bundles_::Bundle::Members::Members()
{
    yang_name = "members"; yang_parent_name = "bundle";
}

Bundles::Bundles_::Bundle::Members::~Members()
{
}

bool Bundles::Bundles_::Bundle::Members::has_data() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_data())
            return true;
    }
    return false;
}

bool Bundles::Bundles_::Bundle::Members::has_operation() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bundles::Bundles_::Bundle::Members::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "members";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::Members::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::Members::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member")
    {
        for(auto const & c : member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bundles::Bundles_::Bundle::Members::Member>();
        c->parent = this;
        member.push_back(std::move(c));
        children[segment_path] = member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::Members::get_children()
{
    for (auto const & c : member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bundles::Bundles_::Bundle::Members::set_value(const std::string & value_path, std::string value)
{
}

Bundles::Bundles_::Bundle::Bundle()
    :
    	bundle_interface{YType::str, "bundle-interface"}
    	,
    data(std::make_unique<Bundles::Bundles_::Bundle::Data>())
	,members(std::make_unique<Bundles::Bundles_::Bundle::Members>())
{
    data->parent = this;
    children["data"] = data.get();

    members->parent = this;
    children["members"] = members.get();

    yang_name = "bundle"; yang_parent_name = "bundles";
}

Bundles::Bundles_::Bundle::~Bundle()
{
}

bool Bundles::Bundles_::Bundle::has_data() const
{
    return bundle_interface.is_set
	|| (data !=  nullptr && data->has_data())
	|| (members !=  nullptr && members->has_data());
}

bool Bundles::Bundles_::Bundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_interface.operation)
	|| (data !=  nullptr && data->has_operation())
	|| (members !=  nullptr && members->has_operation());
}

std::string Bundles::Bundles_::Bundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle" <<"[bundle-interface='" <<bundle_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::Bundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundles/bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_interface.is_set || is_set(bundle_interface.operation)) leaf_name_data.push_back(bundle_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::Bundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<Bundles::Bundles_::Bundle::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    if(child_yang_name == "members")
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
        else
        {
            members = std::make_unique<Bundles::Bundles_::Bundle::Members>();
            members->parent = this;
            children["members"] = members.get();
        }
        return children.at("members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::Bundle::get_children()
{
    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    if(children.find("members") == children.end())
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
    }

    return children;
}

void Bundles::Bundles_::Bundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-interface")
    {
        bundle_interface = value;
    }
}

Bundles::Bundles_::Bundles_()
{
    yang_name = "bundles"; yang_parent_name = "bundles";
}

Bundles::Bundles_::~Bundles_()
{
}

bool Bundles::Bundles_::has_data() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_data())
            return true;
    }
    return false;
}

bool Bundles::Bundles_::has_operation() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bundles::Bundles_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundles";

    return path_buffer.str();

}

EntityPath Bundles::Bundles_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundles/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::Bundles_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle")
    {
        for(auto const & c : bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bundles::Bundles_::Bundle>();
        c->parent = this;
        bundle.push_back(std::move(c));
        children[segment_path] = bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::Bundles_::get_children()
{
    for (auto const & c : bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bundles::Bundles_::set_value(const std::string & value_path, std::string value)
{
}

Bundles::Bundles()
    :
    bundles(std::make_unique<Bundles::Bundles_>())
{
    bundles->parent = this;
    children["bundles"] = bundles.get();

    yang_name = "bundles"; yang_parent_name = "Cisco-IOS-XR-bundlemgr-oper";
}

Bundles::~Bundles()
{
}

bool Bundles::has_data() const
{
    return (bundles !=  nullptr && bundles->has_data());
}

bool Bundles::has_operation() const
{
    return is_set(operation)
	|| (bundles !=  nullptr && bundles->has_operation());
}

std::string Bundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundles";

    return path_buffer.str();

}

EntityPath Bundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundles")
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
        else
        {
            bundles = std::make_unique<Bundles::Bundles_>();
            bundles->parent = this;
            children["bundles"] = bundles.get();
        }
        return children.at("bundles");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bundles::get_children()
{
    if(children.find("bundles") == children.end())
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
    }

    return children;
}

void Bundles::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> Bundles::clone_ptr()
{
    return std::make_unique<Bundles>();
}
LacpBundleMembers::Nodes::Node::Counters::Counters()
    :
    	last_wrong_port{YType::uint32, "last-wrong-port"},
	 time_since_cleared{YType::uint64, "time-since-cleared"},
	 time_since_last_updated{YType::uint64, "time-since-last-updated"},
	 time_since_unexpected_event{YType::uint64, "time-since-unexpected-event"},
	 undecodable_packets{YType::uint32, "undecodable-packets"},
	 unknown_port_count{YType::uint32, "unknown-port-count"},
	 wrong_port_count{YType::uint32, "wrong-port-count"}
{
    yang_name = "counters"; yang_parent_name = "node";
}

LacpBundleMembers::Nodes::Node::Counters::~Counters()
{
}

bool LacpBundleMembers::Nodes::Node::Counters::has_data() const
{
    return last_wrong_port.is_set
	|| time_since_cleared.is_set
	|| time_since_last_updated.is_set
	|| time_since_unexpected_event.is_set
	|| undecodable_packets.is_set
	|| unknown_port_count.is_set
	|| wrong_port_count.is_set;
}

bool LacpBundleMembers::Nodes::Node::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(last_wrong_port.operation)
	|| is_set(time_since_cleared.operation)
	|| is_set(time_since_last_updated.operation)
	|| is_set(time_since_unexpected_event.operation)
	|| is_set(undecodable_packets.operation)
	|| is_set(unknown_port_count.operation)
	|| is_set(wrong_port_count.operation);
}

std::string LacpBundleMembers::Nodes::Node::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Nodes::Node::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (last_wrong_port.is_set || is_set(last_wrong_port.operation)) leaf_name_data.push_back(last_wrong_port.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());
    if (time_since_last_updated.is_set || is_set(time_since_last_updated.operation)) leaf_name_data.push_back(time_since_last_updated.get_name_leafdata());
    if (time_since_unexpected_event.is_set || is_set(time_since_unexpected_event.operation)) leaf_name_data.push_back(time_since_unexpected_event.get_name_leafdata());
    if (undecodable_packets.is_set || is_set(undecodable_packets.operation)) leaf_name_data.push_back(undecodable_packets.get_name_leafdata());
    if (unknown_port_count.is_set || is_set(unknown_port_count.operation)) leaf_name_data.push_back(unknown_port_count.get_name_leafdata());
    if (wrong_port_count.is_set || is_set(wrong_port_count.operation)) leaf_name_data.push_back(wrong_port_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Nodes::Node::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Nodes::Node::Counters::get_children()
{
    return children;
}

void LacpBundleMembers::Nodes::Node::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "last-wrong-port")
    {
        last_wrong_port = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
    if(value_path == "time-since-last-updated")
    {
        time_since_last_updated = value;
    }
    if(value_path == "time-since-unexpected-event")
    {
        time_since_unexpected_event = value;
    }
    if(value_path == "undecodable-packets")
    {
        undecodable_packets = value;
    }
    if(value_path == "unknown-port-count")
    {
        unknown_port_count = value;
    }
    if(value_path == "wrong-port-count")
    {
        wrong_port_count = value;
    }
}

LacpBundleMembers::Nodes::Node::Node()
    :
    	node{YType::str, "node"}
    	,
    counters(std::make_unique<LacpBundleMembers::Nodes::Node::Counters>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    yang_name = "node"; yang_parent_name = "nodes";
}

LacpBundleMembers::Nodes::Node::~Node()
{
}

bool LacpBundleMembers::Nodes::Node::has_data() const
{
    return node.is_set
	|| (counters !=  nullptr && counters->has_data());
}

bool LacpBundleMembers::Nodes::Node::has_operation() const
{
    return is_set(operation)
	|| is_set(node.operation)
	|| (counters !=  nullptr && counters->has_operation());
}

std::string LacpBundleMembers::Nodes::Node::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node" <<"[node='" <<node.get() <<"']";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Nodes::Node::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundle-members/nodes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node.is_set || is_set(node.operation)) leaf_name_data.push_back(node.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Nodes::Node::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<LacpBundleMembers::Nodes::Node::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Nodes::Node::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    return children;
}

void LacpBundleMembers::Nodes::Node::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node")
    {
        node = value;
    }
}

LacpBundleMembers::Nodes::Nodes()
{
    yang_name = "nodes"; yang_parent_name = "lacp-bundle-members";
}

LacpBundleMembers::Nodes::~Nodes()
{
}

bool LacpBundleMembers::Nodes::has_data() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_data())
            return true;
    }
    return false;
}

bool LacpBundleMembers::Nodes::has_operation() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string LacpBundleMembers::Nodes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodes";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Nodes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundle-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Nodes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node")
    {
        for(auto const & c : node)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<LacpBundleMembers::Nodes::Node>();
        c->parent = this;
        node.push_back(std::move(c));
        children[segment_path] = node.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Nodes::get_children()
{
    for (auto const & c : node)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void LacpBundleMembers::Nodes::set_value(const std::string & value_path, std::string value)
{
}

LacpBundleMembers::Members::Member::Data::Data()
    :
    	actor_operational_key{YType::uint16, "actor-operational-key"},
	 actor_port_id{YType::uint16, "actor-port-id"},
	 actor_port_priority{YType::uint16, "actor-port-priority"},
	 actor_port_state{YType::uint8, "actor-port-state"},
	 actor_system_mac_address{YType::str, "actor-system-mac-address"},
	 actor_system_priority{YType::uint16, "actor-system-priority"},
	 attached_aggregator_id{YType::uint32, "attached-aggregator-id"},
	 interface_handle{YType::str, "interface-handle"},
	 partner_operational_key{YType::uint16, "partner-operational-key"},
	 partner_port_id{YType::uint16, "partner-port-id"},
	 partner_port_priority{YType::uint16, "partner-port-priority"},
	 partner_port_state{YType::uint8, "partner-port-state"},
	 partner_system_mac_address{YType::str, "partner-system-mac-address"},
	 partner_system_priority{YType::uint16, "partner-system-priority"},
	 selected_aggregator_id{YType::uint32, "selected-aggregator-id"}
{
    yang_name = "data"; yang_parent_name = "member";
}

LacpBundleMembers::Members::Member::Data::~Data()
{
}

bool LacpBundleMembers::Members::Member::Data::has_data() const
{
    return actor_operational_key.is_set
	|| actor_port_id.is_set
	|| actor_port_priority.is_set
	|| actor_port_state.is_set
	|| actor_system_mac_address.is_set
	|| actor_system_priority.is_set
	|| attached_aggregator_id.is_set
	|| interface_handle.is_set
	|| partner_operational_key.is_set
	|| partner_port_id.is_set
	|| partner_port_priority.is_set
	|| partner_port_state.is_set
	|| partner_system_mac_address.is_set
	|| partner_system_priority.is_set
	|| selected_aggregator_id.is_set;
}

bool LacpBundleMembers::Members::Member::Data::has_operation() const
{
    return is_set(operation)
	|| is_set(actor_operational_key.operation)
	|| is_set(actor_port_id.operation)
	|| is_set(actor_port_priority.operation)
	|| is_set(actor_port_state.operation)
	|| is_set(actor_system_mac_address.operation)
	|| is_set(actor_system_priority.operation)
	|| is_set(attached_aggregator_id.operation)
	|| is_set(interface_handle.operation)
	|| is_set(partner_operational_key.operation)
	|| is_set(partner_port_id.operation)
	|| is_set(partner_port_priority.operation)
	|| is_set(partner_port_state.operation)
	|| is_set(partner_system_mac_address.operation)
	|| is_set(partner_system_priority.operation)
	|| is_set(selected_aggregator_id.operation);
}

std::string LacpBundleMembers::Members::Member::Data::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "data";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Members::Member::Data::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (actor_operational_key.is_set || is_set(actor_operational_key.operation)) leaf_name_data.push_back(actor_operational_key.get_name_leafdata());
    if (actor_port_id.is_set || is_set(actor_port_id.operation)) leaf_name_data.push_back(actor_port_id.get_name_leafdata());
    if (actor_port_priority.is_set || is_set(actor_port_priority.operation)) leaf_name_data.push_back(actor_port_priority.get_name_leafdata());
    if (actor_port_state.is_set || is_set(actor_port_state.operation)) leaf_name_data.push_back(actor_port_state.get_name_leafdata());
    if (actor_system_mac_address.is_set || is_set(actor_system_mac_address.operation)) leaf_name_data.push_back(actor_system_mac_address.get_name_leafdata());
    if (actor_system_priority.is_set || is_set(actor_system_priority.operation)) leaf_name_data.push_back(actor_system_priority.get_name_leafdata());
    if (attached_aggregator_id.is_set || is_set(attached_aggregator_id.operation)) leaf_name_data.push_back(attached_aggregator_id.get_name_leafdata());
    if (interface_handle.is_set || is_set(interface_handle.operation)) leaf_name_data.push_back(interface_handle.get_name_leafdata());
    if (partner_operational_key.is_set || is_set(partner_operational_key.operation)) leaf_name_data.push_back(partner_operational_key.get_name_leafdata());
    if (partner_port_id.is_set || is_set(partner_port_id.operation)) leaf_name_data.push_back(partner_port_id.get_name_leafdata());
    if (partner_port_priority.is_set || is_set(partner_port_priority.operation)) leaf_name_data.push_back(partner_port_priority.get_name_leafdata());
    if (partner_port_state.is_set || is_set(partner_port_state.operation)) leaf_name_data.push_back(partner_port_state.get_name_leafdata());
    if (partner_system_mac_address.is_set || is_set(partner_system_mac_address.operation)) leaf_name_data.push_back(partner_system_mac_address.get_name_leafdata());
    if (partner_system_priority.is_set || is_set(partner_system_priority.operation)) leaf_name_data.push_back(partner_system_priority.get_name_leafdata());
    if (selected_aggregator_id.is_set || is_set(selected_aggregator_id.operation)) leaf_name_data.push_back(selected_aggregator_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Members::Member::Data::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Members::Member::Data::get_children()
{
    return children;
}

void LacpBundleMembers::Members::Member::Data::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "actor-operational-key")
    {
        actor_operational_key = value;
    }
    if(value_path == "actor-port-id")
    {
        actor_port_id = value;
    }
    if(value_path == "actor-port-priority")
    {
        actor_port_priority = value;
    }
    if(value_path == "actor-port-state")
    {
        actor_port_state = value;
    }
    if(value_path == "actor-system-mac-address")
    {
        actor_system_mac_address = value;
    }
    if(value_path == "actor-system-priority")
    {
        actor_system_priority = value;
    }
    if(value_path == "attached-aggregator-id")
    {
        attached_aggregator_id = value;
    }
    if(value_path == "interface-handle")
    {
        interface_handle = value;
    }
    if(value_path == "partner-operational-key")
    {
        partner_operational_key = value;
    }
    if(value_path == "partner-port-id")
    {
        partner_port_id = value;
    }
    if(value_path == "partner-port-priority")
    {
        partner_port_priority = value;
    }
    if(value_path == "partner-port-state")
    {
        partner_port_state = value;
    }
    if(value_path == "partner-system-mac-address")
    {
        partner_system_mac_address = value;
    }
    if(value_path == "partner-system-priority")
    {
        partner_system_priority = value;
    }
    if(value_path == "selected-aggregator-id")
    {
        selected_aggregator_id = value;
    }
}

LacpBundleMembers::Members::Member::Counters::Counters()
    :
    	defaulted{YType::uint32, "defaulted"},
	 excess_lacpd_us_received{YType::uint32, "excess-lacpd-us-received"},
	 excess_marker_packets_received{YType::uint32, "excess-marker-packets-received"},
	 expired{YType::uint32, "expired"},
	 illegal_packets_received{YType::uint32, "illegal-packets-received"},
	 lacpd_us_received{YType::uint32, "lacpd-us-received"},
	 lacpd_us_transmitted{YType::uint32, "lacpd-us-transmitted"},
	 last_cleared_nsec{YType::uint32, "last-cleared-nsec"},
	 last_cleared_sec{YType::uint32, "last-cleared-sec"},
	 marker_packets_received{YType::uint32, "marker-packets-received"},
	 marker_responses_transmitted{YType::uint32, "marker-responses-transmitted"},
	 time_since_cleared{YType::uint64, "time-since-cleared"},
	 time_since_last_lacpdu_received{YType::uint64, "time-since-last-lacpdu-received"},
	 time_since_unexpected_event{YType::uint64, "time-since-unexpected-event"}
{
    yang_name = "counters"; yang_parent_name = "member";
}

LacpBundleMembers::Members::Member::Counters::~Counters()
{
}

bool LacpBundleMembers::Members::Member::Counters::has_data() const
{
    return defaulted.is_set
	|| excess_lacpd_us_received.is_set
	|| excess_marker_packets_received.is_set
	|| expired.is_set
	|| illegal_packets_received.is_set
	|| lacpd_us_received.is_set
	|| lacpd_us_transmitted.is_set
	|| last_cleared_nsec.is_set
	|| last_cleared_sec.is_set
	|| marker_packets_received.is_set
	|| marker_responses_transmitted.is_set
	|| time_since_cleared.is_set
	|| time_since_last_lacpdu_received.is_set
	|| time_since_unexpected_event.is_set;
}

bool LacpBundleMembers::Members::Member::Counters::has_operation() const
{
    return is_set(operation)
	|| is_set(defaulted.operation)
	|| is_set(excess_lacpd_us_received.operation)
	|| is_set(excess_marker_packets_received.operation)
	|| is_set(expired.operation)
	|| is_set(illegal_packets_received.operation)
	|| is_set(lacpd_us_received.operation)
	|| is_set(lacpd_us_transmitted.operation)
	|| is_set(last_cleared_nsec.operation)
	|| is_set(last_cleared_sec.operation)
	|| is_set(marker_packets_received.operation)
	|| is_set(marker_responses_transmitted.operation)
	|| is_set(time_since_cleared.operation)
	|| is_set(time_since_last_lacpdu_received.operation)
	|| is_set(time_since_unexpected_event.operation);
}

std::string LacpBundleMembers::Members::Member::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Members::Member::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (defaulted.is_set || is_set(defaulted.operation)) leaf_name_data.push_back(defaulted.get_name_leafdata());
    if (excess_lacpd_us_received.is_set || is_set(excess_lacpd_us_received.operation)) leaf_name_data.push_back(excess_lacpd_us_received.get_name_leafdata());
    if (excess_marker_packets_received.is_set || is_set(excess_marker_packets_received.operation)) leaf_name_data.push_back(excess_marker_packets_received.get_name_leafdata());
    if (expired.is_set || is_set(expired.operation)) leaf_name_data.push_back(expired.get_name_leafdata());
    if (illegal_packets_received.is_set || is_set(illegal_packets_received.operation)) leaf_name_data.push_back(illegal_packets_received.get_name_leafdata());
    if (lacpd_us_received.is_set || is_set(lacpd_us_received.operation)) leaf_name_data.push_back(lacpd_us_received.get_name_leafdata());
    if (lacpd_us_transmitted.is_set || is_set(lacpd_us_transmitted.operation)) leaf_name_data.push_back(lacpd_us_transmitted.get_name_leafdata());
    if (last_cleared_nsec.is_set || is_set(last_cleared_nsec.operation)) leaf_name_data.push_back(last_cleared_nsec.get_name_leafdata());
    if (last_cleared_sec.is_set || is_set(last_cleared_sec.operation)) leaf_name_data.push_back(last_cleared_sec.get_name_leafdata());
    if (marker_packets_received.is_set || is_set(marker_packets_received.operation)) leaf_name_data.push_back(marker_packets_received.get_name_leafdata());
    if (marker_responses_transmitted.is_set || is_set(marker_responses_transmitted.operation)) leaf_name_data.push_back(marker_responses_transmitted.get_name_leafdata());
    if (time_since_cleared.is_set || is_set(time_since_cleared.operation)) leaf_name_data.push_back(time_since_cleared.get_name_leafdata());
    if (time_since_last_lacpdu_received.is_set || is_set(time_since_last_lacpdu_received.operation)) leaf_name_data.push_back(time_since_last_lacpdu_received.get_name_leafdata());
    if (time_since_unexpected_event.is_set || is_set(time_since_unexpected_event.operation)) leaf_name_data.push_back(time_since_unexpected_event.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Members::Member::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Members::Member::Counters::get_children()
{
    return children;
}

void LacpBundleMembers::Members::Member::Counters::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "defaulted")
    {
        defaulted = value;
    }
    if(value_path == "excess-lacpd-us-received")
    {
        excess_lacpd_us_received = value;
    }
    if(value_path == "excess-marker-packets-received")
    {
        excess_marker_packets_received = value;
    }
    if(value_path == "expired")
    {
        expired = value;
    }
    if(value_path == "illegal-packets-received")
    {
        illegal_packets_received = value;
    }
    if(value_path == "lacpd-us-received")
    {
        lacpd_us_received = value;
    }
    if(value_path == "lacpd-us-transmitted")
    {
        lacpd_us_transmitted = value;
    }
    if(value_path == "last-cleared-nsec")
    {
        last_cleared_nsec = value;
    }
    if(value_path == "last-cleared-sec")
    {
        last_cleared_sec = value;
    }
    if(value_path == "marker-packets-received")
    {
        marker_packets_received = value;
    }
    if(value_path == "marker-responses-transmitted")
    {
        marker_responses_transmitted = value;
    }
    if(value_path == "time-since-cleared")
    {
        time_since_cleared = value;
    }
    if(value_path == "time-since-last-lacpdu-received")
    {
        time_since_last_lacpdu_received = value;
    }
    if(value_path == "time-since-unexpected-event")
    {
        time_since_unexpected_event = value;
    }
}

LacpBundleMembers::Members::Member::Member()
    :
    	member_interface{YType::str, "member-interface"}
    	,
    counters(std::make_unique<LacpBundleMembers::Members::Member::Counters>())
	,data(std::make_unique<LacpBundleMembers::Members::Member::Data>())
{
    counters->parent = this;
    children["counters"] = counters.get();

    data->parent = this;
    children["data"] = data.get();

    yang_name = "member"; yang_parent_name = "members";
}

LacpBundleMembers::Members::Member::~Member()
{
}

bool LacpBundleMembers::Members::Member::has_data() const
{
    return member_interface.is_set
	|| (counters !=  nullptr && counters->has_data())
	|| (data !=  nullptr && data->has_data());
}

bool LacpBundleMembers::Members::Member::has_operation() const
{
    return is_set(operation)
	|| is_set(member_interface.operation)
	|| (counters !=  nullptr && counters->has_operation())
	|| (data !=  nullptr && data->has_operation());
}

std::string LacpBundleMembers::Members::Member::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member" <<"[member-interface='" <<member_interface.get() <<"']";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Members::Member::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundle-members/members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (member_interface.is_set || is_set(member_interface.operation)) leaf_name_data.push_back(member_interface.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Members::Member::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<LacpBundleMembers::Members::Member::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "data")
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
        else
        {
            data = std::make_unique<LacpBundleMembers::Members::Member::Data>();
            data->parent = this;
            children["data"] = data.get();
        }
        return children.at("data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Members::Member::get_children()
{
    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("data") == children.end())
    {
        if(data != nullptr)
        {
            children["data"] = data.get();
        }
    }

    return children;
}

void LacpBundleMembers::Members::Member::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "member-interface")
    {
        member_interface = value;
    }
}

LacpBundleMembers::Members::Members()
{
    yang_name = "members"; yang_parent_name = "lacp-bundle-members";
}

LacpBundleMembers::Members::~Members()
{
}

bool LacpBundleMembers::Members::has_data() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_data())
            return true;
    }
    return false;
}

bool LacpBundleMembers::Members::has_operation() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string LacpBundleMembers::Members::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "members";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::Members::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundle-members/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::Members::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "member")
    {
        for(auto const & c : member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<LacpBundleMembers::Members::Member>();
        c->parent = this;
        member.push_back(std::move(c));
        children[segment_path] = member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::Members::get_children()
{
    for (auto const & c : member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void LacpBundleMembers::Members::set_value(const std::string & value_path, std::string value)
{
}

LacpBundleMembers::LacpBundleMembers()
    :
    members(std::make_unique<LacpBundleMembers::Members>())
	,nodes(std::make_unique<LacpBundleMembers::Nodes>())
{
    members->parent = this;
    children["members"] = members.get();

    nodes->parent = this;
    children["nodes"] = nodes.get();

    yang_name = "lacp-bundle-members"; yang_parent_name = "Cisco-IOS-XR-bundlemgr-oper";
}

LacpBundleMembers::~LacpBundleMembers()
{
}

bool LacpBundleMembers::has_data() const
{
    return (members !=  nullptr && members->has_data())
	|| (nodes !=  nullptr && nodes->has_data());
}

bool LacpBundleMembers::has_operation() const
{
    return is_set(operation)
	|| (members !=  nullptr && members->has_operation())
	|| (nodes !=  nullptr && nodes->has_operation());
}

std::string LacpBundleMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-bundlemgr-oper:lacp-bundle-members";

    return path_buffer.str();

}

EntityPath LacpBundleMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* LacpBundleMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "members")
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
        else
        {
            members = std::make_unique<LacpBundleMembers::Members>();
            members->parent = this;
            children["members"] = members.get();
        }
        return children.at("members");
    }

    if(child_yang_name == "nodes")
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
        else
        {
            nodes = std::make_unique<LacpBundleMembers::Nodes>();
            nodes->parent = this;
            children["nodes"] = nodes.get();
        }
        return children.at("nodes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & LacpBundleMembers::get_children()
{
    if(children.find("members") == children.end())
    {
        if(members != nullptr)
        {
            children["members"] = members.get();
        }
    }

    if(children.find("nodes") == children.end())
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
    }

    return children;
}

void LacpBundleMembers::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> LacpBundleMembers::clone_ptr()
{
    return std::make_unique<LacpBundleMembers>();
}
BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::LoadBalanceData()
    :
    	local_link_threshold{YType::uint32, "local-link-threshold"},
	 type{YType::enumeration, "type"},
	 value_{YType::uint32, "value"}
{
    yang_name = "load-balance-data"; yang_parent_name = "sub-interface";
}

BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::~LoadBalanceData()
{
}

bool BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::has_data() const
{
    return local_link_threshold.is_set
	|| type.is_set
	|| value_.is_set;
}

bool BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::has_operation() const
{
    return is_set(operation)
	|| is_set(local_link_threshold.operation)
	|| is_set(type.operation)
	|| is_set(value_.operation);
}

std::string BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "load-balance-data";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_link_threshold.is_set || is_set(local_link_threshold.operation)) leaf_name_data.push_back(local_link_threshold.get_name_leafdata());
    if (type.is_set || is_set(type.operation)) leaf_name_data.push_back(type.get_name_leafdata());
    if (value_.is_set || is_set(value_.operation)) leaf_name_data.push_back(value_.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::get_children()
{
    return children;
}

void BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-link-threshold")
    {
        local_link_threshold = value;
    }
    if(value_path == "type")
    {
        type = value;
    }
    if(value_path == "value")
    {
        value_ = value;
    }
}

BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::SubInterface()
    :
    	interface_name{YType::str, "interface-name"}
    	,
    load_balance_data(std::make_unique<BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData>())
{
    load_balance_data->parent = this;
    children["load-balance-data"] = load_balance_data.get();

    yang_name = "sub-interface"; yang_parent_name = "bundle-data";
}

BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::~SubInterface()
{
}

bool BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::has_data() const
{
    return interface_name.is_set
	|| (load_balance_data !=  nullptr && load_balance_data->has_data());
}

bool BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| (load_balance_data !=  nullptr && load_balance_data->has_operation());
}

std::string BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "sub-interface";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "load-balance-data")
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
        else
        {
            load_balance_data = std::make_unique<BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::LoadBalanceData>();
            load_balance_data->parent = this;
            children["load-balance-data"] = load_balance_data.get();
        }
        return children.at("load-balance-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::get_children()
{
    if(children.find("load-balance-data") == children.end())
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
}

BundlesAdjacency::Nodes::Node::Brief::BundleData::BundleData()
    :
    	interface_name{YType::str, "interface-name"},
	 member_count{YType::uint32, "member-count"},
	 sub_interface_count{YType::uint32, "sub-interface-count"},
	 total_weight{YType::uint32, "total-weight"}
{
    yang_name = "bundle-data"; yang_parent_name = "brief";
}

BundlesAdjacency::Nodes::Node::Brief::BundleData::~BundleData()
{
}

bool BundlesAdjacency::Nodes::Node::Brief::BundleData::has_data() const
{
    for (std::size_t index=0; index<sub_interface.size(); index++)
    {
        if(sub_interface[index]->has_data())
            return true;
    }
    return interface_name.is_set
	|| member_count.is_set
	|| sub_interface_count.is_set
	|| total_weight.is_set;
}

bool BundlesAdjacency::Nodes::Node::Brief::BundleData::has_operation() const
{
    for (std::size_t index=0; index<sub_interface.size(); index++)
    {
        if(sub_interface[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(member_count.operation)
	|| is_set(sub_interface_count.operation)
	|| is_set(total_weight.operation);
}

std::string BundlesAdjacency::Nodes::Node::Brief::BundleData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-data";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Brief::BundleData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (member_count.is_set || is_set(member_count.operation)) leaf_name_data.push_back(member_count.get_name_leafdata());
    if (sub_interface_count.is_set || is_set(sub_interface_count.operation)) leaf_name_data.push_back(sub_interface_count.get_name_leafdata());
    if (total_weight.is_set || is_set(total_weight.operation)) leaf_name_data.push_back(total_weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Brief::BundleData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "sub-interface")
    {
        for(auto const & c : sub_interface)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node::Brief::BundleData::SubInterface>();
        c->parent = this;
        sub_interface.push_back(std::move(c));
        children[segment_path] = sub_interface.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Brief::BundleData::get_children()
{
    for (auto const & c : sub_interface)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Brief::BundleData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "member-count")
    {
        member_count = value;
    }
    if(value_path == "sub-interface-count")
    {
        sub_interface_count = value;
    }
    if(value_path == "total-weight")
    {
        total_weight = value;
    }
}

BundlesAdjacency::Nodes::Node::Brief::Brief()
{
    yang_name = "brief"; yang_parent_name = "node";
}

BundlesAdjacency::Nodes::Node::Brief::~Brief()
{
}

bool BundlesAdjacency::Nodes::Node::Brief::has_data() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_data())
            return true;
    }
    return false;
}

bool BundlesAdjacency::Nodes::Node::Brief::has_operation() const
{
    for (std::size_t index=0; index<bundle_data.size(); index++)
    {
        if(bundle_data[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundlesAdjacency::Nodes::Node::Brief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "brief";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Brief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Brief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-data")
    {
        for(auto const & c : bundle_data)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node::Brief::BundleData>();
        c->parent = this;
        bundle_data.push_back(std::move(c));
        children[segment_path] = bundle_data.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Brief::get_children()
{
    for (auto const & c : bundle_data)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Brief::set_value(const std::string & value_path, std::string value)
{
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::LoadBalanceData()
    :
    	local_link_threshold{YType::uint32, "local-link-threshold"},
	 type{YType::enumeration, "type"},
	 value_{YType::uint32, "value"}
{
    yang_name = "load-balance-data"; yang_parent_name = "sub-interface";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::~LoadBalanceData()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::has_data() const
{
    return local_link_threshold.is_set
	|| type.is_set
	|| value_.is_set;
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::has_operation() const
{
    return is_set(operation)
	|| is_set(local_link_threshold.operation)
	|| is_set(type.operation)
	|| is_set(value_.operation);
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "load-balance-data";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_link_threshold.is_set || is_set(local_link_threshold.operation)) leaf_name_data.push_back(local_link_threshold.get_name_leafdata());
    if (type.is_set || is_set(type.operation)) leaf_name_data.push_back(type.get_name_leafdata());
    if (value_.is_set || is_set(value_.operation)) leaf_name_data.push_back(value_.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::get_children()
{
    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-link-threshold")
    {
        local_link_threshold = value;
    }
    if(value_path == "type")
    {
        type = value;
    }
    if(value_path == "value")
    {
        value_ = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::SubInterface()
    :
    	interface_name{YType::str, "interface-name"}
    	,
    load_balance_data(std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData>())
{
    load_balance_data->parent = this;
    children["load-balance-data"] = load_balance_data.get();

    yang_name = "sub-interface"; yang_parent_name = "brief";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::~SubInterface()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::has_data() const
{
    return interface_name.is_set
	|| (load_balance_data !=  nullptr && load_balance_data->has_data());
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| (load_balance_data !=  nullptr && load_balance_data->has_operation());
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "sub-interface";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "load-balance-data")
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
        else
        {
            load_balance_data = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::LoadBalanceData>();
            load_balance_data->parent = this;
            children["load-balance-data"] = load_balance_data.get();
        }
        return children.at("load-balance-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::get_children()
{
    if(children.find("load-balance-data") == children.end())
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::Brief()
    :
    	interface_name{YType::str, "interface-name"},
	 member_count{YType::uint32, "member-count"},
	 sub_interface_count{YType::uint32, "sub-interface-count"},
	 total_weight{YType::uint32, "total-weight"}
{
    yang_name = "brief"; yang_parent_name = "bundle-info";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::~Brief()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::has_data() const
{
    for (std::size_t index=0; index<sub_interface.size(); index++)
    {
        if(sub_interface[index]->has_data())
            return true;
    }
    return interface_name.is_set
	|| member_count.is_set
	|| sub_interface_count.is_set
	|| total_weight.is_set;
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::has_operation() const
{
    for (std::size_t index=0; index<sub_interface.size(); index++)
    {
        if(sub_interface[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(member_count.operation)
	|| is_set(sub_interface_count.operation)
	|| is_set(total_weight.operation);
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "brief";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (member_count.is_set || is_set(member_count.operation)) leaf_name_data.push_back(member_count.get_name_leafdata());
    if (sub_interface_count.is_set || is_set(sub_interface_count.operation)) leaf_name_data.push_back(sub_interface_count.get_name_leafdata());
    if (total_weight.is_set || is_set(total_weight.operation)) leaf_name_data.push_back(total_weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "sub-interface")
    {
        for(auto const & c : sub_interface)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::SubInterface>();
        c->parent = this;
        sub_interface.push_back(std::move(c));
        children[segment_path] = sub_interface.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::get_children()
{
    for (auto const & c : sub_interface)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "member-count")
    {
        member_count = value;
    }
    if(value_path == "sub-interface-count")
    {
        sub_interface_count = value;
    }
    if(value_path == "total-weight")
    {
        total_weight = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::LoadBalanceData()
    :
    	local_link_threshold{YType::uint32, "local-link-threshold"},
	 type{YType::enumeration, "type"},
	 value_{YType::uint32, "value"}
{
    yang_name = "load-balance-data"; yang_parent_name = "bundle-info";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::~LoadBalanceData()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::has_data() const
{
    return local_link_threshold.is_set
	|| type.is_set
	|| value_.is_set;
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::has_operation() const
{
    return is_set(operation)
	|| is_set(local_link_threshold.operation)
	|| is_set(type.operation)
	|| is_set(value_.operation);
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "load-balance-data";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_link_threshold.is_set || is_set(local_link_threshold.operation)) leaf_name_data.push_back(local_link_threshold.get_name_leafdata());
    if (type.is_set || is_set(type.operation)) leaf_name_data.push_back(type.get_name_leafdata());
    if (value_.is_set || is_set(value_.operation)) leaf_name_data.push_back(value_.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::get_children()
{
    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-link-threshold")
    {
        local_link_threshold = value;
    }
    if(value_path == "type")
    {
        type = value;
    }
    if(value_path == "value")
    {
        value_ = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::Member()
    :
    	bandwidth{YType::uint8, "bandwidth"},
	 interface_name{YType::str, "interface-name"},
	 link_id{YType::uint8, "link-id"},
	 link_order_number{YType::uint8, "link-order-number"}
{
    yang_name = "member"; yang_parent_name = "bundle-info";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::~Member()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::has_data() const
{
    return bandwidth.is_set
	|| interface_name.is_set
	|| link_id.is_set
	|| link_order_number.is_set;
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(interface_name.operation)
	|| is_set(link_id.operation)
	|| is_set(link_order_number.operation);
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "member";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (link_id.is_set || is_set(link_id.operation)) leaf_name_data.push_back(link_id.get_name_leafdata());
    if (link_order_number.is_set || is_set(link_order_number.operation)) leaf_name_data.push_back(link_order_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::get_children()
{
    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "link-id")
    {
        link_id = value;
    }
    if(value_path == "link-order-number")
    {
        link_order_number = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::LoadBalanceData()
    :
    	local_link_threshold{YType::uint32, "local-link-threshold"},
	 type{YType::enumeration, "type"},
	 value_{YType::uint32, "value"}
{
    yang_name = "load-balance-data"; yang_parent_name = "sub-interface";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::~LoadBalanceData()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::has_data() const
{
    return local_link_threshold.is_set
	|| type.is_set
	|| value_.is_set;
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::has_operation() const
{
    return is_set(operation)
	|| is_set(local_link_threshold.operation)
	|| is_set(type.operation)
	|| is_set(value_.operation);
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "load-balance-data";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_link_threshold.is_set || is_set(local_link_threshold.operation)) leaf_name_data.push_back(local_link_threshold.get_name_leafdata());
    if (type.is_set || is_set(type.operation)) leaf_name_data.push_back(type.get_name_leafdata());
    if (value_.is_set || is_set(value_.operation)) leaf_name_data.push_back(value_.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::get_children()
{
    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-link-threshold")
    {
        local_link_threshold = value;
    }
    if(value_path == "type")
    {
        type = value;
    }
    if(value_path == "value")
    {
        value_ = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::SubInterface()
    :
    	interface_name{YType::str, "interface-name"}
    	,
    load_balance_data(std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData>())
{
    load_balance_data->parent = this;
    children["load-balance-data"] = load_balance_data.get();

    yang_name = "sub-interface"; yang_parent_name = "bundle-info";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::~SubInterface()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::has_data() const
{
    return interface_name.is_set
	|| (load_balance_data !=  nullptr && load_balance_data->has_data());
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| (load_balance_data !=  nullptr && load_balance_data->has_operation());
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "sub-interface";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "load-balance-data")
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
        else
        {
            load_balance_data = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::LoadBalanceData>();
            load_balance_data->parent = this;
            children["load-balance-data"] = load_balance_data.get();
        }
        return children.at("load-balance-data");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::get_children()
{
    if(children.find("load-balance-data") == children.end())
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::BundleInfo()
    :
    	avoid_rebalance{YType::boolean, "avoid-rebalance"},
	 max_member_count{YType::uint32, "max-member-count"},
	 media{YType::enumeration, "media"}
    	,
    brief(std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief>())
	,load_balance_data(std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData>())
{
    brief->parent = this;
    children["brief"] = brief.get();

    load_balance_data->parent = this;
    children["load-balance-data"] = load_balance_data.get();

    yang_name = "bundle-info"; yang_parent_name = "bundle";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::~BundleInfo()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::has_data() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<sub_interface.size(); index++)
    {
        if(sub_interface[index]->has_data())
            return true;
    }
    return avoid_rebalance.is_set
	|| max_member_count.is_set
	|| media.is_set
	|| (brief !=  nullptr && brief->has_data())
	|| (load_balance_data !=  nullptr && load_balance_data->has_data());
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::has_operation() const
{
    for (std::size_t index=0; index<member.size(); index++)
    {
        if(member[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<sub_interface.size(); index++)
    {
        if(sub_interface[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(avoid_rebalance.operation)
	|| is_set(max_member_count.operation)
	|| is_set(media.operation)
	|| (brief !=  nullptr && brief->has_operation())
	|| (load_balance_data !=  nullptr && load_balance_data->has_operation());
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle-info";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (avoid_rebalance.is_set || is_set(avoid_rebalance.operation)) leaf_name_data.push_back(avoid_rebalance.get_name_leafdata());
    if (max_member_count.is_set || is_set(max_member_count.operation)) leaf_name_data.push_back(max_member_count.get_name_leafdata());
    if (media.is_set || is_set(media.operation)) leaf_name_data.push_back(media.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "brief")
    {
        if(brief != nullptr)
        {
            children["brief"] = brief.get();
        }
        else
        {
            brief = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Brief>();
            brief->parent = this;
            children["brief"] = brief.get();
        }
        return children.at("brief");
    }

    if(child_yang_name == "load-balance-data")
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
        else
        {
            load_balance_data = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::LoadBalanceData>();
            load_balance_data->parent = this;
            children["load-balance-data"] = load_balance_data.get();
        }
        return children.at("load-balance-data");
    }

    if(child_yang_name == "member")
    {
        for(auto const & c : member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::Member>();
        c->parent = this;
        member.push_back(std::move(c));
        children[segment_path] = member.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "sub-interface")
    {
        for(auto const & c : sub_interface)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::SubInterface>();
        c->parent = this;
        sub_interface.push_back(std::move(c));
        children[segment_path] = sub_interface.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::get_children()
{
    if(children.find("brief") == children.end())
    {
        if(brief != nullptr)
        {
            children["brief"] = brief.get();
        }
    }

    if(children.find("load-balance-data") == children.end())
    {
        if(load_balance_data != nullptr)
        {
            children["load-balance-data"] = load_balance_data.get();
        }
    }

    for (auto const & c : member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : sub_interface)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "avoid-rebalance")
    {
        avoid_rebalance = value;
    }
    if(value_path == "max-member-count")
    {
        max_member_count = value;
    }
    if(value_path == "media")
    {
        media = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::Bundle()
    :
    	bundle_name{YType::str, "bundle-name"}
    	,
    bundle_info(std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo>())
{
    bundle_info->parent = this;
    children["bundle-info"] = bundle_info.get();

    yang_name = "bundle"; yang_parent_name = "bundles";
}

BundlesAdjacency::Nodes::Node::Bundles::Bundle::~Bundle()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::has_data() const
{
    return bundle_name.is_set
	|| (bundle_info !=  nullptr && bundle_info->has_data());
}

bool BundlesAdjacency::Nodes::Node::Bundles::Bundle::has_operation() const
{
    return is_set(operation)
	|| is_set(bundle_name.operation)
	|| (bundle_info !=  nullptr && bundle_info->has_operation());
}

std::string BundlesAdjacency::Nodes::Node::Bundles::Bundle::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundle" <<"[bundle-name='" <<bundle_name.get() <<"']";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::Bundle::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bundle_name.is_set || is_set(bundle_name.operation)) leaf_name_data.push_back(bundle_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::Bundle::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle-info")
    {
        if(bundle_info != nullptr)
        {
            children["bundle-info"] = bundle_info.get();
        }
        else
        {
            bundle_info = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle::BundleInfo>();
            bundle_info->parent = this;
            children["bundle-info"] = bundle_info.get();
        }
        return children.at("bundle-info");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::Bundle::get_children()
{
    if(children.find("bundle-info") == children.end())
    {
        if(bundle_info != nullptr)
        {
            children["bundle-info"] = bundle_info.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::Bundle::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bundle-name")
    {
        bundle_name = value;
    }
}

BundlesAdjacency::Nodes::Node::Bundles::Bundles()
{
    yang_name = "bundles"; yang_parent_name = "node";
}

BundlesAdjacency::Nodes::Node::Bundles::~Bundles()
{
}

bool BundlesAdjacency::Nodes::Node::Bundles::has_data() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_data())
            return true;
    }
    return false;
}

bool BundlesAdjacency::Nodes::Node::Bundles::has_operation() const
{
    for (std::size_t index=0; index<bundle.size(); index++)
    {
        if(bundle[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundlesAdjacency::Nodes::Node::Bundles::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bundles";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::Bundles::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::Bundles::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bundle")
    {
        for(auto const & c : bundle)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles::Bundle>();
        c->parent = this;
        bundle.push_back(std::move(c));
        children[segment_path] = bundle.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::Bundles::get_children()
{
    for (auto const & c : bundle)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::Bundles::set_value(const std::string & value_path, std::string value)
{
}

BundlesAdjacency::Nodes::Node::Node()
    :
    	node_name{YType::str, "node-name"}
    	,
    brief(std::make_unique<BundlesAdjacency::Nodes::Node::Brief>())
	,bundles(std::make_unique<BundlesAdjacency::Nodes::Node::Bundles>())
{
    brief->parent = this;
    children["brief"] = brief.get();

    bundles->parent = this;
    children["bundles"] = bundles.get();

    yang_name = "node"; yang_parent_name = "nodes";
}

BundlesAdjacency::Nodes::Node::~Node()
{
}

bool BundlesAdjacency::Nodes::Node::has_data() const
{
    return node_name.is_set
	|| (brief !=  nullptr && brief->has_data())
	|| (bundles !=  nullptr && bundles->has_data());
}

bool BundlesAdjacency::Nodes::Node::has_operation() const
{
    return is_set(operation)
	|| is_set(node_name.operation)
	|| (brief !=  nullptr && brief->has_operation())
	|| (bundles !=  nullptr && bundles->has_operation());
}

std::string BundlesAdjacency::Nodes::Node::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "node" <<"[node-name='" <<node_name.get() <<"']";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::Node::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundles-adjacency/nodes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (node_name.is_set || is_set(node_name.operation)) leaf_name_data.push_back(node_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::Node::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "brief")
    {
        if(brief != nullptr)
        {
            children["brief"] = brief.get();
        }
        else
        {
            brief = std::make_unique<BundlesAdjacency::Nodes::Node::Brief>();
            brief->parent = this;
            children["brief"] = brief.get();
        }
        return children.at("brief");
    }

    if(child_yang_name == "bundles")
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
        else
        {
            bundles = std::make_unique<BundlesAdjacency::Nodes::Node::Bundles>();
            bundles->parent = this;
            children["bundles"] = bundles.get();
        }
        return children.at("bundles");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::Node::get_children()
{
    if(children.find("brief") == children.end())
    {
        if(brief != nullptr)
        {
            children["brief"] = brief.get();
        }
    }

    if(children.find("bundles") == children.end())
    {
        if(bundles != nullptr)
        {
            children["bundles"] = bundles.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::Node::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "node-name")
    {
        node_name = value;
    }
}

BundlesAdjacency::Nodes::Nodes()
{
    yang_name = "nodes"; yang_parent_name = "bundles-adjacency";
}

BundlesAdjacency::Nodes::~Nodes()
{
}

bool BundlesAdjacency::Nodes::has_data() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_data())
            return true;
    }
    return false;
}

bool BundlesAdjacency::Nodes::has_operation() const
{
    for (std::size_t index=0; index<node.size(); index++)
    {
        if(node[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string BundlesAdjacency::Nodes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "nodes";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::Nodes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundles-adjacency/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::Nodes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "node")
    {
        for(auto const & c : node)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<BundlesAdjacency::Nodes::Node>();
        c->parent = this;
        node.push_back(std::move(c));
        children[segment_path] = node.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::Nodes::get_children()
{
    for (auto const & c : node)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void BundlesAdjacency::Nodes::set_value(const std::string & value_path, std::string value)
{
}

BundlesAdjacency::BundlesAdjacency()
    :
    nodes(std::make_unique<BundlesAdjacency::Nodes>())
{
    nodes->parent = this;
    children["nodes"] = nodes.get();

    yang_name = "bundles-adjacency"; yang_parent_name = "Cisco-IOS-XR-bundlemgr-oper";
}

BundlesAdjacency::~BundlesAdjacency()
{
}

bool BundlesAdjacency::has_data() const
{
    return (nodes !=  nullptr && nodes->has_data());
}

bool BundlesAdjacency::has_operation() const
{
    return is_set(operation)
	|| (nodes !=  nullptr && nodes->has_operation());
}

std::string BundlesAdjacency::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-bundlemgr-oper:bundles-adjacency";

    return path_buffer.str();

}

EntityPath BundlesAdjacency::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* BundlesAdjacency::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "nodes")
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
        else
        {
            nodes = std::make_unique<BundlesAdjacency::Nodes>();
            nodes->parent = this;
            children["nodes"] = nodes.get();
        }
        return children.at("nodes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & BundlesAdjacency::get_children()
{
    if(children.find("nodes") == children.end())
    {
        if(nodes != nullptr)
        {
            children["nodes"] = nodes.get();
        }
    }

    return children;
}

void BundlesAdjacency::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> BundlesAdjacency::clone_ptr()
{
    return std::make_unique<BundlesAdjacency>();
}

const Enum::YLeaf BmdMlacpSwitchoverEnum::bmd_mlacp_switchover_nonrevertive {0, "bmd-mlacp-switchover-nonrevertive"};
const Enum::YLeaf BmdMlacpSwitchoverEnum::bmd_mlacp_switchover_brute_force {1, "bmd-mlacp-switchover-brute-force"};
const Enum::YLeaf BmdMlacpSwitchoverEnum::bmd_mlacp_switchover_revertive {2, "bmd-mlacp-switchover-revertive"};
const Enum::YLeaf BmdMlacpSwitchoverEnum::bmd_mlacp_switchover_count {3, "bmd-mlacp-switchover-count"};

const Enum::YLeaf LoadBalanceEnum::default_ {0, "default"};
const Enum::YLeaf LoadBalanceEnum::auto_ {1, "auto"};
const Enum::YLeaf LoadBalanceEnum::value_ {2, "value"};
const Enum::YLeaf LoadBalanceEnum::source_ip {3, "source-ip"};
const Enum::YLeaf LoadBalanceEnum::destination_ip {4, "destination-ip"};
const Enum::YLeaf LoadBalanceEnum::unknown {5, "unknown"};

const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_admin_down {0, "bm-bdl-state-admin-down"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_down {1, "bm-bdl-state-down"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_ptnr_down {2, "bm-bdl-state-ptnr-down"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_bundle_shutdown {3, "bm-bdl-state-bundle-shutdown"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_pe_isolated {4, "bm-bdl-state-pe-isolated"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_nak {5, "bm-bdl-state-nak"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_up_active {6, "bm-bdl-state-up-active"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_mlacp_hot_standby {7, "bm-bdl-state-mlacp-hot-standby"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_mlacp_cold_standby {8, "bm-bdl-state-mlacp-cold-standby"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_unknown {9, "bm-bdl-state-unknown"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_cold_standby {10, "bm-bdl-state-cold-standby"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_error_disabled {11, "bm-bdl-state-error-disabled"};
const Enum::YLeaf BmBdlStateEnum::bm_bdl_state_efd_disabled {12, "bm-bdl-state-efd-disabled"};

const Enum::YLeaf LacpPeriodStateEnum::period_s_low {0, "period-s-low"};
const Enum::YLeaf LacpPeriodStateEnum::period_fast {1, "period-fast"};
const Enum::YLeaf LacpPeriodStateEnum::period_none {2, "period-none"};

const Enum::YLeaf BundleMediaEnum::bundle_media_ethernet {0, "bundle-media-ethernet"};
const Enum::YLeaf BundleMediaEnum::bundle_media_pos {1, "bundle-media-pos"};
const Enum::YLeaf BundleMediaEnum::bundle_media_count {2, "bundle-media-count"};

const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_nak {0, "bdl-state-nak"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_unknown {1, "bdl-state-unknown"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_no_sync {2, "bdl-state-no-sync"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_rec_delay {3, "bdl-state-rec-delay"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_up {4, "bdl-state-up"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_down {5, "bdl-state-down"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_admin_down {6, "bdl-state-admin-down"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_test {7, "bdl-state-test"};
const Enum::YLeaf BmdMlacpBdlStateEnumEnum::bdl_state_error {8, "bdl-state-error"};

const Enum::YLeaf BundleMedia1Enum::ethernet {0, "ethernet"};
const Enum::YLeaf BundleMedia1Enum::pos {1, "pos"};

const Enum::YLeaf RxstatesEnum::current_rx {1, "current-rx"};
const Enum::YLeaf RxstatesEnum::expired {2, "expired"};
const Enum::YLeaf RxstatesEnum::defaulted {3, "defaulted"};
const Enum::YLeaf RxstatesEnum::initialize {4, "initialize"};
const Enum::YLeaf RxstatesEnum::lacp_disabled {5, "lacp-disabled"};
const Enum::YLeaf RxstatesEnum::port_disabled {6, "port-disabled"};

const Enum::YLeaf LacpChurnstatesEnum::no_churn {1, "no-churn"};
const Enum::YLeaf LacpChurnstatesEnum::churn {2, "churn"};
const Enum::YLeaf LacpChurnstatesEnum::churn_monitor {3, "churn-monitor"};

const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_idb_create {0, "bmd-event-mbr-idb-create"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_bdl_add {1, "bmd-event-mbr-bdl-add"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_im_state {2, "bmd-event-mbr-im-state"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_sel_logic {3, "bmd-event-mbr-sel-logic"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_mux {4, "bmd-event-mbr-mux"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_bfd {5, "bmd-event-mbr-bfd"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_expired {6, "bmd-event-mbr-expired"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_defaulted {7, "bmd-event-mbr-defaulted"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_first_retry {8, "bmd-event-mbr-first-retry"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_msg {9, "bmd-event-mbr-msg"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_error {10, "bmd-event-mbr-error"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_mlacp_tlv {11, "bmd-event-mbr-mlacp-tlv"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_redundancy_role {12, "bmd-event-mbr-redundancy-role"};
const Enum::YLeaf BmdBagEventMbrItemEnum::bmd_event_mbr_count {13, "bmd-event-mbr-count"};

const Enum::YLeaf BmdBagEventDataEnum::bmd_bag_evt_data_none {0, "bmd-bag-evt-data-none"};
const Enum::YLeaf BmdBagEventDataEnum::bmd_bag_evt_data_error {1, "bmd-bag-evt-data-error"};
const Enum::YLeaf BmdBagEventDataEnum::bmd_bag_evt_data_string {2, "bmd-bag-evt-data-string"};

const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_none {0, "bm-switch-reason-none"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_noop {1, "bm-switch-reason-noop"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_not_mlacp {2, "bm-switch-reason-not-mlacp"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_revertive {3, "bm-switch-reason-revertive"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_bdl_down {4, "bm-switch-reason-bdl-down"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_recovery {5, "bm-switch-reason-recovery"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_preceding_error {6, "bm-switch-reason-preceding-error"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_wrong_order {7, "bm-switch-reason-wrong-order"};
const Enum::YLeaf BmdSwitchReasonEnum::bm_switch_reason_singleton {8, "bm-switch-reason-singleton"};

const Enum::YLeaf BmdMemberTypeEnumEnum::bmd_mbr_local {0, "bmd-mbr-local"};
const Enum::YLeaf BmdMemberTypeEnumEnum::bmd_mbr_foreign {1, "bmd-mbr-foreign"};
const Enum::YLeaf BmdMemberTypeEnumEnum::bmd_mbr_unknown {2, "bmd-mbr-unknown"};

const Enum::YLeaf BmAfIdEnum::bm_af_id_ipv4 {1136568623, "bm-af-id-ipv4"};
const Enum::YLeaf BmAfIdEnum::bm_af_id_ipv6 {1136568624, "bm-af-id-ipv6"};

const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_unknown {0, "bm-mbr-state-reason-unknown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_unselectable_unknown {1, "bm-mbr-state-reason-unselectable-unknown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_link_down {2, "bm-mbr-state-reason-link-down"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_link_deleting {3, "bm-mbr-state-reason-link-deleting"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_creating {4, "bm-mbr-state-reason-creating"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_creating {5, "bm-mbr-state-reason-bundle-creating"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_deleting {6, "bm-mbr-state-reason-bundle-deleting"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_admin_down {7, "bm-mbr-state-reason-bundle-admin-down"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_replicating {8, "bm-mbr-state-reason-replicating"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bandwidth {9, "bm-mbr-state-reason-bandwidth"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_loop_back {10, "bm-mbr-state-reason-loop-back"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_activity_type {11, "bm-mbr-state-reason-activity-type"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_shutdown {12, "bm-mbr-state-reason-bundle-shutdown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_min_selected {13, "bm-mbr-state-reason-min-selected"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_max_selected {14, "bm-mbr-state-reason-max-selected"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_link_limit {15, "bm-mbr-state-reason-link-limit"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_active_limit {16, "bm-mbr-state-reason-active-limit"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_standby_unknown {17, "bm-mbr-state-reason-standby-unknown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_expired {18, "bm-mbr-state-reason-expired"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_defaulted {19, "bm-mbr-state-reason-defaulted"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_act_or_not_agg {20, "bm-mbr-state-reason-act-or-not-agg"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_partner_not_agg {21, "bm-mbr-state-reason-partner-not-agg"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_lagid {22, "bm-mbr-state-reason-lagid"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_not_cfgd {23, "bm-mbr-state-reason-bundle-not-cfgd"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_not_ready {24, "bm-mbr-state-reason-bundle-not-ready"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_partner_ood {25, "bm-mbr-state-reason-partner-ood"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_partner_not_in_sync {26, "bm-mbr-state-reason-partner-not-in-sync"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_foreign_partner_oos {27, "bm-mbr-state-reason-foreign-partner-oos"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_attach_unknown {28, "bm-mbr-state-reason-attach-unknown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_partner_not_collecting {29, "bm-mbr-state-reason-partner-not-collecting"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_collect_unknown {30, "bm-mbr-state-reason-collect-unknown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_standby_foreign {31, "bm-mbr-state-reason-standby-foreign"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bfd_starting {32, "bm-mbr-state-reason-bfd-starting"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bfd_down {33, "bm-mbr-state-reason-bfd-down"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bfd_nbr_unconfig {34, "bm-mbr-state-reason-bfd-nbr-unconfig"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp {35, "bm-mbr-state-reason-mlacp"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_pe_isolated {36, "bm-mbr-state-reason-pe-isolated"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_forced_switchover {37, "bm-mbr-state-reason-forced-switchover"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_errdis_unknown {38, "bm-mbr-state-reason-errdis-unknown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_no_mbr_state_info {39, "bm-mbr-state-reason-mlacp-no-mbr-state-info"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_active {40, "bm-mbr-state-reason-active"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_no_bdl_state_info {41, "bm-mbr-state-reason-mlacp-no-bdl-state-info"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_no_bdl_config_info {42, "bm-mbr-state-reason-mlacp-no-bdl-config-info"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_no_bdl_sync {43, "bm-mbr-state-reason-mlacp-no-bdl-sync"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_bdl_has_no_peer {44, "bm-mbr-state-reason-mlacp-bdl-has-no-peer"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_nak {45, "bm-mbr-state-reason-mlacp-nak"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_transport_unavailable {46, "bm-mbr-state-reason-mlacp-transport-unavailable"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_not_configured {47, "bm-mbr-state-reason-mlacp-not-configured"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_recovery_timer {48, "bm-mbr-state-reason-recovery-timer"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_standby {49, "bm-mbr-state-reason-mlacp-standby"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_maximized_out {50, "bm-mbr-state-reason-maximized-out"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_peer_selected {51, "bm-mbr-state-reason-mlacp-peer-selected"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_mlacp_connect_timer_running {52, "bm-mbr-state-reason-mlacp-connect-timer-running"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_not_mlacp {53, "bm-mbr-state-reason-bundle-not-mlacp"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_no_lon {54, "bm-mbr-state-reason-no-lon"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_cumul_rel_bw_limit {55, "bm-mbr-state-reason-cumul-rel-bw-limit"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_no_mac {56, "bm-mbr-state-reason-no-mac"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_no_system_id {57, "bm-mbr-state-reason-no-system-id"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_link_shutdown {58, "bm-mbr-state-reason-link-shutdown"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_activity_mlacp {59, "bm-mbr-state-reason-activity-mlacp"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_activity_iccp {60, "bm-mbr-state-reason-activity-iccp"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_icpe_mlacp {61, "bm-mbr-state-reason-bundle-icpe-mlacp"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_no_link_num {62, "bm-mbr-state-reason-no-link-num"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_standby_peer_higher_prio {63, "bm-mbr-state-reason-standby-peer-higher-prio"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_red_state_standby {64, "bm-mbr-state-reason-red-state-standby"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_other_red_state_standby {65, "bm-mbr-state-reason-other-red-state-standby"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_hold_ing {66, "bm-mbr-state-reason-hold-ing"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_error_disabled {67, "bm-mbr-state-reason-bundle-error-disabled"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bundle_efd_disabled {68, "bm-mbr-state-reason-bundle-efd-disabled"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_singleton_pe_isolated {69, "bm-mbr-state-reason-singleton-pe-isolated"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bfd_ipv6_starting {70, "bm-mbr-state-reason-bfd-ipv6-starting"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bfd_ipv6_down {71, "bm-mbr-state-reason-bfd-ipv6-down"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_bfd_ipv6_nbr_unconfig {72, "bm-mbr-state-reason-bfd-ipv6-nbr-unconfig"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_timer_running {73, "bm-mbr-state-reason-timer-running"};
const Enum::YLeaf BmMbrStateReasonEnum::bm_mbr_state_reason_count {74, "bm-mbr-state-reason-count"};

const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_idb_create {0, "bmd-event-bdl-idb-create"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_configured {1, "bmd-event-bdl-configured"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_im_state {2, "bmd-event-bdl-im-state"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_mbr_added {3, "bmd-event-bdl-mbr-added"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_mbr_deleted {4, "bmd-event-bdl-mbr-deleted"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_mac_addr {5, "bmd-event-bdl-mac-addr"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_first_retry {6, "bmd-event-bdl-first-retry"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_user_config {7, "bmd-event-bdl-user-config"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_error {8, "bmd-event-bdl-error"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_mlacp_tlv {9, "bmd-event-bdl-mlacp-tlv"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_redundancy_role {10, "bmd-event-bdl-redundancy-role"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bdl_bfd_state_change {11, "bdl-bfd-state-change"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_icl {12, "bmd-event-bdl-icl"};
const Enum::YLeaf BmdBagEventBdlItemEnum::bmd_event_bdl_count {13, "bmd-event-bdl-count"};

const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_incomplete {0, "node-state-incomplete"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_conn_rejected {1, "node-state-conn-rejected"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_connect_sent {2, "node-state-connect-sent"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_unconfigured {3, "node-state-unconfigured"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_unreachable {4, "node-state-unreachable"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_iccp_down {5, "node-state-iccp-down"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_nak {6, "node-state-nak"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_unknown {7, "node-state-unknown"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_mlacp_down {8, "node-state-mlacp-down"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_admin_down {9, "node-state-admin-down"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_pe_isolated {10, "node-state-pe-isolated"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_error {11, "node-state-error"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_test {12, "node-state-test"};
const Enum::YLeaf BmdMlacpNodeStateEnumEnum::node_state_up {13, "node-state-up"};

const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_idb_create {0, "bmd-event-rg-idb-create"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_configured {1, "bmd-event-rg-configured"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_user_config {2, "bmd-event-rg-user-config"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_connect_ion {3, "bmd-event-rg-connect-ion"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_data {4, "bmd-event-rg-data"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_sync {5, "bmd-event-rg-sync"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_first_retry {6, "bmd-event-rg-first-retry"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_error {7, "bmd-event-rg-error"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_mlacp_tlv {8, "bmd-event-rg-mlacp-tlv"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_iccp_event {9, "bmd-event-rg-iccp-event"};
const Enum::YLeaf BmdBagEventRgItemEnum::bmd_event_rg_count {10, "bmd-event-rg-count"};

const Enum::YLeaf BmWhichSystemEnum::bm_which_system_actr {0, "bm-which-system-actr"};
const Enum::YLeaf BmWhichSystemEnum::bm_which_system_ptnr {1, "bm-which-system-ptnr"};

const Enum::YLeaf BmdBfdBdlStateEnum::bmd_bfd_bdl_down {0, "bmd-bfd-bdl-down"};
const Enum::YLeaf BmdBfdBdlStateEnum::bmd_bfd_bdl_unknown {1, "bmd-bfd-bdl-unknown"};
const Enum::YLeaf BmdBfdBdlStateEnum::bmd_bfd_bdl_up {2, "bmd-bfd-bdl-up"};
const Enum::YLeaf BmdBfdBdlStateEnum::bmd_bfd_bdl_count {3, "bmd-bfd-bdl-count"};

const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_nak {0, "mbr-state-nak"};
const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_unknown {1, "mbr-state-unknown"};
const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_up {2, "mbr-state-up"};
const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_down {3, "mbr-state-down"};
const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_admin_down {4, "mbr-state-admin-down"};
const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_test {5, "mbr-state-test"};
const Enum::YLeaf BmdMlacpMbrStateEnumEnum::mbr_state_error {6, "mbr-state-error"};

const Enum::YLeaf BmdBagTargetEnum::bm_bag_target_mbr {0, "bm-bag-target-mbr"};
const Enum::YLeaf BmdBagTargetEnum::bm_bag_target_bdl {1, "bm-bag-target-bdl"};
const Enum::YLeaf BmdBagTargetEnum::bm_bag_target_node {2, "bm-bag-target-node"};
const Enum::YLeaf BmdBagTargetEnum::bm_bag_target_rg {3, "bm-bag-target-rg"};

const Enum::YLeaf BmMuxstateEnum::detached {1, "detached"};
const Enum::YLeaf BmMuxstateEnum::waiting {2, "waiting"};
const Enum::YLeaf BmMuxstateEnum::attached {3, "attached"};
const Enum::YLeaf BmMuxstateEnum::collecting {4, "collecting"};
const Enum::YLeaf BmMuxstateEnum::distributing {5, "distributing"};
const Enum::YLeaf BmMuxstateEnum::collecting_distributing {6, "collecting-distributing"};

const Enum::YLeaf LacpSelStateEnum::unselected {0, "unselected"};
const Enum::YLeaf LacpSelStateEnum::standby {1, "standby"};
const Enum::YLeaf LacpSelStateEnum::selected {2, "selected"};

const Enum::YLeaf BmdMemberStateEnum::bmd_mbr_state_configured {1, "bmd-mbr-state-configured"};
const Enum::YLeaf BmdMemberStateEnum::bmd_mbr_state_standby {2, "bmd-mbr-state-standby"};
const Enum::YLeaf BmdMemberStateEnum::bmd_mbr_state_hot_standby {3, "bmd-mbr-state-hot-standby"};
const Enum::YLeaf BmdMemberStateEnum::bmd_mbr_state_negotiating {4, "bmd-mbr-state-negotiating"};
const Enum::YLeaf BmdMemberStateEnum::bmd_mbr_state_bfd_running {5, "bmd-mbr-state-bfd-running"};
const Enum::YLeaf BmdMemberStateEnum::bmd_mbr_state_active {6, "bmd-mbr-state-active"};

const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_no_reason {0, "bm-mux-reason-no-reason"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_link_down {1, "bm-mux-reason-link-down"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_link_deleted {2, "bm-mux-reason-link-deleted"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_duplex {3, "bm-mux-reason-duplex"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_bandwidth {4, "bm-mux-reason-bandwidth"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_loop_back {5, "bm-mux-reason-loop-back"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_activity_type {6, "bm-mux-reason-activity-type"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_link_limit {7, "bm-mux-reason-link-limit"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_shared {8, "bm-mux-reason-shared"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_lagid {9, "bm-mux-reason-lagid"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_no_bundle {10, "bm-mux-reason-no-bundle"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_no_primary {11, "bm-mux-reason-no-primary"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_bundle_down {12, "bm-mux-reason-bundle-down"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_individual {13, "bm-mux-reason-individual"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_defaulted {14, "bm-mux-reason-defaulted"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_in_sync {15, "bm-mux-reason-in-sync"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_collecting {16, "bm-mux-reason-collecting"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_active_link_limit {17, "bm-mux-reason-active-link-limit"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_distributing {18, "bm-mux-reason-distributing"};
const Enum::YLeaf BmMuxreasonEnum::bm_mux_reason_count {19, "bm-mux-reason-count"};

const Enum::YLeaf BmFeatureStatusEnum::bm_feature_not_configured {0, "bm-feature-not-configured"};
const Enum::YLeaf BmFeatureStatusEnum::bm_feature_not_operational {1, "bm-feature-not-operational"};
const Enum::YLeaf BmFeatureStatusEnum::bm_feature_operational {2, "bm-feature-operational"};

const Enum::YLeaf BmSeverityEnum::ok {0, "ok"};
const Enum::YLeaf BmSeverityEnum::information {1, "information"};
const Enum::YLeaf BmSeverityEnum::misconfiguration {2, "misconfiguration"};
const Enum::YLeaf BmSeverityEnum::warning {3, "warning"};
const Enum::YLeaf BmSeverityEnum::error {5, "error"};

const Enum::YLeaf BundleMlacpModeEnum::bundle_mlacp_mode_standby {0, "bundle-mlacp-mode-standby"};
const Enum::YLeaf BundleMlacpModeEnum::bundle_mlacp_mode_active {1, "bundle-mlacp-mode-active"};
const Enum::YLeaf BundleMlacpModeEnum::bundle_mlacp_mode_count {2, "bundle-mlacp-mode-count"};

const Enum::YLeaf BmdBagMlacpSchActionItemEnum::switchover {0, "switchover"};
const Enum::YLeaf BmdBagMlacpSchActionItemEnum::switchback {1, "switchback"};

const Enum::YLeaf BmStateReasonTargetEnum::member_reason {0, "member-reason"};
const Enum::YLeaf BmStateReasonTargetEnum::bundle_reason {1, "bundle-reason"};

const Enum::YLeaf BmdMlacpNodeSyncEnumEnum::node_sync_req {0, "node-sync-req"};
const Enum::YLeaf BmdMlacpNodeSyncEnumEnum::node_sync_done {1, "node-sync-done"};
const Enum::YLeaf BmdMlacpNodeSyncEnumEnum::node_sync_start {2, "node-sync-start"};
const Enum::YLeaf BmdMlacpNodeSyncEnumEnum::node_sync_init {3, "node-sync-init"};
const Enum::YLeaf BmdMlacpNodeSyncEnumEnum::node_sync_singleton {4, "node-sync-singleton"};

const Enum::YLeaf BmBdlMacSourceEnum::bm_bdl_mac_source_unknown {0, "bm-bdl-mac-source-unknown"};
const Enum::YLeaf BmBdlMacSourceEnum::bm_bdl_mac_source_chassis {1, "bm-bdl-mac-source-chassis"};
const Enum::YLeaf BmBdlMacSourceEnum::bm_bdl_mac_source_configured {2, "bm-bdl-mac-source-configured"};
const Enum::YLeaf BmBdlMacSourceEnum::bm_bdl_mac_source_member {3, "bm-bdl-mac-source-member"};
const Enum::YLeaf BmBdlMacSourceEnum::bm_bdl_mac_source_peer {4, "bm-bdl-mac-source-peer"};


}
}

