
#include <sstream>
#include <iostream>
#include "ydk/entity_util.hpp"
#include "Cisco_IOS_XR_mpls_te_cfg.hpp"

namespace ydk {
namespace Cisco_IOS_XR_mpls_te_cfg {

MplsTe::DiffServTrafficEngineering::Classes::Class_::Class_()
    :
    	class_number{YType::uint32, "class-number"},
	 class_priority{YType::uint32, "class-priority"},
	 class_type{YType::uint32, "class-type"},
	 unused{YType::boolean, "unused"}
{
    yang_name = "class"; yang_parent_name = "classes";
}

MplsTe::DiffServTrafficEngineering::Classes::Class_::~Class_()
{
}

bool MplsTe::DiffServTrafficEngineering::Classes::Class_::has_data() const
{
    return class_number.is_set
	|| class_priority.is_set
	|| class_type.is_set
	|| unused.is_set;
}

bool MplsTe::DiffServTrafficEngineering::Classes::Class_::has_operation() const
{
    return is_set(operation)
	|| is_set(class_number.operation)
	|| is_set(class_priority.operation)
	|| is_set(class_type.operation)
	|| is_set(unused.operation);
}

std::string MplsTe::DiffServTrafficEngineering::Classes::Class_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "class" <<"[class-number='" <<class_number.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::DiffServTrafficEngineering::Classes::Class_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/diff-serv-traffic-engineering/classes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (class_number.is_set || is_set(class_number.operation)) leaf_name_data.push_back(class_number.get_name_leafdata());
    if (class_priority.is_set || is_set(class_priority.operation)) leaf_name_data.push_back(class_priority.get_name_leafdata());
    if (class_type.is_set || is_set(class_type.operation)) leaf_name_data.push_back(class_type.get_name_leafdata());
    if (unused.is_set || is_set(unused.operation)) leaf_name_data.push_back(unused.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::DiffServTrafficEngineering::Classes::Class_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::DiffServTrafficEngineering::Classes::Class_::get_children()
{
    return children;
}

void MplsTe::DiffServTrafficEngineering::Classes::Class_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "class-number")
    {
        class_number = value;
    }
    if(value_path == "class-priority")
    {
        class_priority = value;
    }
    if(value_path == "class-type")
    {
        class_type = value;
    }
    if(value_path == "unused")
    {
        unused = value;
    }
}

MplsTe::DiffServTrafficEngineering::Classes::Classes()
{
    yang_name = "classes"; yang_parent_name = "diff-serv-traffic-engineering";
}

MplsTe::DiffServTrafficEngineering::Classes::~Classes()
{
}

bool MplsTe::DiffServTrafficEngineering::Classes::has_data() const
{
    for (std::size_t index=0; index<class_.size(); index++)
    {
        if(class_[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::DiffServTrafficEngineering::Classes::has_operation() const
{
    for (std::size_t index=0; index<class_.size(); index++)
    {
        if(class_[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::DiffServTrafficEngineering::Classes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "classes";

    return path_buffer.str();

}

EntityPath MplsTe::DiffServTrafficEngineering::Classes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/diff-serv-traffic-engineering/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::DiffServTrafficEngineering::Classes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "class")
    {
        for(auto const & c : class_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::DiffServTrafficEngineering::Classes::Class_>();
        c->parent = this;
        class_.push_back(std::move(c));
        children[segment_path] = class_.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::DiffServTrafficEngineering::Classes::get_children()
{
    for (auto const & c : class_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::DiffServTrafficEngineering::Classes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::DiffServTrafficEngineering::DiffServTrafficEngineering()
    :
    	bandwidth_constraint_model{YType::enumeration, "bandwidth-constraint-model"},
	 mode_ietf{YType::enumeration, "mode-ietf"}
    	,
    classes(std::make_unique<MplsTe::DiffServTrafficEngineering::Classes>())
{
    classes->parent = this;
    children["classes"] = classes.get();

    yang_name = "diff-serv-traffic-engineering"; yang_parent_name = "mpls-te";
}

MplsTe::DiffServTrafficEngineering::~DiffServTrafficEngineering()
{
}

bool MplsTe::DiffServTrafficEngineering::has_data() const
{
    return bandwidth_constraint_model.is_set
	|| mode_ietf.is_set
	|| (classes !=  nullptr && classes->has_data());
}

bool MplsTe::DiffServTrafficEngineering::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_constraint_model.operation)
	|| is_set(mode_ietf.operation)
	|| (classes !=  nullptr && classes->has_operation());
}

std::string MplsTe::DiffServTrafficEngineering::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "diff-serv-traffic-engineering";

    return path_buffer.str();

}

EntityPath MplsTe::DiffServTrafficEngineering::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_constraint_model.is_set || is_set(bandwidth_constraint_model.operation)) leaf_name_data.push_back(bandwidth_constraint_model.get_name_leafdata());
    if (mode_ietf.is_set || is_set(mode_ietf.operation)) leaf_name_data.push_back(mode_ietf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::DiffServTrafficEngineering::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "classes")
    {
        if(classes != nullptr)
        {
            children["classes"] = classes.get();
        }
        else
        {
            classes = std::make_unique<MplsTe::DiffServTrafficEngineering::Classes>();
            classes->parent = this;
            children["classes"] = classes.get();
        }
        return children.at("classes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::DiffServTrafficEngineering::get_children()
{
    if(children.find("classes") == children.end())
    {
        if(classes != nullptr)
        {
            children["classes"] = classes.get();
        }
    }

    return children;
}

void MplsTe::DiffServTrafficEngineering::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-constraint-model")
    {
        bandwidth_constraint_model = value;
    }
    if(value_path == "mode-ietf")
    {
        mode_ietf = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::PathComputation()
    :
    	explicit_path_name{YType::str, "explicit-path-name"},
	 path_computation_method{YType::enumeration, "path-computation-method"},
	 path_computation_server{YType::str, "path-computation-server"}
{
    yang_name = "path-computation"; yang_parent_name = "path-setup";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::~PathComputation()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::has_data() const
{
    return explicit_path_name.is_set
	|| path_computation_method.is_set
	|| path_computation_server.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::has_operation() const
{
    return is_set(operation)
	|| is_set(explicit_path_name.operation)
	|| is_set(path_computation_method.operation)
	|| is_set(path_computation_server.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-computation";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (explicit_path_name.is_set || is_set(explicit_path_name.operation)) leaf_name_data.push_back(explicit_path_name.get_name_leafdata());
    if (path_computation_method.is_set || is_set(path_computation_method.operation)) leaf_name_data.push_back(path_computation_method.get_name_leafdata());
    if (path_computation_server.is_set || is_set(path_computation_server.operation)) leaf_name_data.push_back(path_computation_server.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "explicit-path-name")
    {
        explicit_path_name = value;
    }
    if(value_path == "path-computation-method")
    {
        path_computation_method = value;
    }
    if(value_path == "path-computation-server")
    {
        path_computation_server = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathSetup()
    :
    	path_setup_name{YType::str, "path-setup-name"},
	 enable{YType::empty, "enable"},
	 preference{YType::int32, "preference"}
    	,
    path_computation(nullptr) // presence node
{
    yang_name = "path-setup"; yang_parent_name = "path-setups";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::~PathSetup()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::has_data() const
{
    return path_setup_name.is_set
	|| enable.is_set
	|| preference.is_set
	|| (path_computation !=  nullptr && path_computation->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::has_operation() const
{
    return is_set(operation)
	|| is_set(path_setup_name.operation)
	|| is_set(enable.operation)
	|| is_set(preference.operation)
	|| (path_computation !=  nullptr && path_computation->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-setup" <<"[path-setup-name='" <<path_setup_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (path_setup_name.is_set || is_set(path_setup_name.operation)) leaf_name_data.push_back(path_setup_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (preference.is_set || is_set(preference.operation)) leaf_name_data.push_back(preference.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-computation")
    {
        if(path_computation != nullptr)
        {
            children["path-computation"] = path_computation.get();
        }
        else
        {
            path_computation = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::PathComputation>();
            path_computation->parent = this;
            children["path-computation"] = path_computation.get();
        }
        return children.at("path-computation");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::get_children()
{
    if(children.find("path-computation") == children.end())
    {
        if(path_computation != nullptr)
        {
            children["path-computation"] = path_computation.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "path-setup-name")
    {
        path_setup_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "preference")
    {
        preference = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetups()
{
    yang_name = "path-setups"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::~PathSetups()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::has_data() const
{
    for (std::size_t index=0; index<path_setup.size(); index++)
    {
        if(path_setup[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::has_operation() const
{
    for (std::size_t index=0; index<path_setup.size(); index++)
    {
        if(path_setup[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-setups";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-setup")
    {
        for(auto const & c : path_setup)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::PathSetup>();
        c->parent = this;
        path_setup.push_back(std::move(c));
        children[segment_path] = path_setup.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::get_children()
{
    for (auto const & c : path_setup)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::Invalidation()
    :
    	path_invalidation_action{YType::enumeration, "path-invalidation-action"},
	 path_invalidation_timeout{YType::uint32, "path-invalidation-timeout"}
{
    yang_name = "invalidation"; yang_parent_name = "tunnel-path-selection";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::~Invalidation()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::has_data() const
{
    return path_invalidation_action.is_set
	|| path_invalidation_timeout.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::has_operation() const
{
    return is_set(operation)
	|| is_set(path_invalidation_action.operation)
	|| is_set(path_invalidation_timeout.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalidation";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (path_invalidation_action.is_set || is_set(path_invalidation_action.operation)) leaf_name_data.push_back(path_invalidation_action.get_name_leafdata());
    if (path_invalidation_timeout.is_set || is_set(path_invalidation_timeout.operation)) leaf_name_data.push_back(path_invalidation_timeout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "path-invalidation-action")
    {
        path_invalidation_action = value;
    }
    if(value_path == "path-invalidation-timeout")
    {
        path_invalidation_timeout = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::TunnelPathSelection()
    :
    	path_selection_cost_limit{YType::uint32, "path-selection-cost-limit"},
	 path_selection_hop_limit{YType::uint32, "path-selection-hop-limit"},
	 tiebreaker{YType::enumeration, "tiebreaker"}
    	,
    invalidation(nullptr) // presence node
{
    yang_name = "tunnel-path-selection"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::~TunnelPathSelection()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::has_data() const
{
    return path_selection_cost_limit.is_set
	|| path_selection_hop_limit.is_set
	|| tiebreaker.is_set
	|| (invalidation !=  nullptr && invalidation->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(path_selection_cost_limit.operation)
	|| is_set(path_selection_hop_limit.operation)
	|| is_set(tiebreaker.operation)
	|| (invalidation !=  nullptr && invalidation->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (path_selection_cost_limit.is_set || is_set(path_selection_cost_limit.operation)) leaf_name_data.push_back(path_selection_cost_limit.get_name_leafdata());
    if (path_selection_hop_limit.is_set || is_set(path_selection_hop_limit.operation)) leaf_name_data.push_back(path_selection_hop_limit.get_name_leafdata());
    if (tiebreaker.is_set || is_set(tiebreaker.operation)) leaf_name_data.push_back(tiebreaker.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "invalidation")
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
        else
        {
            invalidation = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::Invalidation>();
            invalidation->parent = this;
            children["invalidation"] = invalidation.get();
        }
        return children.at("invalidation");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::get_children()
{
    if(children.find("invalidation") == children.end())
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "path-selection-cost-limit")
    {
        path_selection_cost_limit = value;
    }
    if(value_path == "path-selection-hop-limit")
    {
        path_selection_hop_limit = value;
    }
    if(value_path == "tiebreaker")
    {
        tiebreaker = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::Underflow()
    :
    	underflow_threshold_limit{YType::uint32, "underflow-threshold-limit"},
	 underflow_threshold_percent{YType::uint32, "underflow-threshold-percent"},
	 underflow_threshold_value{YType::uint32, "underflow-threshold-value"}
{
    yang_name = "underflow"; yang_parent_name = "auto-bandwidth";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::~Underflow()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::has_data() const
{
    return underflow_threshold_limit.is_set
	|| underflow_threshold_percent.is_set
	|| underflow_threshold_value.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::has_operation() const
{
    return is_set(operation)
	|| is_set(underflow_threshold_limit.operation)
	|| is_set(underflow_threshold_percent.operation)
	|| is_set(underflow_threshold_value.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "underflow";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (underflow_threshold_limit.is_set || is_set(underflow_threshold_limit.operation)) leaf_name_data.push_back(underflow_threshold_limit.get_name_leafdata());
    if (underflow_threshold_percent.is_set || is_set(underflow_threshold_percent.operation)) leaf_name_data.push_back(underflow_threshold_percent.get_name_leafdata());
    if (underflow_threshold_value.is_set || is_set(underflow_threshold_value.operation)) leaf_name_data.push_back(underflow_threshold_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "underflow-threshold-limit")
    {
        underflow_threshold_limit = value;
    }
    if(value_path == "underflow-threshold-percent")
    {
        underflow_threshold_percent = value;
    }
    if(value_path == "underflow-threshold-value")
    {
        underflow_threshold_value = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::Overflow()
    :
    	overflow_threshold_limit{YType::uint32, "overflow-threshold-limit"},
	 overflow_threshold_percent{YType::uint32, "overflow-threshold-percent"},
	 overflow_threshold_value{YType::uint32, "overflow-threshold-value"}
{
    yang_name = "overflow"; yang_parent_name = "auto-bandwidth";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::~Overflow()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::has_data() const
{
    return overflow_threshold_limit.is_set
	|| overflow_threshold_percent.is_set
	|| overflow_threshold_value.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::has_operation() const
{
    return is_set(operation)
	|| is_set(overflow_threshold_limit.operation)
	|| is_set(overflow_threshold_percent.operation)
	|| is_set(overflow_threshold_value.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "overflow";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (overflow_threshold_limit.is_set || is_set(overflow_threshold_limit.operation)) leaf_name_data.push_back(overflow_threshold_limit.get_name_leafdata());
    if (overflow_threshold_percent.is_set || is_set(overflow_threshold_percent.operation)) leaf_name_data.push_back(overflow_threshold_percent.get_name_leafdata());
    if (overflow_threshold_value.is_set || is_set(overflow_threshold_value.operation)) leaf_name_data.push_back(overflow_threshold_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "overflow-threshold-limit")
    {
        overflow_threshold_limit = value;
    }
    if(value_path == "overflow-threshold-percent")
    {
        overflow_threshold_percent = value;
    }
    if(value_path == "overflow-threshold-value")
    {
        overflow_threshold_value = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::BandwidthLimits()
    :
    	bandwidth_max_limit{YType::uint32, "bandwidth-max-limit"},
	 bandwidth_min_limit{YType::uint32, "bandwidth-min-limit"}
{
    yang_name = "bandwidth-limits"; yang_parent_name = "auto-bandwidth";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::~BandwidthLimits()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::has_data() const
{
    return bandwidth_max_limit.is_set
	|| bandwidth_min_limit.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_max_limit.operation)
	|| is_set(bandwidth_min_limit.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bandwidth-limits";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_max_limit.is_set || is_set(bandwidth_max_limit.operation)) leaf_name_data.push_back(bandwidth_max_limit.get_name_leafdata());
    if (bandwidth_min_limit.is_set || is_set(bandwidth_min_limit.operation)) leaf_name_data.push_back(bandwidth_min_limit.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-max-limit")
    {
        bandwidth_max_limit = value;
    }
    if(value_path == "bandwidth-min-limit")
    {
        bandwidth_min_limit = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::AdjustmentThreshold()
    :
    	adjustment_threshold_percent{YType::uint32, "adjustment-threshold-percent"},
	 adjustment_threshold_value{YType::uint32, "adjustment-threshold-value"}
{
    yang_name = "adjustment-threshold"; yang_parent_name = "auto-bandwidth";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::~AdjustmentThreshold()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::has_data() const
{
    return adjustment_threshold_percent.is_set
	|| adjustment_threshold_value.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::has_operation() const
{
    return is_set(operation)
	|| is_set(adjustment_threshold_percent.operation)
	|| is_set(adjustment_threshold_value.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "adjustment-threshold";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjustment_threshold_percent.is_set || is_set(adjustment_threshold_percent.operation)) leaf_name_data.push_back(adjustment_threshold_percent.get_name_leafdata());
    if (adjustment_threshold_value.is_set || is_set(adjustment_threshold_value.operation)) leaf_name_data.push_back(adjustment_threshold_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjustment-threshold-percent")
    {
        adjustment_threshold_percent = value;
    }
    if(value_path == "adjustment-threshold-value")
    {
        adjustment_threshold_value = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AutoBandwidth()
    :
    	application_frequency{YType::uint32, "application-frequency"},
	 collection_only{YType::empty, "collection-only"},
	 enabled{YType::boolean, "enabled"},
	 overflow_enable{YType::boolean, "overflow-enable"},
	 underflow_enable{YType::boolean, "underflow-enable"}
    	,
    adjustment_threshold(nullptr) // presence node
	,bandwidth_limits(nullptr) // presence node
	,overflow(nullptr) // presence node
	,underflow(nullptr) // presence node
{
    yang_name = "auto-bandwidth"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::~AutoBandwidth()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::has_data() const
{
    return application_frequency.is_set
	|| collection_only.is_set
	|| enabled.is_set
	|| overflow_enable.is_set
	|| underflow_enable.is_set
	|| (adjustment_threshold !=  nullptr && adjustment_threshold->has_data())
	|| (bandwidth_limits !=  nullptr && bandwidth_limits->has_data())
	|| (overflow !=  nullptr && overflow->has_data())
	|| (underflow !=  nullptr && underflow->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::has_operation() const
{
    return is_set(operation)
	|| is_set(application_frequency.operation)
	|| is_set(collection_only.operation)
	|| is_set(enabled.operation)
	|| is_set(overflow_enable.operation)
	|| is_set(underflow_enable.operation)
	|| (adjustment_threshold !=  nullptr && adjustment_threshold->has_operation())
	|| (bandwidth_limits !=  nullptr && bandwidth_limits->has_operation())
	|| (overflow !=  nullptr && overflow->has_operation())
	|| (underflow !=  nullptr && underflow->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-bandwidth";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (application_frequency.is_set || is_set(application_frequency.operation)) leaf_name_data.push_back(application_frequency.get_name_leafdata());
    if (collection_only.is_set || is_set(collection_only.operation)) leaf_name_data.push_back(collection_only.get_name_leafdata());
    if (enabled.is_set || is_set(enabled.operation)) leaf_name_data.push_back(enabled.get_name_leafdata());
    if (overflow_enable.is_set || is_set(overflow_enable.operation)) leaf_name_data.push_back(overflow_enable.get_name_leafdata());
    if (underflow_enable.is_set || is_set(underflow_enable.operation)) leaf_name_data.push_back(underflow_enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "adjustment-threshold")
    {
        if(adjustment_threshold != nullptr)
        {
            children["adjustment-threshold"] = adjustment_threshold.get();
        }
        else
        {
            adjustment_threshold = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::AdjustmentThreshold>();
            adjustment_threshold->parent = this;
            children["adjustment-threshold"] = adjustment_threshold.get();
        }
        return children.at("adjustment-threshold");
    }

    if(child_yang_name == "bandwidth-limits")
    {
        if(bandwidth_limits != nullptr)
        {
            children["bandwidth-limits"] = bandwidth_limits.get();
        }
        else
        {
            bandwidth_limits = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::BandwidthLimits>();
            bandwidth_limits->parent = this;
            children["bandwidth-limits"] = bandwidth_limits.get();
        }
        return children.at("bandwidth-limits");
    }

    if(child_yang_name == "overflow")
    {
        if(overflow != nullptr)
        {
            children["overflow"] = overflow.get();
        }
        else
        {
            overflow = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Overflow>();
            overflow->parent = this;
            children["overflow"] = overflow.get();
        }
        return children.at("overflow");
    }

    if(child_yang_name == "underflow")
    {
        if(underflow != nullptr)
        {
            children["underflow"] = underflow.get();
        }
        else
        {
            underflow = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::Underflow>();
            underflow->parent = this;
            children["underflow"] = underflow.get();
        }
        return children.at("underflow");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::get_children()
{
    if(children.find("adjustment-threshold") == children.end())
    {
        if(adjustment_threshold != nullptr)
        {
            children["adjustment-threshold"] = adjustment_threshold.get();
        }
    }

    if(children.find("bandwidth-limits") == children.end())
    {
        if(bandwidth_limits != nullptr)
        {
            children["bandwidth-limits"] = bandwidth_limits.get();
        }
    }

    if(children.find("overflow") == children.end())
    {
        if(overflow != nullptr)
        {
            children["overflow"] = overflow.get();
        }
    }

    if(children.find("underflow") == children.end())
    {
        if(underflow != nullptr)
        {
            children["underflow"] = underflow.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "application-frequency")
    {
        application_frequency = value;
    }
    if(value_path == "collection-only")
    {
        collection_only = value;
    }
    if(value_path == "enabled")
    {
        enabled = value;
    }
    if(value_path == "overflow-enable")
    {
        overflow_enable = value;
    }
    if(value_path == "underflow-enable")
    {
        underflow_enable = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::Priority()
    :
    	hold_priority{YType::uint32, "hold-priority"},
	 setup_priority{YType::uint32, "setup-priority"}
{
    yang_name = "priority"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::~Priority()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::has_data() const
{
    return hold_priority.is_set
	|| setup_priority.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::has_operation() const
{
    return is_set(operation)
	|| is_set(hold_priority.operation)
	|| is_set(setup_priority.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "priority";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hold_priority.is_set || is_set(hold_priority.operation)) leaf_name_data.push_back(hold_priority.get_name_leafdata());
    if (setup_priority.is_set || is_set(setup_priority.operation)) leaf_name_data.push_back(setup_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hold-priority")
    {
        hold_priority = value;
    }
    if(value_path == "setup-priority")
    {
        setup_priority = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::Logging()
    :
    	all{YType::empty, "all"},
	 bandwidth_change_message{YType::empty, "bandwidth-change-message"},
	 bfd_state_message{YType::empty, "bfd-state-message"},
	 insufficient_bw_message{YType::empty, "insufficient-bw-message"},
	 lsp_switch_over_change_message{YType::empty, "lsp-switch-over-change-message"},
	 pcalc_failure_message{YType::empty, "pcalc-failure-message"},
	 record_route_messsage{YType::empty, "record-route-messsage"},
	 reoptimize_attempts_message{YType::empty, "reoptimize-attempts-message"},
	 reoptimized_message{YType::empty, "reoptimized-message"},
	 reroute_messsage{YType::empty, "reroute-messsage"},
	 state_message{YType::empty, "state-message"}
{
    yang_name = "logging"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::~Logging()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::has_data() const
{
    return all.is_set
	|| bandwidth_change_message.is_set
	|| bfd_state_message.is_set
	|| insufficient_bw_message.is_set
	|| lsp_switch_over_change_message.is_set
	|| pcalc_failure_message.is_set
	|| record_route_messsage.is_set
	|| reoptimize_attempts_message.is_set
	|| reoptimized_message.is_set
	|| reroute_messsage.is_set
	|| state_message.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::has_operation() const
{
    return is_set(operation)
	|| is_set(all.operation)
	|| is_set(bandwidth_change_message.operation)
	|| is_set(bfd_state_message.operation)
	|| is_set(insufficient_bw_message.operation)
	|| is_set(lsp_switch_over_change_message.operation)
	|| is_set(pcalc_failure_message.operation)
	|| is_set(record_route_messsage.operation)
	|| is_set(reoptimize_attempts_message.operation)
	|| is_set(reoptimized_message.operation)
	|| is_set(reroute_messsage.operation)
	|| is_set(state_message.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "logging";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all.is_set || is_set(all.operation)) leaf_name_data.push_back(all.get_name_leafdata());
    if (bandwidth_change_message.is_set || is_set(bandwidth_change_message.operation)) leaf_name_data.push_back(bandwidth_change_message.get_name_leafdata());
    if (bfd_state_message.is_set || is_set(bfd_state_message.operation)) leaf_name_data.push_back(bfd_state_message.get_name_leafdata());
    if (insufficient_bw_message.is_set || is_set(insufficient_bw_message.operation)) leaf_name_data.push_back(insufficient_bw_message.get_name_leafdata());
    if (lsp_switch_over_change_message.is_set || is_set(lsp_switch_over_change_message.operation)) leaf_name_data.push_back(lsp_switch_over_change_message.get_name_leafdata());
    if (pcalc_failure_message.is_set || is_set(pcalc_failure_message.operation)) leaf_name_data.push_back(pcalc_failure_message.get_name_leafdata());
    if (record_route_messsage.is_set || is_set(record_route_messsage.operation)) leaf_name_data.push_back(record_route_messsage.get_name_leafdata());
    if (reoptimize_attempts_message.is_set || is_set(reoptimize_attempts_message.operation)) leaf_name_data.push_back(reoptimize_attempts_message.get_name_leafdata());
    if (reoptimized_message.is_set || is_set(reoptimized_message.operation)) leaf_name_data.push_back(reoptimized_message.get_name_leafdata());
    if (reroute_messsage.is_set || is_set(reroute_messsage.operation)) leaf_name_data.push_back(reroute_messsage.get_name_leafdata());
    if (state_message.is_set || is_set(state_message.operation)) leaf_name_data.push_back(state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all")
    {
        all = value;
    }
    if(value_path == "bandwidth-change-message")
    {
        bandwidth_change_message = value;
    }
    if(value_path == "bfd-state-message")
    {
        bfd_state_message = value;
    }
    if(value_path == "insufficient-bw-message")
    {
        insufficient_bw_message = value;
    }
    if(value_path == "lsp-switch-over-change-message")
    {
        lsp_switch_over_change_message = value;
    }
    if(value_path == "pcalc-failure-message")
    {
        pcalc_failure_message = value;
    }
    if(value_path == "record-route-messsage")
    {
        record_route_messsage = value;
    }
    if(value_path == "reoptimize-attempts-message")
    {
        reoptimize_attempts_message = value;
    }
    if(value_path == "reoptimized-message")
    {
        reoptimized_message = value;
    }
    if(value_path == "reroute-messsage")
    {
        reroute_messsage = value;
    }
    if(value_path == "state-message")
    {
        state_message = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::Bandwidth()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 class_or_pool_type{YType::uint32, "class-or-pool-type"},
	 dste_type{YType::enumeration, "dste-type"}
{
    yang_name = "bandwidth"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::~Bandwidth()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::has_data() const
{
    return bandwidth.is_set
	|| class_or_pool_type.is_set
	|| dste_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(class_or_pool_type.operation)
	|| is_set(dste_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bandwidth";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (class_or_pool_type.is_set || is_set(class_or_pool_type.operation)) leaf_name_data.push_back(class_or_pool_type.get_name_leafdata());
    if (dste_type.is_set || is_set(dste_type.operation)) leaf_name_data.push_back(dste_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "class-or-pool-type")
    {
        class_or_pool_type = value;
    }
    if(value_path == "dste-type")
    {
        dste_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::Metric()
    :
    	absolute_metric{YType::uint32, "absolute-metric"},
	 constant_metric{YType::uint32, "constant-metric"},
	 metric_type{YType::enumeration, "metric-type"},
	 relative_metric{YType::int32, "relative-metric"}
{
    yang_name = "metric"; yang_parent_name = "autoroute";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::~Metric()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::has_data() const
{
    return absolute_metric.is_set
	|| constant_metric.is_set
	|| metric_type.is_set
	|| relative_metric.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::has_operation() const
{
    return is_set(operation)
	|| is_set(absolute_metric.operation)
	|| is_set(constant_metric.operation)
	|| is_set(metric_type.operation)
	|| is_set(relative_metric.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "metric";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (absolute_metric.is_set || is_set(absolute_metric.operation)) leaf_name_data.push_back(absolute_metric.get_name_leafdata());
    if (constant_metric.is_set || is_set(constant_metric.operation)) leaf_name_data.push_back(constant_metric.get_name_leafdata());
    if (metric_type.is_set || is_set(metric_type.operation)) leaf_name_data.push_back(metric_type.get_name_leafdata());
    if (relative_metric.is_set || is_set(relative_metric.operation)) leaf_name_data.push_back(relative_metric.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "absolute-metric")
    {
        absolute_metric = value;
    }
    if(value_path == "constant-metric")
    {
        constant_metric = value;
    }
    if(value_path == "metric-type")
    {
        metric_type = value;
    }
    if(value_path == "relative-metric")
    {
        relative_metric = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::Metric()
    :
    	absolute_metric{YType::uint32, "absolute-metric"},
	 constant_metric{YType::uint32, "constant-metric"},
	 metric_type{YType::enumeration, "metric-type"},
	 relative_metric{YType::int32, "relative-metric"}
{
    yang_name = "metric"; yang_parent_name = "autoroute-announce";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::~Metric()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::has_data() const
{
    return absolute_metric.is_set
	|| constant_metric.is_set
	|| metric_type.is_set
	|| relative_metric.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::has_operation() const
{
    return is_set(operation)
	|| is_set(absolute_metric.operation)
	|| is_set(constant_metric.operation)
	|| is_set(metric_type.operation)
	|| is_set(relative_metric.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "metric";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (absolute_metric.is_set || is_set(absolute_metric.operation)) leaf_name_data.push_back(absolute_metric.get_name_leafdata());
    if (constant_metric.is_set || is_set(constant_metric.operation)) leaf_name_data.push_back(constant_metric.get_name_leafdata());
    if (metric_type.is_set || is_set(metric_type.operation)) leaf_name_data.push_back(metric_type.get_name_leafdata());
    if (relative_metric.is_set || is_set(relative_metric.operation)) leaf_name_data.push_back(relative_metric.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "absolute-metric")
    {
        absolute_metric = value;
    }
    if(value_path == "constant-metric")
    {
        constant_metric = value;
    }
    if(value_path == "metric-type")
    {
        metric_type = value;
    }
    if(value_path == "relative-metric")
    {
        relative_metric = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::AutorouteAnnounce()
    :
    	enable{YType::empty, "enable"},
	 include_ipv6{YType::empty, "include-ipv6"}
    	,
    metric(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric>())
{
    metric->parent = this;
    children["metric"] = metric.get();

    yang_name = "autoroute-announce"; yang_parent_name = "autoroute";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::~AutorouteAnnounce()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::has_data() const
{
    return enable.is_set
	|| include_ipv6.is_set
	|| (metric !=  nullptr && metric->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| is_set(include_ipv6.operation)
	|| (metric !=  nullptr && metric->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "autoroute-announce";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (include_ipv6.is_set || is_set(include_ipv6.operation)) leaf_name_data.push_back(include_ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "metric")
    {
        if(metric != nullptr)
        {
            children["metric"] = metric.get();
        }
        else
        {
            metric = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::Metric>();
            metric->parent = this;
            children["metric"] = metric.get();
        }
        return children.at("metric");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::get_children()
{
    if(children.find("metric") == children.end())
    {
        if(metric != nullptr)
        {
            children["metric"] = metric.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "include-ipv6")
    {
        include_ipv6 = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::Destination()
    :
    	destination_address{YType::str, "destination-address"}
{
    yang_name = "destination"; yang_parent_name = "destination-xr";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::~Destination()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::has_data() const
{
    return destination_address.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination" <<"[destination-address='" <<destination_address.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::DestinationXr()
{
    yang_name = "destination-xr"; yang_parent_name = "autoroute";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::~DestinationXr()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::has_data() const
{
    for (std::size_t index=0; index<destination.size(); index++)
    {
        if(destination[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::has_operation() const
{
    for (std::size_t index=0; index<destination.size(); index++)
    {
        if(destination[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination-xr";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination")
    {
        for(auto const & c : destination)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::Destination>();
        c->parent = this;
        destination.push_back(std::move(c));
        children[segment_path] = destination.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::get_children()
{
    for (auto const & c : destination)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Autoroute()
    :
    	destination{YType::empty, "destination"}
    	,
    autoroute_announce(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce>())
	,destination_xr(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr>())
	,metric(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric>())
{
    autoroute_announce->parent = this;
    children["autoroute-announce"] = autoroute_announce.get();

    destination_xr->parent = this;
    children["destination-xr"] = destination_xr.get();

    metric->parent = this;
    children["metric"] = metric.get();

    yang_name = "autoroute"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::~Autoroute()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::has_data() const
{
    return destination.is_set
	|| (autoroute_announce !=  nullptr && autoroute_announce->has_data())
	|| (destination_xr !=  nullptr && destination_xr->has_data())
	|| (metric !=  nullptr && metric->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::has_operation() const
{
    return is_set(operation)
	|| is_set(destination.operation)
	|| (autoroute_announce !=  nullptr && autoroute_announce->has_operation())
	|| (destination_xr !=  nullptr && destination_xr->has_operation())
	|| (metric !=  nullptr && metric->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "autoroute";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination.is_set || is_set(destination.operation)) leaf_name_data.push_back(destination.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "autoroute-announce")
    {
        if(autoroute_announce != nullptr)
        {
            children["autoroute-announce"] = autoroute_announce.get();
        }
        else
        {
            autoroute_announce = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::AutorouteAnnounce>();
            autoroute_announce->parent = this;
            children["autoroute-announce"] = autoroute_announce.get();
        }
        return children.at("autoroute-announce");
    }

    if(child_yang_name == "destination-xr")
    {
        if(destination_xr != nullptr)
        {
            children["destination-xr"] = destination_xr.get();
        }
        else
        {
            destination_xr = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::DestinationXr>();
            destination_xr->parent = this;
            children["destination-xr"] = destination_xr.get();
        }
        return children.at("destination-xr");
    }

    if(child_yang_name == "metric")
    {
        if(metric != nullptr)
        {
            children["metric"] = metric.get();
        }
        else
        {
            metric = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::Metric>();
            metric->parent = this;
            children["metric"] = metric.get();
        }
        return children.at("metric");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::get_children()
{
    if(children.find("autoroute-announce") == children.end())
    {
        if(autoroute_announce != nullptr)
        {
            children["autoroute-announce"] = autoroute_announce.get();
        }
    }

    if(children.find("destination-xr") == children.end())
    {
        if(destination_xr != nullptr)
        {
            children["destination-xr"] = destination_xr.get();
        }
    }

    if(children.find("metric") == children.end())
    {
        if(metric != nullptr)
        {
            children["metric"] = metric.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination")
    {
        destination = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::NewStyleAffinityAffinityType()
    :
    	affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::~NewStyleAffinityAffinityType()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_data() const
{
    return affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::NewStyleAffinityAffinityTypeAffinity1()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::~NewStyleAffinityAffinityTypeAffinity1()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_data() const
{
    return affinity1.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::NewStyleAffinityAffinityTypeAffinity1Affinity2()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::~NewStyleAffinityAffinityTypeAffinity1Affinity2()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity10{YType::str, "affinity10"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_data() const
{
    return affinity1.is_set
	|| affinity10.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity10.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity10='" <<affinity10.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity10.is_set || is_set(affinity10.operation)) leaf_name_data.push_back(affinity10.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity10")
    {
        affinity10 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypes()
{
    yang_name = "new-style-affinity-affinity-types"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::~NewStyleAffinityAffinityTypes()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::has_data() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::has_operation() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-types";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type")
    {
        for(auto const & c : new_style_affinity_affinity_type)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType>();
        c->parent = this;
        new_style_affinity_affinity_type.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::get_children()
{
    for (auto const & c : new_style_affinity_affinity_type)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::FastReroute()
    :
    	bandwidth_protection{YType::uint32, "bandwidth-protection"},
	 node_protection{YType::uint32, "node-protection"}
{
    yang_name = "fast-reroute"; yang_parent_name = "tunnel-attributes";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::~FastReroute()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::has_data() const
{
    return bandwidth_protection.is_set
	|| node_protection.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_protection.operation)
	|| is_set(node_protection.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fast-reroute";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_protection.is_set || is_set(bandwidth_protection.operation)) leaf_name_data.push_back(bandwidth_protection.get_name_leafdata());
    if (node_protection.is_set || is_set(node_protection.operation)) leaf_name_data.push_back(node_protection.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-protection")
    {
        bandwidth_protection = value;
    }
    if(value_path == "node-protection")
    {
        node_protection = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelAttributes()
    :
    	destination{YType::str, "destination"},
	 forward_class{YType::uint32, "forward-class"},
	 load_share{YType::uint32, "load-share"},
	 path_selection_metric{YType::enumeration, "path-selection-metric"},
	 record_route{YType::empty, "record-route"},
	 shutdown{YType::empty, "shutdown"},
	 soft_preemption{YType::empty, "soft-preemption"}
    	,
    auto_bandwidth(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth>())
	,autoroute(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute>())
	,bandwidth(nullptr) // presence node
	,fast_reroute(nullptr) // presence node
	,logging(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging>())
	,new_style_affinity_affinity_types(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes>())
	,path_setups(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups>())
	,priority(nullptr) // presence node
	,tunnel_path_selection(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection>())
{
    auto_bandwidth->parent = this;
    children["auto-bandwidth"] = auto_bandwidth.get();

    autoroute->parent = this;
    children["autoroute"] = autoroute.get();

    logging->parent = this;
    children["logging"] = logging.get();

    new_style_affinity_affinity_types->parent = this;
    children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();

    path_setups->parent = this;
    children["path-setups"] = path_setups.get();

    tunnel_path_selection->parent = this;
    children["tunnel-path-selection"] = tunnel_path_selection.get();

    yang_name = "tunnel-attributes"; yang_parent_name = "tunnel";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::~TunnelAttributes()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::has_data() const
{
    return destination.is_set
	|| forward_class.is_set
	|| load_share.is_set
	|| path_selection_metric.is_set
	|| record_route.is_set
	|| shutdown.is_set
	|| soft_preemption.is_set
	|| (auto_bandwidth !=  nullptr && auto_bandwidth->has_data())
	|| (autoroute !=  nullptr && autoroute->has_data())
	|| (bandwidth !=  nullptr && bandwidth->has_data())
	|| (fast_reroute !=  nullptr && fast_reroute->has_data())
	|| (logging !=  nullptr && logging->has_data())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_data())
	|| (path_setups !=  nullptr && path_setups->has_data())
	|| (priority !=  nullptr && priority->has_data())
	|| (tunnel_path_selection !=  nullptr && tunnel_path_selection->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::has_operation() const
{
    return is_set(operation)
	|| is_set(destination.operation)
	|| is_set(forward_class.operation)
	|| is_set(load_share.operation)
	|| is_set(path_selection_metric.operation)
	|| is_set(record_route.operation)
	|| is_set(shutdown.operation)
	|| is_set(soft_preemption.operation)
	|| (auto_bandwidth !=  nullptr && auto_bandwidth->has_operation())
	|| (autoroute !=  nullptr && autoroute->has_operation())
	|| (bandwidth !=  nullptr && bandwidth->has_operation())
	|| (fast_reroute !=  nullptr && fast_reroute->has_operation())
	|| (logging !=  nullptr && logging->has_operation())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_operation())
	|| (path_setups !=  nullptr && path_setups->has_operation())
	|| (priority !=  nullptr && priority->has_operation())
	|| (tunnel_path_selection !=  nullptr && tunnel_path_selection->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination.is_set || is_set(destination.operation)) leaf_name_data.push_back(destination.get_name_leafdata());
    if (forward_class.is_set || is_set(forward_class.operation)) leaf_name_data.push_back(forward_class.get_name_leafdata());
    if (load_share.is_set || is_set(load_share.operation)) leaf_name_data.push_back(load_share.get_name_leafdata());
    if (path_selection_metric.is_set || is_set(path_selection_metric.operation)) leaf_name_data.push_back(path_selection_metric.get_name_leafdata());
    if (record_route.is_set || is_set(record_route.operation)) leaf_name_data.push_back(record_route.get_name_leafdata());
    if (shutdown.is_set || is_set(shutdown.operation)) leaf_name_data.push_back(shutdown.get_name_leafdata());
    if (soft_preemption.is_set || is_set(soft_preemption.operation)) leaf_name_data.push_back(soft_preemption.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "auto-bandwidth")
    {
        if(auto_bandwidth != nullptr)
        {
            children["auto-bandwidth"] = auto_bandwidth.get();
        }
        else
        {
            auto_bandwidth = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::AutoBandwidth>();
            auto_bandwidth->parent = this;
            children["auto-bandwidth"] = auto_bandwidth.get();
        }
        return children.at("auto-bandwidth");
    }

    if(child_yang_name == "autoroute")
    {
        if(autoroute != nullptr)
        {
            children["autoroute"] = autoroute.get();
        }
        else
        {
            autoroute = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Autoroute>();
            autoroute->parent = this;
            children["autoroute"] = autoroute.get();
        }
        return children.at("autoroute");
    }

    if(child_yang_name == "bandwidth")
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
        else
        {
            bandwidth = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Bandwidth>();
            bandwidth->parent = this;
            children["bandwidth"] = bandwidth.get();
        }
        return children.at("bandwidth");
    }

    if(child_yang_name == "fast-reroute")
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
        else
        {
            fast_reroute = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::FastReroute>();
            fast_reroute->parent = this;
            children["fast-reroute"] = fast_reroute.get();
        }
        return children.at("fast-reroute");
    }

    if(child_yang_name == "logging")
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
        else
        {
            logging = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Logging>();
            logging->parent = this;
            children["logging"] = logging.get();
        }
        return children.at("logging");
    }

    if(child_yang_name == "new-style-affinity-affinity-types")
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        else
        {
            new_style_affinity_affinity_types = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::NewStyleAffinityAffinityTypes>();
            new_style_affinity_affinity_types->parent = this;
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        return children.at("new-style-affinity-affinity-types");
    }

    if(child_yang_name == "path-setups")
    {
        if(path_setups != nullptr)
        {
            children["path-setups"] = path_setups.get();
        }
        else
        {
            path_setups = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::PathSetups>();
            path_setups->parent = this;
            children["path-setups"] = path_setups.get();
        }
        return children.at("path-setups");
    }

    if(child_yang_name == "priority")
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
        else
        {
            priority = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::Priority>();
            priority->parent = this;
            children["priority"] = priority.get();
        }
        return children.at("priority");
    }

    if(child_yang_name == "tunnel-path-selection")
    {
        if(tunnel_path_selection != nullptr)
        {
            children["tunnel-path-selection"] = tunnel_path_selection.get();
        }
        else
        {
            tunnel_path_selection = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::TunnelPathSelection>();
            tunnel_path_selection->parent = this;
            children["tunnel-path-selection"] = tunnel_path_selection.get();
        }
        return children.at("tunnel-path-selection");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::get_children()
{
    if(children.find("auto-bandwidth") == children.end())
    {
        if(auto_bandwidth != nullptr)
        {
            children["auto-bandwidth"] = auto_bandwidth.get();
        }
    }

    if(children.find("autoroute") == children.end())
    {
        if(autoroute != nullptr)
        {
            children["autoroute"] = autoroute.get();
        }
    }

    if(children.find("bandwidth") == children.end())
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
    }

    if(children.find("fast-reroute") == children.end())
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
    }

    if(children.find("logging") == children.end())
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
    }

    if(children.find("new-style-affinity-affinity-types") == children.end())
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
    }

    if(children.find("path-setups") == children.end())
    {
        if(path_setups != nullptr)
        {
            children["path-setups"] = path_setups.get();
        }
    }

    if(children.find("priority") == children.end())
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
    }

    if(children.find("tunnel-path-selection") == children.end())
    {
        if(tunnel_path_selection != nullptr)
        {
            children["tunnel-path-selection"] = tunnel_path_selection.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination")
    {
        destination = value;
    }
    if(value_path == "forward-class")
    {
        forward_class = value;
    }
    if(value_path == "load-share")
    {
        load_share = value;
    }
    if(value_path == "path-selection-metric")
    {
        path_selection_metric = value;
    }
    if(value_path == "record-route")
    {
        record_route = value;
    }
    if(value_path == "shutdown")
    {
        shutdown = value;
    }
    if(value_path == "soft-preemption")
    {
        soft_preemption = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::TunnelId()
    :
    	tunnel_id{YType::uint32, "tunnel-id"},
	 tunnel_id_type{YType::enumeration, "tunnel-id-type"}
{
    yang_name = "tunnel-id"; yang_parent_name = "tunnel";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::~TunnelId()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::has_data() const
{
    return tunnel_id.is_set
	|| tunnel_id_type.is_set;
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::has_operation() const
{
    return is_set(operation)
	|| is_set(tunnel_id.operation)
	|| is_set(tunnel_id_type.operation);
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-id";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tunnel_id.is_set || is_set(tunnel_id.operation)) leaf_name_data.push_back(tunnel_id.get_name_leafdata());
    if (tunnel_id_type.is_set || is_set(tunnel_id_type.operation)) leaf_name_data.push_back(tunnel_id_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::get_children()
{
    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tunnel-id")
    {
        tunnel_id = value;
    }
    if(value_path == "tunnel-id-type")
    {
        tunnel_id_type = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnel::Tunnel()
    :
    	tunnel_name{YType::str, "tunnel-name"},
	 tunnel_type{YType::enumeration, "tunnel-type"},
	 enable{YType::empty, "enable"}
    	,
    tunnel_attributes(std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes>())
	,tunnel_id(nullptr) // presence node
{
    tunnel_attributes->parent = this;
    children["tunnel-attributes"] = tunnel_attributes.get();

    yang_name = "tunnel"; yang_parent_name = "tunnels";
}

MplsTe::NamedTunnels::Tunnels::Tunnel::~Tunnel()
{
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::has_data() const
{
    return tunnel_name.is_set
	|| tunnel_type.is_set
	|| enable.is_set
	|| (tunnel_attributes !=  nullptr && tunnel_attributes->has_data())
	|| (tunnel_id !=  nullptr && tunnel_id->has_data());
}

bool MplsTe::NamedTunnels::Tunnels::Tunnel::has_operation() const
{
    return is_set(operation)
	|| is_set(tunnel_name.operation)
	|| is_set(tunnel_type.operation)
	|| is_set(enable.operation)
	|| (tunnel_attributes !=  nullptr && tunnel_attributes->has_operation())
	|| (tunnel_id !=  nullptr && tunnel_id->has_operation());
}

std::string MplsTe::NamedTunnels::Tunnels::Tunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel" <<"[tunnel-name='" <<tunnel_name.get() <<"']" <<"[tunnel-type='" <<tunnel_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::Tunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/named-tunnels/tunnels/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tunnel_name.is_set || is_set(tunnel_name.operation)) leaf_name_data.push_back(tunnel_name.get_name_leafdata());
    if (tunnel_type.is_set || is_set(tunnel_type.operation)) leaf_name_data.push_back(tunnel_type.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::Tunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnel-attributes")
    {
        if(tunnel_attributes != nullptr)
        {
            children["tunnel-attributes"] = tunnel_attributes.get();
        }
        else
        {
            tunnel_attributes = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelAttributes>();
            tunnel_attributes->parent = this;
            children["tunnel-attributes"] = tunnel_attributes.get();
        }
        return children.at("tunnel-attributes");
    }

    if(child_yang_name == "tunnel-id")
    {
        if(tunnel_id != nullptr)
        {
            children["tunnel-id"] = tunnel_id.get();
        }
        else
        {
            tunnel_id = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel::TunnelId>();
            tunnel_id->parent = this;
            children["tunnel-id"] = tunnel_id.get();
        }
        return children.at("tunnel-id");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::Tunnel::get_children()
{
    if(children.find("tunnel-attributes") == children.end())
    {
        if(tunnel_attributes != nullptr)
        {
            children["tunnel-attributes"] = tunnel_attributes.get();
        }
    }

    if(children.find("tunnel-id") == children.end())
    {
        if(tunnel_id != nullptr)
        {
            children["tunnel-id"] = tunnel_id.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::Tunnel::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tunnel-name")
    {
        tunnel_name = value;
    }
    if(value_path == "tunnel-type")
    {
        tunnel_type = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::NamedTunnels::Tunnels::Tunnels()
{
    yang_name = "tunnels"; yang_parent_name = "named-tunnels";
}

MplsTe::NamedTunnels::Tunnels::~Tunnels()
{
}

bool MplsTe::NamedTunnels::Tunnels::has_data() const
{
    for (std::size_t index=0; index<tunnel.size(); index++)
    {
        if(tunnel[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::NamedTunnels::Tunnels::has_operation() const
{
    for (std::size_t index=0; index<tunnel.size(); index++)
    {
        if(tunnel[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::NamedTunnels::Tunnels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnels";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::Tunnels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/named-tunnels/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::Tunnels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnel")
    {
        for(auto const & c : tunnel)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::NamedTunnels::Tunnels::Tunnel>();
        c->parent = this;
        tunnel.push_back(std::move(c));
        children[segment_path] = tunnel.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::Tunnels::get_children()
{
    for (auto const & c : tunnel)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::Tunnels::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::NamedTunnels::NamedTunnels()
    :
    	enable{YType::empty, "enable"}
    	,
    tunnels(std::make_unique<MplsTe::NamedTunnels::Tunnels>())
{
    tunnels->parent = this;
    children["tunnels"] = tunnels.get();

    yang_name = "named-tunnels"; yang_parent_name = "mpls-te";
}

MplsTe::NamedTunnels::~NamedTunnels()
{
}

bool MplsTe::NamedTunnels::has_data() const
{
    return enable.is_set
	|| (tunnels !=  nullptr && tunnels->has_data());
}

bool MplsTe::NamedTunnels::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| (tunnels !=  nullptr && tunnels->has_operation());
}

std::string MplsTe::NamedTunnels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "named-tunnels";

    return path_buffer.str();

}

EntityPath MplsTe::NamedTunnels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::NamedTunnels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnels")
    {
        if(tunnels != nullptr)
        {
            children["tunnels"] = tunnels.get();
        }
        else
        {
            tunnels = std::make_unique<MplsTe::NamedTunnels::Tunnels>();
            tunnels->parent = this;
            children["tunnels"] = tunnels.get();
        }
        return children.at("tunnels");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::NamedTunnels::get_children()
{
    if(children.find("tunnels") == children.end())
    {
        if(tunnels != nullptr)
        {
            children["tunnels"] = tunnels.get();
        }
    }

    return children;
}

void MplsTe::NamedTunnels::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::Holddown()
    :
    	maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"}
{
    yang_name = "holddown"; yang_parent_name = "path-option-timers";
}

MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::~Holddown()
{
}

bool MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::has_data() const
{
    return maximum.is_set
	|| minimum.is_set;
}

bool MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::has_operation() const
{
    return is_set(operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation);
}

std::string MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "holddown";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/timers/path-option-timers/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
}

MplsTe::GmplsUni::Timers::PathOptionTimers::PathOptionTimers()
    :
    holddown(std::make_unique<MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown>())
{
    holddown->parent = this;
    children["holddown"] = holddown.get();

    yang_name = "path-option-timers"; yang_parent_name = "timers";
}

MplsTe::GmplsUni::Timers::PathOptionTimers::~PathOptionTimers()
{
}

bool MplsTe::GmplsUni::Timers::PathOptionTimers::has_data() const
{
    return (holddown !=  nullptr && holddown->has_data());
}

bool MplsTe::GmplsUni::Timers::PathOptionTimers::has_operation() const
{
    return is_set(operation)
	|| (holddown !=  nullptr && holddown->has_operation());
}

std::string MplsTe::GmplsUni::Timers::PathOptionTimers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-option-timers";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Timers::PathOptionTimers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/timers/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Timers::PathOptionTimers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "holddown")
    {
        if(holddown != nullptr)
        {
            children["holddown"] = holddown.get();
        }
        else
        {
            holddown = std::make_unique<MplsTe::GmplsUni::Timers::PathOptionTimers::Holddown>();
            holddown->parent = this;
            children["holddown"] = holddown.get();
        }
        return children.at("holddown");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Timers::PathOptionTimers::get_children()
{
    if(children.find("holddown") == children.end())
    {
        if(holddown != nullptr)
        {
            children["holddown"] = holddown.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::Timers::PathOptionTimers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsUni::Timers::Timers()
    :
    path_option_timers(std::make_unique<MplsTe::GmplsUni::Timers::PathOptionTimers>())
{
    path_option_timers->parent = this;
    children["path-option-timers"] = path_option_timers.get();

    yang_name = "timers"; yang_parent_name = "gmpls-uni";
}

MplsTe::GmplsUni::Timers::~Timers()
{
}

bool MplsTe::GmplsUni::Timers::has_data() const
{
    return (path_option_timers !=  nullptr && path_option_timers->has_data());
}

bool MplsTe::GmplsUni::Timers::has_operation() const
{
    return is_set(operation)
	|| (path_option_timers !=  nullptr && path_option_timers->has_operation());
}

std::string MplsTe::GmplsUni::Timers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timers";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Timers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Timers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-option-timers")
    {
        if(path_option_timers != nullptr)
        {
            children["path-option-timers"] = path_option_timers.get();
        }
        else
        {
            path_option_timers = std::make_unique<MplsTe::GmplsUni::Timers::PathOptionTimers>();
            path_option_timers->parent = this;
            children["path-option-timers"] = path_option_timers.get();
        }
        return children.at("path-option-timers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Timers::get_children()
{
    if(children.find("path-option-timers") == children.end())
    {
        if(path_option_timers != nullptr)
        {
            children["path-option-timers"] = path_option_timers.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::Timers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsUni::Controllers::Controller::Announce::Announce()
    :
    	srl_gs{YType::empty, "srl-gs"}
{
    yang_name = "announce"; yang_parent_name = "controller";
}

MplsTe::GmplsUni::Controllers::Controller::Announce::~Announce()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::Announce::has_data() const
{
    return srl_gs.is_set;
}

bool MplsTe::GmplsUni::Controllers::Controller::Announce::has_operation() const
{
    return is_set(operation)
	|| is_set(srl_gs.operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::Announce::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "announce";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::Announce::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srl_gs.is_set || is_set(srl_gs.operation)) leaf_name_data.push_back(srl_gs.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::Announce::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::Announce::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::Announce::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srl-gs")
    {
        srl_gs = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::ControllerLogging()
    :
    	discovered_srlg_change_logging{YType::empty, "discovered-srlg-change-logging"}
{
    yang_name = "controller-logging"; yang_parent_name = "controller";
}

MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::~ControllerLogging()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::has_data() const
{
    return discovered_srlg_change_logging.is_set;
}

bool MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::has_operation() const
{
    return is_set(operation)
	|| is_set(discovered_srlg_change_logging.operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controller-logging";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (discovered_srlg_change_logging.is_set || is_set(discovered_srlg_change_logging.operation)) leaf_name_data.push_back(discovered_srlg_change_logging.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::ControllerLogging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "discovered-srlg-change-logging")
    {
        discovered_srlg_change_logging = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::PathOption()
    :
    	preference_level{YType::uint32, "preference-level"},
	 dwdm_channel{YType::uint32, "dwdm-channel"},
	 lockdown{YType::enumeration, "lockdown"},
	 path_id{YType::uint32, "path-id"},
	 path_name{YType::str, "path-name"},
	 path_type{YType::enumeration, "path-type"},
	 signaled_label{YType::enumeration, "signaled-label"},
	 verbatim{YType::enumeration, "verbatim"},
	 xro_attribute_set_name{YType::str, "xro-attribute-set-name"},
	 xro_type{YType::empty, "xro-type"}
{
    yang_name = "path-option"; yang_parent_name = "path-options";
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::~PathOption()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::has_data() const
{
    return preference_level.is_set
	|| dwdm_channel.is_set
	|| lockdown.is_set
	|| path_id.is_set
	|| path_name.is_set
	|| path_type.is_set
	|| signaled_label.is_set
	|| verbatim.is_set
	|| xro_attribute_set_name.is_set
	|| xro_type.is_set;
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::has_operation() const
{
    return is_set(operation)
	|| is_set(preference_level.operation)
	|| is_set(dwdm_channel.operation)
	|| is_set(lockdown.operation)
	|| is_set(path_id.operation)
	|| is_set(path_name.operation)
	|| is_set(path_type.operation)
	|| is_set(signaled_label.operation)
	|| is_set(verbatim.operation)
	|| is_set(xro_attribute_set_name.operation)
	|| is_set(xro_type.operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-option" <<"[preference-level='" <<preference_level.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (preference_level.is_set || is_set(preference_level.operation)) leaf_name_data.push_back(preference_level.get_name_leafdata());
    if (dwdm_channel.is_set || is_set(dwdm_channel.operation)) leaf_name_data.push_back(dwdm_channel.get_name_leafdata());
    if (lockdown.is_set || is_set(lockdown.operation)) leaf_name_data.push_back(lockdown.get_name_leafdata());
    if (path_id.is_set || is_set(path_id.operation)) leaf_name_data.push_back(path_id.get_name_leafdata());
    if (path_name.is_set || is_set(path_name.operation)) leaf_name_data.push_back(path_name.get_name_leafdata());
    if (path_type.is_set || is_set(path_type.operation)) leaf_name_data.push_back(path_type.get_name_leafdata());
    if (signaled_label.is_set || is_set(signaled_label.operation)) leaf_name_data.push_back(signaled_label.get_name_leafdata());
    if (verbatim.is_set || is_set(verbatim.operation)) leaf_name_data.push_back(verbatim.get_name_leafdata());
    if (xro_attribute_set_name.is_set || is_set(xro_attribute_set_name.operation)) leaf_name_data.push_back(xro_attribute_set_name.get_name_leafdata());
    if (xro_type.is_set || is_set(xro_type.operation)) leaf_name_data.push_back(xro_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "preference-level")
    {
        preference_level = value;
    }
    if(value_path == "dwdm-channel")
    {
        dwdm_channel = value;
    }
    if(value_path == "lockdown")
    {
        lockdown = value;
    }
    if(value_path == "path-id")
    {
        path_id = value;
    }
    if(value_path == "path-name")
    {
        path_name = value;
    }
    if(value_path == "path-type")
    {
        path_type = value;
    }
    if(value_path == "signaled-label")
    {
        signaled_label = value;
    }
    if(value_path == "verbatim")
    {
        verbatim = value;
    }
    if(value_path == "xro-attribute-set-name")
    {
        xro_attribute_set_name = value;
    }
    if(value_path == "xro-type")
    {
        xro_type = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOptions()
{
    yang_name = "path-options"; yang_parent_name = "gmpls-unitunnel-head";
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::~PathOptions()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::has_data() const
{
    for (std::size_t index=0; index<path_option.size(); index++)
    {
        if(path_option[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::has_operation() const
{
    for (std::size_t index=0; index<path_option.size(); index++)
    {
        if(path_option[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-options";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-option")
    {
        for(auto const & c : path_option)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::PathOption>();
        c->parent = this;
        path_option.push_back(std::move(c));
        children[segment_path] = path_option.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::get_children()
{
    for (auto const & c : path_option)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::Recording()
    :
    	srlg{YType::empty, "srlg"}
{
    yang_name = "recording"; yang_parent_name = "gmpls-unitunnel-head";
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::~Recording()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::has_data() const
{
    return srlg.is_set;
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::has_operation() const
{
    return is_set(operation)
	|| is_set(srlg.operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "recording";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srlg.is_set || is_set(srlg.operation)) leaf_name_data.push_back(srlg.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srlg")
    {
        srlg = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::Logging()
    :
    	state_message{YType::empty, "state-message"}
{
    yang_name = "logging"; yang_parent_name = "gmpls-unitunnel-head";
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::~Logging()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::has_data() const
{
    return state_message.is_set;
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::has_operation() const
{
    return is_set(operation)
	|| is_set(state_message.operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "logging";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (state_message.is_set || is_set(state_message.operation)) leaf_name_data.push_back(state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "state-message")
    {
        state_message = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::Priority()
    :
    	hold_priority{YType::uint32, "hold-priority"},
	 setup_priority{YType::uint32, "setup-priority"}
{
    yang_name = "priority"; yang_parent_name = "gmpls-unitunnel-head";
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::~Priority()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::has_data() const
{
    return hold_priority.is_set
	|| setup_priority.is_set;
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::has_operation() const
{
    return is_set(operation)
	|| is_set(hold_priority.operation)
	|| is_set(setup_priority.operation);
}

std::string MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "priority";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hold_priority.is_set || is_set(hold_priority.operation)) leaf_name_data.push_back(hold_priority.get_name_leafdata());
    if (setup_priority.is_set || is_set(setup_priority.operation)) leaf_name_data.push_back(setup_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::get_children()
{
    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hold-priority")
    {
        hold_priority = value;
    }
    if(value_path == "setup-priority")
    {
        setup_priority = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::GmplsUnitunnelHead()
    :
    	destination{YType::str, "destination"},
	 enable{YType::empty, "enable"},
	 record_route{YType::empty, "record-route"},
	 signalled_name{YType::str, "signalled-name"},
	 tunnel_id{YType::uint32, "tunnel-id"}
    	,
    logging(std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging>())
	,path_options(std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions>())
	,priority(nullptr) // presence node
	,recording(std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording>())
{
    logging->parent = this;
    children["logging"] = logging.get();

    path_options->parent = this;
    children["path-options"] = path_options.get();

    recording->parent = this;
    children["recording"] = recording.get();

    yang_name = "gmpls-unitunnel-head"; yang_parent_name = "controller";
}

MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::~GmplsUnitunnelHead()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::has_data() const
{
    return destination.is_set
	|| enable.is_set
	|| record_route.is_set
	|| signalled_name.is_set
	|| tunnel_id.is_set
	|| (logging !=  nullptr && logging->has_data())
	|| (path_options !=  nullptr && path_options->has_data())
	|| (priority !=  nullptr && priority->has_data())
	|| (recording !=  nullptr && recording->has_data());
}

bool MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::has_operation() const
{
    return is_set(operation)
	|| is_set(destination.operation)
	|| is_set(enable.operation)
	|| is_set(record_route.operation)
	|| is_set(signalled_name.operation)
	|| is_set(tunnel_id.operation)
	|| (logging !=  nullptr && logging->has_operation())
	|| (path_options !=  nullptr && path_options->has_operation())
	|| (priority !=  nullptr && priority->has_operation())
	|| (recording !=  nullptr && recording->has_operation());
}

std::string MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "gmpls-unitunnel-head";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination.is_set || is_set(destination.operation)) leaf_name_data.push_back(destination.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (record_route.is_set || is_set(record_route.operation)) leaf_name_data.push_back(record_route.get_name_leafdata());
    if (signalled_name.is_set || is_set(signalled_name.operation)) leaf_name_data.push_back(signalled_name.get_name_leafdata());
    if (tunnel_id.is_set || is_set(tunnel_id.operation)) leaf_name_data.push_back(tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "logging")
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
        else
        {
            logging = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Logging>();
            logging->parent = this;
            children["logging"] = logging.get();
        }
        return children.at("logging");
    }

    if(child_yang_name == "path-options")
    {
        if(path_options != nullptr)
        {
            children["path-options"] = path_options.get();
        }
        else
        {
            path_options = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::PathOptions>();
            path_options->parent = this;
            children["path-options"] = path_options.get();
        }
        return children.at("path-options");
    }

    if(child_yang_name == "priority")
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
        else
        {
            priority = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Priority>();
            priority->parent = this;
            children["priority"] = priority.get();
        }
        return children.at("priority");
    }

    if(child_yang_name == "recording")
    {
        if(recording != nullptr)
        {
            children["recording"] = recording.get();
        }
        else
        {
            recording = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::Recording>();
            recording->parent = this;
            children["recording"] = recording.get();
        }
        return children.at("recording");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::get_children()
{
    if(children.find("logging") == children.end())
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
    }

    if(children.find("path-options") == children.end())
    {
        if(path_options != nullptr)
        {
            children["path-options"] = path_options.get();
        }
    }

    if(children.find("priority") == children.end())
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
    }

    if(children.find("recording") == children.end())
    {
        if(recording != nullptr)
        {
            children["recording"] = recording.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination")
    {
        destination = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "record-route")
    {
        record_route = value;
    }
    if(value_path == "signalled-name")
    {
        signalled_name = value;
    }
    if(value_path == "tunnel-id")
    {
        tunnel_id = value;
    }
}

MplsTe::GmplsUni::Controllers::Controller::Controller()
    :
    	controller_name{YType::str, "controller-name"},
	 enable{YType::empty, "enable"}
    	,
    announce(std::make_unique<MplsTe::GmplsUni::Controllers::Controller::Announce>())
	,controller_logging(std::make_unique<MplsTe::GmplsUni::Controllers::Controller::ControllerLogging>())
	,gmpls_unitunnel_head(std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead>())
{
    announce->parent = this;
    children["announce"] = announce.get();

    controller_logging->parent = this;
    children["controller-logging"] = controller_logging.get();

    gmpls_unitunnel_head->parent = this;
    children["gmpls-unitunnel-head"] = gmpls_unitunnel_head.get();

    yang_name = "controller"; yang_parent_name = "controllers";
}

MplsTe::GmplsUni::Controllers::Controller::~Controller()
{
}

bool MplsTe::GmplsUni::Controllers::Controller::has_data() const
{
    return controller_name.is_set
	|| enable.is_set
	|| (announce !=  nullptr && announce->has_data())
	|| (controller_logging !=  nullptr && controller_logging->has_data())
	|| (gmpls_unitunnel_head !=  nullptr && gmpls_unitunnel_head->has_data());
}

bool MplsTe::GmplsUni::Controllers::Controller::has_operation() const
{
    return is_set(operation)
	|| is_set(controller_name.operation)
	|| is_set(enable.operation)
	|| (announce !=  nullptr && announce->has_operation())
	|| (controller_logging !=  nullptr && controller_logging->has_operation())
	|| (gmpls_unitunnel_head !=  nullptr && gmpls_unitunnel_head->has_operation());
}

std::string MplsTe::GmplsUni::Controllers::Controller::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controller" <<"[controller-name='" <<controller_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::Controller::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/controllers/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (controller_name.is_set || is_set(controller_name.operation)) leaf_name_data.push_back(controller_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::Controller::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "announce")
    {
        if(announce != nullptr)
        {
            children["announce"] = announce.get();
        }
        else
        {
            announce = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::Announce>();
            announce->parent = this;
            children["announce"] = announce.get();
        }
        return children.at("announce");
    }

    if(child_yang_name == "controller-logging")
    {
        if(controller_logging != nullptr)
        {
            children["controller-logging"] = controller_logging.get();
        }
        else
        {
            controller_logging = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::ControllerLogging>();
            controller_logging->parent = this;
            children["controller-logging"] = controller_logging.get();
        }
        return children.at("controller-logging");
    }

    if(child_yang_name == "gmpls-unitunnel-head")
    {
        if(gmpls_unitunnel_head != nullptr)
        {
            children["gmpls-unitunnel-head"] = gmpls_unitunnel_head.get();
        }
        else
        {
            gmpls_unitunnel_head = std::make_unique<MplsTe::GmplsUni::Controllers::Controller::GmplsUnitunnelHead>();
            gmpls_unitunnel_head->parent = this;
            children["gmpls-unitunnel-head"] = gmpls_unitunnel_head.get();
        }
        return children.at("gmpls-unitunnel-head");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::Controller::get_children()
{
    if(children.find("announce") == children.end())
    {
        if(announce != nullptr)
        {
            children["announce"] = announce.get();
        }
    }

    if(children.find("controller-logging") == children.end())
    {
        if(controller_logging != nullptr)
        {
            children["controller-logging"] = controller_logging.get();
        }
    }

    if(children.find("gmpls-unitunnel-head") == children.end())
    {
        if(gmpls_unitunnel_head != nullptr)
        {
            children["gmpls-unitunnel-head"] = gmpls_unitunnel_head.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::Controllers::Controller::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "controller-name")
    {
        controller_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GmplsUni::Controllers::Controllers()
{
    yang_name = "controllers"; yang_parent_name = "gmpls-uni";
}

MplsTe::GmplsUni::Controllers::~Controllers()
{
}

bool MplsTe::GmplsUni::Controllers::has_data() const
{
    for (std::size_t index=0; index<controller.size(); index++)
    {
        if(controller[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsUni::Controllers::has_operation() const
{
    for (std::size_t index=0; index<controller.size(); index++)
    {
        if(controller[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsUni::Controllers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controllers";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::Controllers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-uni/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::Controllers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "controller")
    {
        for(auto const & c : controller)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsUni::Controllers::Controller>();
        c->parent = this;
        controller.push_back(std::move(c));
        children[segment_path] = controller.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::Controllers::get_children()
{
    for (auto const & c : controller)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::Controllers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsUni::GmplsUni()
    :
    controllers(std::make_unique<MplsTe::GmplsUni::Controllers>())
	,timers(std::make_unique<MplsTe::GmplsUni::Timers>())
{
    controllers->parent = this;
    children["controllers"] = controllers.get();

    timers->parent = this;
    children["timers"] = timers.get();

    yang_name = "gmpls-uni"; yang_parent_name = "mpls-te";
}

MplsTe::GmplsUni::~GmplsUni()
{
}

bool MplsTe::GmplsUni::has_data() const
{
    return (controllers !=  nullptr && controllers->has_data())
	|| (timers !=  nullptr && timers->has_data());
}

bool MplsTe::GmplsUni::has_operation() const
{
    return is_set(operation)
	|| (controllers !=  nullptr && controllers->has_operation())
	|| (timers !=  nullptr && timers->has_operation());
}

std::string MplsTe::GmplsUni::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "gmpls-uni";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsUni::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsUni::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "controllers")
    {
        if(controllers != nullptr)
        {
            children["controllers"] = controllers.get();
        }
        else
        {
            controllers = std::make_unique<MplsTe::GmplsUni::Controllers>();
            controllers->parent = this;
            children["controllers"] = controllers.get();
        }
        return children.at("controllers");
    }

    if(child_yang_name == "timers")
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
        else
        {
            timers = std::make_unique<MplsTe::GmplsUni::Timers>();
            timers->parent = this;
            children["timers"] = timers.get();
        }
        return children.at("timers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsUni::get_children()
{
    if(children.find("controllers") == children.end())
    {
        if(controllers != nullptr)
        {
            children["controllers"] = controllers.get();
        }
    }

    if(children.find("timers") == children.end())
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
    }

    return children;
}

void MplsTe::GmplsUni::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::TunnelRange()
    :
    	max_tunnel_id{YType::uint32, "max-tunnel-id"},
	 min_tunnel_id{YType::uint32, "min-tunnel-id"}
{
    yang_name = "tunnel-range"; yang_parent_name = "pcc";
}

MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::~TunnelRange()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::has_data() const
{
    return max_tunnel_id.is_set
	|| min_tunnel_id.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::has_operation() const
{
    return is_set(operation)
	|| is_set(max_tunnel_id.operation)
	|| is_set(min_tunnel_id.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-range";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/pcc/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (max_tunnel_id.is_set || is_set(max_tunnel_id.operation)) leaf_name_data.push_back(max_tunnel_id.get_name_leafdata());
    if (min_tunnel_id.is_set || is_set(min_tunnel_id.operation)) leaf_name_data.push_back(min_tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "max-tunnel-id")
    {
        max_tunnel_id = value;
    }
    if(value_path == "min-tunnel-id")
    {
        min_tunnel_id = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Pcc::Pcc()
    :
    tunnel_range(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange>())
{
    tunnel_range->parent = this;
    children["tunnel-range"] = tunnel_range.get();

    yang_name = "pcc"; yang_parent_name = "auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::Pcc::~Pcc()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Pcc::has_data() const
{
    return (tunnel_range !=  nullptr && tunnel_range->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::Pcc::has_operation() const
{
    return is_set(operation)
	|| (tunnel_range !=  nullptr && tunnel_range->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Pcc::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pcc";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Pcc::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Pcc::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnel-range")
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
        else
        {
            tunnel_range = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Pcc::TunnelRange>();
            tunnel_range->parent = this;
            children["tunnel-range"] = tunnel_range.get();
        }
        return children.at("tunnel-range");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Pcc::get_children()
{
    if(children.find("tunnel-range") == children.end())
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Pcc::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::TunnelRange()
    :
    	max_tunnel_id{YType::uint32, "max-tunnel-id"},
	 min_tunnel_id{YType::uint32, "min-tunnel-id"}
{
    yang_name = "tunnel-range"; yang_parent_name = "p2p-auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::~TunnelRange()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::has_data() const
{
    return max_tunnel_id.is_set
	|| min_tunnel_id.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::has_operation() const
{
    return is_set(operation)
	|| is_set(max_tunnel_id.operation)
	|| is_set(min_tunnel_id.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-range";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/p2p-auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (max_tunnel_id.is_set || is_set(max_tunnel_id.operation)) leaf_name_data.push_back(max_tunnel_id.get_name_leafdata());
    if (min_tunnel_id.is_set || is_set(min_tunnel_id.operation)) leaf_name_data.push_back(min_tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "max-tunnel-id")
    {
        max_tunnel_id = value;
    }
    if(value_path == "min-tunnel-id")
    {
        min_tunnel_id = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::P2PAutoTunnel()
    :
    tunnel_range(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange>())
{
    tunnel_range->parent = this;
    children["tunnel-range"] = tunnel_range.get();

    yang_name = "p2p-auto-tunnel"; yang_parent_name = "auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::~P2PAutoTunnel()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::has_data() const
{
    return (tunnel_range !=  nullptr && tunnel_range->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::has_operation() const
{
    return is_set(operation)
	|| (tunnel_range !=  nullptr && tunnel_range->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2p-auto-tunnel";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnel-range")
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
        else
        {
            tunnel_range = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::TunnelRange>();
            tunnel_range->parent = this;
            children["tunnel-range"] = tunnel_range.get();
        }
        return children.at("tunnel-range");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::get_children()
{
    if(children.find("tunnel-range") == children.end())
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::Removal()
    :
    	unused{YType::uint32, "unused"}
{
    yang_name = "removal"; yang_parent_name = "timers";
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::~Removal()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::has_data() const
{
    return unused.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::has_operation() const
{
    return is_set(operation)
	|| is_set(unused.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "removal";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/backup/timers/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (unused.is_set || is_set(unused.operation)) leaf_name_data.push_back(unused.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "unused")
    {
        unused = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Timers()
    :
    removal(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal>())
{
    removal->parent = this;
    children["removal"] = removal.get();

    yang_name = "timers"; yang_parent_name = "backup";
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::~Timers()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::has_data() const
{
    return (removal !=  nullptr && removal->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::has_operation() const
{
    return is_set(operation)
	|| (removal !=  nullptr && removal->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timers";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/backup/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "removal")
    {
        if(removal != nullptr)
        {
            children["removal"] = removal.get();
        }
        else
        {
            removal = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::Removal>();
            removal->parent = this;
            children["removal"] = removal.get();
        }
        return children.at("removal");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::get_children()
{
    if(children.find("removal") == children.end())
    {
        if(removal != nullptr)
        {
            children["removal"] = removal.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::TunnelRange()
    :
    	max_tunnel_id{YType::uint32, "max-tunnel-id"},
	 min_tunnel_id{YType::uint32, "min-tunnel-id"}
{
    yang_name = "tunnel-range"; yang_parent_name = "backup";
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::~TunnelRange()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::has_data() const
{
    return max_tunnel_id.is_set
	|| min_tunnel_id.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::has_operation() const
{
    return is_set(operation)
	|| is_set(max_tunnel_id.operation)
	|| is_set(min_tunnel_id.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-range";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/backup/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (max_tunnel_id.is_set || is_set(max_tunnel_id.operation)) leaf_name_data.push_back(max_tunnel_id.get_name_leafdata());
    if (min_tunnel_id.is_set || is_set(min_tunnel_id.operation)) leaf_name_data.push_back(min_tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "max-tunnel-id")
    {
        max_tunnel_id = value;
    }
    if(value_path == "min-tunnel-id")
    {
        min_tunnel_id = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::Backup()
    :
    	affinity_ignore{YType::empty, "affinity-ignore"}
    	,
    timers(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers>())
	,tunnel_range(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange>())
{
    timers->parent = this;
    children["timers"] = timers.get();

    tunnel_range->parent = this;
    children["tunnel-range"] = tunnel_range.get();

    yang_name = "backup"; yang_parent_name = "auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::Backup::~Backup()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::has_data() const
{
    return affinity_ignore.is_set
	|| (timers !=  nullptr && timers->has_data())
	|| (tunnel_range !=  nullptr && tunnel_range->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::Backup::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_ignore.operation)
	|| (timers !=  nullptr && timers->has_operation())
	|| (tunnel_range !=  nullptr && tunnel_range->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_ignore.is_set || is_set(affinity_ignore.operation)) leaf_name_data.push_back(affinity_ignore.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timers")
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
        else
        {
            timers = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup::Timers>();
            timers->parent = this;
            children["timers"] = timers.get();
        }
        return children.at("timers");
    }

    if(child_yang_name == "tunnel-range")
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
        else
        {
            tunnel_range = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup::TunnelRange>();
            tunnel_range->parent = this;
            children["tunnel-range"] = tunnel_range.get();
        }
        return children.at("tunnel-range");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Backup::get_children()
{
    if(children.find("timers") == children.end())
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
    }

    if(children.find("tunnel-range") == children.end())
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Backup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-ignore")
    {
        affinity_ignore = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::MeshGroup()
    :
    	mesh_group_id{YType::uint32, "mesh-group-id"},
	 attribute_set{YType::str, "attribute-set"},
	 create{YType::empty, "create"},
	 destination_list{YType::str, "destination-list"},
	 disable{YType::empty, "disable"},
	 one_hop{YType::empty, "one-hop"}
{
    yang_name = "mesh-group"; yang_parent_name = "mesh-groups";
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::~MeshGroup()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::has_data() const
{
    return mesh_group_id.is_set
	|| attribute_set.is_set
	|| create.is_set
	|| destination_list.is_set
	|| disable.is_set
	|| one_hop.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::has_operation() const
{
    return is_set(operation)
	|| is_set(mesh_group_id.operation)
	|| is_set(attribute_set.operation)
	|| is_set(create.operation)
	|| is_set(destination_list.operation)
	|| is_set(disable.operation)
	|| is_set(one_hop.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mesh-group" <<"[mesh-group-id='" <<mesh_group_id.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/mesh-groups/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mesh_group_id.is_set || is_set(mesh_group_id.operation)) leaf_name_data.push_back(mesh_group_id.get_name_leafdata());
    if (attribute_set.is_set || is_set(attribute_set.operation)) leaf_name_data.push_back(attribute_set.get_name_leafdata());
    if (create.is_set || is_set(create.operation)) leaf_name_data.push_back(create.get_name_leafdata());
    if (destination_list.is_set || is_set(destination_list.operation)) leaf_name_data.push_back(destination_list.get_name_leafdata());
    if (disable.is_set || is_set(disable.operation)) leaf_name_data.push_back(disable.get_name_leafdata());
    if (one_hop.is_set || is_set(one_hop.operation)) leaf_name_data.push_back(one_hop.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mesh-group-id")
    {
        mesh_group_id = value;
    }
    if(value_path == "attribute-set")
    {
        attribute_set = value;
    }
    if(value_path == "create")
    {
        create = value;
    }
    if(value_path == "destination-list")
    {
        destination_list = value;
    }
    if(value_path == "disable")
    {
        disable = value;
    }
    if(value_path == "one-hop")
    {
        one_hop = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroups()
{
    yang_name = "mesh-groups"; yang_parent_name = "mesh";
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::~MeshGroups()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::has_data() const
{
    for (std::size_t index=0; index<mesh_group.size(); index++)
    {
        if(mesh_group[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::has_operation() const
{
    for (std::size_t index=0; index<mesh_group.size(); index++)
    {
        if(mesh_group[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mesh-groups";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mesh-group")
    {
        for(auto const & c : mesh_group)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::MeshGroup>();
        c->parent = this;
        mesh_group.push_back(std::move(c));
        children[segment_path] = mesh_group.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::get_children()
{
    for (auto const & c : mesh_group)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::Removal()
    :
    	unused{YType::uint32, "unused"}
{
    yang_name = "removal"; yang_parent_name = "timers";
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::~Removal()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::has_data() const
{
    return unused.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::has_operation() const
{
    return is_set(operation)
	|| is_set(unused.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "removal";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/timers/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (unused.is_set || is_set(unused.operation)) leaf_name_data.push_back(unused.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "unused")
    {
        unused = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Timers()
    :
    removal(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal>())
{
    removal->parent = this;
    children["removal"] = removal.get();

    yang_name = "timers"; yang_parent_name = "mesh";
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::~Timers()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::has_data() const
{
    return (removal !=  nullptr && removal->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::has_operation() const
{
    return is_set(operation)
	|| (removal !=  nullptr && removal->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timers";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "removal")
    {
        if(removal != nullptr)
        {
            children["removal"] = removal.get();
        }
        else
        {
            removal = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::Removal>();
            removal->parent = this;
            children["removal"] = removal.get();
        }
        return children.at("removal");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::get_children()
{
    if(children.find("removal") == children.end())
    {
        if(removal != nullptr)
        {
            children["removal"] = removal.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::TunnelRange()
    :
    	max_tunnel_id{YType::uint32, "max-tunnel-id"},
	 min_tunnel_id{YType::uint32, "min-tunnel-id"}
{
    yang_name = "tunnel-range"; yang_parent_name = "mesh";
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::~TunnelRange()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::has_data() const
{
    return max_tunnel_id.is_set
	|| min_tunnel_id.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::has_operation() const
{
    return is_set(operation)
	|| is_set(max_tunnel_id.operation)
	|| is_set(min_tunnel_id.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-range";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/mesh/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (max_tunnel_id.is_set || is_set(max_tunnel_id.operation)) leaf_name_data.push_back(max_tunnel_id.get_name_leafdata());
    if (min_tunnel_id.is_set || is_set(min_tunnel_id.operation)) leaf_name_data.push_back(min_tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "max-tunnel-id")
    {
        max_tunnel_id = value;
    }
    if(value_path == "min-tunnel-id")
    {
        min_tunnel_id = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::Mesh()
    :
    mesh_groups(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups>())
	,timers(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers>())
	,tunnel_range(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange>())
{
    mesh_groups->parent = this;
    children["mesh-groups"] = mesh_groups.get();

    timers->parent = this;
    children["timers"] = timers.get();

    tunnel_range->parent = this;
    children["tunnel-range"] = tunnel_range.get();

    yang_name = "mesh"; yang_parent_name = "auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::Mesh::~Mesh()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::has_data() const
{
    return (mesh_groups !=  nullptr && mesh_groups->has_data())
	|| (timers !=  nullptr && timers->has_data())
	|| (tunnel_range !=  nullptr && tunnel_range->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::Mesh::has_operation() const
{
    return is_set(operation)
	|| (mesh_groups !=  nullptr && mesh_groups->has_operation())
	|| (timers !=  nullptr && timers->has_operation())
	|| (tunnel_range !=  nullptr && tunnel_range->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::Mesh::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mesh";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::Mesh::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::Mesh::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "mesh-groups")
    {
        if(mesh_groups != nullptr)
        {
            children["mesh-groups"] = mesh_groups.get();
        }
        else
        {
            mesh_groups = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::MeshGroups>();
            mesh_groups->parent = this;
            children["mesh-groups"] = mesh_groups.get();
        }
        return children.at("mesh-groups");
    }

    if(child_yang_name == "timers")
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
        else
        {
            timers = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::Timers>();
            timers->parent = this;
            children["timers"] = timers.get();
        }
        return children.at("timers");
    }

    if(child_yang_name == "tunnel-range")
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
        else
        {
            tunnel_range = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh::TunnelRange>();
            tunnel_range->parent = this;
            children["tunnel-range"] = tunnel_range.get();
        }
        return children.at("tunnel-range");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::Mesh::get_children()
{
    if(children.find("mesh-groups") == children.end())
    {
        if(mesh_groups != nullptr)
        {
            children["mesh-groups"] = mesh_groups.get();
        }
    }

    if(children.find("timers") == children.end())
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
    }

    if(children.find("tunnel-range") == children.end())
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::Mesh::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::TunnelRange()
    :
    	max_tunnel_id{YType::uint32, "max-tunnel-id"},
	 min_tunnel_id{YType::uint32, "min-tunnel-id"}
{
    yang_name = "tunnel-range"; yang_parent_name = "p2mp-auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::~TunnelRange()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::has_data() const
{
    return max_tunnel_id.is_set
	|| min_tunnel_id.is_set;
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::has_operation() const
{
    return is_set(operation)
	|| is_set(max_tunnel_id.operation)
	|| is_set(min_tunnel_id.operation);
}

std::string MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-range";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/p2mp-auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (max_tunnel_id.is_set || is_set(max_tunnel_id.operation)) leaf_name_data.push_back(max_tunnel_id.get_name_leafdata());
    if (min_tunnel_id.is_set || is_set(min_tunnel_id.operation)) leaf_name_data.push_back(min_tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "max-tunnel-id")
    {
        max_tunnel_id = value;
    }
    if(value_path == "min-tunnel-id")
    {
        min_tunnel_id = value;
    }
}

MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::P2MpAutoTunnel()
    :
    tunnel_range(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange>())
{
    tunnel_range->parent = this;
    children["tunnel-range"] = tunnel_range.get();

    yang_name = "p2mp-auto-tunnel"; yang_parent_name = "auto-tunnel";
}

MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::~P2MpAutoTunnel()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::has_data() const
{
    return (tunnel_range !=  nullptr && tunnel_range->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::has_operation() const
{
    return is_set(operation)
	|| (tunnel_range !=  nullptr && tunnel_range->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2mp-auto-tunnel";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/auto-tunnel/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnel-range")
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
        else
        {
            tunnel_range = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::TunnelRange>();
            tunnel_range->parent = this;
            children["tunnel-range"] = tunnel_range.get();
        }
        return children.at("tunnel-range");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::get_children()
{
    if(children.find("tunnel-range") == children.end())
    {
        if(tunnel_range != nullptr)
        {
            children["tunnel-range"] = tunnel_range.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AutoTunnel::AutoTunnel()
    :
    backup(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup>())
	,mesh(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh>())
	,p2mp_auto_tunnel(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel>())
	,p2p_auto_tunnel(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel>())
	,pcc(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Pcc>())
{
    backup->parent = this;
    children["backup"] = backup.get();

    mesh->parent = this;
    children["mesh"] = mesh.get();

    p2mp_auto_tunnel->parent = this;
    children["p2mp-auto-tunnel"] = p2mp_auto_tunnel.get();

    p2p_auto_tunnel->parent = this;
    children["p2p-auto-tunnel"] = p2p_auto_tunnel.get();

    pcc->parent = this;
    children["pcc"] = pcc.get();

    yang_name = "auto-tunnel"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::AutoTunnel::~AutoTunnel()
{
}

bool MplsTe::GlobalAttributes::AutoTunnel::has_data() const
{
    return (backup !=  nullptr && backup->has_data())
	|| (mesh !=  nullptr && mesh->has_data())
	|| (p2mp_auto_tunnel !=  nullptr && p2mp_auto_tunnel->has_data())
	|| (p2p_auto_tunnel !=  nullptr && p2p_auto_tunnel->has_data())
	|| (pcc !=  nullptr && pcc->has_data());
}

bool MplsTe::GlobalAttributes::AutoTunnel::has_operation() const
{
    return is_set(operation)
	|| (backup !=  nullptr && backup->has_operation())
	|| (mesh !=  nullptr && mesh->has_operation())
	|| (p2mp_auto_tunnel !=  nullptr && p2mp_auto_tunnel->has_operation())
	|| (p2p_auto_tunnel !=  nullptr && p2p_auto_tunnel->has_operation())
	|| (pcc !=  nullptr && pcc->has_operation());
}

std::string MplsTe::GlobalAttributes::AutoTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-tunnel";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AutoTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AutoTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup")
    {
        if(backup != nullptr)
        {
            children["backup"] = backup.get();
        }
        else
        {
            backup = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Backup>();
            backup->parent = this;
            children["backup"] = backup.get();
        }
        return children.at("backup");
    }

    if(child_yang_name == "mesh")
    {
        if(mesh != nullptr)
        {
            children["mesh"] = mesh.get();
        }
        else
        {
            mesh = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Mesh>();
            mesh->parent = this;
            children["mesh"] = mesh.get();
        }
        return children.at("mesh");
    }

    if(child_yang_name == "p2mp-auto-tunnel")
    {
        if(p2mp_auto_tunnel != nullptr)
        {
            children["p2mp-auto-tunnel"] = p2mp_auto_tunnel.get();
        }
        else
        {
            p2mp_auto_tunnel = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2MpAutoTunnel>();
            p2mp_auto_tunnel->parent = this;
            children["p2mp-auto-tunnel"] = p2mp_auto_tunnel.get();
        }
        return children.at("p2mp-auto-tunnel");
    }

    if(child_yang_name == "p2p-auto-tunnel")
    {
        if(p2p_auto_tunnel != nullptr)
        {
            children["p2p-auto-tunnel"] = p2p_auto_tunnel.get();
        }
        else
        {
            p2p_auto_tunnel = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::P2PAutoTunnel>();
            p2p_auto_tunnel->parent = this;
            children["p2p-auto-tunnel"] = p2p_auto_tunnel.get();
        }
        return children.at("p2p-auto-tunnel");
    }

    if(child_yang_name == "pcc")
    {
        if(pcc != nullptr)
        {
            children["pcc"] = pcc.get();
        }
        else
        {
            pcc = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel::Pcc>();
            pcc->parent = this;
            children["pcc"] = pcc.get();
        }
        return children.at("pcc");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AutoTunnel::get_children()
{
    if(children.find("backup") == children.end())
    {
        if(backup != nullptr)
        {
            children["backup"] = backup.get();
        }
    }

    if(children.find("mesh") == children.end())
    {
        if(mesh != nullptr)
        {
            children["mesh"] = mesh.get();
        }
    }

    if(children.find("p2mp-auto-tunnel") == children.end())
    {
        if(p2mp_auto_tunnel != nullptr)
        {
            children["p2mp-auto-tunnel"] = p2mp_auto_tunnel.get();
        }
    }

    if(children.find("p2p-auto-tunnel") == children.end())
    {
        if(p2p_auto_tunnel != nullptr)
        {
            children["p2p-auto-tunnel"] = p2p_auto_tunnel.get();
        }
    }

    if(children.find("pcc") == children.end())
    {
        if(pcc != nullptr)
        {
            children["pcc"] = pcc.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AutoTunnel::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::OorRedState()
    :
    	oor_accept_lsp_min_bandwidth{YType::int32, "oor-accept-lsp-min-bandwidth"},
	 oor_accept_reopt_lsp{YType::empty, "oor-accept-reopt-lsp"},
	 oor_available_bandwidth_percentage{YType::uint32, "oor-available-bandwidth-percentage"},
	 oor_metric_te_penalty{YType::int32, "oor-metric-te-penalty"},
	 oor_node_protection_disable{YType::empty, "oor-node-protection-disable"}
{
    yang_name = "oor-red-state"; yang_parent_name = "hardware-out-of-resource";
}

MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::~OorRedState()
{
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::has_data() const
{
    return oor_accept_lsp_min_bandwidth.is_set
	|| oor_accept_reopt_lsp.is_set
	|| oor_available_bandwidth_percentage.is_set
	|| oor_metric_te_penalty.is_set
	|| oor_node_protection_disable.is_set;
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::has_operation() const
{
    return is_set(operation)
	|| is_set(oor_accept_lsp_min_bandwidth.operation)
	|| is_set(oor_accept_reopt_lsp.operation)
	|| is_set(oor_available_bandwidth_percentage.operation)
	|| is_set(oor_metric_te_penalty.operation)
	|| is_set(oor_node_protection_disable.operation);
}

std::string MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "oor-red-state";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/hardware-out-of-resource/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (oor_accept_lsp_min_bandwidth.is_set || is_set(oor_accept_lsp_min_bandwidth.operation)) leaf_name_data.push_back(oor_accept_lsp_min_bandwidth.get_name_leafdata());
    if (oor_accept_reopt_lsp.is_set || is_set(oor_accept_reopt_lsp.operation)) leaf_name_data.push_back(oor_accept_reopt_lsp.get_name_leafdata());
    if (oor_available_bandwidth_percentage.is_set || is_set(oor_available_bandwidth_percentage.operation)) leaf_name_data.push_back(oor_available_bandwidth_percentage.get_name_leafdata());
    if (oor_metric_te_penalty.is_set || is_set(oor_metric_te_penalty.operation)) leaf_name_data.push_back(oor_metric_te_penalty.get_name_leafdata());
    if (oor_node_protection_disable.is_set || is_set(oor_node_protection_disable.operation)) leaf_name_data.push_back(oor_node_protection_disable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "oor-accept-lsp-min-bandwidth")
    {
        oor_accept_lsp_min_bandwidth = value;
    }
    if(value_path == "oor-accept-reopt-lsp")
    {
        oor_accept_reopt_lsp = value;
    }
    if(value_path == "oor-available-bandwidth-percentage")
    {
        oor_available_bandwidth_percentage = value;
    }
    if(value_path == "oor-metric-te-penalty")
    {
        oor_metric_te_penalty = value;
    }
    if(value_path == "oor-node-protection-disable")
    {
        oor_node_protection_disable = value;
    }
}

MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::OorYellowState()
    :
    	oor_accept_lsp_min_bandwidth{YType::int32, "oor-accept-lsp-min-bandwidth"},
	 oor_accept_reopt_lsp{YType::empty, "oor-accept-reopt-lsp"},
	 oor_available_bandwidth_percentage{YType::uint32, "oor-available-bandwidth-percentage"},
	 oor_metric_te_penalty{YType::int32, "oor-metric-te-penalty"},
	 oor_node_protection_disable{YType::empty, "oor-node-protection-disable"}
{
    yang_name = "oor-yellow-state"; yang_parent_name = "hardware-out-of-resource";
}

MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::~OorYellowState()
{
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::has_data() const
{
    return oor_accept_lsp_min_bandwidth.is_set
	|| oor_accept_reopt_lsp.is_set
	|| oor_available_bandwidth_percentage.is_set
	|| oor_metric_te_penalty.is_set
	|| oor_node_protection_disable.is_set;
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::has_operation() const
{
    return is_set(operation)
	|| is_set(oor_accept_lsp_min_bandwidth.operation)
	|| is_set(oor_accept_reopt_lsp.operation)
	|| is_set(oor_available_bandwidth_percentage.operation)
	|| is_set(oor_metric_te_penalty.operation)
	|| is_set(oor_node_protection_disable.operation);
}

std::string MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "oor-yellow-state";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/hardware-out-of-resource/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (oor_accept_lsp_min_bandwidth.is_set || is_set(oor_accept_lsp_min_bandwidth.operation)) leaf_name_data.push_back(oor_accept_lsp_min_bandwidth.get_name_leafdata());
    if (oor_accept_reopt_lsp.is_set || is_set(oor_accept_reopt_lsp.operation)) leaf_name_data.push_back(oor_accept_reopt_lsp.get_name_leafdata());
    if (oor_available_bandwidth_percentage.is_set || is_set(oor_available_bandwidth_percentage.operation)) leaf_name_data.push_back(oor_available_bandwidth_percentage.get_name_leafdata());
    if (oor_metric_te_penalty.is_set || is_set(oor_metric_te_penalty.operation)) leaf_name_data.push_back(oor_metric_te_penalty.get_name_leafdata());
    if (oor_node_protection_disable.is_set || is_set(oor_node_protection_disable.operation)) leaf_name_data.push_back(oor_node_protection_disable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "oor-accept-lsp-min-bandwidth")
    {
        oor_accept_lsp_min_bandwidth = value;
    }
    if(value_path == "oor-accept-reopt-lsp")
    {
        oor_accept_reopt_lsp = value;
    }
    if(value_path == "oor-available-bandwidth-percentage")
    {
        oor_available_bandwidth_percentage = value;
    }
    if(value_path == "oor-metric-te-penalty")
    {
        oor_metric_te_penalty = value;
    }
    if(value_path == "oor-node-protection-disable")
    {
        oor_node_protection_disable = value;
    }
}

MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::OorGreenState()
    :
    	oor_accept_lsp_min_bandwidth{YType::int32, "oor-accept-lsp-min-bandwidth"},
	 oor_accept_reopt_lsp{YType::empty, "oor-accept-reopt-lsp"},
	 oor_available_bandwidth_percentage{YType::uint32, "oor-available-bandwidth-percentage"},
	 oor_metric_te_penalty{YType::int32, "oor-metric-te-penalty"},
	 oor_node_protection_disable{YType::empty, "oor-node-protection-disable"},
	 oor_recovery_duration{YType::uint32, "oor-recovery-duration"}
{
    yang_name = "oor-green-state"; yang_parent_name = "hardware-out-of-resource";
}

MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::~OorGreenState()
{
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::has_data() const
{
    return oor_accept_lsp_min_bandwidth.is_set
	|| oor_accept_reopt_lsp.is_set
	|| oor_available_bandwidth_percentage.is_set
	|| oor_metric_te_penalty.is_set
	|| oor_node_protection_disable.is_set
	|| oor_recovery_duration.is_set;
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::has_operation() const
{
    return is_set(operation)
	|| is_set(oor_accept_lsp_min_bandwidth.operation)
	|| is_set(oor_accept_reopt_lsp.operation)
	|| is_set(oor_available_bandwidth_percentage.operation)
	|| is_set(oor_metric_te_penalty.operation)
	|| is_set(oor_node_protection_disable.operation)
	|| is_set(oor_recovery_duration.operation);
}

std::string MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "oor-green-state";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/hardware-out-of-resource/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (oor_accept_lsp_min_bandwidth.is_set || is_set(oor_accept_lsp_min_bandwidth.operation)) leaf_name_data.push_back(oor_accept_lsp_min_bandwidth.get_name_leafdata());
    if (oor_accept_reopt_lsp.is_set || is_set(oor_accept_reopt_lsp.operation)) leaf_name_data.push_back(oor_accept_reopt_lsp.get_name_leafdata());
    if (oor_available_bandwidth_percentage.is_set || is_set(oor_available_bandwidth_percentage.operation)) leaf_name_data.push_back(oor_available_bandwidth_percentage.get_name_leafdata());
    if (oor_metric_te_penalty.is_set || is_set(oor_metric_te_penalty.operation)) leaf_name_data.push_back(oor_metric_te_penalty.get_name_leafdata());
    if (oor_node_protection_disable.is_set || is_set(oor_node_protection_disable.operation)) leaf_name_data.push_back(oor_node_protection_disable.get_name_leafdata());
    if (oor_recovery_duration.is_set || is_set(oor_recovery_duration.operation)) leaf_name_data.push_back(oor_recovery_duration.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "oor-accept-lsp-min-bandwidth")
    {
        oor_accept_lsp_min_bandwidth = value;
    }
    if(value_path == "oor-accept-reopt-lsp")
    {
        oor_accept_reopt_lsp = value;
    }
    if(value_path == "oor-available-bandwidth-percentage")
    {
        oor_available_bandwidth_percentage = value;
    }
    if(value_path == "oor-metric-te-penalty")
    {
        oor_metric_te_penalty = value;
    }
    if(value_path == "oor-node-protection-disable")
    {
        oor_node_protection_disable = value;
    }
    if(value_path == "oor-recovery-duration")
    {
        oor_recovery_duration = value;
    }
}

MplsTe::GlobalAttributes::HardwareOutOfResource::HardwareOutOfResource()
    :
    oor_green_state(std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState>())
	,oor_red_state(std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState>())
	,oor_yellow_state(std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState>())
{
    oor_green_state->parent = this;
    children["oor-green-state"] = oor_green_state.get();

    oor_red_state->parent = this;
    children["oor-red-state"] = oor_red_state.get();

    oor_yellow_state->parent = this;
    children["oor-yellow-state"] = oor_yellow_state.get();

    yang_name = "hardware-out-of-resource"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::HardwareOutOfResource::~HardwareOutOfResource()
{
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::has_data() const
{
    return (oor_green_state !=  nullptr && oor_green_state->has_data())
	|| (oor_red_state !=  nullptr && oor_red_state->has_data())
	|| (oor_yellow_state !=  nullptr && oor_yellow_state->has_data());
}

bool MplsTe::GlobalAttributes::HardwareOutOfResource::has_operation() const
{
    return is_set(operation)
	|| (oor_green_state !=  nullptr && oor_green_state->has_operation())
	|| (oor_red_state !=  nullptr && oor_red_state->has_operation())
	|| (oor_yellow_state !=  nullptr && oor_yellow_state->has_operation());
}

std::string MplsTe::GlobalAttributes::HardwareOutOfResource::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "hardware-out-of-resource";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::HardwareOutOfResource::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::HardwareOutOfResource::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "oor-green-state")
    {
        if(oor_green_state != nullptr)
        {
            children["oor-green-state"] = oor_green_state.get();
        }
        else
        {
            oor_green_state = std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource::OorGreenState>();
            oor_green_state->parent = this;
            children["oor-green-state"] = oor_green_state.get();
        }
        return children.at("oor-green-state");
    }

    if(child_yang_name == "oor-red-state")
    {
        if(oor_red_state != nullptr)
        {
            children["oor-red-state"] = oor_red_state.get();
        }
        else
        {
            oor_red_state = std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource::OorRedState>();
            oor_red_state->parent = this;
            children["oor-red-state"] = oor_red_state.get();
        }
        return children.at("oor-red-state");
    }

    if(child_yang_name == "oor-yellow-state")
    {
        if(oor_yellow_state != nullptr)
        {
            children["oor-yellow-state"] = oor_yellow_state.get();
        }
        else
        {
            oor_yellow_state = std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource::OorYellowState>();
            oor_yellow_state->parent = this;
            children["oor-yellow-state"] = oor_yellow_state.get();
        }
        return children.at("oor-yellow-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::HardwareOutOfResource::get_children()
{
    if(children.find("oor-green-state") == children.end())
    {
        if(oor_green_state != nullptr)
        {
            children["oor-green-state"] = oor_green_state.get();
        }
    }

    if(children.find("oor-red-state") == children.end())
    {
        if(oor_red_state != nullptr)
        {
            children["oor-red-state"] = oor_red_state.get();
        }
    }

    if(children.find("oor-yellow-state") == children.end())
    {
        if(oor_yellow_state != nullptr)
        {
            children["oor-yellow-state"] = oor_yellow_state.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::HardwareOutOfResource::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::SecondaryRouterId()
    :
    	secondary_router_id_value{YType::str, "secondary-router-id-value"}
{
    yang_name = "secondary-router-id"; yang_parent_name = "secondary-router-ids";
}

MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::~SecondaryRouterId()
{
}

bool MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::has_data() const
{
    return secondary_router_id_value.is_set;
}

bool MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::has_operation() const
{
    return is_set(operation)
	|| is_set(secondary_router_id_value.operation);
}

std::string MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "secondary-router-id" <<"[secondary-router-id-value='" <<secondary_router_id_value.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/secondary-router-ids/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (secondary_router_id_value.is_set || is_set(secondary_router_id_value.operation)) leaf_name_data.push_back(secondary_router_id_value.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "secondary-router-id-value")
    {
        secondary_router_id_value = value;
    }
}

MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterIds()
{
    yang_name = "secondary-router-ids"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::SecondaryRouterIds::~SecondaryRouterIds()
{
}

bool MplsTe::GlobalAttributes::SecondaryRouterIds::has_data() const
{
    for (std::size_t index=0; index<secondary_router_id.size(); index++)
    {
        if(secondary_router_id[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::SecondaryRouterIds::has_operation() const
{
    for (std::size_t index=0; index<secondary_router_id.size(); index++)
    {
        if(secondary_router_id[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::SecondaryRouterIds::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "secondary-router-ids";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::SecondaryRouterIds::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::SecondaryRouterIds::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "secondary-router-id")
    {
        for(auto const & c : secondary_router_id)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::SecondaryRouterIds::SecondaryRouterId>();
        c->parent = this;
        secondary_router_id.push_back(std::move(c));
        children[segment_path] = secondary_router_id.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::SecondaryRouterIds::get_children()
{
    for (auto const & c : secondary_router_id)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::SecondaryRouterIds::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::StaticSrlgMember()
    :
    	from_address{YType::str, "from-address"},
	 to_address{YType::str, "to-address"}
{
    yang_name = "static-srlg-member"; yang_parent_name = "static-srlg-members";
}

MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::~StaticSrlgMember()
{
}

bool MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::has_data() const
{
    return from_address.is_set
	|| to_address.is_set;
}

bool MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::has_operation() const
{
    return is_set(operation)
	|| is_set(from_address.operation)
	|| is_set(to_address.operation);
}

std::string MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "static-srlg-member" <<"[from-address='" <<from_address.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (from_address.is_set || is_set(from_address.operation)) leaf_name_data.push_back(from_address.get_name_leafdata());
    if (to_address.is_set || is_set(to_address.operation)) leaf_name_data.push_back(to_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "from-address")
    {
        from_address = value;
    }
    if(value_path == "to-address")
    {
        to_address = value;
    }
}

MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMembers()
{
    yang_name = "static-srlg-members"; yang_parent_name = "name";
}

MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::~StaticSrlgMembers()
{
}

bool MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::has_data() const
{
    for (std::size_t index=0; index<static_srlg_member.size(); index++)
    {
        if(static_srlg_member[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::has_operation() const
{
    for (std::size_t index=0; index<static_srlg_member.size(); index++)
    {
        if(static_srlg_member[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "static-srlg-members";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "static-srlg-member")
    {
        for(auto const & c : static_srlg_member)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::StaticSrlgMember>();
        c->parent = this;
        static_srlg_member.push_back(std::move(c));
        children[segment_path] = static_srlg_member.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::get_children()
{
    for (auto const & c : static_srlg_member)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::Srlg::Names::Name::Name()
    :
    	srlg_name{YType::str, "srlg-name"},
	 admin_weight{YType::int32, "admin-weight"}
    	,
    static_srlg_members(std::make_unique<MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers>())
{
    static_srlg_members->parent = this;
    children["static-srlg-members"] = static_srlg_members.get();

    yang_name = "name"; yang_parent_name = "names";
}

MplsTe::GlobalAttributes::Srlg::Names::Name::~Name()
{
}

bool MplsTe::GlobalAttributes::Srlg::Names::Name::has_data() const
{
    return srlg_name.is_set
	|| admin_weight.is_set
	|| (static_srlg_members !=  nullptr && static_srlg_members->has_data());
}

bool MplsTe::GlobalAttributes::Srlg::Names::Name::has_operation() const
{
    return is_set(operation)
	|| is_set(srlg_name.operation)
	|| is_set(admin_weight.operation)
	|| (static_srlg_members !=  nullptr && static_srlg_members->has_operation());
}

std::string MplsTe::GlobalAttributes::Srlg::Names::Name::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "name" <<"[srlg-name='" <<srlg_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Names::Name::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/names/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srlg_name.is_set || is_set(srlg_name.operation)) leaf_name_data.push_back(srlg_name.get_name_leafdata());
    if (admin_weight.is_set || is_set(admin_weight.operation)) leaf_name_data.push_back(admin_weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Names::Name::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "static-srlg-members")
    {
        if(static_srlg_members != nullptr)
        {
            children["static-srlg-members"] = static_srlg_members.get();
        }
        else
        {
            static_srlg_members = std::make_unique<MplsTe::GlobalAttributes::Srlg::Names::Name::StaticSrlgMembers>();
            static_srlg_members->parent = this;
            children["static-srlg-members"] = static_srlg_members.get();
        }
        return children.at("static-srlg-members");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Names::Name::get_children()
{
    if(children.find("static-srlg-members") == children.end())
    {
        if(static_srlg_members != nullptr)
        {
            children["static-srlg-members"] = static_srlg_members.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::Names::Name::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srlg-name")
    {
        srlg_name = value;
    }
    if(value_path == "admin-weight")
    {
        admin_weight = value;
    }
}

MplsTe::GlobalAttributes::Srlg::Names::Names()
{
    yang_name = "names"; yang_parent_name = "srlg";
}

MplsTe::GlobalAttributes::Srlg::Names::~Names()
{
}

bool MplsTe::GlobalAttributes::Srlg::Names::has_data() const
{
    for (std::size_t index=0; index<name.size(); index++)
    {
        if(name[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::Srlg::Names::has_operation() const
{
    for (std::size_t index=0; index<name.size(); index++)
    {
        if(name[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::Srlg::Names::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "names";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Names::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Names::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "name")
    {
        for(auto const & c : name)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::Srlg::Names::Name>();
        c->parent = this;
        name.push_back(std::move(c));
        children[segment_path] = name.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Names::get_children()
{
    for (auto const & c : name)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::Names::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::Ipv4AddressMap()
    :
    	outgoing_ipv4_address{YType::str, "outgoing-ipv4-address"},
	 remote_ipv4_address{YType::str, "remote-ipv4-address"}
{
    yang_name = "ipv4-address-map"; yang_parent_name = "ipv4-address-maps";
}

MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::~Ipv4AddressMap()
{
}

bool MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::has_data() const
{
    return outgoing_ipv4_address.is_set
	|| remote_ipv4_address.is_set;
}

bool MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::has_operation() const
{
    return is_set(operation)
	|| is_set(outgoing_ipv4_address.operation)
	|| is_set(remote_ipv4_address.operation);
}

std::string MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-address-map" <<"[outgoing-ipv4-address='" <<outgoing_ipv4_address.get() <<"']" <<"[remote-ipv4-address='" <<remote_ipv4_address.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (outgoing_ipv4_address.is_set || is_set(outgoing_ipv4_address.operation)) leaf_name_data.push_back(outgoing_ipv4_address.get_name_leafdata());
    if (remote_ipv4_address.is_set || is_set(remote_ipv4_address.operation)) leaf_name_data.push_back(remote_ipv4_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "outgoing-ipv4-address")
    {
        outgoing_ipv4_address = value;
    }
    if(value_path == "remote-ipv4-address")
    {
        remote_ipv4_address = value;
    }
}

MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMaps()
{
    yang_name = "ipv4-address-maps"; yang_parent_name = "value";
}

MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::~Ipv4AddressMaps()
{
}

bool MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::has_data() const
{
    for (std::size_t index=0; index<ipv4_address_map.size(); index++)
    {
        if(ipv4_address_map[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::has_operation() const
{
    for (std::size_t index=0; index<ipv4_address_map.size(); index++)
    {
        if(ipv4_address_map[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-address-maps";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-address-map")
    {
        for(auto const & c : ipv4_address_map)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::Ipv4AddressMap>();
        c->parent = this;
        ipv4_address_map.push_back(std::move(c));
        children[segment_path] = ipv4_address_map.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::get_children()
{
    for (auto const & c : ipv4_address_map)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::Srlg::Values::Value_::Value_()
    :
    	srlg_number{YType::uint32, "srlg-number"},
	 admin_weight{YType::int32, "admin-weight"}
    	,
    ipv4_address_maps(std::make_unique<MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps>())
{
    ipv4_address_maps->parent = this;
    children["ipv4-address-maps"] = ipv4_address_maps.get();

    yang_name = "value"; yang_parent_name = "values";
}

MplsTe::GlobalAttributes::Srlg::Values::Value_::~Value_()
{
}

bool MplsTe::GlobalAttributes::Srlg::Values::Value_::has_data() const
{
    return srlg_number.is_set
	|| admin_weight.is_set
	|| (ipv4_address_maps !=  nullptr && ipv4_address_maps->has_data());
}

bool MplsTe::GlobalAttributes::Srlg::Values::Value_::has_operation() const
{
    return is_set(operation)
	|| is_set(srlg_number.operation)
	|| is_set(admin_weight.operation)
	|| (ipv4_address_maps !=  nullptr && ipv4_address_maps->has_operation());
}

std::string MplsTe::GlobalAttributes::Srlg::Values::Value_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value" <<"[srlg-number='" <<srlg_number.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Values::Value_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/values/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srlg_number.is_set || is_set(srlg_number.operation)) leaf_name_data.push_back(srlg_number.get_name_leafdata());
    if (admin_weight.is_set || is_set(admin_weight.operation)) leaf_name_data.push_back(admin_weight.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Values::Value_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-address-maps")
    {
        if(ipv4_address_maps != nullptr)
        {
            children["ipv4-address-maps"] = ipv4_address_maps.get();
        }
        else
        {
            ipv4_address_maps = std::make_unique<MplsTe::GlobalAttributes::Srlg::Values::Value_::Ipv4AddressMaps>();
            ipv4_address_maps->parent = this;
            children["ipv4-address-maps"] = ipv4_address_maps.get();
        }
        return children.at("ipv4-address-maps");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Values::Value_::get_children()
{
    if(children.find("ipv4-address-maps") == children.end())
    {
        if(ipv4_address_maps != nullptr)
        {
            children["ipv4-address-maps"] = ipv4_address_maps.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::Values::Value_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srlg-number")
    {
        srlg_number = value;
    }
    if(value_path == "admin-weight")
    {
        admin_weight = value;
    }
}

MplsTe::GlobalAttributes::Srlg::Values::Values()
{
    yang_name = "values"; yang_parent_name = "srlg";
}

MplsTe::GlobalAttributes::Srlg::Values::~Values()
{
}

bool MplsTe::GlobalAttributes::Srlg::Values::has_data() const
{
    for (std::size_t index=0; index<value_.size(); index++)
    {
        if(value_[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::Srlg::Values::has_operation() const
{
    for (std::size_t index=0; index<value_.size(); index++)
    {
        if(value_[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::Srlg::Values::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "values";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::Values::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/srlg/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::Values::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "value")
    {
        for(auto const & c : value_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::Srlg::Values::Value_>();
        c->parent = this;
        value_.push_back(std::move(c));
        children[segment_path] = value_.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::Values::get_children()
{
    for (auto const & c : value_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::Values::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::Srlg::Srlg()
    :
    	default_admin_weight{YType::int32, "default-admin-weight"},
	 enable{YType::empty, "enable"}
    	,
    names(std::make_unique<MplsTe::GlobalAttributes::Srlg::Names>())
	,values(std::make_unique<MplsTe::GlobalAttributes::Srlg::Values>())
{
    names->parent = this;
    children["names"] = names.get();

    values->parent = this;
    children["values"] = values.get();

    yang_name = "srlg"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::Srlg::~Srlg()
{
}

bool MplsTe::GlobalAttributes::Srlg::has_data() const
{
    return default_admin_weight.is_set
	|| enable.is_set
	|| (names !=  nullptr && names->has_data())
	|| (values !=  nullptr && values->has_data());
}

bool MplsTe::GlobalAttributes::Srlg::has_operation() const
{
    return is_set(operation)
	|| is_set(default_admin_weight.operation)
	|| is_set(enable.operation)
	|| (names !=  nullptr && names->has_operation())
	|| (values !=  nullptr && values->has_operation());
}

std::string MplsTe::GlobalAttributes::Srlg::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srlg";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Srlg::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (default_admin_weight.is_set || is_set(default_admin_weight.operation)) leaf_name_data.push_back(default_admin_weight.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Srlg::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "names")
    {
        if(names != nullptr)
        {
            children["names"] = names.get();
        }
        else
        {
            names = std::make_unique<MplsTe::GlobalAttributes::Srlg::Names>();
            names->parent = this;
            children["names"] = names.get();
        }
        return children.at("names");
    }

    if(child_yang_name == "values")
    {
        if(values != nullptr)
        {
            children["values"] = values.get();
        }
        else
        {
            values = std::make_unique<MplsTe::GlobalAttributes::Srlg::Values>();
            values->parent = this;
            children["values"] = values.get();
        }
        return children.at("values");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Srlg::get_children()
{
    if(children.find("names") == children.end())
    {
        if(names != nullptr)
        {
            children["names"] = names.get();
        }
    }

    if(children.find("values") == children.end())
    {
        if(values != nullptr)
        {
            children["values"] = values.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Srlg::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "default-admin-weight")
    {
        default_admin_weight = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::Queues::Queue::Queue()
    :
    	role{YType::enumeration, "role"},
	 value_{YType::uint32, "value"}
{
    yang_name = "queue"; yang_parent_name = "queues";
}

MplsTe::GlobalAttributes::Queues::Queue::~Queue()
{
}

bool MplsTe::GlobalAttributes::Queues::Queue::has_data() const
{
    return role.is_set
	|| value_.is_set;
}

bool MplsTe::GlobalAttributes::Queues::Queue::has_operation() const
{
    return is_set(operation)
	|| is_set(role.operation)
	|| is_set(value_.operation);
}

std::string MplsTe::GlobalAttributes::Queues::Queue::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "queue" <<"[role='" <<role.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Queues::Queue::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/queues/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (role.is_set || is_set(role.operation)) leaf_name_data.push_back(role.get_name_leafdata());
    if (value_.is_set || is_set(value_.operation)) leaf_name_data.push_back(value_.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Queues::Queue::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Queues::Queue::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::Queues::Queue::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "role")
    {
        role = value;
    }
    if(value_path == "value")
    {
        value_ = value;
    }
}

MplsTe::GlobalAttributes::Queues::Queues()
{
    yang_name = "queues"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::Queues::~Queues()
{
}

bool MplsTe::GlobalAttributes::Queues::has_data() const
{
    for (std::size_t index=0; index<queue.size(); index++)
    {
        if(queue[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::Queues::has_operation() const
{
    for (std::size_t index=0; index<queue.size(); index++)
    {
        if(queue[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::Queues::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "queues";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Queues::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Queues::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "queue")
    {
        for(auto const & c : queue)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::Queues::Queue>();
        c->parent = this;
        queue.push_back(std::move(c));
        children[segment_path] = queue.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Queues::get_children()
{
    for (auto const & c : queue)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::Queues::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::Mib::Mib()
    :
    	midpoint_lsp_stats_collection_disable{YType::empty, "midpoint-lsp-stats-collection-disable"}
{
    yang_name = "mib"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::Mib::~Mib()
{
}

bool MplsTe::GlobalAttributes::Mib::has_data() const
{
    return midpoint_lsp_stats_collection_disable.is_set;
}

bool MplsTe::GlobalAttributes::Mib::has_operation() const
{
    return is_set(operation)
	|| is_set(midpoint_lsp_stats_collection_disable.operation);
}

std::string MplsTe::GlobalAttributes::Mib::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mib";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::Mib::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (midpoint_lsp_stats_collection_disable.is_set || is_set(midpoint_lsp_stats_collection_disable.operation)) leaf_name_data.push_back(midpoint_lsp_stats_collection_disable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::Mib::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::Mib::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::Mib::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "midpoint-lsp-stats-collection-disable")
    {
        midpoint_lsp_stats_collection_disable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::BfdReversePath()
    :
    	bfd_reverse_path_type{YType::enumeration, "bfd-reverse-path-type"},
	 binding_label{YType::uint32, "binding-label"}
{
    yang_name = "bfd-reverse-path"; yang_parent_name = "path-option-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::~BfdReversePath()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::has_data() const
{
    return bfd_reverse_path_type.is_set
	|| binding_label.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::has_operation() const
{
    return is_set(operation)
	|| is_set(bfd_reverse_path_type.operation)
	|| is_set(binding_label.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-reverse-path";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfd_reverse_path_type.is_set || is_set(bfd_reverse_path_type.operation)) leaf_name_data.push_back(bfd_reverse_path_type.get_name_leafdata());
    if (binding_label.is_set || is_set(binding_label.operation)) leaf_name_data.push_back(binding_label.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfd-reverse-path-type")
    {
        bfd_reverse_path_type = value;
    }
    if(value_path == "binding-label")
    {
        binding_label = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::Invalidation()
    :
    	path_invalidation_action{YType::enumeration, "path-invalidation-action"},
	 path_invalidation_timeout{YType::uint32, "path-invalidation-timeout"}
{
    yang_name = "invalidation"; yang_parent_name = "att-path-option-path-selection";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::~Invalidation()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::has_data() const
{
    return path_invalidation_action.is_set
	|| path_invalidation_timeout.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::has_operation() const
{
    return is_set(operation)
	|| is_set(path_invalidation_action.operation)
	|| is_set(path_invalidation_timeout.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalidation";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (path_invalidation_action.is_set || is_set(path_invalidation_action.operation)) leaf_name_data.push_back(path_invalidation_action.get_name_leafdata());
    if (path_invalidation_timeout.is_set || is_set(path_invalidation_timeout.operation)) leaf_name_data.push_back(path_invalidation_timeout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "path-invalidation-action")
    {
        path_invalidation_action = value;
    }
    if(value_path == "path-invalidation-timeout")
    {
        path_invalidation_timeout = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::AttPathOptionPathSelection()
    :
    	enable{YType::empty, "enable"},
	 path_selection_cost_limit{YType::uint32, "path-selection-cost-limit"},
	 path_selection_exclude_list{YType::str, "path-selection-exclude-list"}
    	,
    invalidation(nullptr) // presence node
{
    yang_name = "att-path-option-path-selection"; yang_parent_name = "path-option-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::~AttPathOptionPathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::has_data() const
{
    return enable.is_set
	|| path_selection_cost_limit.is_set
	|| path_selection_exclude_list.is_set
	|| (invalidation !=  nullptr && invalidation->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| is_set(path_selection_cost_limit.operation)
	|| is_set(path_selection_exclude_list.operation)
	|| (invalidation !=  nullptr && invalidation->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "att-path-option-path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (path_selection_cost_limit.is_set || is_set(path_selection_cost_limit.operation)) leaf_name_data.push_back(path_selection_cost_limit.get_name_leafdata());
    if (path_selection_exclude_list.is_set || is_set(path_selection_exclude_list.operation)) leaf_name_data.push_back(path_selection_exclude_list.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "invalidation")
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
        else
        {
            invalidation = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::Invalidation>();
            invalidation->parent = this;
            children["invalidation"] = invalidation.get();
        }
        return children.at("invalidation");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::get_children()
{
    if(children.find("invalidation") == children.end())
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "path-selection-cost-limit")
    {
        path_selection_cost_limit = value;
    }
    if(value_path == "path-selection-exclude-list")
    {
        path_selection_exclude_list = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::Bidirectional()
    :
    	bd_group_id{YType::uint32, "bd-group-id"},
	 bd_source_address{YType::str, "bd-source-address"}
{
    yang_name = "bidirectional"; yang_parent_name = "pce";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::~Bidirectional()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::has_data() const
{
    return bd_group_id.is_set
	|| bd_source_address.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::has_operation() const
{
    return is_set(operation)
	|| is_set(bd_group_id.operation)
	|| is_set(bd_source_address.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bidirectional";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bd_group_id.is_set || is_set(bd_group_id.operation)) leaf_name_data.push_back(bd_group_id.get_name_leafdata());
    if (bd_source_address.is_set || is_set(bd_source_address.operation)) leaf_name_data.push_back(bd_source_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bd-group-id")
    {
        bd_group_id = value;
    }
    if(value_path == "bd-source-address")
    {
        bd_source_address = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::DisjointPath()
    :
    	dp_group_id{YType::uint32, "dp-group-id"},
	 dp_source_address{YType::str, "dp-source-address"},
	 dp_type{YType::uint32, "dp-type"}
{
    yang_name = "disjoint-path"; yang_parent_name = "pce";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::~DisjointPath()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::has_data() const
{
    return dp_group_id.is_set
	|| dp_source_address.is_set
	|| dp_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::has_operation() const
{
    return is_set(operation)
	|| is_set(dp_group_id.operation)
	|| is_set(dp_source_address.operation)
	|| is_set(dp_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disjoint-path";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dp_group_id.is_set || is_set(dp_group_id.operation)) leaf_name_data.push_back(dp_group_id.get_name_leafdata());
    if (dp_source_address.is_set || is_set(dp_source_address.operation)) leaf_name_data.push_back(dp_source_address.get_name_leafdata());
    if (dp_type.is_set || is_set(dp_type.operation)) leaf_name_data.push_back(dp_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dp-group-id")
    {
        dp_group_id = value;
    }
    if(value_path == "dp-source-address")
    {
        dp_source_address = value;
    }
    if(value_path == "dp-type")
    {
        dp_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Pce()
    :
    	enable{YType::empty, "enable"}
    	,
    bidirectional(nullptr) // presence node
	,disjoint_path(nullptr) // presence node
{
    yang_name = "pce"; yang_parent_name = "path-option-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::~Pce()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::has_data() const
{
    return enable.is_set
	|| (bidirectional !=  nullptr && bidirectional->has_data())
	|| (disjoint_path !=  nullptr && disjoint_path->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| (bidirectional !=  nullptr && bidirectional->has_operation())
	|| (disjoint_path !=  nullptr && disjoint_path->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pce";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bidirectional")
    {
        if(bidirectional != nullptr)
        {
            children["bidirectional"] = bidirectional.get();
        }
        else
        {
            bidirectional = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::Bidirectional>();
            bidirectional->parent = this;
            children["bidirectional"] = bidirectional.get();
        }
        return children.at("bidirectional");
    }

    if(child_yang_name == "disjoint-path")
    {
        if(disjoint_path != nullptr)
        {
            children["disjoint-path"] = disjoint_path.get();
        }
        else
        {
            disjoint_path = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::DisjointPath>();
            disjoint_path->parent = this;
            children["disjoint-path"] = disjoint_path.get();
        }
        return children.at("disjoint-path");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::get_children()
{
    if(children.find("bidirectional") == children.end())
    {
        if(bidirectional != nullptr)
        {
            children["bidirectional"] = bidirectional.get();
        }
    }

    if(children.find("disjoint-path") == children.end())
    {
        if(disjoint_path != nullptr)
        {
            children["disjoint-path"] = disjoint_path.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::AffinityMask()
    :
    	affinity{YType::str, "affinity"},
	 mask{YType::str, "mask"}
{
    yang_name = "affinity-mask"; yang_parent_name = "path-option-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::~AffinityMask()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::has_data() const
{
    return affinity.is_set
	|| mask.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity.operation)
	|| is_set(mask.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mask";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity.is_set || is_set(affinity.operation)) leaf_name_data.push_back(affinity.get_name_leafdata());
    if (mask.is_set || is_set(mask.operation)) leaf_name_data.push_back(mask.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity")
    {
        affinity = value;
    }
    if(value_path == "mask")
    {
        mask = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::Bandwidth()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 class_or_pool_type{YType::uint32, "class-or-pool-type"},
	 dste_type{YType::enumeration, "dste-type"}
{
    yang_name = "bandwidth"; yang_parent_name = "path-option-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::~Bandwidth()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::has_data() const
{
    return bandwidth.is_set
	|| class_or_pool_type.is_set
	|| dste_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(class_or_pool_type.operation)
	|| is_set(dste_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bandwidth";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (class_or_pool_type.is_set || is_set(class_or_pool_type.operation)) leaf_name_data.push_back(class_or_pool_type.get_name_leafdata());
    if (dste_type.is_set || is_set(dste_type.operation)) leaf_name_data.push_back(dste_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "class-or-pool-type")
    {
        class_or_pool_type = value;
    }
    if(value_path == "dste-type")
    {
        dste_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::NewStyleAffinityAffinityType()
    :
    	affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::~NewStyleAffinityAffinityType()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_data() const
{
    return affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::NewStyleAffinityAffinityTypeAffinity1()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::~NewStyleAffinityAffinityTypeAffinity1()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_data() const
{
    return affinity1.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::NewStyleAffinityAffinityTypeAffinity1Affinity2()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::~NewStyleAffinityAffinityTypeAffinity1Affinity2()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity10{YType::str, "affinity10"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_data() const
{
    return affinity1.is_set
	|| affinity10.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity10.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity10='" <<affinity10.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity10.is_set || is_set(affinity10.operation)) leaf_name_data.push_back(affinity10.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity10")
    {
        affinity10 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypes()
{
    yang_name = "new-style-affinity-affinity-types"; yang_parent_name = "path-option-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::~NewStyleAffinityAffinityTypes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::has_data() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::has_operation() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-types";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type")
    {
        for(auto const & c : new_style_affinity_affinity_type)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType>();
        c->parent = this;
        new_style_affinity_affinity_type.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::get_children()
{
    for (auto const & c : new_style_affinity_affinity_type)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::PathOptionAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 enable{YType::empty, "enable"}
    	,
    affinity_mask(nullptr) // presence node
	,att_path_option_path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection>())
	,bandwidth(nullptr) // presence node
	,bfd_reverse_path(nullptr) // presence node
	,new_style_affinity_affinity_types(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes>())
	,pce(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce>())
{
    att_path_option_path_selection->parent = this;
    children["att-path-option-path-selection"] = att_path_option_path_selection.get();

    new_style_affinity_affinity_types->parent = this;
    children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();

    pce->parent = this;
    children["pce"] = pce.get();

    yang_name = "path-option-attribute"; yang_parent_name = "path-option-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::~PathOptionAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| enable.is_set
	|| (affinity_mask !=  nullptr && affinity_mask->has_data())
	|| (att_path_option_path_selection !=  nullptr && att_path_option_path_selection->has_data())
	|| (bandwidth !=  nullptr && bandwidth->has_data())
	|| (bfd_reverse_path !=  nullptr && bfd_reverse_path->has_data())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_data())
	|| (pce !=  nullptr && pce->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(enable.operation)
	|| (affinity_mask !=  nullptr && affinity_mask->has_operation())
	|| (att_path_option_path_selection !=  nullptr && att_path_option_path_selection->has_operation())
	|| (bandwidth !=  nullptr && bandwidth->has_operation())
	|| (bfd_reverse_path !=  nullptr && bfd_reverse_path->has_operation())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_operation())
	|| (pce !=  nullptr && pce->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-option-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/path-option-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mask")
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
        else
        {
            affinity_mask = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AffinityMask>();
            affinity_mask->parent = this;
            children["affinity-mask"] = affinity_mask.get();
        }
        return children.at("affinity-mask");
    }

    if(child_yang_name == "att-path-option-path-selection")
    {
        if(att_path_option_path_selection != nullptr)
        {
            children["att-path-option-path-selection"] = att_path_option_path_selection.get();
        }
        else
        {
            att_path_option_path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::AttPathOptionPathSelection>();
            att_path_option_path_selection->parent = this;
            children["att-path-option-path-selection"] = att_path_option_path_selection.get();
        }
        return children.at("att-path-option-path-selection");
    }

    if(child_yang_name == "bandwidth")
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
        else
        {
            bandwidth = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Bandwidth>();
            bandwidth->parent = this;
            children["bandwidth"] = bandwidth.get();
        }
        return children.at("bandwidth");
    }

    if(child_yang_name == "bfd-reverse-path")
    {
        if(bfd_reverse_path != nullptr)
        {
            children["bfd-reverse-path"] = bfd_reverse_path.get();
        }
        else
        {
            bfd_reverse_path = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::BfdReversePath>();
            bfd_reverse_path->parent = this;
            children["bfd-reverse-path"] = bfd_reverse_path.get();
        }
        return children.at("bfd-reverse-path");
    }

    if(child_yang_name == "new-style-affinity-affinity-types")
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        else
        {
            new_style_affinity_affinity_types = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::NewStyleAffinityAffinityTypes>();
            new_style_affinity_affinity_types->parent = this;
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        return children.at("new-style-affinity-affinity-types");
    }

    if(child_yang_name == "pce")
    {
        if(pce != nullptr)
        {
            children["pce"] = pce.get();
        }
        else
        {
            pce = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::Pce>();
            pce->parent = this;
            children["pce"] = pce.get();
        }
        return children.at("pce");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::get_children()
{
    if(children.find("affinity-mask") == children.end())
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
    }

    if(children.find("att-path-option-path-selection") == children.end())
    {
        if(att_path_option_path_selection != nullptr)
        {
            children["att-path-option-path-selection"] = att_path_option_path_selection.get();
        }
    }

    if(children.find("bandwidth") == children.end())
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
    }

    if(children.find("bfd-reverse-path") == children.end())
    {
        if(bfd_reverse_path != nullptr)
        {
            children["bfd-reverse-path"] = bfd_reverse_path.get();
        }
    }

    if(children.find("new-style-affinity-affinity-types") == children.end())
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
    }

    if(children.find("pce") == children.end())
    {
        if(pce != nullptr)
        {
            children["pce"] = pce.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttributes()
{
    yang_name = "path-option-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::~PathOptionAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::has_data() const
{
    for (std::size_t index=0; index<path_option_attribute.size(); index++)
    {
        if(path_option_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::has_operation() const
{
    for (std::size_t index=0; index<path_option_attribute.size(); index++)
    {
        if(path_option_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-option-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-option-attribute")
    {
        for(auto const & c : path_option_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::PathOptionAttribute>();
        c->parent = this;
        path_option_attribute.push_back(std::move(c));
        children[segment_path] = path_option_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::get_children()
{
    for (auto const & c : path_option_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::Priority()
    :
    	hold_priority{YType::uint32, "hold-priority"},
	 setup_priority{YType::uint32, "setup-priority"}
{
    yang_name = "priority"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::~Priority()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::has_data() const
{
    return hold_priority.is_set
	|| setup_priority.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::has_operation() const
{
    return is_set(operation)
	|| is_set(hold_priority.operation)
	|| is_set(setup_priority.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "priority";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hold_priority.is_set || is_set(hold_priority.operation)) leaf_name_data.push_back(hold_priority.get_name_leafdata());
    if (setup_priority.is_set || is_set(setup_priority.operation)) leaf_name_data.push_back(setup_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hold-priority")
    {
        hold_priority = value;
    }
    if(value_path == "setup-priority")
    {
        setup_priority = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::AffinityMask()
    :
    	affinity{YType::str, "affinity"},
	 mask{YType::str, "mask"}
{
    yang_name = "affinity-mask"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::~AffinityMask()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::has_data() const
{
    return affinity.is_set
	|| mask.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity.operation)
	|| is_set(mask.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mask";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity.is_set || is_set(affinity.operation)) leaf_name_data.push_back(affinity.get_name_leafdata());
    if (mask.is_set || is_set(mask.operation)) leaf_name_data.push_back(mask.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity")
    {
        affinity = value;
    }
    if(value_path == "mask")
    {
        mask = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::Bandwidth()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 class_or_pool_type{YType::uint32, "class-or-pool-type"},
	 dste_type{YType::enumeration, "dste-type"}
{
    yang_name = "bandwidth"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::~Bandwidth()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::has_data() const
{
    return bandwidth.is_set
	|| class_or_pool_type.is_set
	|| dste_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(class_or_pool_type.operation)
	|| is_set(dste_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bandwidth";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (class_or_pool_type.is_set || is_set(class_or_pool_type.operation)) leaf_name_data.push_back(class_or_pool_type.get_name_leafdata());
    if (dste_type.is_set || is_set(dste_type.operation)) leaf_name_data.push_back(dste_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "class-or-pool-type")
    {
        class_or_pool_type = value;
    }
    if(value_path == "dste-type")
    {
        dste_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::PathSelection()
    :
    	enable{YType::empty, "enable"}
{
    yang_name = "path-selection"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::has_data() const
{
    return enable.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::NewStyleAffinityAffinityType()
    :
    	affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::~NewStyleAffinityAffinityType()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_data() const
{
    return affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::NewStyleAffinityAffinityTypeAffinity1()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::~NewStyleAffinityAffinityTypeAffinity1()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_data() const
{
    return affinity1.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::NewStyleAffinityAffinityTypeAffinity1Affinity2()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::~NewStyleAffinityAffinityTypeAffinity1Affinity2()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity10{YType::str, "affinity10"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_data() const
{
    return affinity1.is_set
	|| affinity10.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity10.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity10='" <<affinity10.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity10.is_set || is_set(affinity10.operation)) leaf_name_data.push_back(affinity10.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity10")
    {
        affinity10 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypes()
{
    yang_name = "new-style-affinity-affinity-types"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::~NewStyleAffinityAffinityTypes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::has_data() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::has_operation() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-types";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type")
    {
        for(auto const & c : new_style_affinity_affinity_type)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType>();
        c->parent = this;
        new_style_affinity_affinity_type.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::get_children()
{
    for (auto const & c : new_style_affinity_affinity_type)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::FastReroute()
    :
    	bandwidth_protection{YType::uint32, "bandwidth-protection"},
	 node_protection{YType::uint32, "node-protection"}
{
    yang_name = "fast-reroute"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::~FastReroute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::has_data() const
{
    return bandwidth_protection.is_set
	|| node_protection.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_protection.operation)
	|| is_set(node_protection.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fast-reroute";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_protection.is_set || is_set(bandwidth_protection.operation)) leaf_name_data.push_back(bandwidth_protection.get_name_leafdata());
    if (node_protection.is_set || is_set(node_protection.operation)) leaf_name_data.push_back(node_protection.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-protection")
    {
        bandwidth_protection = value;
    }
    if(value_path == "node-protection")
    {
        node_protection = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::Logging()
    :
    	all{YType::empty, "all"},
	 bandwidth_change_message{YType::empty, "bandwidth-change-message"},
	 insufficient_bw_message{YType::empty, "insufficient-bw-message"},
	 pcalc_failure_message{YType::empty, "pcalc-failure-message"},
	 reoptimize_attempts_message{YType::empty, "reoptimize-attempts-message"},
	 reoptimized_message{YType::empty, "reoptimized-message"},
	 reroute_messsage{YType::empty, "reroute-messsage"},
	 state_message{YType::empty, "state-message"},
	 sub_lsp_state_message{YType::empty, "sub-lsp-state-message"}
{
    yang_name = "logging"; yang_parent_name = "p2mpte-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::~Logging()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::has_data() const
{
    return all.is_set
	|| bandwidth_change_message.is_set
	|| insufficient_bw_message.is_set
	|| pcalc_failure_message.is_set
	|| reoptimize_attempts_message.is_set
	|| reoptimized_message.is_set
	|| reroute_messsage.is_set
	|| state_message.is_set
	|| sub_lsp_state_message.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::has_operation() const
{
    return is_set(operation)
	|| is_set(all.operation)
	|| is_set(bandwidth_change_message.operation)
	|| is_set(insufficient_bw_message.operation)
	|| is_set(pcalc_failure_message.operation)
	|| is_set(reoptimize_attempts_message.operation)
	|| is_set(reoptimized_message.operation)
	|| is_set(reroute_messsage.operation)
	|| is_set(state_message.operation)
	|| is_set(sub_lsp_state_message.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "logging";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all.is_set || is_set(all.operation)) leaf_name_data.push_back(all.get_name_leafdata());
    if (bandwidth_change_message.is_set || is_set(bandwidth_change_message.operation)) leaf_name_data.push_back(bandwidth_change_message.get_name_leafdata());
    if (insufficient_bw_message.is_set || is_set(insufficient_bw_message.operation)) leaf_name_data.push_back(insufficient_bw_message.get_name_leafdata());
    if (pcalc_failure_message.is_set || is_set(pcalc_failure_message.operation)) leaf_name_data.push_back(pcalc_failure_message.get_name_leafdata());
    if (reoptimize_attempts_message.is_set || is_set(reoptimize_attempts_message.operation)) leaf_name_data.push_back(reoptimize_attempts_message.get_name_leafdata());
    if (reoptimized_message.is_set || is_set(reoptimized_message.operation)) leaf_name_data.push_back(reoptimized_message.get_name_leafdata());
    if (reroute_messsage.is_set || is_set(reroute_messsage.operation)) leaf_name_data.push_back(reroute_messsage.get_name_leafdata());
    if (state_message.is_set || is_set(state_message.operation)) leaf_name_data.push_back(state_message.get_name_leafdata());
    if (sub_lsp_state_message.is_set || is_set(sub_lsp_state_message.operation)) leaf_name_data.push_back(sub_lsp_state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all")
    {
        all = value;
    }
    if(value_path == "bandwidth-change-message")
    {
        bandwidth_change_message = value;
    }
    if(value_path == "insufficient-bw-message")
    {
        insufficient_bw_message = value;
    }
    if(value_path == "pcalc-failure-message")
    {
        pcalc_failure_message = value;
    }
    if(value_path == "reoptimize-attempts-message")
    {
        reoptimize_attempts_message = value;
    }
    if(value_path == "reoptimized-message")
    {
        reoptimized_message = value;
    }
    if(value_path == "reroute-messsage")
    {
        reroute_messsage = value;
    }
    if(value_path == "state-message")
    {
        state_message = value;
    }
    if(value_path == "sub-lsp-state-message")
    {
        sub_lsp_state_message = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::P2MpteAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 enable{YType::empty, "enable"},
	 interface_bandwidth{YType::uint32, "interface-bandwidth"},
	 record_route{YType::empty, "record-route"}
    	,
    affinity_mask(nullptr) // presence node
	,bandwidth(nullptr) // presence node
	,fast_reroute(nullptr) // presence node
	,logging(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging>())
	,new_style_affinity_affinity_types(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes>())
	,path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection>())
	,priority(nullptr) // presence node
{
    logging->parent = this;
    children["logging"] = logging.get();

    new_style_affinity_affinity_types->parent = this;
    children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();

    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    yang_name = "p2mpte-attribute"; yang_parent_name = "p2mpte-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::~P2MpteAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| enable.is_set
	|| interface_bandwidth.is_set
	|| record_route.is_set
	|| (affinity_mask !=  nullptr && affinity_mask->has_data())
	|| (bandwidth !=  nullptr && bandwidth->has_data())
	|| (fast_reroute !=  nullptr && fast_reroute->has_data())
	|| (logging !=  nullptr && logging->has_data())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_data())
	|| (path_selection !=  nullptr && path_selection->has_data())
	|| (priority !=  nullptr && priority->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(enable.operation)
	|| is_set(interface_bandwidth.operation)
	|| is_set(record_route.operation)
	|| (affinity_mask !=  nullptr && affinity_mask->has_operation())
	|| (bandwidth !=  nullptr && bandwidth->has_operation())
	|| (fast_reroute !=  nullptr && fast_reroute->has_operation())
	|| (logging !=  nullptr && logging->has_operation())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_operation())
	|| (path_selection !=  nullptr && path_selection->has_operation())
	|| (priority !=  nullptr && priority->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2mpte-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/p2mpte-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (interface_bandwidth.is_set || is_set(interface_bandwidth.operation)) leaf_name_data.push_back(interface_bandwidth.get_name_leafdata());
    if (record_route.is_set || is_set(record_route.operation)) leaf_name_data.push_back(record_route.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mask")
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
        else
        {
            affinity_mask = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::AffinityMask>();
            affinity_mask->parent = this;
            children["affinity-mask"] = affinity_mask.get();
        }
        return children.at("affinity-mask");
    }

    if(child_yang_name == "bandwidth")
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
        else
        {
            bandwidth = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Bandwidth>();
            bandwidth->parent = this;
            children["bandwidth"] = bandwidth.get();
        }
        return children.at("bandwidth");
    }

    if(child_yang_name == "fast-reroute")
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
        else
        {
            fast_reroute = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::FastReroute>();
            fast_reroute->parent = this;
            children["fast-reroute"] = fast_reroute.get();
        }
        return children.at("fast-reroute");
    }

    if(child_yang_name == "logging")
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
        else
        {
            logging = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Logging>();
            logging->parent = this;
            children["logging"] = logging.get();
        }
        return children.at("logging");
    }

    if(child_yang_name == "new-style-affinity-affinity-types")
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        else
        {
            new_style_affinity_affinity_types = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::NewStyleAffinityAffinityTypes>();
            new_style_affinity_affinity_types->parent = this;
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        return children.at("new-style-affinity-affinity-types");
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    if(child_yang_name == "priority")
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
        else
        {
            priority = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::Priority>();
            priority->parent = this;
            children["priority"] = priority.get();
        }
        return children.at("priority");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::get_children()
{
    if(children.find("affinity-mask") == children.end())
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
    }

    if(children.find("bandwidth") == children.end())
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
    }

    if(children.find("fast-reroute") == children.end())
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
    }

    if(children.find("logging") == children.end())
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
    }

    if(children.find("new-style-affinity-affinity-types") == children.end())
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
    }

    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    if(children.find("priority") == children.end())
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "interface-bandwidth")
    {
        interface_bandwidth = value;
    }
    if(value_path == "record-route")
    {
        record_route = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttributes()
{
    yang_name = "p2mpte-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::~P2MpteAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::has_data() const
{
    for (std::size_t index=0; index<p2mpte_attribute.size(); index++)
    {
        if(p2mpte_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::has_operation() const
{
    for (std::size_t index=0; index<p2mpte_attribute.size(); index++)
    {
        if(p2mpte_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2mpte-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "p2mpte-attribute")
    {
        for(auto const & c : p2mpte_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::P2MpteAttribute>();
        c->parent = this;
        p2mpte_attribute.push_back(std::move(c));
        children[segment_path] = p2mpte_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::get_children()
{
    for (auto const & c : p2mpte_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::Index_()
    :
    	index_number{YType::uint32, "index-number"},
	 mpls_label{YType::int32, "mpls-label"},
	 prepend_type{YType::enumeration, "prepend-type"}
{
    yang_name = "index"; yang_parent_name = "indexes";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::~Index_()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::has_data() const
{
    return index_number.is_set
	|| mpls_label.is_set
	|| prepend_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::has_operation() const
{
    return is_set(operation)
	|| is_set(index_number.operation)
	|| is_set(mpls_label.operation)
	|| is_set(prepend_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "index" <<"[index-number='" <<index_number.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (index_number.is_set || is_set(index_number.operation)) leaf_name_data.push_back(index_number.get_name_leafdata());
    if (mpls_label.is_set || is_set(mpls_label.operation)) leaf_name_data.push_back(mpls_label.get_name_leafdata());
    if (prepend_type.is_set || is_set(prepend_type.operation)) leaf_name_data.push_back(prepend_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "index-number")
    {
        index_number = value;
    }
    if(value_path == "mpls-label")
    {
        mpls_label = value;
    }
    if(value_path == "prepend-type")
    {
        prepend_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Indexes()
{
    yang_name = "indexes"; yang_parent_name = "segment-routing-prepend";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::~Indexes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::has_data() const
{
    for (std::size_t index=0; index<index_.size(); index++)
    {
        if(index_[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::has_operation() const
{
    for (std::size_t index=0; index<index_.size(); index++)
    {
        if(index_[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "indexes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "index")
    {
        for(auto const & c : index_)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::Index_>();
        c->parent = this;
        index_.push_back(std::move(c));
        children[segment_path] = index_.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::get_children()
{
    for (auto const & c : index_)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::SegmentRoutingPrepend()
    :
    	enable{YType::empty, "enable"}
    	,
    indexes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes>())
{
    indexes->parent = this;
    children["indexes"] = indexes.get();

    yang_name = "segment-routing-prepend"; yang_parent_name = "path-selection";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::~SegmentRoutingPrepend()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::has_data() const
{
    return enable.is_set
	|| (indexes !=  nullptr && indexes->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| (indexes !=  nullptr && indexes->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "segment-routing-prepend";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "indexes")
    {
        if(indexes != nullptr)
        {
            children["indexes"] = indexes.get();
        }
        else
        {
            indexes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::Indexes>();
            indexes->parent = this;
            children["indexes"] = indexes.get();
        }
        return children.at("indexes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::get_children()
{
    if(children.find("indexes") == children.end())
    {
        if(indexes != nullptr)
        {
            children["indexes"] = indexes.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::Invalidation()
    :
    	invalidation_timer{YType::uint32, "invalidation-timer"},
	 invalidation_timer_expire_type{YType::enumeration, "invalidation-timer-expire-type"}
{
    yang_name = "invalidation"; yang_parent_name = "path-selection";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::~Invalidation()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::has_data() const
{
    return invalidation_timer.is_set
	|| invalidation_timer_expire_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::has_operation() const
{
    return is_set(operation)
	|| is_set(invalidation_timer.operation)
	|| is_set(invalidation_timer_expire_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalidation";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (invalidation_timer.is_set || is_set(invalidation_timer.operation)) leaf_name_data.push_back(invalidation_timer.get_name_leafdata());
    if (invalidation_timer_expire_type.is_set || is_set(invalidation_timer_expire_type.operation)) leaf_name_data.push_back(invalidation_timer_expire_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "invalidation-timer")
    {
        invalidation_timer = value;
    }
    if(value_path == "invalidation-timer-expire-type")
    {
        invalidation_timer_expire_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::PathSelection()
    :
    	enable{YType::empty, "enable"},
	 path_selection_metric{YType::enumeration, "path-selection-metric"},
	 path_selection_segment_routing_adjacency_protection{YType::enumeration, "path-selection-segment-routing-adjacency-protection"}
    	,
    invalidation(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation>())
	,segment_routing_prepend(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend>())
{
    invalidation->parent = this;
    children["invalidation"] = invalidation.get();

    segment_routing_prepend->parent = this;
    children["segment-routing-prepend"] = segment_routing_prepend.get();

    yang_name = "path-selection"; yang_parent_name = "p2p-te-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::has_data() const
{
    return enable.is_set
	|| path_selection_metric.is_set
	|| path_selection_segment_routing_adjacency_protection.is_set
	|| (invalidation !=  nullptr && invalidation->has_data())
	|| (segment_routing_prepend !=  nullptr && segment_routing_prepend->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| is_set(path_selection_metric.operation)
	|| is_set(path_selection_segment_routing_adjacency_protection.operation)
	|| (invalidation !=  nullptr && invalidation->has_operation())
	|| (segment_routing_prepend !=  nullptr && segment_routing_prepend->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (path_selection_metric.is_set || is_set(path_selection_metric.operation)) leaf_name_data.push_back(path_selection_metric.get_name_leafdata());
    if (path_selection_segment_routing_adjacency_protection.is_set || is_set(path_selection_segment_routing_adjacency_protection.operation)) leaf_name_data.push_back(path_selection_segment_routing_adjacency_protection.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "invalidation")
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
        else
        {
            invalidation = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::Invalidation>();
            invalidation->parent = this;
            children["invalidation"] = invalidation.get();
        }
        return children.at("invalidation");
    }

    if(child_yang_name == "segment-routing-prepend")
    {
        if(segment_routing_prepend != nullptr)
        {
            children["segment-routing-prepend"] = segment_routing_prepend.get();
        }
        else
        {
            segment_routing_prepend = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::SegmentRoutingPrepend>();
            segment_routing_prepend->parent = this;
            children["segment-routing-prepend"] = segment_routing_prepend.get();
        }
        return children.at("segment-routing-prepend");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::get_children()
{
    if(children.find("invalidation") == children.end())
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
    }

    if(children.find("segment-routing-prepend") == children.end())
    {
        if(segment_routing_prepend != nullptr)
        {
            children["segment-routing-prepend"] = segment_routing_prepend.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "path-selection-metric")
    {
        path_selection_metric = value;
    }
    if(value_path == "path-selection-segment-routing-adjacency-protection")
    {
        path_selection_segment_routing_adjacency_protection = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::Bidirectional()
    :
    	bd_group_id{YType::uint32, "bd-group-id"},
	 bd_source_address{YType::str, "bd-source-address"}
{
    yang_name = "bidirectional"; yang_parent_name = "pce";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::~Bidirectional()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::has_data() const
{
    return bd_group_id.is_set
	|| bd_source_address.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::has_operation() const
{
    return is_set(operation)
	|| is_set(bd_group_id.operation)
	|| is_set(bd_source_address.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bidirectional";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bd_group_id.is_set || is_set(bd_group_id.operation)) leaf_name_data.push_back(bd_group_id.get_name_leafdata());
    if (bd_source_address.is_set || is_set(bd_source_address.operation)) leaf_name_data.push_back(bd_source_address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bd-group-id")
    {
        bd_group_id = value;
    }
    if(value_path == "bd-source-address")
    {
        bd_source_address = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::DisjointPath()
    :
    	dp_group_id{YType::uint32, "dp-group-id"},
	 dp_source_address{YType::str, "dp-source-address"},
	 dp_type{YType::uint32, "dp-type"}
{
    yang_name = "disjoint-path"; yang_parent_name = "pce";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::~DisjointPath()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::has_data() const
{
    return dp_group_id.is_set
	|| dp_source_address.is_set
	|| dp_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::has_operation() const
{
    return is_set(operation)
	|| is_set(dp_group_id.operation)
	|| is_set(dp_source_address.operation)
	|| is_set(dp_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "disjoint-path";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dp_group_id.is_set || is_set(dp_group_id.operation)) leaf_name_data.push_back(dp_group_id.get_name_leafdata());
    if (dp_source_address.is_set || is_set(dp_source_address.operation)) leaf_name_data.push_back(dp_source_address.get_name_leafdata());
    if (dp_type.is_set || is_set(dp_type.operation)) leaf_name_data.push_back(dp_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dp-group-id")
    {
        dp_group_id = value;
    }
    if(value_path == "dp-source-address")
    {
        dp_source_address = value;
    }
    if(value_path == "dp-type")
    {
        dp_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Pce()
    :
    	enable{YType::empty, "enable"}
    	,
    bidirectional(nullptr) // presence node
	,disjoint_path(nullptr) // presence node
{
    yang_name = "pce"; yang_parent_name = "p2p-te-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::~Pce()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::has_data() const
{
    return enable.is_set
	|| (bidirectional !=  nullptr && bidirectional->has_data())
	|| (disjoint_path !=  nullptr && disjoint_path->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| (bidirectional !=  nullptr && bidirectional->has_operation())
	|| (disjoint_path !=  nullptr && disjoint_path->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pce";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bidirectional")
    {
        if(bidirectional != nullptr)
        {
            children["bidirectional"] = bidirectional.get();
        }
        else
        {
            bidirectional = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::Bidirectional>();
            bidirectional->parent = this;
            children["bidirectional"] = bidirectional.get();
        }
        return children.at("bidirectional");
    }

    if(child_yang_name == "disjoint-path")
    {
        if(disjoint_path != nullptr)
        {
            children["disjoint-path"] = disjoint_path.get();
        }
        else
        {
            disjoint_path = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::DisjointPath>();
            disjoint_path->parent = this;
            children["disjoint-path"] = disjoint_path.get();
        }
        return children.at("disjoint-path");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::get_children()
{
    if(children.find("bidirectional") == children.end())
    {
        if(bidirectional != nullptr)
        {
            children["bidirectional"] = bidirectional.get();
        }
    }

    if(children.find("disjoint-path") == children.end())
    {
        if(disjoint_path != nullptr)
        {
            children["disjoint-path"] = disjoint_path.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::AffinityMask()
    :
    	affinity{YType::str, "affinity"},
	 mask{YType::str, "mask"}
{
    yang_name = "affinity-mask"; yang_parent_name = "p2p-te-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::~AffinityMask()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::has_data() const
{
    return affinity.is_set
	|| mask.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity.operation)
	|| is_set(mask.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mask";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity.is_set || is_set(affinity.operation)) leaf_name_data.push_back(affinity.get_name_leafdata());
    if (mask.is_set || is_set(mask.operation)) leaf_name_data.push_back(mask.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity")
    {
        affinity = value;
    }
    if(value_path == "mask")
    {
        mask = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::Logging()
    :
    	all{YType::empty, "all"},
	 bandwidth_change_message{YType::empty, "bandwidth-change-message"},
	 bfd_state_message{YType::empty, "bfd-state-message"},
	 insufficient_bw_message{YType::empty, "insufficient-bw-message"},
	 lsp_switch_over_change_message{YType::empty, "lsp-switch-over-change-message"},
	 pcalc_failure_message{YType::empty, "pcalc-failure-message"},
	 record_route_messsage{YType::empty, "record-route-messsage"},
	 reoptimize_attempts_message{YType::empty, "reoptimize-attempts-message"},
	 reoptimized_message{YType::empty, "reoptimized-message"},
	 reroute_messsage{YType::empty, "reroute-messsage"},
	 state_message{YType::empty, "state-message"}
{
    yang_name = "logging"; yang_parent_name = "p2p-te-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::~Logging()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::has_data() const
{
    return all.is_set
	|| bandwidth_change_message.is_set
	|| bfd_state_message.is_set
	|| insufficient_bw_message.is_set
	|| lsp_switch_over_change_message.is_set
	|| pcalc_failure_message.is_set
	|| record_route_messsage.is_set
	|| reoptimize_attempts_message.is_set
	|| reoptimized_message.is_set
	|| reroute_messsage.is_set
	|| state_message.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::has_operation() const
{
    return is_set(operation)
	|| is_set(all.operation)
	|| is_set(bandwidth_change_message.operation)
	|| is_set(bfd_state_message.operation)
	|| is_set(insufficient_bw_message.operation)
	|| is_set(lsp_switch_over_change_message.operation)
	|| is_set(pcalc_failure_message.operation)
	|| is_set(record_route_messsage.operation)
	|| is_set(reoptimize_attempts_message.operation)
	|| is_set(reoptimized_message.operation)
	|| is_set(reroute_messsage.operation)
	|| is_set(state_message.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "logging";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (all.is_set || is_set(all.operation)) leaf_name_data.push_back(all.get_name_leafdata());
    if (bandwidth_change_message.is_set || is_set(bandwidth_change_message.operation)) leaf_name_data.push_back(bandwidth_change_message.get_name_leafdata());
    if (bfd_state_message.is_set || is_set(bfd_state_message.operation)) leaf_name_data.push_back(bfd_state_message.get_name_leafdata());
    if (insufficient_bw_message.is_set || is_set(insufficient_bw_message.operation)) leaf_name_data.push_back(insufficient_bw_message.get_name_leafdata());
    if (lsp_switch_over_change_message.is_set || is_set(lsp_switch_over_change_message.operation)) leaf_name_data.push_back(lsp_switch_over_change_message.get_name_leafdata());
    if (pcalc_failure_message.is_set || is_set(pcalc_failure_message.operation)) leaf_name_data.push_back(pcalc_failure_message.get_name_leafdata());
    if (record_route_messsage.is_set || is_set(record_route_messsage.operation)) leaf_name_data.push_back(record_route_messsage.get_name_leafdata());
    if (reoptimize_attempts_message.is_set || is_set(reoptimize_attempts_message.operation)) leaf_name_data.push_back(reoptimize_attempts_message.get_name_leafdata());
    if (reoptimized_message.is_set || is_set(reoptimized_message.operation)) leaf_name_data.push_back(reoptimized_message.get_name_leafdata());
    if (reroute_messsage.is_set || is_set(reroute_messsage.operation)) leaf_name_data.push_back(reroute_messsage.get_name_leafdata());
    if (state_message.is_set || is_set(state_message.operation)) leaf_name_data.push_back(state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "all")
    {
        all = value;
    }
    if(value_path == "bandwidth-change-message")
    {
        bandwidth_change_message = value;
    }
    if(value_path == "bfd-state-message")
    {
        bfd_state_message = value;
    }
    if(value_path == "insufficient-bw-message")
    {
        insufficient_bw_message = value;
    }
    if(value_path == "lsp-switch-over-change-message")
    {
        lsp_switch_over_change_message = value;
    }
    if(value_path == "pcalc-failure-message")
    {
        pcalc_failure_message = value;
    }
    if(value_path == "record-route-messsage")
    {
        record_route_messsage = value;
    }
    if(value_path == "reoptimize-attempts-message")
    {
        reoptimize_attempts_message = value;
    }
    if(value_path == "reoptimized-message")
    {
        reoptimized_message = value;
    }
    if(value_path == "reroute-messsage")
    {
        reroute_messsage = value;
    }
    if(value_path == "state-message")
    {
        state_message = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::NewStyleAffinityAffinityType()
    :
    	affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::~NewStyleAffinityAffinityType()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_data() const
{
    return affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::NewStyleAffinityAffinityTypeAffinity1()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::~NewStyleAffinityAffinityTypeAffinity1()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_data() const
{
    return affinity1.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::NewStyleAffinityAffinityTypeAffinity1Affinity2()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::~NewStyleAffinityAffinityTypeAffinity1Affinity2()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity10{YType::str, "affinity10"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_data() const
{
    return affinity1.is_set
	|| affinity10.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity10.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity10='" <<affinity10.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity10.is_set || is_set(affinity10.operation)) leaf_name_data.push_back(affinity10.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity10")
    {
        affinity10 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypes()
{
    yang_name = "new-style-affinity-affinity-types"; yang_parent_name = "p2p-te-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::~NewStyleAffinityAffinityTypes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::has_data() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::has_operation() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-types";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type")
    {
        for(auto const & c : new_style_affinity_affinity_type)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType>();
        c->parent = this;
        new_style_affinity_affinity_type.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::get_children()
{
    for (auto const & c : new_style_affinity_affinity_type)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::P2PTeAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 enable{YType::empty, "enable"}
    	,
    affinity_mask(nullptr) // presence node
	,logging(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging>())
	,new_style_affinity_affinity_types(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes>())
	,path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection>())
	,pce(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce>())
{
    logging->parent = this;
    children["logging"] = logging.get();

    new_style_affinity_affinity_types->parent = this;
    children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();

    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    pce->parent = this;
    children["pce"] = pce.get();

    yang_name = "p2p-te-attribute"; yang_parent_name = "p2p-te-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::~P2PTeAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| enable.is_set
	|| (affinity_mask !=  nullptr && affinity_mask->has_data())
	|| (logging !=  nullptr && logging->has_data())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_data())
	|| (path_selection !=  nullptr && path_selection->has_data())
	|| (pce !=  nullptr && pce->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(enable.operation)
	|| (affinity_mask !=  nullptr && affinity_mask->has_operation())
	|| (logging !=  nullptr && logging->has_operation())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_operation())
	|| (path_selection !=  nullptr && path_selection->has_operation())
	|| (pce !=  nullptr && pce->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2p-te-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/p2p-te-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mask")
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
        else
        {
            affinity_mask = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::AffinityMask>();
            affinity_mask->parent = this;
            children["affinity-mask"] = affinity_mask.get();
        }
        return children.at("affinity-mask");
    }

    if(child_yang_name == "logging")
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
        else
        {
            logging = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Logging>();
            logging->parent = this;
            children["logging"] = logging.get();
        }
        return children.at("logging");
    }

    if(child_yang_name == "new-style-affinity-affinity-types")
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        else
        {
            new_style_affinity_affinity_types = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::NewStyleAffinityAffinityTypes>();
            new_style_affinity_affinity_types->parent = this;
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        return children.at("new-style-affinity-affinity-types");
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    if(child_yang_name == "pce")
    {
        if(pce != nullptr)
        {
            children["pce"] = pce.get();
        }
        else
        {
            pce = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::Pce>();
            pce->parent = this;
            children["pce"] = pce.get();
        }
        return children.at("pce");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::get_children()
{
    if(children.find("affinity-mask") == children.end())
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
    }

    if(children.find("logging") == children.end())
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
    }

    if(children.find("new-style-affinity-affinity-types") == children.end())
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
    }

    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    if(children.find("pce") == children.end())
    {
        if(pce != nullptr)
        {
            children["pce"] = pce.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttributes()
{
    yang_name = "p2p-te-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::~P2PTeAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::has_data() const
{
    for (std::size_t index=0; index<p2p_te_attribute.size(); index++)
    {
        if(p2p_te_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::has_operation() const
{
    for (std::size_t index=0; index<p2p_te_attribute.size(); index++)
    {
        if(p2p_te_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "p2p-te-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "p2p-te-attribute")
    {
        for(auto const & c : p2p_te_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::P2PTeAttribute>();
        c->parent = this;
        p2p_te_attribute.push_back(std::move(c));
        children[segment_path] = p2p_te_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::get_children()
{
    for (auto const & c : p2p_te_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::SignalledName()
    :
    	mp_address{YType::boolean, "mp-address"},
	 name{YType::str, "name"},
	 protected_interface_type{YType::enumeration, "protected-interface-type"},
	 source_type{YType::enumeration, "source-type"}
{
    yang_name = "signalled-name"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::~SignalledName()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::has_data() const
{
    return mp_address.is_set
	|| name.is_set
	|| protected_interface_type.is_set
	|| source_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_address.operation)
	|| is_set(name.operation)
	|| is_set(protected_interface_type.operation)
	|| is_set(source_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "signalled-name";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_address.is_set || is_set(mp_address.operation)) leaf_name_data.push_back(mp_address.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());
    if (protected_interface_type.is_set || is_set(protected_interface_type.operation)) leaf_name_data.push_back(protected_interface_type.get_name_leafdata());
    if (source_type.is_set || is_set(source_type.operation)) leaf_name_data.push_back(source_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-address")
    {
        mp_address = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
    if(value_path == "protected-interface-type")
    {
        protected_interface_type = value;
    }
    if(value_path == "source-type")
    {
        source_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::AutoBackupLogging()
    :
    	bandwidth_change_message{YType::empty, "bandwidth-change-message"},
	 reoptimize_attempts_message{YType::empty, "reoptimize-attempts-message"},
	 reoptimized_message{YType::empty, "reoptimized-message"},
	 state_message{YType::empty, "state-message"}
{
    yang_name = "auto-backup-logging"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::~AutoBackupLogging()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::has_data() const
{
    return bandwidth_change_message.is_set
	|| reoptimize_attempts_message.is_set
	|| reoptimized_message.is_set
	|| state_message.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_change_message.operation)
	|| is_set(reoptimize_attempts_message.operation)
	|| is_set(reoptimized_message.operation)
	|| is_set(state_message.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-backup-logging";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_change_message.is_set || is_set(bandwidth_change_message.operation)) leaf_name_data.push_back(bandwidth_change_message.get_name_leafdata());
    if (reoptimize_attempts_message.is_set || is_set(reoptimize_attempts_message.operation)) leaf_name_data.push_back(reoptimize_attempts_message.get_name_leafdata());
    if (reoptimized_message.is_set || is_set(reoptimized_message.operation)) leaf_name_data.push_back(reoptimized_message.get_name_leafdata());
    if (state_message.is_set || is_set(state_message.operation)) leaf_name_data.push_back(state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-change-message")
    {
        bandwidth_change_message = value;
    }
    if(value_path == "reoptimize-attempts-message")
    {
        reoptimize_attempts_message = value;
    }
    if(value_path == "reoptimized-message")
    {
        reoptimized_message = value;
    }
    if(value_path == "state-message")
    {
        state_message = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::Priority()
    :
    	hold_priority{YType::uint32, "hold-priority"},
	 setup_priority{YType::uint32, "setup-priority"}
{
    yang_name = "priority"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::~Priority()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::has_data() const
{
    return hold_priority.is_set
	|| setup_priority.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::has_operation() const
{
    return is_set(operation)
	|| is_set(hold_priority.operation)
	|| is_set(setup_priority.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "priority";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hold_priority.is_set || is_set(hold_priority.operation)) leaf_name_data.push_back(hold_priority.get_name_leafdata());
    if (setup_priority.is_set || is_set(setup_priority.operation)) leaf_name_data.push_back(setup_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hold-priority")
    {
        hold_priority = value;
    }
    if(value_path == "setup-priority")
    {
        setup_priority = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::AffinityMask()
    :
    	affinity{YType::str, "affinity"},
	 mask{YType::str, "mask"}
{
    yang_name = "affinity-mask"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::~AffinityMask()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::has_data() const
{
    return affinity.is_set
	|| mask.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity.operation)
	|| is_set(mask.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mask";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity.is_set || is_set(affinity.operation)) leaf_name_data.push_back(affinity.get_name_leafdata());
    if (mask.is_set || is_set(mask.operation)) leaf_name_data.push_back(mask.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity")
    {
        affinity = value;
    }
    if(value_path == "mask")
    {
        mask = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::PathSelection()
    :
    	enable{YType::empty, "enable"}
{
    yang_name = "path-selection"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::has_data() const
{
    return enable.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::PolicyClasses()
    :
    	policy_class{YType::uint32, "policy-class"}
{
    yang_name = "policy-classes"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::~PolicyClasses()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::has_data() const
{
    for (auto const & leaf : policy_class.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::has_operation() const
{
    for (auto const & leaf : policy_class.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(policy_class.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-classes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto policy_class_name_datas = policy_class.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), policy_class_name_datas.begin(), policy_class_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "policy-class")
    {
        policy_class.append(value);
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::NewStyleAffinityAffinityType()
    :
    	affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::~NewStyleAffinityAffinityType()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_data() const
{
    return affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::NewStyleAffinityAffinityTypeAffinity1()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::~NewStyleAffinityAffinityTypeAffinity1()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_data() const
{
    return affinity1.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::NewStyleAffinityAffinityTypeAffinity1Affinity2()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::~NewStyleAffinityAffinityTypeAffinity1Affinity2()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity10{YType::str, "affinity10"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_data() const
{
    return affinity1.is_set
	|| affinity10.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity10.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity10='" <<affinity10.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity10.is_set || is_set(affinity10.operation)) leaf_name_data.push_back(affinity10.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity10")
    {
        affinity10 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypes()
{
    yang_name = "new-style-affinity-affinity-types"; yang_parent_name = "auto-backup-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::~NewStyleAffinityAffinityTypes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::has_data() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::has_operation() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-types";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type")
    {
        for(auto const & c : new_style_affinity_affinity_type)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType>();
        c->parent = this;
        new_style_affinity_affinity_type.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::get_children()
{
    for (auto const & c : new_style_affinity_affinity_type)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 enable{YType::empty, "enable"},
	 record_route{YType::empty, "record-route"}
    	,
    affinity_mask(nullptr) // presence node
	,auto_backup_logging(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging>())
	,new_style_affinity_affinity_types(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes>())
	,path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection>())
	,policy_classes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses>())
	,priority(nullptr) // presence node
	,signalled_name(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName>())
{
    auto_backup_logging->parent = this;
    children["auto-backup-logging"] = auto_backup_logging.get();

    new_style_affinity_affinity_types->parent = this;
    children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();

    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    policy_classes->parent = this;
    children["policy-classes"] = policy_classes.get();

    signalled_name->parent = this;
    children["signalled-name"] = signalled_name.get();

    yang_name = "auto-backup-attribute"; yang_parent_name = "auto-backup-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::~AutoBackupAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| enable.is_set
	|| record_route.is_set
	|| (affinity_mask !=  nullptr && affinity_mask->has_data())
	|| (auto_backup_logging !=  nullptr && auto_backup_logging->has_data())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_data())
	|| (path_selection !=  nullptr && path_selection->has_data())
	|| (policy_classes !=  nullptr && policy_classes->has_data())
	|| (priority !=  nullptr && priority->has_data())
	|| (signalled_name !=  nullptr && signalled_name->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(enable.operation)
	|| is_set(record_route.operation)
	|| (affinity_mask !=  nullptr && affinity_mask->has_operation())
	|| (auto_backup_logging !=  nullptr && auto_backup_logging->has_operation())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_operation())
	|| (path_selection !=  nullptr && path_selection->has_operation())
	|| (policy_classes !=  nullptr && policy_classes->has_operation())
	|| (priority !=  nullptr && priority->has_operation())
	|| (signalled_name !=  nullptr && signalled_name->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-backup-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/auto-backup-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (record_route.is_set || is_set(record_route.operation)) leaf_name_data.push_back(record_route.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mask")
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
        else
        {
            affinity_mask = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AffinityMask>();
            affinity_mask->parent = this;
            children["affinity-mask"] = affinity_mask.get();
        }
        return children.at("affinity-mask");
    }

    if(child_yang_name == "auto-backup-logging")
    {
        if(auto_backup_logging != nullptr)
        {
            children["auto-backup-logging"] = auto_backup_logging.get();
        }
        else
        {
            auto_backup_logging = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::AutoBackupLogging>();
            auto_backup_logging->parent = this;
            children["auto-backup-logging"] = auto_backup_logging.get();
        }
        return children.at("auto-backup-logging");
    }

    if(child_yang_name == "new-style-affinity-affinity-types")
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        else
        {
            new_style_affinity_affinity_types = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::NewStyleAffinityAffinityTypes>();
            new_style_affinity_affinity_types->parent = this;
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        return children.at("new-style-affinity-affinity-types");
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    if(child_yang_name == "policy-classes")
    {
        if(policy_classes != nullptr)
        {
            children["policy-classes"] = policy_classes.get();
        }
        else
        {
            policy_classes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::PolicyClasses>();
            policy_classes->parent = this;
            children["policy-classes"] = policy_classes.get();
        }
        return children.at("policy-classes");
    }

    if(child_yang_name == "priority")
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
        else
        {
            priority = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::Priority>();
            priority->parent = this;
            children["priority"] = priority.get();
        }
        return children.at("priority");
    }

    if(child_yang_name == "signalled-name")
    {
        if(signalled_name != nullptr)
        {
            children["signalled-name"] = signalled_name.get();
        }
        else
        {
            signalled_name = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::SignalledName>();
            signalled_name->parent = this;
            children["signalled-name"] = signalled_name.get();
        }
        return children.at("signalled-name");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::get_children()
{
    if(children.find("affinity-mask") == children.end())
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
    }

    if(children.find("auto-backup-logging") == children.end())
    {
        if(auto_backup_logging != nullptr)
        {
            children["auto-backup-logging"] = auto_backup_logging.get();
        }
    }

    if(children.find("new-style-affinity-affinity-types") == children.end())
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
    }

    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    if(children.find("policy-classes") == children.end())
    {
        if(policy_classes != nullptr)
        {
            children["policy-classes"] = policy_classes.get();
        }
    }

    if(children.find("priority") == children.end())
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
    }

    if(children.find("signalled-name") == children.end())
    {
        if(signalled_name != nullptr)
        {
            children["signalled-name"] = signalled_name.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "record-route")
    {
        record_route = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttributes()
{
    yang_name = "auto-backup-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::~AutoBackupAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::has_data() const
{
    for (std::size_t index=0; index<auto_backup_attribute.size(); index++)
    {
        if(auto_backup_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::has_operation() const
{
    for (std::size_t index=0; index<auto_backup_attribute.size(); index++)
    {
        if(auto_backup_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-backup-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "auto-backup-attribute")
    {
        for(auto const & c : auto_backup_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::AutoBackupAttribute>();
        c->parent = this;
        auto_backup_attribute.push_back(std::move(c));
        children[segment_path] = auto_backup_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::get_children()
{
    for (auto const & c : auto_backup_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::ScheduleDuration()
    :
    	hour{YType::uint32, "hour"},
	 minutes{YType::uint32, "minutes"}
{
    yang_name = "schedule-duration"; yang_parent_name = "revert-schedule-name";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::~ScheduleDuration()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::has_data() const
{
    return hour.is_set
	|| minutes.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::has_operation() const
{
    return is_set(operation)
	|| is_set(hour.operation)
	|| is_set(minutes.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "schedule-duration";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hour.is_set || is_set(hour.operation)) leaf_name_data.push_back(hour.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hour")
    {
        hour = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::ScheduleDate()
    :
    	day{YType::uint32, "day"},
	 hour{YType::uint32, "hour"},
	 minutes{YType::uint32, "minutes"},
	 month{YType::uint32, "month"},
	 year{YType::uint32, "year"}
{
    yang_name = "schedule-date"; yang_parent_name = "revert-schedule-name";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::~ScheduleDate()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::has_data() const
{
    return day.is_set
	|| hour.is_set
	|| minutes.is_set
	|| month.is_set
	|| year.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::has_operation() const
{
    return is_set(operation)
	|| is_set(day.operation)
	|| is_set(hour.operation)
	|| is_set(minutes.operation)
	|| is_set(month.operation)
	|| is_set(year.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "schedule-date";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (day.is_set || is_set(day.operation)) leaf_name_data.push_back(day.get_name_leafdata());
    if (hour.is_set || is_set(hour.operation)) leaf_name_data.push_back(hour.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (month.is_set || is_set(month.operation)) leaf_name_data.push_back(month.get_name_leafdata());
    if (year.is_set || is_set(year.operation)) leaf_name_data.push_back(year.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "day")
    {
        day = value;
    }
    if(value_path == "hour")
    {
        hour = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "month")
    {
        month = value;
    }
    if(value_path == "year")
    {
        year = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::RevertScheduleName()
    :
    	schedule_name{YType::str, "schedule-name"},
	 revert_schedule_frequency{YType::uint32, "revert-schedule-frequency"},
	 revert_schedule_max_tries{YType::uint32, "revert-schedule-max-tries"},
	 sch_name_enable{YType::empty, "sch-name-enable"}
    	,
    schedule_date(nullptr) // presence node
	,schedule_duration(nullptr) // presence node
{
    yang_name = "revert-schedule-name"; yang_parent_name = "revert-schedule-names";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::~RevertScheduleName()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::has_data() const
{
    return schedule_name.is_set
	|| revert_schedule_frequency.is_set
	|| revert_schedule_max_tries.is_set
	|| sch_name_enable.is_set
	|| (schedule_date !=  nullptr && schedule_date->has_data())
	|| (schedule_duration !=  nullptr && schedule_duration->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::has_operation() const
{
    return is_set(operation)
	|| is_set(schedule_name.operation)
	|| is_set(revert_schedule_frequency.operation)
	|| is_set(revert_schedule_max_tries.operation)
	|| is_set(sch_name_enable.operation)
	|| (schedule_date !=  nullptr && schedule_date->has_operation())
	|| (schedule_duration !=  nullptr && schedule_duration->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "revert-schedule-name" <<"[schedule-name='" <<schedule_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (schedule_name.is_set || is_set(schedule_name.operation)) leaf_name_data.push_back(schedule_name.get_name_leafdata());
    if (revert_schedule_frequency.is_set || is_set(revert_schedule_frequency.operation)) leaf_name_data.push_back(revert_schedule_frequency.get_name_leafdata());
    if (revert_schedule_max_tries.is_set || is_set(revert_schedule_max_tries.operation)) leaf_name_data.push_back(revert_schedule_max_tries.get_name_leafdata());
    if (sch_name_enable.is_set || is_set(sch_name_enable.operation)) leaf_name_data.push_back(sch_name_enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "schedule-date")
    {
        if(schedule_date != nullptr)
        {
            children["schedule-date"] = schedule_date.get();
        }
        else
        {
            schedule_date = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDate>();
            schedule_date->parent = this;
            children["schedule-date"] = schedule_date.get();
        }
        return children.at("schedule-date");
    }

    if(child_yang_name == "schedule-duration")
    {
        if(schedule_duration != nullptr)
        {
            children["schedule-duration"] = schedule_duration.get();
        }
        else
        {
            schedule_duration = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::ScheduleDuration>();
            schedule_duration->parent = this;
            children["schedule-duration"] = schedule_duration.get();
        }
        return children.at("schedule-duration");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::get_children()
{
    if(children.find("schedule-date") == children.end())
    {
        if(schedule_date != nullptr)
        {
            children["schedule-date"] = schedule_date.get();
        }
    }

    if(children.find("schedule-duration") == children.end())
    {
        if(schedule_duration != nullptr)
        {
            children["schedule-duration"] = schedule_duration.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "schedule-name")
    {
        schedule_name = value;
    }
    if(value_path == "revert-schedule-frequency")
    {
        revert_schedule_frequency = value;
    }
    if(value_path == "revert-schedule-max-tries")
    {
        revert_schedule_max_tries = value;
    }
    if(value_path == "sch-name-enable")
    {
        sch_name_enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleNames()
{
    yang_name = "revert-schedule-names"; yang_parent_name = "otn-pp-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::~RevertScheduleNames()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::has_data() const
{
    for (std::size_t index=0; index<revert_schedule_name.size(); index++)
    {
        if(revert_schedule_name[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::has_operation() const
{
    for (std::size_t index=0; index<revert_schedule_name.size(); index++)
    {
        if(revert_schedule_name[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "revert-schedule-names";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "revert-schedule-name")
    {
        for(auto const & c : revert_schedule_name)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::RevertScheduleName>();
        c->parent = this;
        revert_schedule_name.push_back(std::move(c));
        children[segment_path] = revert_schedule_name.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::get_children()
{
    for (auto const & c : revert_schedule_name)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::SubNetworkConnectionMode()
    :
    	connection_mode{YType::enumeration, "connection-mode"},
	 connection_monitoring_mode{YType::uint32, "connection-monitoring-mode"}
{
    yang_name = "sub-network-connection-mode"; yang_parent_name = "otn-pp-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::~SubNetworkConnectionMode()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::has_data() const
{
    return connection_mode.is_set
	|| connection_monitoring_mode.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::has_operation() const
{
    return is_set(operation)
	|| is_set(connection_mode.operation)
	|| is_set(connection_monitoring_mode.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "sub-network-connection-mode";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (connection_mode.is_set || is_set(connection_mode.operation)) leaf_name_data.push_back(connection_mode.get_name_leafdata());
    if (connection_monitoring_mode.is_set || is_set(connection_monitoring_mode.operation)) leaf_name_data.push_back(connection_monitoring_mode.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "connection-mode")
    {
        connection_mode = value;
    }
    if(value_path == "connection-monitoring-mode")
    {
        connection_monitoring_mode = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::Timers()
    :
    	aps_hold_off{YType::uint32, "aps-hold-off"},
	 aps_wait_to_restore{YType::uint32, "aps-wait-to-restore"}
{
    yang_name = "timers"; yang_parent_name = "otn-pp-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::~Timers()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::has_data() const
{
    return aps_hold_off.is_set
	|| aps_wait_to_restore.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::has_operation() const
{
    return is_set(operation)
	|| is_set(aps_hold_off.operation)
	|| is_set(aps_wait_to_restore.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timers";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (aps_hold_off.is_set || is_set(aps_hold_off.operation)) leaf_name_data.push_back(aps_hold_off.get_name_leafdata());
    if (aps_wait_to_restore.is_set || is_set(aps_wait_to_restore.operation)) leaf_name_data.push_back(aps_wait_to_restore.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "aps-hold-off")
    {
        aps_hold_off = value;
    }
    if(value_path == "aps-wait-to-restore")
    {
        aps_wait_to_restore = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::PathSelection()
    :
    	enable{YType::empty, "enable"}
{
    yang_name = "path-selection"; yang_parent_name = "otn-pp-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::has_data() const
{
    return enable.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::OtnPpAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 aps_protection_mode{YType::enumeration, "aps-protection-mode"},
	 aps_protection_type{YType::enumeration, "aps-protection-type"},
	 aps_restoration_style{YType::enumeration, "aps-restoration-style"},
	 enable{YType::empty, "enable"}
    	,
    path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection>())
	,revert_schedule_names(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames>())
	,sub_network_connection_mode(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode>())
	,timers(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers>())
{
    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    revert_schedule_names->parent = this;
    children["revert-schedule-names"] = revert_schedule_names.get();

    sub_network_connection_mode->parent = this;
    children["sub-network-connection-mode"] = sub_network_connection_mode.get();

    timers->parent = this;
    children["timers"] = timers.get();

    yang_name = "otn-pp-attribute"; yang_parent_name = "otn-pp-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::~OtnPpAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| aps_protection_mode.is_set
	|| aps_protection_type.is_set
	|| aps_restoration_style.is_set
	|| enable.is_set
	|| (path_selection !=  nullptr && path_selection->has_data())
	|| (revert_schedule_names !=  nullptr && revert_schedule_names->has_data())
	|| (sub_network_connection_mode !=  nullptr && sub_network_connection_mode->has_data())
	|| (timers !=  nullptr && timers->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(aps_protection_mode.operation)
	|| is_set(aps_protection_type.operation)
	|| is_set(aps_restoration_style.operation)
	|| is_set(enable.operation)
	|| (path_selection !=  nullptr && path_selection->has_operation())
	|| (revert_schedule_names !=  nullptr && revert_schedule_names->has_operation())
	|| (sub_network_connection_mode !=  nullptr && sub_network_connection_mode->has_operation())
	|| (timers !=  nullptr && timers->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "otn-pp-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/otn-pp-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (aps_protection_mode.is_set || is_set(aps_protection_mode.operation)) leaf_name_data.push_back(aps_protection_mode.get_name_leafdata());
    if (aps_protection_type.is_set || is_set(aps_protection_type.operation)) leaf_name_data.push_back(aps_protection_type.get_name_leafdata());
    if (aps_restoration_style.is_set || is_set(aps_restoration_style.operation)) leaf_name_data.push_back(aps_restoration_style.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    if(child_yang_name == "revert-schedule-names")
    {
        if(revert_schedule_names != nullptr)
        {
            children["revert-schedule-names"] = revert_schedule_names.get();
        }
        else
        {
            revert_schedule_names = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::RevertScheduleNames>();
            revert_schedule_names->parent = this;
            children["revert-schedule-names"] = revert_schedule_names.get();
        }
        return children.at("revert-schedule-names");
    }

    if(child_yang_name == "sub-network-connection-mode")
    {
        if(sub_network_connection_mode != nullptr)
        {
            children["sub-network-connection-mode"] = sub_network_connection_mode.get();
        }
        else
        {
            sub_network_connection_mode = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::SubNetworkConnectionMode>();
            sub_network_connection_mode->parent = this;
            children["sub-network-connection-mode"] = sub_network_connection_mode.get();
        }
        return children.at("sub-network-connection-mode");
    }

    if(child_yang_name == "timers")
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
        else
        {
            timers = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::Timers>();
            timers->parent = this;
            children["timers"] = timers.get();
        }
        return children.at("timers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::get_children()
{
    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    if(children.find("revert-schedule-names") == children.end())
    {
        if(revert_schedule_names != nullptr)
        {
            children["revert-schedule-names"] = revert_schedule_names.get();
        }
    }

    if(children.find("sub-network-connection-mode") == children.end())
    {
        if(sub_network_connection_mode != nullptr)
        {
            children["sub-network-connection-mode"] = sub_network_connection_mode.get();
        }
    }

    if(children.find("timers") == children.end())
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "aps-protection-mode")
    {
        aps_protection_mode = value;
    }
    if(value_path == "aps-protection-type")
    {
        aps_protection_type = value;
    }
    if(value_path == "aps-restoration-style")
    {
        aps_restoration_style = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttributes()
{
    yang_name = "otn-pp-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::~OtnPpAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::has_data() const
{
    for (std::size_t index=0; index<otn_pp_attribute.size(); index++)
    {
        if(otn_pp_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::has_operation() const
{
    for (std::size_t index=0; index<otn_pp_attribute.size(); index++)
    {
        if(otn_pp_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "otn-pp-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "otn-pp-attribute")
    {
        for(auto const & c : otn_pp_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::OtnPpAttribute>();
        c->parent = this;
        otn_pp_attribute.push_back(std::move(c));
        children[segment_path] = otn_pp_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::get_children()
{
    for (auto const & c : otn_pp_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::AutoMeshLogging()
    :
    	bandwidth_change_message{YType::empty, "bandwidth-change-message"},
	 insufficient_bw_message{YType::empty, "insufficient-bw-message"},
	 pcalc_failure_message{YType::empty, "pcalc-failure-message"},
	 reoptimize_attempts_message{YType::empty, "reoptimize-attempts-message"},
	 reoptimized_message{YType::empty, "reoptimized-message"},
	 reroute_messsage{YType::empty, "reroute-messsage"},
	 state_message{YType::empty, "state-message"}
{
    yang_name = "auto-mesh-logging"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::~AutoMeshLogging()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::has_data() const
{
    return bandwidth_change_message.is_set
	|| insufficient_bw_message.is_set
	|| pcalc_failure_message.is_set
	|| reoptimize_attempts_message.is_set
	|| reoptimized_message.is_set
	|| reroute_messsage.is_set
	|| state_message.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_change_message.operation)
	|| is_set(insufficient_bw_message.operation)
	|| is_set(pcalc_failure_message.operation)
	|| is_set(reoptimize_attempts_message.operation)
	|| is_set(reoptimized_message.operation)
	|| is_set(reroute_messsage.operation)
	|| is_set(state_message.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-mesh-logging";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_change_message.is_set || is_set(bandwidth_change_message.operation)) leaf_name_data.push_back(bandwidth_change_message.get_name_leafdata());
    if (insufficient_bw_message.is_set || is_set(insufficient_bw_message.operation)) leaf_name_data.push_back(insufficient_bw_message.get_name_leafdata());
    if (pcalc_failure_message.is_set || is_set(pcalc_failure_message.operation)) leaf_name_data.push_back(pcalc_failure_message.get_name_leafdata());
    if (reoptimize_attempts_message.is_set || is_set(reoptimize_attempts_message.operation)) leaf_name_data.push_back(reoptimize_attempts_message.get_name_leafdata());
    if (reoptimized_message.is_set || is_set(reoptimized_message.operation)) leaf_name_data.push_back(reoptimized_message.get_name_leafdata());
    if (reroute_messsage.is_set || is_set(reroute_messsage.operation)) leaf_name_data.push_back(reroute_messsage.get_name_leafdata());
    if (state_message.is_set || is_set(state_message.operation)) leaf_name_data.push_back(state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-change-message")
    {
        bandwidth_change_message = value;
    }
    if(value_path == "insufficient-bw-message")
    {
        insufficient_bw_message = value;
    }
    if(value_path == "pcalc-failure-message")
    {
        pcalc_failure_message = value;
    }
    if(value_path == "reoptimize-attempts-message")
    {
        reoptimize_attempts_message = value;
    }
    if(value_path == "reoptimized-message")
    {
        reoptimized_message = value;
    }
    if(value_path == "reroute-messsage")
    {
        reroute_messsage = value;
    }
    if(value_path == "state-message")
    {
        state_message = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::Priority()
    :
    	hold_priority{YType::uint32, "hold-priority"},
	 setup_priority{YType::uint32, "setup-priority"}
{
    yang_name = "priority"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::~Priority()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::has_data() const
{
    return hold_priority.is_set
	|| setup_priority.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::has_operation() const
{
    return is_set(operation)
	|| is_set(hold_priority.operation)
	|| is_set(setup_priority.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "priority";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hold_priority.is_set || is_set(hold_priority.operation)) leaf_name_data.push_back(hold_priority.get_name_leafdata());
    if (setup_priority.is_set || is_set(setup_priority.operation)) leaf_name_data.push_back(setup_priority.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hold-priority")
    {
        hold_priority = value;
    }
    if(value_path == "setup-priority")
    {
        setup_priority = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::AffinityMask()
    :
    	affinity{YType::str, "affinity"},
	 mask{YType::str, "mask"}
{
    yang_name = "affinity-mask"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::~AffinityMask()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::has_data() const
{
    return affinity.is_set
	|| mask.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity.operation)
	|| is_set(mask.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mask";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity.is_set || is_set(affinity.operation)) leaf_name_data.push_back(affinity.get_name_leafdata());
    if (mask.is_set || is_set(mask.operation)) leaf_name_data.push_back(mask.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity")
    {
        affinity = value;
    }
    if(value_path == "mask")
    {
        mask = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::Bandwidth()
    :
    	bandwidth{YType::uint32, "bandwidth"},
	 class_or_pool_type{YType::uint32, "class-or-pool-type"},
	 dste_type{YType::enumeration, "dste-type"}
{
    yang_name = "bandwidth"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::~Bandwidth()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::has_data() const
{
    return bandwidth.is_set
	|| class_or_pool_type.is_set
	|| dste_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth.operation)
	|| is_set(class_or_pool_type.operation)
	|| is_set(dste_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bandwidth";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth.is_set || is_set(bandwidth.operation)) leaf_name_data.push_back(bandwidth.get_name_leafdata());
    if (class_or_pool_type.is_set || is_set(class_or_pool_type.operation)) leaf_name_data.push_back(class_or_pool_type.get_name_leafdata());
    if (dste_type.is_set || is_set(dste_type.operation)) leaf_name_data.push_back(dste_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth")
    {
        bandwidth = value;
    }
    if(value_path == "class-or-pool-type")
    {
        class_or_pool_type = value;
    }
    if(value_path == "dste-type")
    {
        dste_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::PathSelection()
    :
    	enable{YType::empty, "enable"}
{
    yang_name = "path-selection"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::has_data() const
{
    return enable.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::PolicyClasses()
    :
    	policy_class{YType::uint32, "policy-class"}
{
    yang_name = "policy-classes"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::~PolicyClasses()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::has_data() const
{
    for (auto const & leaf : policy_class.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::has_operation() const
{
    for (auto const & leaf : policy_class.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(policy_class.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "policy-classes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto policy_class_name_datas = policy_class.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), policy_class_name_datas.begin(), policy_class_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "policy-class")
    {
        policy_class.append(value);
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::NewStyleAffinityAffinityType()
    :
    	affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::~NewStyleAffinityAffinityType()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_data() const
{
    return affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::NewStyleAffinityAffinityTypeAffinity1()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::~NewStyleAffinityAffinityTypeAffinity1()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_data() const
{
    return affinity1.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::NewStyleAffinityAffinityTypeAffinity1Affinity2()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::~NewStyleAffinityAffinityTypeAffinity1Affinity2()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_data() const
{
    return affinity1.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
    :
    	affinity1{YType::str, "affinity1"},
	 affinity10{YType::str, "affinity10"},
	 affinity2{YType::str, "affinity2"},
	 affinity3{YType::str, "affinity3"},
	 affinity4{YType::str, "affinity4"},
	 affinity5{YType::str, "affinity5"},
	 affinity6{YType::str, "affinity6"},
	 affinity7{YType::str, "affinity7"},
	 affinity8{YType::str, "affinity8"},
	 affinity9{YType::str, "affinity9"},
	 affinity_type{YType::enumeration, "affinity-type"}
{
    yang_name = "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10"; yang_parent_name = "new-style-affinity-affinity-types";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::~NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_data() const
{
    return affinity1.is_set
	|| affinity10.is_set
	|| affinity2.is_set
	|| affinity3.is_set
	|| affinity4.is_set
	|| affinity5.is_set
	|| affinity6.is_set
	|| affinity7.is_set
	|| affinity8.is_set
	|| affinity9.is_set
	|| affinity_type.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity1.operation)
	|| is_set(affinity10.operation)
	|| is_set(affinity2.operation)
	|| is_set(affinity3.operation)
	|| is_set(affinity4.operation)
	|| is_set(affinity5.operation)
	|| is_set(affinity6.operation)
	|| is_set(affinity7.operation)
	|| is_set(affinity8.operation)
	|| is_set(affinity9.operation)
	|| is_set(affinity_type.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10" <<"[affinity1='" <<affinity1.get() <<"']" <<"[affinity10='" <<affinity10.get() <<"']" <<"[affinity2='" <<affinity2.get() <<"']" <<"[affinity3='" <<affinity3.get() <<"']" <<"[affinity4='" <<affinity4.get() <<"']" <<"[affinity5='" <<affinity5.get() <<"']" <<"[affinity6='" <<affinity6.get() <<"']" <<"[affinity7='" <<affinity7.get() <<"']" <<"[affinity8='" <<affinity8.get() <<"']" <<"[affinity9='" <<affinity9.get() <<"']" <<"[affinity-type='" <<affinity_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity1.is_set || is_set(affinity1.operation)) leaf_name_data.push_back(affinity1.get_name_leafdata());
    if (affinity10.is_set || is_set(affinity10.operation)) leaf_name_data.push_back(affinity10.get_name_leafdata());
    if (affinity2.is_set || is_set(affinity2.operation)) leaf_name_data.push_back(affinity2.get_name_leafdata());
    if (affinity3.is_set || is_set(affinity3.operation)) leaf_name_data.push_back(affinity3.get_name_leafdata());
    if (affinity4.is_set || is_set(affinity4.operation)) leaf_name_data.push_back(affinity4.get_name_leafdata());
    if (affinity5.is_set || is_set(affinity5.operation)) leaf_name_data.push_back(affinity5.get_name_leafdata());
    if (affinity6.is_set || is_set(affinity6.operation)) leaf_name_data.push_back(affinity6.get_name_leafdata());
    if (affinity7.is_set || is_set(affinity7.operation)) leaf_name_data.push_back(affinity7.get_name_leafdata());
    if (affinity8.is_set || is_set(affinity8.operation)) leaf_name_data.push_back(affinity8.get_name_leafdata());
    if (affinity9.is_set || is_set(affinity9.operation)) leaf_name_data.push_back(affinity9.get_name_leafdata());
    if (affinity_type.is_set || is_set(affinity_type.operation)) leaf_name_data.push_back(affinity_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity1")
    {
        affinity1 = value;
    }
    if(value_path == "affinity10")
    {
        affinity10 = value;
    }
    if(value_path == "affinity2")
    {
        affinity2 = value;
    }
    if(value_path == "affinity3")
    {
        affinity3 = value;
    }
    if(value_path == "affinity4")
    {
        affinity4 = value;
    }
    if(value_path == "affinity5")
    {
        affinity5 = value;
    }
    if(value_path == "affinity6")
    {
        affinity6 = value;
    }
    if(value_path == "affinity7")
    {
        affinity7 = value;
    }
    if(value_path == "affinity8")
    {
        affinity8 = value;
    }
    if(value_path == "affinity9")
    {
        affinity9 = value;
    }
    if(value_path == "affinity-type")
    {
        affinity_type = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypes()
{
    yang_name = "new-style-affinity-affinity-types"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::~NewStyleAffinityAffinityTypes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::has_data() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::has_operation() const
{
    for (std::size_t index=0; index<new_style_affinity_affinity_type.size(); index++)
    {
        if(new_style_affinity_affinity_type[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.size(); index++)
    {
        if(new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "new-style-affinity-affinity-types";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type")
    {
        for(auto const & c : new_style_affinity_affinity_type)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityType>();
        c->parent = this;
        new_style_affinity_affinity_type.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "new-style-affinity-affinity-type-affinity1-affinity2-affinity3-affinity4-affinity5-affinity6-affinity7-affinity8-affinity9-affinity10")
    {
        for(auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::NewStyleAffinityAffinityTypeAffinity1Affinity2Affinity3Affinity4Affinity5Affinity6Affinity7Affinity8Affinity9Affinity10>();
        c->parent = this;
        new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.push_back(std::move(c));
        children[segment_path] = new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::get_children()
{
    for (auto const & c : new_style_affinity_affinity_type)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : new_style_affinity_affinity_type_affinity1_affinity2_affinity3_affinity4_affinity5_affinity6_affinity7_affinity8_affinity9_affinity10)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::FastReroute()
    :
    	bandwidth_protection{YType::uint32, "bandwidth-protection"},
	 node_protection{YType::uint32, "node-protection"}
{
    yang_name = "fast-reroute"; yang_parent_name = "auto-mesh-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::~FastReroute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::has_data() const
{
    return bandwidth_protection.is_set
	|| node_protection.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_protection.operation)
	|| is_set(node_protection.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fast-reroute";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_protection.is_set || is_set(bandwidth_protection.operation)) leaf_name_data.push_back(bandwidth_protection.get_name_leafdata());
    if (node_protection.is_set || is_set(node_protection.operation)) leaf_name_data.push_back(node_protection.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-protection")
    {
        bandwidth_protection = value;
    }
    if(value_path == "node-protection")
    {
        node_protection = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 autoroute_announce{YType::empty, "autoroute-announce"},
	 collection_only{YType::empty, "collection-only"},
	 enable{YType::empty, "enable"},
	 forward_class{YType::uint32, "forward-class"},
	 interface_bandwidth{YType::uint32, "interface-bandwidth"},
	 load_share{YType::uint32, "load-share"},
	 record_route{YType::empty, "record-route"},
	 soft_preemption{YType::empty, "soft-preemption"}
    	,
    affinity_mask(nullptr) // presence node
	,auto_mesh_logging(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging>())
	,bandwidth(nullptr) // presence node
	,fast_reroute(nullptr) // presence node
	,new_style_affinity_affinity_types(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes>())
	,path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection>())
	,policy_classes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses>())
	,priority(nullptr) // presence node
{
    auto_mesh_logging->parent = this;
    children["auto-mesh-logging"] = auto_mesh_logging.get();

    new_style_affinity_affinity_types->parent = this;
    children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();

    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    policy_classes->parent = this;
    children["policy-classes"] = policy_classes.get();

    yang_name = "auto-mesh-attribute"; yang_parent_name = "auto-mesh-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::~AutoMeshAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| autoroute_announce.is_set
	|| collection_only.is_set
	|| enable.is_set
	|| forward_class.is_set
	|| interface_bandwidth.is_set
	|| load_share.is_set
	|| record_route.is_set
	|| soft_preemption.is_set
	|| (affinity_mask !=  nullptr && affinity_mask->has_data())
	|| (auto_mesh_logging !=  nullptr && auto_mesh_logging->has_data())
	|| (bandwidth !=  nullptr && bandwidth->has_data())
	|| (fast_reroute !=  nullptr && fast_reroute->has_data())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_data())
	|| (path_selection !=  nullptr && path_selection->has_data())
	|| (policy_classes !=  nullptr && policy_classes->has_data())
	|| (priority !=  nullptr && priority->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(autoroute_announce.operation)
	|| is_set(collection_only.operation)
	|| is_set(enable.operation)
	|| is_set(forward_class.operation)
	|| is_set(interface_bandwidth.operation)
	|| is_set(load_share.operation)
	|| is_set(record_route.operation)
	|| is_set(soft_preemption.operation)
	|| (affinity_mask !=  nullptr && affinity_mask->has_operation())
	|| (auto_mesh_logging !=  nullptr && auto_mesh_logging->has_operation())
	|| (bandwidth !=  nullptr && bandwidth->has_operation())
	|| (fast_reroute !=  nullptr && fast_reroute->has_operation())
	|| (new_style_affinity_affinity_types !=  nullptr && new_style_affinity_affinity_types->has_operation())
	|| (path_selection !=  nullptr && path_selection->has_operation())
	|| (policy_classes !=  nullptr && policy_classes->has_operation())
	|| (priority !=  nullptr && priority->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-mesh-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/auto-mesh-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (autoroute_announce.is_set || is_set(autoroute_announce.operation)) leaf_name_data.push_back(autoroute_announce.get_name_leafdata());
    if (collection_only.is_set || is_set(collection_only.operation)) leaf_name_data.push_back(collection_only.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (forward_class.is_set || is_set(forward_class.operation)) leaf_name_data.push_back(forward_class.get_name_leafdata());
    if (interface_bandwidth.is_set || is_set(interface_bandwidth.operation)) leaf_name_data.push_back(interface_bandwidth.get_name_leafdata());
    if (load_share.is_set || is_set(load_share.operation)) leaf_name_data.push_back(load_share.get_name_leafdata());
    if (record_route.is_set || is_set(record_route.operation)) leaf_name_data.push_back(record_route.get_name_leafdata());
    if (soft_preemption.is_set || is_set(soft_preemption.operation)) leaf_name_data.push_back(soft_preemption.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mask")
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
        else
        {
            affinity_mask = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AffinityMask>();
            affinity_mask->parent = this;
            children["affinity-mask"] = affinity_mask.get();
        }
        return children.at("affinity-mask");
    }

    if(child_yang_name == "auto-mesh-logging")
    {
        if(auto_mesh_logging != nullptr)
        {
            children["auto-mesh-logging"] = auto_mesh_logging.get();
        }
        else
        {
            auto_mesh_logging = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::AutoMeshLogging>();
            auto_mesh_logging->parent = this;
            children["auto-mesh-logging"] = auto_mesh_logging.get();
        }
        return children.at("auto-mesh-logging");
    }

    if(child_yang_name == "bandwidth")
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
        else
        {
            bandwidth = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Bandwidth>();
            bandwidth->parent = this;
            children["bandwidth"] = bandwidth.get();
        }
        return children.at("bandwidth");
    }

    if(child_yang_name == "fast-reroute")
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
        else
        {
            fast_reroute = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::FastReroute>();
            fast_reroute->parent = this;
            children["fast-reroute"] = fast_reroute.get();
        }
        return children.at("fast-reroute");
    }

    if(child_yang_name == "new-style-affinity-affinity-types")
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        else
        {
            new_style_affinity_affinity_types = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::NewStyleAffinityAffinityTypes>();
            new_style_affinity_affinity_types->parent = this;
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
        return children.at("new-style-affinity-affinity-types");
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    if(child_yang_name == "policy-classes")
    {
        if(policy_classes != nullptr)
        {
            children["policy-classes"] = policy_classes.get();
        }
        else
        {
            policy_classes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::PolicyClasses>();
            policy_classes->parent = this;
            children["policy-classes"] = policy_classes.get();
        }
        return children.at("policy-classes");
    }

    if(child_yang_name == "priority")
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
        else
        {
            priority = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::Priority>();
            priority->parent = this;
            children["priority"] = priority.get();
        }
        return children.at("priority");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::get_children()
{
    if(children.find("affinity-mask") == children.end())
    {
        if(affinity_mask != nullptr)
        {
            children["affinity-mask"] = affinity_mask.get();
        }
    }

    if(children.find("auto-mesh-logging") == children.end())
    {
        if(auto_mesh_logging != nullptr)
        {
            children["auto-mesh-logging"] = auto_mesh_logging.get();
        }
    }

    if(children.find("bandwidth") == children.end())
    {
        if(bandwidth != nullptr)
        {
            children["bandwidth"] = bandwidth.get();
        }
    }

    if(children.find("fast-reroute") == children.end())
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
    }

    if(children.find("new-style-affinity-affinity-types") == children.end())
    {
        if(new_style_affinity_affinity_types != nullptr)
        {
            children["new-style-affinity-affinity-types"] = new_style_affinity_affinity_types.get();
        }
    }

    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    if(children.find("policy-classes") == children.end())
    {
        if(policy_classes != nullptr)
        {
            children["policy-classes"] = policy_classes.get();
        }
    }

    if(children.find("priority") == children.end())
    {
        if(priority != nullptr)
        {
            children["priority"] = priority.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "autoroute-announce")
    {
        autoroute_announce = value;
    }
    if(value_path == "collection-only")
    {
        collection_only = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "forward-class")
    {
        forward_class = value;
    }
    if(value_path == "interface-bandwidth")
    {
        interface_bandwidth = value;
    }
    if(value_path == "load-share")
    {
        load_share = value;
    }
    if(value_path == "record-route")
    {
        record_route = value;
    }
    if(value_path == "soft-preemption")
    {
        soft_preemption = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttributes()
{
    yang_name = "auto-mesh-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::~AutoMeshAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::has_data() const
{
    for (std::size_t index=0; index<auto_mesh_attribute.size(); index++)
    {
        if(auto_mesh_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::has_operation() const
{
    for (std::size_t index=0; index<auto_mesh_attribute.size(); index++)
    {
        if(auto_mesh_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-mesh-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "auto-mesh-attribute")
    {
        for(auto const & c : auto_mesh_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::AutoMeshAttribute>();
        c->parent = this;
        auto_mesh_attribute.push_back(std::move(c));
        children[segment_path] = auto_mesh_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::get_children()
{
    for (auto const & c : auto_mesh_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::Srlg()
    :
    	srlg{YType::uint32, "srlg"},
	 conformance{YType::enumeration, "conformance"}
{
    yang_name = "srlg"; yang_parent_name = "srlgs";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::~Srlg()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::has_data() const
{
    return srlg.is_set
	|| conformance.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::has_operation() const
{
    return is_set(operation)
	|| is_set(srlg.operation)
	|| is_set(conformance.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srlg" <<"[srlg='" <<srlg.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srlg.is_set || is_set(srlg.operation)) leaf_name_data.push_back(srlg.get_name_leafdata());
    if (conformance.is_set || is_set(conformance.operation)) leaf_name_data.push_back(conformance.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srlg")
    {
        srlg = value;
    }
    if(value_path == "conformance")
    {
        conformance = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlgs()
{
    yang_name = "srlgs"; yang_parent_name = "path-diversity";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::~Srlgs()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::has_data() const
{
    for (std::size_t index=0; index<srlg.size(); index++)
    {
        if(srlg[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::has_operation() const
{
    for (std::size_t index=0; index<srlg.size(); index++)
    {
        if(srlg[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srlgs";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "srlg")
    {
        for(auto const & c : srlg)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::Srlg>();
        c->parent = this;
        srlg.push_back(std::move(c));
        children[segment_path] = srlg.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::get_children()
{
    for (auto const & c : srlg)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::Fec()
    :
    	destination{YType::str, "destination"},
	 extended_tunnel_id{YType::str, "extended-tunnel-id"},
	 lsp_id{YType::uint32, "lsp-id"},
	 source{YType::str, "source"},
	 tunnel_id{YType::uint32, "tunnel-id"},
	 conformance{YType::enumeration, "conformance"}
{
    yang_name = "fec"; yang_parent_name = "fecs";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::~Fec()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::has_data() const
{
    return destination.is_set
	|| extended_tunnel_id.is_set
	|| lsp_id.is_set
	|| source.is_set
	|| tunnel_id.is_set
	|| conformance.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::has_operation() const
{
    return is_set(operation)
	|| is_set(destination.operation)
	|| is_set(extended_tunnel_id.operation)
	|| is_set(lsp_id.operation)
	|| is_set(source.operation)
	|| is_set(tunnel_id.operation)
	|| is_set(conformance.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fec" <<"[destination='" <<destination.get() <<"']" <<"[extended-tunnel-id='" <<extended_tunnel_id.get() <<"']" <<"[lsp-id='" <<lsp_id.get() <<"']" <<"[source='" <<source.get() <<"']" <<"[tunnel-id='" <<tunnel_id.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination.is_set || is_set(destination.operation)) leaf_name_data.push_back(destination.get_name_leafdata());
    if (extended_tunnel_id.is_set || is_set(extended_tunnel_id.operation)) leaf_name_data.push_back(extended_tunnel_id.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (source.is_set || is_set(source.operation)) leaf_name_data.push_back(source.get_name_leafdata());
    if (tunnel_id.is_set || is_set(tunnel_id.operation)) leaf_name_data.push_back(tunnel_id.get_name_leafdata());
    if (conformance.is_set || is_set(conformance.operation)) leaf_name_data.push_back(conformance.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination")
    {
        destination = value;
    }
    if(value_path == "extended-tunnel-id")
    {
        extended_tunnel_id = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "source")
    {
        source = value;
    }
    if(value_path == "tunnel-id")
    {
        tunnel_id = value;
    }
    if(value_path == "conformance")
    {
        conformance = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fecs()
{
    yang_name = "fecs"; yang_parent_name = "lsp";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::~Fecs()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::has_data() const
{
    for (std::size_t index=0; index<fec.size(); index++)
    {
        if(fec[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::has_operation() const
{
    for (std::size_t index=0; index<fec.size(); index++)
    {
        if(fec[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fecs";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "fec")
    {
        for(auto const & c : fec)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::Fec>();
        c->parent = this;
        fec.push_back(std::move(c));
        children[segment_path] = fec.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::get_children()
{
    for (auto const & c : fec)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Lsp()
    :
    fecs(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs>())
{
    fecs->parent = this;
    children["fecs"] = fecs.get();

    yang_name = "lsp"; yang_parent_name = "path-diversity";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::~Lsp()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::has_data() const
{
    return (fecs !=  nullptr && fecs->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::has_operation() const
{
    return is_set(operation)
	|| (fecs !=  nullptr && fecs->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "fecs")
    {
        if(fecs != nullptr)
        {
            children["fecs"] = fecs.get();
        }
        else
        {
            fecs = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::Fecs>();
            fecs->parent = this;
            children["fecs"] = fecs.get();
        }
        return children.at("fecs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::get_children()
{
    if(children.find("fecs") == children.end())
    {
        if(fecs != nullptr)
        {
            children["fecs"] = fecs.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::PathDiversity()
    :
    lsp(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp>())
	,srlgs(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs>())
{
    lsp->parent = this;
    children["lsp"] = lsp.get();

    srlgs->parent = this;
    children["srlgs"] = srlgs.get();

    yang_name = "path-diversity"; yang_parent_name = "xro-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::~PathDiversity()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::has_data() const
{
    return (lsp !=  nullptr && lsp->has_data())
	|| (srlgs !=  nullptr && srlgs->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::has_operation() const
{
    return is_set(operation)
	|| (lsp !=  nullptr && lsp->has_operation())
	|| (srlgs !=  nullptr && srlgs->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-diversity";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp")
    {
        if(lsp != nullptr)
        {
            children["lsp"] = lsp.get();
        }
        else
        {
            lsp = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Lsp>();
            lsp->parent = this;
            children["lsp"] = lsp.get();
        }
        return children.at("lsp");
    }

    if(child_yang_name == "srlgs")
    {
        if(srlgs != nullptr)
        {
            children["srlgs"] = srlgs.get();
        }
        else
        {
            srlgs = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::Srlgs>();
            srlgs->parent = this;
            children["srlgs"] = srlgs.get();
        }
        return children.at("srlgs");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::get_children()
{
    if(children.find("lsp") == children.end())
    {
        if(lsp != nullptr)
        {
            children["lsp"] = lsp.get();
        }
    }

    if(children.find("srlgs") == children.end())
    {
        if(srlgs != nullptr)
        {
            children["srlgs"] = srlgs.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::PathSelection()
    :
    	enable{YType::empty, "enable"}
{
    yang_name = "path-selection"; yang_parent_name = "xro-attribute";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::has_data() const
{
    return enable.is_set;
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::XroAttribute()
    :
    	attribute_set_name{YType::str, "attribute-set-name"},
	 enable{YType::empty, "enable"}
    	,
    path_diversity(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity>())
	,path_selection(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection>())
{
    path_diversity->parent = this;
    children["path-diversity"] = path_diversity.get();

    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    yang_name = "xro-attribute"; yang_parent_name = "xro-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::~XroAttribute()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::has_data() const
{
    return attribute_set_name.is_set
	|| enable.is_set
	|| (path_diversity !=  nullptr && path_diversity->has_data())
	|| (path_selection !=  nullptr && path_selection->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set_name.operation)
	|| is_set(enable.operation)
	|| (path_diversity !=  nullptr && path_diversity->has_operation())
	|| (path_selection !=  nullptr && path_selection->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "xro-attribute" <<"[attribute-set-name='" <<attribute_set_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/xro-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set_name.is_set || is_set(attribute_set_name.operation)) leaf_name_data.push_back(attribute_set_name.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-diversity")
    {
        if(path_diversity != nullptr)
        {
            children["path-diversity"] = path_diversity.get();
        }
        else
        {
            path_diversity = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathDiversity>();
            path_diversity->parent = this;
            children["path-diversity"] = path_diversity.get();
        }
        return children.at("path-diversity");
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::get_children()
{
    if(children.find("path-diversity") == children.end())
    {
        if(path_diversity != nullptr)
        {
            children["path-diversity"] = path_diversity.get();
        }
    }

    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set-name")
    {
        attribute_set_name = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttributes()
{
    yang_name = "xro-attributes"; yang_parent_name = "attribute-set";
}

MplsTe::GlobalAttributes::AttributeSet::XroAttributes::~XroAttributes()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::has_data() const
{
    for (std::size_t index=0; index<xro_attribute.size(); index++)
    {
        if(xro_attribute[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AttributeSet::XroAttributes::has_operation() const
{
    for (std::size_t index=0; index<xro_attribute.size(); index++)
    {
        if(xro_attribute[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AttributeSet::XroAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "xro-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::XroAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/attribute-set/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::XroAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "xro-attribute")
    {
        for(auto const & c : xro_attribute)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes::XroAttribute>();
        c->parent = this;
        xro_attribute.push_back(std::move(c));
        children[segment_path] = xro_attribute.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::XroAttributes::get_children()
{
    for (auto const & c : xro_attribute)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::XroAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::AttributeSet::AttributeSet()
    :
    auto_backup_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes>())
	,auto_mesh_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes>())
	,otn_pp_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes>())
	,p2mpte_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes>())
	,p2p_te_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes>())
	,path_option_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes>())
	,xro_attributes(std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes>())
{
    auto_backup_attributes->parent = this;
    children["auto-backup-attributes"] = auto_backup_attributes.get();

    auto_mesh_attributes->parent = this;
    children["auto-mesh-attributes"] = auto_mesh_attributes.get();

    otn_pp_attributes->parent = this;
    children["otn-pp-attributes"] = otn_pp_attributes.get();

    p2mpte_attributes->parent = this;
    children["p2mpte-attributes"] = p2mpte_attributes.get();

    p2p_te_attributes->parent = this;
    children["p2p-te-attributes"] = p2p_te_attributes.get();

    path_option_attributes->parent = this;
    children["path-option-attributes"] = path_option_attributes.get();

    xro_attributes->parent = this;
    children["xro-attributes"] = xro_attributes.get();

    yang_name = "attribute-set"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::AttributeSet::~AttributeSet()
{
}

bool MplsTe::GlobalAttributes::AttributeSet::has_data() const
{
    return (auto_backup_attributes !=  nullptr && auto_backup_attributes->has_data())
	|| (auto_mesh_attributes !=  nullptr && auto_mesh_attributes->has_data())
	|| (otn_pp_attributes !=  nullptr && otn_pp_attributes->has_data())
	|| (p2mpte_attributes !=  nullptr && p2mpte_attributes->has_data())
	|| (p2p_te_attributes !=  nullptr && p2p_te_attributes->has_data())
	|| (path_option_attributes !=  nullptr && path_option_attributes->has_data())
	|| (xro_attributes !=  nullptr && xro_attributes->has_data());
}

bool MplsTe::GlobalAttributes::AttributeSet::has_operation() const
{
    return is_set(operation)
	|| (auto_backup_attributes !=  nullptr && auto_backup_attributes->has_operation())
	|| (auto_mesh_attributes !=  nullptr && auto_mesh_attributes->has_operation())
	|| (otn_pp_attributes !=  nullptr && otn_pp_attributes->has_operation())
	|| (p2mpte_attributes !=  nullptr && p2mpte_attributes->has_operation())
	|| (p2p_te_attributes !=  nullptr && p2p_te_attributes->has_operation())
	|| (path_option_attributes !=  nullptr && path_option_attributes->has_operation())
	|| (xro_attributes !=  nullptr && xro_attributes->has_operation());
}

std::string MplsTe::GlobalAttributes::AttributeSet::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "attribute-set";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AttributeSet::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AttributeSet::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "auto-backup-attributes")
    {
        if(auto_backup_attributes != nullptr)
        {
            children["auto-backup-attributes"] = auto_backup_attributes.get();
        }
        else
        {
            auto_backup_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoBackupAttributes>();
            auto_backup_attributes->parent = this;
            children["auto-backup-attributes"] = auto_backup_attributes.get();
        }
        return children.at("auto-backup-attributes");
    }

    if(child_yang_name == "auto-mesh-attributes")
    {
        if(auto_mesh_attributes != nullptr)
        {
            children["auto-mesh-attributes"] = auto_mesh_attributes.get();
        }
        else
        {
            auto_mesh_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::AutoMeshAttributes>();
            auto_mesh_attributes->parent = this;
            children["auto-mesh-attributes"] = auto_mesh_attributes.get();
        }
        return children.at("auto-mesh-attributes");
    }

    if(child_yang_name == "otn-pp-attributes")
    {
        if(otn_pp_attributes != nullptr)
        {
            children["otn-pp-attributes"] = otn_pp_attributes.get();
        }
        else
        {
            otn_pp_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::OtnPpAttributes>();
            otn_pp_attributes->parent = this;
            children["otn-pp-attributes"] = otn_pp_attributes.get();
        }
        return children.at("otn-pp-attributes");
    }

    if(child_yang_name == "p2mpte-attributes")
    {
        if(p2mpte_attributes != nullptr)
        {
            children["p2mpte-attributes"] = p2mpte_attributes.get();
        }
        else
        {
            p2mpte_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2MpteAttributes>();
            p2mpte_attributes->parent = this;
            children["p2mpte-attributes"] = p2mpte_attributes.get();
        }
        return children.at("p2mpte-attributes");
    }

    if(child_yang_name == "p2p-te-attributes")
    {
        if(p2p_te_attributes != nullptr)
        {
            children["p2p-te-attributes"] = p2p_te_attributes.get();
        }
        else
        {
            p2p_te_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::P2PTeAttributes>();
            p2p_te_attributes->parent = this;
            children["p2p-te-attributes"] = p2p_te_attributes.get();
        }
        return children.at("p2p-te-attributes");
    }

    if(child_yang_name == "path-option-attributes")
    {
        if(path_option_attributes != nullptr)
        {
            children["path-option-attributes"] = path_option_attributes.get();
        }
        else
        {
            path_option_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::PathOptionAttributes>();
            path_option_attributes->parent = this;
            children["path-option-attributes"] = path_option_attributes.get();
        }
        return children.at("path-option-attributes");
    }

    if(child_yang_name == "xro-attributes")
    {
        if(xro_attributes != nullptr)
        {
            children["xro-attributes"] = xro_attributes.get();
        }
        else
        {
            xro_attributes = std::make_unique<MplsTe::GlobalAttributes::AttributeSet::XroAttributes>();
            xro_attributes->parent = this;
            children["xro-attributes"] = xro_attributes.get();
        }
        return children.at("xro-attributes");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AttributeSet::get_children()
{
    if(children.find("auto-backup-attributes") == children.end())
    {
        if(auto_backup_attributes != nullptr)
        {
            children["auto-backup-attributes"] = auto_backup_attributes.get();
        }
    }

    if(children.find("auto-mesh-attributes") == children.end())
    {
        if(auto_mesh_attributes != nullptr)
        {
            children["auto-mesh-attributes"] = auto_mesh_attributes.get();
        }
    }

    if(children.find("otn-pp-attributes") == children.end())
    {
        if(otn_pp_attributes != nullptr)
        {
            children["otn-pp-attributes"] = otn_pp_attributes.get();
        }
    }

    if(children.find("p2mpte-attributes") == children.end())
    {
        if(p2mpte_attributes != nullptr)
        {
            children["p2mpte-attributes"] = p2mpte_attributes.get();
        }
    }

    if(children.find("p2p-te-attributes") == children.end())
    {
        if(p2p_te_attributes != nullptr)
        {
            children["p2p-te-attributes"] = p2p_te_attributes.get();
        }
    }

    if(children.find("path-option-attributes") == children.end())
    {
        if(path_option_attributes != nullptr)
        {
            children["path-option-attributes"] = path_option_attributes.get();
        }
    }

    if(children.find("xro-attributes") == children.end())
    {
        if(xro_attributes != nullptr)
        {
            children["xro-attributes"] = xro_attributes.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AttributeSet::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::BfdOverLsp::Tail::Tail()
    :
    	minimum_interval{YType::uint32, "minimum-interval"},
	 multiplier{YType::uint32, "multiplier"}
{
    yang_name = "tail"; yang_parent_name = "bfd-over-lsp";
}

MplsTe::GlobalAttributes::BfdOverLsp::Tail::~Tail()
{
}

bool MplsTe::GlobalAttributes::BfdOverLsp::Tail::has_data() const
{
    return minimum_interval.is_set
	|| multiplier.is_set;
}

bool MplsTe::GlobalAttributes::BfdOverLsp::Tail::has_operation() const
{
    return is_set(operation)
	|| is_set(minimum_interval.operation)
	|| is_set(multiplier.operation);
}

std::string MplsTe::GlobalAttributes::BfdOverLsp::Tail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tail";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::BfdOverLsp::Tail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/bfd-over-lsp/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (minimum_interval.is_set || is_set(minimum_interval.operation)) leaf_name_data.push_back(minimum_interval.get_name_leafdata());
    if (multiplier.is_set || is_set(multiplier.operation)) leaf_name_data.push_back(multiplier.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::BfdOverLsp::Tail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::BfdOverLsp::Tail::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::BfdOverLsp::Tail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "minimum-interval")
    {
        minimum_interval = value;
    }
    if(value_path == "multiplier")
    {
        multiplier = value;
    }
}

MplsTe::GlobalAttributes::BfdOverLsp::Head::Head()
    :
    	down_action{YType::enumeration, "down-action"},
	 reopt_timeout{YType::uint32, "reopt-timeout"}
{
    yang_name = "head"; yang_parent_name = "bfd-over-lsp";
}

MplsTe::GlobalAttributes::BfdOverLsp::Head::~Head()
{
}

bool MplsTe::GlobalAttributes::BfdOverLsp::Head::has_data() const
{
    return down_action.is_set
	|| reopt_timeout.is_set;
}

bool MplsTe::GlobalAttributes::BfdOverLsp::Head::has_operation() const
{
    return is_set(operation)
	|| is_set(down_action.operation)
	|| is_set(reopt_timeout.operation);
}

std::string MplsTe::GlobalAttributes::BfdOverLsp::Head::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "head";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::BfdOverLsp::Head::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/bfd-over-lsp/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_action.is_set || is_set(down_action.operation)) leaf_name_data.push_back(down_action.get_name_leafdata());
    if (reopt_timeout.is_set || is_set(reopt_timeout.operation)) leaf_name_data.push_back(reopt_timeout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::BfdOverLsp::Head::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::BfdOverLsp::Head::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::BfdOverLsp::Head::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-action")
    {
        down_action = value;
    }
    if(value_path == "reopt-timeout")
    {
        reopt_timeout = value;
    }
}

MplsTe::GlobalAttributes::BfdOverLsp::BfdOverLsp()
    :
    head(std::make_unique<MplsTe::GlobalAttributes::BfdOverLsp::Head>())
	,tail(std::make_unique<MplsTe::GlobalAttributes::BfdOverLsp::Tail>())
{
    head->parent = this;
    children["head"] = head.get();

    tail->parent = this;
    children["tail"] = tail.get();

    yang_name = "bfd-over-lsp"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::BfdOverLsp::~BfdOverLsp()
{
}

bool MplsTe::GlobalAttributes::BfdOverLsp::has_data() const
{
    return (head !=  nullptr && head->has_data())
	|| (tail !=  nullptr && tail->has_data());
}

bool MplsTe::GlobalAttributes::BfdOverLsp::has_operation() const
{
    return is_set(operation)
	|| (head !=  nullptr && head->has_operation())
	|| (tail !=  nullptr && tail->has_operation());
}

std::string MplsTe::GlobalAttributes::BfdOverLsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd-over-lsp";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::BfdOverLsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::BfdOverLsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "head")
    {
        if(head != nullptr)
        {
            children["head"] = head.get();
        }
        else
        {
            head = std::make_unique<MplsTe::GlobalAttributes::BfdOverLsp::Head>();
            head->parent = this;
            children["head"] = head.get();
        }
        return children.at("head");
    }

    if(child_yang_name == "tail")
    {
        if(tail != nullptr)
        {
            children["tail"] = tail.get();
        }
        else
        {
            tail = std::make_unique<MplsTe::GlobalAttributes::BfdOverLsp::Tail>();
            tail->parent = this;
            children["tail"] = tail.get();
        }
        return children.at("tail");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::BfdOverLsp::get_children()
{
    if(children.find("head") == children.end())
    {
        if(head != nullptr)
        {
            children["head"] = head.get();
        }
    }

    if(children.find("tail") == children.end())
    {
        if(tail != nullptr)
        {
            children["tail"] = tail.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::BfdOverLsp::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::StatefulTimers()
    :
    	redelegation_timeout{YType::uint32, "redelegation-timeout"},
	 state_timeout{YType::uint32, "state-timeout"}
{
    yang_name = "stateful-timers"; yang_parent_name = "pce-stateful";
}

MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::~StatefulTimers()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::has_data() const
{
    return redelegation_timeout.is_set
	|| state_timeout.is_set;
}

bool MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::has_operation() const
{
    return is_set(operation)
	|| is_set(redelegation_timeout.operation)
	|| is_set(state_timeout.operation);
}

std::string MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "stateful-timers";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/pce-stateful/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (redelegation_timeout.is_set || is_set(redelegation_timeout.operation)) leaf_name_data.push_back(redelegation_timeout.get_name_leafdata());
    if (state_timeout.is_set || is_set(state_timeout.operation)) leaf_name_data.push_back(state_timeout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "redelegation-timeout")
    {
        redelegation_timeout = value;
    }
    if(value_path == "state-timeout")
    {
        state_timeout = value;
    }
}

MplsTe::GlobalAttributes::PceAttributes::PceStateful::PceStateful()
    :
    	cisco_extension{YType::empty, "cisco-extension"},
	 delegation{YType::empty, "delegation"},
	 enable{YType::empty, "enable"},
	 fast_repair{YType::empty, "fast-repair"},
	 instantiation{YType::empty, "instantiation"},
	 report{YType::empty, "report"}
    	,
    stateful_timers(std::make_unique<MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers>())
{
    stateful_timers->parent = this;
    children["stateful-timers"] = stateful_timers.get();

    yang_name = "pce-stateful"; yang_parent_name = "pce-attributes";
}

MplsTe::GlobalAttributes::PceAttributes::PceStateful::~PceStateful()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::PceStateful::has_data() const
{
    return cisco_extension.is_set
	|| delegation.is_set
	|| enable.is_set
	|| fast_repair.is_set
	|| instantiation.is_set
	|| report.is_set
	|| (stateful_timers !=  nullptr && stateful_timers->has_data());
}

bool MplsTe::GlobalAttributes::PceAttributes::PceStateful::has_operation() const
{
    return is_set(operation)
	|| is_set(cisco_extension.operation)
	|| is_set(delegation.operation)
	|| is_set(enable.operation)
	|| is_set(fast_repair.operation)
	|| is_set(instantiation.operation)
	|| is_set(report.operation)
	|| (stateful_timers !=  nullptr && stateful_timers->has_operation());
}

std::string MplsTe::GlobalAttributes::PceAttributes::PceStateful::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pce-stateful";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::PceStateful::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cisco_extension.is_set || is_set(cisco_extension.operation)) leaf_name_data.push_back(cisco_extension.get_name_leafdata());
    if (delegation.is_set || is_set(delegation.operation)) leaf_name_data.push_back(delegation.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (fast_repair.is_set || is_set(fast_repair.operation)) leaf_name_data.push_back(fast_repair.get_name_leafdata());
    if (instantiation.is_set || is_set(instantiation.operation)) leaf_name_data.push_back(instantiation.get_name_leafdata());
    if (report.is_set || is_set(report.operation)) leaf_name_data.push_back(report.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::PceStateful::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "stateful-timers")
    {
        if(stateful_timers != nullptr)
        {
            children["stateful-timers"] = stateful_timers.get();
        }
        else
        {
            stateful_timers = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::PceStateful::StatefulTimers>();
            stateful_timers->parent = this;
            children["stateful-timers"] = stateful_timers.get();
        }
        return children.at("stateful-timers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::PceStateful::get_children()
{
    if(children.find("stateful-timers") == children.end())
    {
        if(stateful_timers != nullptr)
        {
            children["stateful-timers"] = stateful_timers.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::PceStateful::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cisco-extension")
    {
        cisco_extension = value;
    }
    if(value_path == "delegation")
    {
        delegation = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "fast-repair")
    {
        fast_repair = value;
    }
    if(value_path == "instantiation")
    {
        instantiation = value;
    }
    if(value_path == "report")
    {
        report = value;
    }
}

MplsTe::GlobalAttributes::PceAttributes::Timer::Timer()
{
    yang_name = "timer"; yang_parent_name = "pce-attributes";
}

MplsTe::GlobalAttributes::PceAttributes::Timer::~Timer()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::Timer::has_data() const
{
    return false;
}

bool MplsTe::GlobalAttributes::PceAttributes::Timer::has_operation() const
{
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::PceAttributes::Timer::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timer";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::Timer::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::Timer::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::Timer::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::Timer::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::Peer()
    :
    	pce_peer_address{YType::str, "pce-peer-address"},
	 enable{YType::empty, "enable"},
	 keychain{YType::str, "keychain"},
	 password{YType::str, "password"},
	 precedence{YType::uint32, "precedence"}
{
    yang_name = "peer"; yang_parent_name = "peers";
}

MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::~Peer()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::has_data() const
{
    return pce_peer_address.is_set
	|| enable.is_set
	|| keychain.is_set
	|| password.is_set
	|| precedence.is_set;
}

bool MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::has_operation() const
{
    return is_set(operation)
	|| is_set(pce_peer_address.operation)
	|| is_set(enable.operation)
	|| is_set(keychain.operation)
	|| is_set(password.operation)
	|| is_set(precedence.operation);
}

std::string MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "peer" <<"[pce-peer-address='" <<pce_peer_address.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/peers/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (pce_peer_address.is_set || is_set(pce_peer_address.operation)) leaf_name_data.push_back(pce_peer_address.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (keychain.is_set || is_set(keychain.operation)) leaf_name_data.push_back(keychain.get_name_leafdata());
    if (password.is_set || is_set(password.operation)) leaf_name_data.push_back(password.get_name_leafdata());
    if (precedence.is_set || is_set(precedence.operation)) leaf_name_data.push_back(precedence.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::Peers::Peer::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "pce-peer-address")
    {
        pce_peer_address = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "keychain")
    {
        keychain = value;
    }
    if(value_path == "password")
    {
        password = value;
    }
    if(value_path == "precedence")
    {
        precedence = value;
    }
}

MplsTe::GlobalAttributes::PceAttributes::Peers::Peers()
{
    yang_name = "peers"; yang_parent_name = "pce-attributes";
}

MplsTe::GlobalAttributes::PceAttributes::Peers::~Peers()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::Peers::has_data() const
{
    for (std::size_t index=0; index<peer.size(); index++)
    {
        if(peer[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::PceAttributes::Peers::has_operation() const
{
    for (std::size_t index=0; index<peer.size(); index++)
    {
        if(peer[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::PceAttributes::Peers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "peers";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::Peers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::Peers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "peer")
    {
        for(auto const & c : peer)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Peers::Peer>();
        c->parent = this;
        peer.push_back(std::move(c));
        children[segment_path] = peer.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::Peers::get_children()
{
    for (auto const & c : peer)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::Peers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PceAttributes::Logging::Events::Events()
    :
    	peer_status{YType::empty, "peer-status"}
{
    yang_name = "events"; yang_parent_name = "logging";
}

MplsTe::GlobalAttributes::PceAttributes::Logging::Events::~Events()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::Logging::Events::has_data() const
{
    return peer_status.is_set;
}

bool MplsTe::GlobalAttributes::PceAttributes::Logging::Events::has_operation() const
{
    return is_set(operation)
	|| is_set(peer_status.operation);
}

std::string MplsTe::GlobalAttributes::PceAttributes::Logging::Events::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "events";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::Logging::Events::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/logging/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (peer_status.is_set || is_set(peer_status.operation)) leaf_name_data.push_back(peer_status.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::Logging::Events::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::Logging::Events::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::Logging::Events::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "peer-status")
    {
        peer_status = value;
    }
}

MplsTe::GlobalAttributes::PceAttributes::Logging::Logging()
    :
    events(std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Logging::Events>())
{
    events->parent = this;
    children["events"] = events.get();

    yang_name = "logging"; yang_parent_name = "pce-attributes";
}

MplsTe::GlobalAttributes::PceAttributes::Logging::~Logging()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::Logging::has_data() const
{
    return (events !=  nullptr && events->has_data());
}

bool MplsTe::GlobalAttributes::PceAttributes::Logging::has_operation() const
{
    return is_set(operation)
	|| (events !=  nullptr && events->has_operation());
}

std::string MplsTe::GlobalAttributes::PceAttributes::Logging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "logging";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::Logging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/pce-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::Logging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "events")
    {
        if(events != nullptr)
        {
            children["events"] = events.get();
        }
        else
        {
            events = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Logging::Events>();
            events->parent = this;
            children["events"] = events.get();
        }
        return children.at("events");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::Logging::get_children()
{
    if(children.find("events") == children.end())
    {
        if(events != nullptr)
        {
            children["events"] = events.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::Logging::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PceAttributes::PceAttributes()
    :
    	address{YType::str, "address"},
	 deadtimer{YType::uint32, "deadtimer"},
	 keepalive{YType::uint32, "keepalive"},
	 keepalive_tolerance{YType::uint32, "keepalive-tolerance"},
	 keychain{YType::str, "keychain"},
	 password{YType::str, "password"},
	 peer_source_addr{YType::str, "peer-source-addr"},
	 precedence{YType::uint32, "precedence"},
	 reoptimize_period{YType::uint32, "reoptimize-period"},
	 request_timeout{YType::uint32, "request-timeout"},
	 segment_routing{YType::empty, "segment-routing"},
	 speaker_entity_id{YType::str, "speaker-entity-id"}
    	,
    logging(std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Logging>())
	,pce_stateful(std::make_unique<MplsTe::GlobalAttributes::PceAttributes::PceStateful>())
	,peers(std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Peers>())
	,timer(std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Timer>())
{
    logging->parent = this;
    children["logging"] = logging.get();

    pce_stateful->parent = this;
    children["pce-stateful"] = pce_stateful.get();

    peers->parent = this;
    children["peers"] = peers.get();

    timer->parent = this;
    children["timer"] = timer.get();

    yang_name = "pce-attributes"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::PceAttributes::~PceAttributes()
{
}

bool MplsTe::GlobalAttributes::PceAttributes::has_data() const
{
    return address.is_set
	|| deadtimer.is_set
	|| keepalive.is_set
	|| keepalive_tolerance.is_set
	|| keychain.is_set
	|| password.is_set
	|| peer_source_addr.is_set
	|| precedence.is_set
	|| reoptimize_period.is_set
	|| request_timeout.is_set
	|| segment_routing.is_set
	|| speaker_entity_id.is_set
	|| (logging !=  nullptr && logging->has_data())
	|| (pce_stateful !=  nullptr && pce_stateful->has_data())
	|| (peers !=  nullptr && peers->has_data())
	|| (timer !=  nullptr && timer->has_data());
}

bool MplsTe::GlobalAttributes::PceAttributes::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation)
	|| is_set(deadtimer.operation)
	|| is_set(keepalive.operation)
	|| is_set(keepalive_tolerance.operation)
	|| is_set(keychain.operation)
	|| is_set(password.operation)
	|| is_set(peer_source_addr.operation)
	|| is_set(precedence.operation)
	|| is_set(reoptimize_period.operation)
	|| is_set(request_timeout.operation)
	|| is_set(segment_routing.operation)
	|| is_set(speaker_entity_id.operation)
	|| (logging !=  nullptr && logging->has_operation())
	|| (pce_stateful !=  nullptr && pce_stateful->has_operation())
	|| (peers !=  nullptr && peers->has_operation())
	|| (timer !=  nullptr && timer->has_operation());
}

std::string MplsTe::GlobalAttributes::PceAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "pce-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PceAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());
    if (deadtimer.is_set || is_set(deadtimer.operation)) leaf_name_data.push_back(deadtimer.get_name_leafdata());
    if (keepalive.is_set || is_set(keepalive.operation)) leaf_name_data.push_back(keepalive.get_name_leafdata());
    if (keepalive_tolerance.is_set || is_set(keepalive_tolerance.operation)) leaf_name_data.push_back(keepalive_tolerance.get_name_leafdata());
    if (keychain.is_set || is_set(keychain.operation)) leaf_name_data.push_back(keychain.get_name_leafdata());
    if (password.is_set || is_set(password.operation)) leaf_name_data.push_back(password.get_name_leafdata());
    if (peer_source_addr.is_set || is_set(peer_source_addr.operation)) leaf_name_data.push_back(peer_source_addr.get_name_leafdata());
    if (precedence.is_set || is_set(precedence.operation)) leaf_name_data.push_back(precedence.get_name_leafdata());
    if (reoptimize_period.is_set || is_set(reoptimize_period.operation)) leaf_name_data.push_back(reoptimize_period.get_name_leafdata());
    if (request_timeout.is_set || is_set(request_timeout.operation)) leaf_name_data.push_back(request_timeout.get_name_leafdata());
    if (segment_routing.is_set || is_set(segment_routing.operation)) leaf_name_data.push_back(segment_routing.get_name_leafdata());
    if (speaker_entity_id.is_set || is_set(speaker_entity_id.operation)) leaf_name_data.push_back(speaker_entity_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PceAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "logging")
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
        else
        {
            logging = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Logging>();
            logging->parent = this;
            children["logging"] = logging.get();
        }
        return children.at("logging");
    }

    if(child_yang_name == "pce-stateful")
    {
        if(pce_stateful != nullptr)
        {
            children["pce-stateful"] = pce_stateful.get();
        }
        else
        {
            pce_stateful = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::PceStateful>();
            pce_stateful->parent = this;
            children["pce-stateful"] = pce_stateful.get();
        }
        return children.at("pce-stateful");
    }

    if(child_yang_name == "peers")
    {
        if(peers != nullptr)
        {
            children["peers"] = peers.get();
        }
        else
        {
            peers = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Peers>();
            peers->parent = this;
            children["peers"] = peers.get();
        }
        return children.at("peers");
    }

    if(child_yang_name == "timer")
    {
        if(timer != nullptr)
        {
            children["timer"] = timer.get();
        }
        else
        {
            timer = std::make_unique<MplsTe::GlobalAttributes::PceAttributes::Timer>();
            timer->parent = this;
            children["timer"] = timer.get();
        }
        return children.at("timer");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PceAttributes::get_children()
{
    if(children.find("logging") == children.end())
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
    }

    if(children.find("pce-stateful") == children.end())
    {
        if(pce_stateful != nullptr)
        {
            children["pce-stateful"] = pce_stateful.get();
        }
    }

    if(children.find("peers") == children.end())
    {
        if(peers != nullptr)
        {
            children["peers"] = peers.get();
        }
    }

    if(children.find("timer") == children.end())
    {
        if(timer != nullptr)
        {
            children["timer"] = timer.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PceAttributes::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
    if(value_path == "deadtimer")
    {
        deadtimer = value;
    }
    if(value_path == "keepalive")
    {
        keepalive = value;
    }
    if(value_path == "keepalive-tolerance")
    {
        keepalive_tolerance = value;
    }
    if(value_path == "keychain")
    {
        keychain = value;
    }
    if(value_path == "password")
    {
        password = value;
    }
    if(value_path == "peer-source-addr")
    {
        peer_source_addr = value;
    }
    if(value_path == "precedence")
    {
        precedence = value;
    }
    if(value_path == "reoptimize-period")
    {
        reoptimize_period = value;
    }
    if(value_path == "request-timeout")
    {
        request_timeout = value;
    }
    if(value_path == "segment-routing")
    {
        segment_routing = value;
    }
    if(value_path == "speaker-entity-id")
    {
        speaker_entity_id = value;
    }
}

MplsTe::GlobalAttributes::SoftPreemption::SoftPreemption()
    :
    	enable{YType::boolean, "enable"},
	 frr_rewrite{YType::empty, "frr-rewrite"},
	 timeout{YType::uint32, "timeout"}
{
    yang_name = "soft-preemption"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::SoftPreemption::~SoftPreemption()
{
}

bool MplsTe::GlobalAttributes::SoftPreemption::has_data() const
{
    return enable.is_set
	|| frr_rewrite.is_set
	|| timeout.is_set;
}

bool MplsTe::GlobalAttributes::SoftPreemption::has_operation() const
{
    return is_set(operation)
	|| is_set(enable.operation)
	|| is_set(frr_rewrite.operation)
	|| is_set(timeout.operation);
}

std::string MplsTe::GlobalAttributes::SoftPreemption::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "soft-preemption";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::SoftPreemption::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (frr_rewrite.is_set || is_set(frr_rewrite.operation)) leaf_name_data.push_back(frr_rewrite.get_name_leafdata());
    if (timeout.is_set || is_set(timeout.operation)) leaf_name_data.push_back(timeout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::SoftPreemption::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::SoftPreemption::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::SoftPreemption::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "frr-rewrite")
    {
        frr_rewrite = value;
    }
    if(value_path == "timeout")
    {
        timeout = value;
    }
}

MplsTe::GlobalAttributes::FastReroute::Timers::Timers()
    :
    	hold_backup{YType::uint32, "hold-backup"},
	 promotion{YType::uint32, "promotion"}
{
    yang_name = "timers"; yang_parent_name = "fast-reroute";
}

MplsTe::GlobalAttributes::FastReroute::Timers::~Timers()
{
}

bool MplsTe::GlobalAttributes::FastReroute::Timers::has_data() const
{
    return hold_backup.is_set
	|| promotion.is_set;
}

bool MplsTe::GlobalAttributes::FastReroute::Timers::has_operation() const
{
    return is_set(operation)
	|| is_set(hold_backup.operation)
	|| is_set(promotion.operation);
}

std::string MplsTe::GlobalAttributes::FastReroute::Timers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "timers";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::FastReroute::Timers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/fast-reroute/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (hold_backup.is_set || is_set(hold_backup.operation)) leaf_name_data.push_back(hold_backup.get_name_leafdata());
    if (promotion.is_set || is_set(promotion.operation)) leaf_name_data.push_back(promotion.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::FastReroute::Timers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::FastReroute::Timers::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::FastReroute::Timers::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "hold-backup")
    {
        hold_backup = value;
    }
    if(value_path == "promotion")
    {
        promotion = value;
    }
}

MplsTe::GlobalAttributes::FastReroute::FastReroute()
    :
    timers(std::make_unique<MplsTe::GlobalAttributes::FastReroute::Timers>())
{
    timers->parent = this;
    children["timers"] = timers.get();

    yang_name = "fast-reroute"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::FastReroute::~FastReroute()
{
}

bool MplsTe::GlobalAttributes::FastReroute::has_data() const
{
    return (timers !=  nullptr && timers->has_data());
}

bool MplsTe::GlobalAttributes::FastReroute::has_operation() const
{
    return is_set(operation)
	|| (timers !=  nullptr && timers->has_operation());
}

std::string MplsTe::GlobalAttributes::FastReroute::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fast-reroute";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::FastReroute::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::FastReroute::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "timers")
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
        else
        {
            timers = std::make_unique<MplsTe::GlobalAttributes::FastReroute::Timers>();
            timers->parent = this;
            children["timers"] = timers.get();
        }
        return children.at("timers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::FastReroute::get_children()
{
    if(children.find("timers") == children.end())
    {
        if(timers != nullptr)
        {
            children["timers"] = timers.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::FastReroute::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::LooseMetric()
    :
    	class_type{YType::uint32, "class-type"},
	 metric_type{YType::enumeration, "metric-type"}
{
    yang_name = "loose-metric"; yang_parent_name = "loose-metrics";
}

MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::~LooseMetric()
{
}

bool MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::has_data() const
{
    return class_type.is_set
	|| metric_type.is_set;
}

bool MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::has_operation() const
{
    return is_set(operation)
	|| is_set(class_type.operation)
	|| is_set(metric_type.operation);
}

std::string MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "loose-metric" <<"[class-type='" <<class_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/loose-metrics/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (class_type.is_set || is_set(class_type.operation)) leaf_name_data.push_back(class_type.get_name_leafdata());
    if (metric_type.is_set || is_set(metric_type.operation)) leaf_name_data.push_back(metric_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "class-type")
    {
        class_type = value;
    }
    if(value_path == "metric-type")
    {
        metric_type = value;
    }
}

MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetrics()
{
    yang_name = "loose-metrics"; yang_parent_name = "path-selection";
}

MplsTe::GlobalAttributes::PathSelection::LooseMetrics::~LooseMetrics()
{
}

bool MplsTe::GlobalAttributes::PathSelection::LooseMetrics::has_data() const
{
    for (std::size_t index=0; index<loose_metric.size(); index++)
    {
        if(loose_metric[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::PathSelection::LooseMetrics::has_operation() const
{
    for (std::size_t index=0; index<loose_metric.size(); index++)
    {
        if(loose_metric[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::PathSelection::LooseMetrics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "loose-metrics";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::LooseMetrics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::LooseMetrics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "loose-metric")
    {
        for(auto const & c : loose_metric)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::PathSelection::LooseMetrics::LooseMetric>();
        c->parent = this;
        loose_metric.push_back(std::move(c));
        children[segment_path] = loose_metric.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::LooseMetrics::get_children()
{
    for (auto const & c : loose_metric)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PathSelection::LooseMetrics::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PathSelection::Invalidation::Invalidation()
    :
    	path_invalidation_action{YType::enumeration, "path-invalidation-action"},
	 path_invalidation_timeout{YType::uint32, "path-invalidation-timeout"}
{
    yang_name = "invalidation"; yang_parent_name = "path-selection";
}

MplsTe::GlobalAttributes::PathSelection::Invalidation::~Invalidation()
{
}

bool MplsTe::GlobalAttributes::PathSelection::Invalidation::has_data() const
{
    return path_invalidation_action.is_set
	|| path_invalidation_timeout.is_set;
}

bool MplsTe::GlobalAttributes::PathSelection::Invalidation::has_operation() const
{
    return is_set(operation)
	|| is_set(path_invalidation_action.operation)
	|| is_set(path_invalidation_timeout.operation);
}

std::string MplsTe::GlobalAttributes::PathSelection::Invalidation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "invalidation";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::Invalidation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (path_invalidation_action.is_set || is_set(path_invalidation_action.operation)) leaf_name_data.push_back(path_invalidation_action.get_name_leafdata());
    if (path_invalidation_timeout.is_set || is_set(path_invalidation_timeout.operation)) leaf_name_data.push_back(path_invalidation_timeout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::Invalidation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::Invalidation::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PathSelection::Invalidation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "path-invalidation-action")
    {
        path_invalidation_action = value;
    }
    if(value_path == "path-invalidation-timeout")
    {
        path_invalidation_timeout = value;
    }
}

MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::IgnoreOverloadRole()
    :
    	head{YType::boolean, "head"},
	 mid{YType::boolean, "mid"},
	 tail{YType::boolean, "tail"}
{
    yang_name = "ignore-overload-role"; yang_parent_name = "path-selection";
}

MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::~IgnoreOverloadRole()
{
}

bool MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::has_data() const
{
    return head.is_set
	|| mid.is_set
	|| tail.is_set;
}

bool MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::has_operation() const
{
    return is_set(operation)
	|| is_set(head.operation)
	|| is_set(mid.operation)
	|| is_set(tail.operation);
}

std::string MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ignore-overload-role";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (head.is_set || is_set(head.operation)) leaf_name_data.push_back(head.get_name_leafdata());
    if (mid.is_set || is_set(mid.operation)) leaf_name_data.push_back(mid.get_name_leafdata());
    if (tail.is_set || is_set(tail.operation)) leaf_name_data.push_back(tail.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "head")
    {
        head = value;
    }
    if(value_path == "mid")
    {
        mid = value;
    }
    if(value_path == "tail")
    {
        tail = value;
    }
}

MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::LooseAffinity()
    :
    	class_type{YType::uint32, "class-type"},
	 affinity{YType::str, "affinity"},
	 mask{YType::str, "mask"}
{
    yang_name = "loose-affinity"; yang_parent_name = "loose-affinities";
}

MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::~LooseAffinity()
{
}

bool MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::has_data() const
{
    return class_type.is_set
	|| affinity.is_set
	|| mask.is_set;
}

bool MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::has_operation() const
{
    return is_set(operation)
	|| is_set(class_type.operation)
	|| is_set(affinity.operation)
	|| is_set(mask.operation);
}

std::string MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "loose-affinity" <<"[class-type='" <<class_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/loose-affinities/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (class_type.is_set || is_set(class_type.operation)) leaf_name_data.push_back(class_type.get_name_leafdata());
    if (affinity.is_set || is_set(affinity.operation)) leaf_name_data.push_back(affinity.get_name_leafdata());
    if (mask.is_set || is_set(mask.operation)) leaf_name_data.push_back(mask.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "class-type")
    {
        class_type = value;
    }
    if(value_path == "affinity")
    {
        affinity = value;
    }
    if(value_path == "mask")
    {
        mask = value;
    }
}

MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinities()
{
    yang_name = "loose-affinities"; yang_parent_name = "path-selection";
}

MplsTe::GlobalAttributes::PathSelection::LooseAffinities::~LooseAffinities()
{
}

bool MplsTe::GlobalAttributes::PathSelection::LooseAffinities::has_data() const
{
    for (std::size_t index=0; index<loose_affinity.size(); index++)
    {
        if(loose_affinity[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::PathSelection::LooseAffinities::has_operation() const
{
    for (std::size_t index=0; index<loose_affinity.size(); index++)
    {
        if(loose_affinity[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::PathSelection::LooseAffinities::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "loose-affinities";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::LooseAffinities::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/path-selection/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::LooseAffinities::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "loose-affinity")
    {
        for(auto const & c : loose_affinity)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::PathSelection::LooseAffinities::LooseAffinity>();
        c->parent = this;
        loose_affinity.push_back(std::move(c));
        children[segment_path] = loose_affinity.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::LooseAffinities::get_children()
{
    for (auto const & c : loose_affinity)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PathSelection::LooseAffinities::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::PathSelection::PathSelection()
    :
    	cost_limit{YType::uint32, "cost-limit"},
	 loose_domain_match{YType::boolean, "loose-domain-match"},
	 metric{YType::enumeration, "metric"},
	 tiebreaker{YType::enumeration, "tiebreaker"}
    	,
    ignore_overload_role(std::make_unique<MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole>())
	,invalidation(std::make_unique<MplsTe::GlobalAttributes::PathSelection::Invalidation>())
	,loose_affinities(std::make_unique<MplsTe::GlobalAttributes::PathSelection::LooseAffinities>())
	,loose_metrics(std::make_unique<MplsTe::GlobalAttributes::PathSelection::LooseMetrics>())
{
    ignore_overload_role->parent = this;
    children["ignore-overload-role"] = ignore_overload_role.get();

    invalidation->parent = this;
    children["invalidation"] = invalidation.get();

    loose_affinities->parent = this;
    children["loose-affinities"] = loose_affinities.get();

    loose_metrics->parent = this;
    children["loose-metrics"] = loose_metrics.get();

    yang_name = "path-selection"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::PathSelection::~PathSelection()
{
}

bool MplsTe::GlobalAttributes::PathSelection::has_data() const
{
    return cost_limit.is_set
	|| loose_domain_match.is_set
	|| metric.is_set
	|| tiebreaker.is_set
	|| (ignore_overload_role !=  nullptr && ignore_overload_role->has_data())
	|| (invalidation !=  nullptr && invalidation->has_data())
	|| (loose_affinities !=  nullptr && loose_affinities->has_data())
	|| (loose_metrics !=  nullptr && loose_metrics->has_data());
}

bool MplsTe::GlobalAttributes::PathSelection::has_operation() const
{
    return is_set(operation)
	|| is_set(cost_limit.operation)
	|| is_set(loose_domain_match.operation)
	|| is_set(metric.operation)
	|| is_set(tiebreaker.operation)
	|| (ignore_overload_role !=  nullptr && ignore_overload_role->has_operation())
	|| (invalidation !=  nullptr && invalidation->has_operation())
	|| (loose_affinities !=  nullptr && loose_affinities->has_operation())
	|| (loose_metrics !=  nullptr && loose_metrics->has_operation());
}

std::string MplsTe::GlobalAttributes::PathSelection::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-selection";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::PathSelection::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (cost_limit.is_set || is_set(cost_limit.operation)) leaf_name_data.push_back(cost_limit.get_name_leafdata());
    if (loose_domain_match.is_set || is_set(loose_domain_match.operation)) leaf_name_data.push_back(loose_domain_match.get_name_leafdata());
    if (metric.is_set || is_set(metric.operation)) leaf_name_data.push_back(metric.get_name_leafdata());
    if (tiebreaker.is_set || is_set(tiebreaker.operation)) leaf_name_data.push_back(tiebreaker.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::PathSelection::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ignore-overload-role")
    {
        if(ignore_overload_role != nullptr)
        {
            children["ignore-overload-role"] = ignore_overload_role.get();
        }
        else
        {
            ignore_overload_role = std::make_unique<MplsTe::GlobalAttributes::PathSelection::IgnoreOverloadRole>();
            ignore_overload_role->parent = this;
            children["ignore-overload-role"] = ignore_overload_role.get();
        }
        return children.at("ignore-overload-role");
    }

    if(child_yang_name == "invalidation")
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
        else
        {
            invalidation = std::make_unique<MplsTe::GlobalAttributes::PathSelection::Invalidation>();
            invalidation->parent = this;
            children["invalidation"] = invalidation.get();
        }
        return children.at("invalidation");
    }

    if(child_yang_name == "loose-affinities")
    {
        if(loose_affinities != nullptr)
        {
            children["loose-affinities"] = loose_affinities.get();
        }
        else
        {
            loose_affinities = std::make_unique<MplsTe::GlobalAttributes::PathSelection::LooseAffinities>();
            loose_affinities->parent = this;
            children["loose-affinities"] = loose_affinities.get();
        }
        return children.at("loose-affinities");
    }

    if(child_yang_name == "loose-metrics")
    {
        if(loose_metrics != nullptr)
        {
            children["loose-metrics"] = loose_metrics.get();
        }
        else
        {
            loose_metrics = std::make_unique<MplsTe::GlobalAttributes::PathSelection::LooseMetrics>();
            loose_metrics->parent = this;
            children["loose-metrics"] = loose_metrics.get();
        }
        return children.at("loose-metrics");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::PathSelection::get_children()
{
    if(children.find("ignore-overload-role") == children.end())
    {
        if(ignore_overload_role != nullptr)
        {
            children["ignore-overload-role"] = ignore_overload_role.get();
        }
    }

    if(children.find("invalidation") == children.end())
    {
        if(invalidation != nullptr)
        {
            children["invalidation"] = invalidation.get();
        }
    }

    if(children.find("loose-affinities") == children.end())
    {
        if(loose_affinities != nullptr)
        {
            children["loose-affinities"] = loose_affinities.get();
        }
    }

    if(children.find("loose-metrics") == children.end())
    {
        if(loose_metrics != nullptr)
        {
            children["loose-metrics"] = loose_metrics.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::PathSelection::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "cost-limit")
    {
        cost_limit = value;
    }
    if(value_path == "loose-domain-match")
    {
        loose_domain_match = value;
    }
    if(value_path == "metric")
    {
        metric = value;
    }
    if(value_path == "tiebreaker")
    {
        tiebreaker = value;
    }
}

MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::AffinityMapping()
    :
    	affinity_name{YType::str, "affinity-name"},
	 value_{YType::str, "value"},
	 value_type{YType::enumeration, "value-type"}
{
    yang_name = "affinity-mapping"; yang_parent_name = "affinity-mappings";
}

MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::~AffinityMapping()
{
}

bool MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::has_data() const
{
    return affinity_name.is_set
	|| value_.is_set
	|| value_type.is_set;
}

bool MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::has_operation() const
{
    return is_set(operation)
	|| is_set(affinity_name.operation)
	|| is_set(value_.operation)
	|| is_set(value_type.operation);
}

std::string MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mapping" <<"[affinity-name='" <<affinity_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/affinity-mappings/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_name.is_set || is_set(affinity_name.operation)) leaf_name_data.push_back(affinity_name.get_name_leafdata());
    if (value_.is_set || is_set(value_.operation)) leaf_name_data.push_back(value_.get_name_leafdata());
    if (value_type.is_set || is_set(value_type.operation)) leaf_name_data.push_back(value_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::get_children()
{
    return children;
}

void MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-name")
    {
        affinity_name = value;
    }
    if(value_path == "value")
    {
        value_ = value;
    }
    if(value_path == "value-type")
    {
        value_type = value;
    }
}

MplsTe::GlobalAttributes::AffinityMappings::AffinityMappings()
{
    yang_name = "affinity-mappings"; yang_parent_name = "global-attributes";
}

MplsTe::GlobalAttributes::AffinityMappings::~AffinityMappings()
{
}

bool MplsTe::GlobalAttributes::AffinityMappings::has_data() const
{
    for (std::size_t index=0; index<affinity_mapping.size(); index++)
    {
        if(affinity_mapping[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GlobalAttributes::AffinityMappings::has_operation() const
{
    for (std::size_t index=0; index<affinity_mapping.size(); index++)
    {
        if(affinity_mapping[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GlobalAttributes::AffinityMappings::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "affinity-mappings";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::AffinityMappings::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/global-attributes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::AffinityMappings::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mapping")
    {
        for(auto const & c : affinity_mapping)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GlobalAttributes::AffinityMappings::AffinityMapping>();
        c->parent = this;
        affinity_mapping.push_back(std::move(c));
        children[segment_path] = affinity_mapping.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::AffinityMappings::get_children()
{
    for (auto const & c : affinity_mapping)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::AffinityMappings::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GlobalAttributes::GlobalAttributes()
    :
    	advertise_explicit_nulls{YType::empty, "advertise-explicit-nulls"},
	 auto_bandwidth_collect_frequency{YType::uint32, "auto-bandwidth-collect-frequency"},
	 disable_reoptimize_affinity_failure{YType::empty, "disable-reoptimize-affinity-failure"},
	 enable_unequal_load_balancing{YType::empty, "enable-unequal-load-balancing"},
	 fault_oam{YType::empty, "fault-oam"},
	 graceful_preemption_on_bandwidth_reduction{YType::empty, "graceful-preemption-on-bandwidth-reduction"},
	 link_holddown_timer{YType::uint32, "link-holddown-timer"},
	 log_all{YType::empty, "log-all"},
	 log_frr_protection{YType::enumeration, "log-frr-protection"},
	 log_head{YType::empty, "log-head"},
	 log_issu_status{YType::empty, "log-issu-status"},
	 log_mid{YType::empty, "log-mid"},
	 log_nsr_status{YType::empty, "log-nsr-status"},
	 log_preemption{YType::empty, "log-preemption"},
	 log_tail{YType::empty, "log-tail"},
	 loose_path_retry_period{YType::uint32, "loose-path-retry-period"},
	 maximum_tunnels{YType::uint32, "maximum-tunnels"},
	 path_selection_ignore_overload{YType::empty, "path-selection-ignore-overload"},
	 reopt_delay_path_protect_switchover_timer{YType::uint32, "reopt-delay-path-protect-switchover-timer"},
	 reoptimize_delay_after_affinity_failure_timer{YType::uint32, "reoptimize-delay-after-affinity-failure-timer"},
	 reoptimize_delay_after_frr_timer{YType::uint32, "reoptimize-delay-after-frr-timer"},
	 reoptimize_delay_cleanup_timer{YType::uint32, "reoptimize-delay-cleanup-timer"},
	 reoptimize_delay_install_timer{YType::uint32, "reoptimize-delay-install-timer"},
	 reoptimize_link_up{YType::empty, "reoptimize-link-up"},
	 reoptimize_load_balancing{YType::empty, "reoptimize-load-balancing"},
	 reoptimize_timer_frequency{YType::uint32, "reoptimize-timer-frequency"}
    	,
    affinity_mappings(std::make_unique<MplsTe::GlobalAttributes::AffinityMappings>())
	,attribute_set(std::make_unique<MplsTe::GlobalAttributes::AttributeSet>())
	,auto_tunnel(std::make_unique<MplsTe::GlobalAttributes::AutoTunnel>())
	,bfd_over_lsp(std::make_unique<MplsTe::GlobalAttributes::BfdOverLsp>())
	,fast_reroute(std::make_unique<MplsTe::GlobalAttributes::FastReroute>())
	,hardware_out_of_resource(std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource>())
	,mib(std::make_unique<MplsTe::GlobalAttributes::Mib>())
	,path_selection(std::make_unique<MplsTe::GlobalAttributes::PathSelection>())
	,pce_attributes(std::make_unique<MplsTe::GlobalAttributes::PceAttributes>())
	,queues(std::make_unique<MplsTe::GlobalAttributes::Queues>())
	,secondary_router_ids(std::make_unique<MplsTe::GlobalAttributes::SecondaryRouterIds>())
	,soft_preemption(std::make_unique<MplsTe::GlobalAttributes::SoftPreemption>())
	,srlg(std::make_unique<MplsTe::GlobalAttributes::Srlg>())
{
    affinity_mappings->parent = this;
    children["affinity-mappings"] = affinity_mappings.get();

    attribute_set->parent = this;
    children["attribute-set"] = attribute_set.get();

    auto_tunnel->parent = this;
    children["auto-tunnel"] = auto_tunnel.get();

    bfd_over_lsp->parent = this;
    children["bfd-over-lsp"] = bfd_over_lsp.get();

    fast_reroute->parent = this;
    children["fast-reroute"] = fast_reroute.get();

    hardware_out_of_resource->parent = this;
    children["hardware-out-of-resource"] = hardware_out_of_resource.get();

    mib->parent = this;
    children["mib"] = mib.get();

    path_selection->parent = this;
    children["path-selection"] = path_selection.get();

    pce_attributes->parent = this;
    children["pce-attributes"] = pce_attributes.get();

    queues->parent = this;
    children["queues"] = queues.get();

    secondary_router_ids->parent = this;
    children["secondary-router-ids"] = secondary_router_ids.get();

    soft_preemption->parent = this;
    children["soft-preemption"] = soft_preemption.get();

    srlg->parent = this;
    children["srlg"] = srlg.get();

    yang_name = "global-attributes"; yang_parent_name = "mpls-te";
}

MplsTe::GlobalAttributes::~GlobalAttributes()
{
}

bool MplsTe::GlobalAttributes::has_data() const
{
    return advertise_explicit_nulls.is_set
	|| auto_bandwidth_collect_frequency.is_set
	|| disable_reoptimize_affinity_failure.is_set
	|| enable_unequal_load_balancing.is_set
	|| fault_oam.is_set
	|| graceful_preemption_on_bandwidth_reduction.is_set
	|| link_holddown_timer.is_set
	|| log_all.is_set
	|| log_frr_protection.is_set
	|| log_head.is_set
	|| log_issu_status.is_set
	|| log_mid.is_set
	|| log_nsr_status.is_set
	|| log_preemption.is_set
	|| log_tail.is_set
	|| loose_path_retry_period.is_set
	|| maximum_tunnels.is_set
	|| path_selection_ignore_overload.is_set
	|| reopt_delay_path_protect_switchover_timer.is_set
	|| reoptimize_delay_after_affinity_failure_timer.is_set
	|| reoptimize_delay_after_frr_timer.is_set
	|| reoptimize_delay_cleanup_timer.is_set
	|| reoptimize_delay_install_timer.is_set
	|| reoptimize_link_up.is_set
	|| reoptimize_load_balancing.is_set
	|| reoptimize_timer_frequency.is_set
	|| (affinity_mappings !=  nullptr && affinity_mappings->has_data())
	|| (attribute_set !=  nullptr && attribute_set->has_data())
	|| (auto_tunnel !=  nullptr && auto_tunnel->has_data())
	|| (bfd_over_lsp !=  nullptr && bfd_over_lsp->has_data())
	|| (fast_reroute !=  nullptr && fast_reroute->has_data())
	|| (hardware_out_of_resource !=  nullptr && hardware_out_of_resource->has_data())
	|| (mib !=  nullptr && mib->has_data())
	|| (path_selection !=  nullptr && path_selection->has_data())
	|| (pce_attributes !=  nullptr && pce_attributes->has_data())
	|| (queues !=  nullptr && queues->has_data())
	|| (secondary_router_ids !=  nullptr && secondary_router_ids->has_data())
	|| (soft_preemption !=  nullptr && soft_preemption->has_data())
	|| (srlg !=  nullptr && srlg->has_data());
}

bool MplsTe::GlobalAttributes::has_operation() const
{
    return is_set(operation)
	|| is_set(advertise_explicit_nulls.operation)
	|| is_set(auto_bandwidth_collect_frequency.operation)
	|| is_set(disable_reoptimize_affinity_failure.operation)
	|| is_set(enable_unequal_load_balancing.operation)
	|| is_set(fault_oam.operation)
	|| is_set(graceful_preemption_on_bandwidth_reduction.operation)
	|| is_set(link_holddown_timer.operation)
	|| is_set(log_all.operation)
	|| is_set(log_frr_protection.operation)
	|| is_set(log_head.operation)
	|| is_set(log_issu_status.operation)
	|| is_set(log_mid.operation)
	|| is_set(log_nsr_status.operation)
	|| is_set(log_preemption.operation)
	|| is_set(log_tail.operation)
	|| is_set(loose_path_retry_period.operation)
	|| is_set(maximum_tunnels.operation)
	|| is_set(path_selection_ignore_overload.operation)
	|| is_set(reopt_delay_path_protect_switchover_timer.operation)
	|| is_set(reoptimize_delay_after_affinity_failure_timer.operation)
	|| is_set(reoptimize_delay_after_frr_timer.operation)
	|| is_set(reoptimize_delay_cleanup_timer.operation)
	|| is_set(reoptimize_delay_install_timer.operation)
	|| is_set(reoptimize_link_up.operation)
	|| is_set(reoptimize_load_balancing.operation)
	|| is_set(reoptimize_timer_frequency.operation)
	|| (affinity_mappings !=  nullptr && affinity_mappings->has_operation())
	|| (attribute_set !=  nullptr && attribute_set->has_operation())
	|| (auto_tunnel !=  nullptr && auto_tunnel->has_operation())
	|| (bfd_over_lsp !=  nullptr && bfd_over_lsp->has_operation())
	|| (fast_reroute !=  nullptr && fast_reroute->has_operation())
	|| (hardware_out_of_resource !=  nullptr && hardware_out_of_resource->has_operation())
	|| (mib !=  nullptr && mib->has_operation())
	|| (path_selection !=  nullptr && path_selection->has_operation())
	|| (pce_attributes !=  nullptr && pce_attributes->has_operation())
	|| (queues !=  nullptr && queues->has_operation())
	|| (secondary_router_ids !=  nullptr && secondary_router_ids->has_operation())
	|| (soft_preemption !=  nullptr && soft_preemption->has_operation())
	|| (srlg !=  nullptr && srlg->has_operation());
}

std::string MplsTe::GlobalAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "global-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::GlobalAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (advertise_explicit_nulls.is_set || is_set(advertise_explicit_nulls.operation)) leaf_name_data.push_back(advertise_explicit_nulls.get_name_leafdata());
    if (auto_bandwidth_collect_frequency.is_set || is_set(auto_bandwidth_collect_frequency.operation)) leaf_name_data.push_back(auto_bandwidth_collect_frequency.get_name_leafdata());
    if (disable_reoptimize_affinity_failure.is_set || is_set(disable_reoptimize_affinity_failure.operation)) leaf_name_data.push_back(disable_reoptimize_affinity_failure.get_name_leafdata());
    if (enable_unequal_load_balancing.is_set || is_set(enable_unequal_load_balancing.operation)) leaf_name_data.push_back(enable_unequal_load_balancing.get_name_leafdata());
    if (fault_oam.is_set || is_set(fault_oam.operation)) leaf_name_data.push_back(fault_oam.get_name_leafdata());
    if (graceful_preemption_on_bandwidth_reduction.is_set || is_set(graceful_preemption_on_bandwidth_reduction.operation)) leaf_name_data.push_back(graceful_preemption_on_bandwidth_reduction.get_name_leafdata());
    if (link_holddown_timer.is_set || is_set(link_holddown_timer.operation)) leaf_name_data.push_back(link_holddown_timer.get_name_leafdata());
    if (log_all.is_set || is_set(log_all.operation)) leaf_name_data.push_back(log_all.get_name_leafdata());
    if (log_frr_protection.is_set || is_set(log_frr_protection.operation)) leaf_name_data.push_back(log_frr_protection.get_name_leafdata());
    if (log_head.is_set || is_set(log_head.operation)) leaf_name_data.push_back(log_head.get_name_leafdata());
    if (log_issu_status.is_set || is_set(log_issu_status.operation)) leaf_name_data.push_back(log_issu_status.get_name_leafdata());
    if (log_mid.is_set || is_set(log_mid.operation)) leaf_name_data.push_back(log_mid.get_name_leafdata());
    if (log_nsr_status.is_set || is_set(log_nsr_status.operation)) leaf_name_data.push_back(log_nsr_status.get_name_leafdata());
    if (log_preemption.is_set || is_set(log_preemption.operation)) leaf_name_data.push_back(log_preemption.get_name_leafdata());
    if (log_tail.is_set || is_set(log_tail.operation)) leaf_name_data.push_back(log_tail.get_name_leafdata());
    if (loose_path_retry_period.is_set || is_set(loose_path_retry_period.operation)) leaf_name_data.push_back(loose_path_retry_period.get_name_leafdata());
    if (maximum_tunnels.is_set || is_set(maximum_tunnels.operation)) leaf_name_data.push_back(maximum_tunnels.get_name_leafdata());
    if (path_selection_ignore_overload.is_set || is_set(path_selection_ignore_overload.operation)) leaf_name_data.push_back(path_selection_ignore_overload.get_name_leafdata());
    if (reopt_delay_path_protect_switchover_timer.is_set || is_set(reopt_delay_path_protect_switchover_timer.operation)) leaf_name_data.push_back(reopt_delay_path_protect_switchover_timer.get_name_leafdata());
    if (reoptimize_delay_after_affinity_failure_timer.is_set || is_set(reoptimize_delay_after_affinity_failure_timer.operation)) leaf_name_data.push_back(reoptimize_delay_after_affinity_failure_timer.get_name_leafdata());
    if (reoptimize_delay_after_frr_timer.is_set || is_set(reoptimize_delay_after_frr_timer.operation)) leaf_name_data.push_back(reoptimize_delay_after_frr_timer.get_name_leafdata());
    if (reoptimize_delay_cleanup_timer.is_set || is_set(reoptimize_delay_cleanup_timer.operation)) leaf_name_data.push_back(reoptimize_delay_cleanup_timer.get_name_leafdata());
    if (reoptimize_delay_install_timer.is_set || is_set(reoptimize_delay_install_timer.operation)) leaf_name_data.push_back(reoptimize_delay_install_timer.get_name_leafdata());
    if (reoptimize_link_up.is_set || is_set(reoptimize_link_up.operation)) leaf_name_data.push_back(reoptimize_link_up.get_name_leafdata());
    if (reoptimize_load_balancing.is_set || is_set(reoptimize_load_balancing.operation)) leaf_name_data.push_back(reoptimize_load_balancing.get_name_leafdata());
    if (reoptimize_timer_frequency.is_set || is_set(reoptimize_timer_frequency.operation)) leaf_name_data.push_back(reoptimize_timer_frequency.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GlobalAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "affinity-mappings")
    {
        if(affinity_mappings != nullptr)
        {
            children["affinity-mappings"] = affinity_mappings.get();
        }
        else
        {
            affinity_mappings = std::make_unique<MplsTe::GlobalAttributes::AffinityMappings>();
            affinity_mappings->parent = this;
            children["affinity-mappings"] = affinity_mappings.get();
        }
        return children.at("affinity-mappings");
    }

    if(child_yang_name == "attribute-set")
    {
        if(attribute_set != nullptr)
        {
            children["attribute-set"] = attribute_set.get();
        }
        else
        {
            attribute_set = std::make_unique<MplsTe::GlobalAttributes::AttributeSet>();
            attribute_set->parent = this;
            children["attribute-set"] = attribute_set.get();
        }
        return children.at("attribute-set");
    }

    if(child_yang_name == "auto-tunnel")
    {
        if(auto_tunnel != nullptr)
        {
            children["auto-tunnel"] = auto_tunnel.get();
        }
        else
        {
            auto_tunnel = std::make_unique<MplsTe::GlobalAttributes::AutoTunnel>();
            auto_tunnel->parent = this;
            children["auto-tunnel"] = auto_tunnel.get();
        }
        return children.at("auto-tunnel");
    }

    if(child_yang_name == "bfd-over-lsp")
    {
        if(bfd_over_lsp != nullptr)
        {
            children["bfd-over-lsp"] = bfd_over_lsp.get();
        }
        else
        {
            bfd_over_lsp = std::make_unique<MplsTe::GlobalAttributes::BfdOverLsp>();
            bfd_over_lsp->parent = this;
            children["bfd-over-lsp"] = bfd_over_lsp.get();
        }
        return children.at("bfd-over-lsp");
    }

    if(child_yang_name == "fast-reroute")
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
        else
        {
            fast_reroute = std::make_unique<MplsTe::GlobalAttributes::FastReroute>();
            fast_reroute->parent = this;
            children["fast-reroute"] = fast_reroute.get();
        }
        return children.at("fast-reroute");
    }

    if(child_yang_name == "hardware-out-of-resource")
    {
        if(hardware_out_of_resource != nullptr)
        {
            children["hardware-out-of-resource"] = hardware_out_of_resource.get();
        }
        else
        {
            hardware_out_of_resource = std::make_unique<MplsTe::GlobalAttributes::HardwareOutOfResource>();
            hardware_out_of_resource->parent = this;
            children["hardware-out-of-resource"] = hardware_out_of_resource.get();
        }
        return children.at("hardware-out-of-resource");
    }

    if(child_yang_name == "mib")
    {
        if(mib != nullptr)
        {
            children["mib"] = mib.get();
        }
        else
        {
            mib = std::make_unique<MplsTe::GlobalAttributes::Mib>();
            mib->parent = this;
            children["mib"] = mib.get();
        }
        return children.at("mib");
    }

    if(child_yang_name == "path-selection")
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
        else
        {
            path_selection = std::make_unique<MplsTe::GlobalAttributes::PathSelection>();
            path_selection->parent = this;
            children["path-selection"] = path_selection.get();
        }
        return children.at("path-selection");
    }

    if(child_yang_name == "pce-attributes")
    {
        if(pce_attributes != nullptr)
        {
            children["pce-attributes"] = pce_attributes.get();
        }
        else
        {
            pce_attributes = std::make_unique<MplsTe::GlobalAttributes::PceAttributes>();
            pce_attributes->parent = this;
            children["pce-attributes"] = pce_attributes.get();
        }
        return children.at("pce-attributes");
    }

    if(child_yang_name == "queues")
    {
        if(queues != nullptr)
        {
            children["queues"] = queues.get();
        }
        else
        {
            queues = std::make_unique<MplsTe::GlobalAttributes::Queues>();
            queues->parent = this;
            children["queues"] = queues.get();
        }
        return children.at("queues");
    }

    if(child_yang_name == "secondary-router-ids")
    {
        if(secondary_router_ids != nullptr)
        {
            children["secondary-router-ids"] = secondary_router_ids.get();
        }
        else
        {
            secondary_router_ids = std::make_unique<MplsTe::GlobalAttributes::SecondaryRouterIds>();
            secondary_router_ids->parent = this;
            children["secondary-router-ids"] = secondary_router_ids.get();
        }
        return children.at("secondary-router-ids");
    }

    if(child_yang_name == "soft-preemption")
    {
        if(soft_preemption != nullptr)
        {
            children["soft-preemption"] = soft_preemption.get();
        }
        else
        {
            soft_preemption = std::make_unique<MplsTe::GlobalAttributes::SoftPreemption>();
            soft_preemption->parent = this;
            children["soft-preemption"] = soft_preemption.get();
        }
        return children.at("soft-preemption");
    }

    if(child_yang_name == "srlg")
    {
        if(srlg != nullptr)
        {
            children["srlg"] = srlg.get();
        }
        else
        {
            srlg = std::make_unique<MplsTe::GlobalAttributes::Srlg>();
            srlg->parent = this;
            children["srlg"] = srlg.get();
        }
        return children.at("srlg");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GlobalAttributes::get_children()
{
    if(children.find("affinity-mappings") == children.end())
    {
        if(affinity_mappings != nullptr)
        {
            children["affinity-mappings"] = affinity_mappings.get();
        }
    }

    if(children.find("attribute-set") == children.end())
    {
        if(attribute_set != nullptr)
        {
            children["attribute-set"] = attribute_set.get();
        }
    }

    if(children.find("auto-tunnel") == children.end())
    {
        if(auto_tunnel != nullptr)
        {
            children["auto-tunnel"] = auto_tunnel.get();
        }
    }

    if(children.find("bfd-over-lsp") == children.end())
    {
        if(bfd_over_lsp != nullptr)
        {
            children["bfd-over-lsp"] = bfd_over_lsp.get();
        }
    }

    if(children.find("fast-reroute") == children.end())
    {
        if(fast_reroute != nullptr)
        {
            children["fast-reroute"] = fast_reroute.get();
        }
    }

    if(children.find("hardware-out-of-resource") == children.end())
    {
        if(hardware_out_of_resource != nullptr)
        {
            children["hardware-out-of-resource"] = hardware_out_of_resource.get();
        }
    }

    if(children.find("mib") == children.end())
    {
        if(mib != nullptr)
        {
            children["mib"] = mib.get();
        }
    }

    if(children.find("path-selection") == children.end())
    {
        if(path_selection != nullptr)
        {
            children["path-selection"] = path_selection.get();
        }
    }

    if(children.find("pce-attributes") == children.end())
    {
        if(pce_attributes != nullptr)
        {
            children["pce-attributes"] = pce_attributes.get();
        }
    }

    if(children.find("queues") == children.end())
    {
        if(queues != nullptr)
        {
            children["queues"] = queues.get();
        }
    }

    if(children.find("secondary-router-ids") == children.end())
    {
        if(secondary_router_ids != nullptr)
        {
            children["secondary-router-ids"] = secondary_router_ids.get();
        }
    }

    if(children.find("soft-preemption") == children.end())
    {
        if(soft_preemption != nullptr)
        {
            children["soft-preemption"] = soft_preemption.get();
        }
    }

    if(children.find("srlg") == children.end())
    {
        if(srlg != nullptr)
        {
            children["srlg"] = srlg.get();
        }
    }

    return children;
}

void MplsTe::GlobalAttributes::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "advertise-explicit-nulls")
    {
        advertise_explicit_nulls = value;
    }
    if(value_path == "auto-bandwidth-collect-frequency")
    {
        auto_bandwidth_collect_frequency = value;
    }
    if(value_path == "disable-reoptimize-affinity-failure")
    {
        disable_reoptimize_affinity_failure = value;
    }
    if(value_path == "enable-unequal-load-balancing")
    {
        enable_unequal_load_balancing = value;
    }
    if(value_path == "fault-oam")
    {
        fault_oam = value;
    }
    if(value_path == "graceful-preemption-on-bandwidth-reduction")
    {
        graceful_preemption_on_bandwidth_reduction = value;
    }
    if(value_path == "link-holddown-timer")
    {
        link_holddown_timer = value;
    }
    if(value_path == "log-all")
    {
        log_all = value;
    }
    if(value_path == "log-frr-protection")
    {
        log_frr_protection = value;
    }
    if(value_path == "log-head")
    {
        log_head = value;
    }
    if(value_path == "log-issu-status")
    {
        log_issu_status = value;
    }
    if(value_path == "log-mid")
    {
        log_mid = value;
    }
    if(value_path == "log-nsr-status")
    {
        log_nsr_status = value;
    }
    if(value_path == "log-preemption")
    {
        log_preemption = value;
    }
    if(value_path == "log-tail")
    {
        log_tail = value;
    }
    if(value_path == "loose-path-retry-period")
    {
        loose_path_retry_period = value;
    }
    if(value_path == "maximum-tunnels")
    {
        maximum_tunnels = value;
    }
    if(value_path == "path-selection-ignore-overload")
    {
        path_selection_ignore_overload = value;
    }
    if(value_path == "reopt-delay-path-protect-switchover-timer")
    {
        reopt_delay_path_protect_switchover_timer = value;
    }
    if(value_path == "reoptimize-delay-after-affinity-failure-timer")
    {
        reoptimize_delay_after_affinity_failure_timer = value;
    }
    if(value_path == "reoptimize-delay-after-frr-timer")
    {
        reoptimize_delay_after_frr_timer = value;
    }
    if(value_path == "reoptimize-delay-cleanup-timer")
    {
        reoptimize_delay_cleanup_timer = value;
    }
    if(value_path == "reoptimize-delay-install-timer")
    {
        reoptimize_delay_install_timer = value;
    }
    if(value_path == "reoptimize-link-up")
    {
        reoptimize_link_up = value;
    }
    if(value_path == "reoptimize-load-balancing")
    {
        reoptimize_load_balancing = value;
    }
    if(value_path == "reoptimize-timer-frequency")
    {
        reoptimize_timer_frequency = value;
    }
}

MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::Ldi()
    :
    	disable{YType::empty, "disable"}
{
    yang_name = "ldi"; yang_parent_name = "protection-trigger";
}

MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::~Ldi()
{
}

bool MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::has_data() const
{
    return disable.is_set;
}

bool MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::has_operation() const
{
    return is_set(operation)
	|| is_set(disable.operation);
}

std::string MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ldi";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/fault/protection-trigger/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (disable.is_set || is_set(disable.operation)) leaf_name_data.push_back(disable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "disable")
    {
        disable = value;
    }
}

MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::Lkr()
    :
    	disable{YType::empty, "disable"}
{
    yang_name = "lkr"; yang_parent_name = "protection-trigger";
}

MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::~Lkr()
{
}

bool MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::has_data() const
{
    return disable.is_set;
}

bool MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::has_operation() const
{
    return is_set(operation)
	|| is_set(disable.operation);
}

std::string MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lkr";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/fault/protection-trigger/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (disable.is_set || is_set(disable.operation)) leaf_name_data.push_back(disable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "disable")
    {
        disable = value;
    }
}

MplsTe::TransportProfile::Fault::ProtectionTrigger::ProtectionTrigger()
    :
    	ais{YType::empty, "ais"}
    	,
    ldi(std::make_unique<MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi>())
	,lkr(std::make_unique<MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr>())
{
    ldi->parent = this;
    children["ldi"] = ldi.get();

    lkr->parent = this;
    children["lkr"] = lkr.get();

    yang_name = "protection-trigger"; yang_parent_name = "fault";
}

MplsTe::TransportProfile::Fault::ProtectionTrigger::~ProtectionTrigger()
{
}

bool MplsTe::TransportProfile::Fault::ProtectionTrigger::has_data() const
{
    return ais.is_set
	|| (ldi !=  nullptr && ldi->has_data())
	|| (lkr !=  nullptr && lkr->has_data());
}

bool MplsTe::TransportProfile::Fault::ProtectionTrigger::has_operation() const
{
    return is_set(operation)
	|| is_set(ais.operation)
	|| (ldi !=  nullptr && ldi->has_operation())
	|| (lkr !=  nullptr && lkr->has_operation());
}

std::string MplsTe::TransportProfile::Fault::ProtectionTrigger::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protection-trigger";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Fault::ProtectionTrigger::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/fault/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (ais.is_set || is_set(ais.operation)) leaf_name_data.push_back(ais.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Fault::ProtectionTrigger::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ldi")
    {
        if(ldi != nullptr)
        {
            children["ldi"] = ldi.get();
        }
        else
        {
            ldi = std::make_unique<MplsTe::TransportProfile::Fault::ProtectionTrigger::Ldi>();
            ldi->parent = this;
            children["ldi"] = ldi.get();
        }
        return children.at("ldi");
    }

    if(child_yang_name == "lkr")
    {
        if(lkr != nullptr)
        {
            children["lkr"] = lkr.get();
        }
        else
        {
            lkr = std::make_unique<MplsTe::TransportProfile::Fault::ProtectionTrigger::Lkr>();
            lkr->parent = this;
            children["lkr"] = lkr.get();
        }
        return children.at("lkr");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Fault::ProtectionTrigger::get_children()
{
    if(children.find("ldi") == children.end())
    {
        if(ldi != nullptr)
        {
            children["ldi"] = ldi.get();
        }
    }

    if(children.find("lkr") == children.end())
    {
        if(lkr != nullptr)
        {
            children["lkr"] = lkr.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Fault::ProtectionTrigger::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "ais")
    {
        ais = value;
    }
}

MplsTe::TransportProfile::Fault::Fault()
    :
    	refresh_interval{YType::uint32, "refresh-interval"},
	 wait_to_restore_interval{YType::uint32, "wait-to-restore-interval"}
    	,
    protection_trigger(std::make_unique<MplsTe::TransportProfile::Fault::ProtectionTrigger>())
{
    protection_trigger->parent = this;
    children["protection-trigger"] = protection_trigger.get();

    yang_name = "fault"; yang_parent_name = "transport-profile";
}

MplsTe::TransportProfile::Fault::~Fault()
{
}

bool MplsTe::TransportProfile::Fault::has_data() const
{
    return refresh_interval.is_set
	|| wait_to_restore_interval.is_set
	|| (protection_trigger !=  nullptr && protection_trigger->has_data());
}

bool MplsTe::TransportProfile::Fault::has_operation() const
{
    return is_set(operation)
	|| is_set(refresh_interval.operation)
	|| is_set(wait_to_restore_interval.operation)
	|| (protection_trigger !=  nullptr && protection_trigger->has_operation());
}

std::string MplsTe::TransportProfile::Fault::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "fault";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Fault::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (refresh_interval.is_set || is_set(refresh_interval.operation)) leaf_name_data.push_back(refresh_interval.get_name_leafdata());
    if (wait_to_restore_interval.is_set || is_set(wait_to_restore_interval.operation)) leaf_name_data.push_back(wait_to_restore_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Fault::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "protection-trigger")
    {
        if(protection_trigger != nullptr)
        {
            children["protection-trigger"] = protection_trigger.get();
        }
        else
        {
            protection_trigger = std::make_unique<MplsTe::TransportProfile::Fault::ProtectionTrigger>();
            protection_trigger->parent = this;
            children["protection-trigger"] = protection_trigger.get();
        }
        return children.at("protection-trigger");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Fault::get_children()
{
    if(children.find("protection-trigger") == children.end())
    {
        if(protection_trigger != nullptr)
        {
            children["protection-trigger"] = protection_trigger.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Fault::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "refresh-interval")
    {
        refresh_interval = value;
    }
    if(value_path == "wait-to-restore-interval")
    {
        wait_to_restore_interval = value;
    }
}

MplsTe::TransportProfile::Alarm::SuppressEvent::SuppressEvent()
    :
    	disable{YType::empty, "disable"}
{
    yang_name = "suppress-event"; yang_parent_name = "alarm";
}

MplsTe::TransportProfile::Alarm::SuppressEvent::~SuppressEvent()
{
}

bool MplsTe::TransportProfile::Alarm::SuppressEvent::has_data() const
{
    return disable.is_set;
}

bool MplsTe::TransportProfile::Alarm::SuppressEvent::has_operation() const
{
    return is_set(operation)
	|| is_set(disable.operation);
}

std::string MplsTe::TransportProfile::Alarm::SuppressEvent::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "suppress-event";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Alarm::SuppressEvent::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/alarm/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (disable.is_set || is_set(disable.operation)) leaf_name_data.push_back(disable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Alarm::SuppressEvent::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Alarm::SuppressEvent::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Alarm::SuppressEvent::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "disable")
    {
        disable = value;
    }
}

MplsTe::TransportProfile::Alarm::Alarm()
    :
    	enable_alarm{YType::empty, "enable-alarm"},
	 soak_time{YType::uint32, "soak-time"}
    	,
    suppress_event(std::make_unique<MplsTe::TransportProfile::Alarm::SuppressEvent>())
{
    suppress_event->parent = this;
    children["suppress-event"] = suppress_event.get();

    yang_name = "alarm"; yang_parent_name = "transport-profile";
}

MplsTe::TransportProfile::Alarm::~Alarm()
{
}

bool MplsTe::TransportProfile::Alarm::has_data() const
{
    return enable_alarm.is_set
	|| soak_time.is_set
	|| (suppress_event !=  nullptr && suppress_event->has_data());
}

bool MplsTe::TransportProfile::Alarm::has_operation() const
{
    return is_set(operation)
	|| is_set(enable_alarm.operation)
	|| is_set(soak_time.operation)
	|| (suppress_event !=  nullptr && suppress_event->has_operation());
}

std::string MplsTe::TransportProfile::Alarm::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "alarm";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Alarm::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable_alarm.is_set || is_set(enable_alarm.operation)) leaf_name_data.push_back(enable_alarm.get_name_leafdata());
    if (soak_time.is_set || is_set(soak_time.operation)) leaf_name_data.push_back(soak_time.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Alarm::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "suppress-event")
    {
        if(suppress_event != nullptr)
        {
            children["suppress-event"] = suppress_event.get();
        }
        else
        {
            suppress_event = std::make_unique<MplsTe::TransportProfile::Alarm::SuppressEvent>();
            suppress_event->parent = this;
            children["suppress-event"] = suppress_event.get();
        }
        return children.at("suppress-event");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Alarm::get_children()
{
    if(children.find("suppress-event") == children.end())
    {
        if(suppress_event != nullptr)
        {
            children["suppress-event"] = suppress_event.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Alarm::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable-alarm")
    {
        enable_alarm = value;
    }
    if(value_path == "soak-time")
    {
        soak_time = value;
    }
}

MplsTe::TransportProfile::Bfd::MinIntervalStandby::MinIntervalStandby()
    :
    	interval_standby_ms{YType::uint32, "interval-standby-ms"},
	 interval_standby_us{YType::uint32, "interval-standby-us"}
{
    yang_name = "min-interval-standby"; yang_parent_name = "bfd";
}

MplsTe::TransportProfile::Bfd::MinIntervalStandby::~MinIntervalStandby()
{
}

bool MplsTe::TransportProfile::Bfd::MinIntervalStandby::has_data() const
{
    return interval_standby_ms.is_set
	|| interval_standby_us.is_set;
}

bool MplsTe::TransportProfile::Bfd::MinIntervalStandby::has_operation() const
{
    return is_set(operation)
	|| is_set(interval_standby_ms.operation)
	|| is_set(interval_standby_us.operation);
}

std::string MplsTe::TransportProfile::Bfd::MinIntervalStandby::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "min-interval-standby";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Bfd::MinIntervalStandby::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interval_standby_ms.is_set || is_set(interval_standby_ms.operation)) leaf_name_data.push_back(interval_standby_ms.get_name_leafdata());
    if (interval_standby_us.is_set || is_set(interval_standby_us.operation)) leaf_name_data.push_back(interval_standby_us.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Bfd::MinIntervalStandby::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Bfd::MinIntervalStandby::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Bfd::MinIntervalStandby::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interval-standby-ms")
    {
        interval_standby_ms = value;
    }
    if(value_path == "interval-standby-us")
    {
        interval_standby_us = value;
    }
}

MplsTe::TransportProfile::Bfd::MinInterval::MinInterval()
    :
    	interval_ms{YType::uint32, "interval-ms"},
	 interval_us{YType::uint32, "interval-us"}
{
    yang_name = "min-interval"; yang_parent_name = "bfd";
}

MplsTe::TransportProfile::Bfd::MinInterval::~MinInterval()
{
}

bool MplsTe::TransportProfile::Bfd::MinInterval::has_data() const
{
    return interval_ms.is_set
	|| interval_us.is_set;
}

bool MplsTe::TransportProfile::Bfd::MinInterval::has_operation() const
{
    return is_set(operation)
	|| is_set(interval_ms.operation)
	|| is_set(interval_us.operation);
}

std::string MplsTe::TransportProfile::Bfd::MinInterval::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "min-interval";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Bfd::MinInterval::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interval_ms.is_set || is_set(interval_ms.operation)) leaf_name_data.push_back(interval_ms.get_name_leafdata());
    if (interval_us.is_set || is_set(interval_us.operation)) leaf_name_data.push_back(interval_us.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Bfd::MinInterval::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Bfd::MinInterval::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Bfd::MinInterval::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interval-ms")
    {
        interval_ms = value;
    }
    if(value_path == "interval-us")
    {
        interval_us = value;
    }
}

MplsTe::TransportProfile::Bfd::Bfd()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_multiplier_standby{YType::uint32, "detection-multiplier-standby"}
    	,
    min_interval(std::make_unique<MplsTe::TransportProfile::Bfd::MinInterval>())
	,min_interval_standby(std::make_unique<MplsTe::TransportProfile::Bfd::MinIntervalStandby>())
{
    min_interval->parent = this;
    children["min-interval"] = min_interval.get();

    min_interval_standby->parent = this;
    children["min-interval-standby"] = min_interval_standby.get();

    yang_name = "bfd"; yang_parent_name = "transport-profile";
}

MplsTe::TransportProfile::Bfd::~Bfd()
{
}

bool MplsTe::TransportProfile::Bfd::has_data() const
{
    return detection_multiplier.is_set
	|| detection_multiplier_standby.is_set
	|| (min_interval !=  nullptr && min_interval->has_data())
	|| (min_interval_standby !=  nullptr && min_interval_standby->has_data());
}

bool MplsTe::TransportProfile::Bfd::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_multiplier_standby.operation)
	|| (min_interval !=  nullptr && min_interval->has_operation())
	|| (min_interval_standby !=  nullptr && min_interval_standby->has_operation());
}

std::string MplsTe::TransportProfile::Bfd::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Bfd::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_multiplier_standby.is_set || is_set(detection_multiplier_standby.operation)) leaf_name_data.push_back(detection_multiplier_standby.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Bfd::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "min-interval")
    {
        if(min_interval != nullptr)
        {
            children["min-interval"] = min_interval.get();
        }
        else
        {
            min_interval = std::make_unique<MplsTe::TransportProfile::Bfd::MinInterval>();
            min_interval->parent = this;
            children["min-interval"] = min_interval.get();
        }
        return children.at("min-interval");
    }

    if(child_yang_name == "min-interval-standby")
    {
        if(min_interval_standby != nullptr)
        {
            children["min-interval-standby"] = min_interval_standby.get();
        }
        else
        {
            min_interval_standby = std::make_unique<MplsTe::TransportProfile::Bfd::MinIntervalStandby>();
            min_interval_standby->parent = this;
            children["min-interval-standby"] = min_interval_standby.get();
        }
        return children.at("min-interval-standby");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Bfd::get_children()
{
    if(children.find("min-interval") == children.end())
    {
        if(min_interval != nullptr)
        {
            children["min-interval"] = min_interval.get();
        }
    }

    if(children.find("min-interval-standby") == children.end())
    {
        if(min_interval_standby != nullptr)
        {
            children["min-interval-standby"] = min_interval_standby.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Bfd::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-multiplier-standby")
    {
        detection_multiplier_standby = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::Source::Source()
    :
    	global_id{YType::uint32, "global-id"},
	 node_id{YType::str, "node-id"},
	 tunnel_id{YType::uint32, "tunnel-id"}
{
    yang_name = "source"; yang_parent_name = "midpoint";
}

MplsTe::TransportProfile::Midpoints::Midpoint::Source::~Source()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::Source::has_data() const
{
    return global_id.is_set
	|| node_id.is_set
	|| tunnel_id.is_set;
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::Source::has_operation() const
{
    return is_set(operation)
	|| is_set(global_id.operation)
	|| is_set(node_id.operation)
	|| is_set(tunnel_id.operation);
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::Source::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::Source::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (global_id.is_set || is_set(global_id.operation)) leaf_name_data.push_back(global_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (tunnel_id.is_set || is_set(tunnel_id.operation)) leaf_name_data.push_back(tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::Source::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::Source::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::Source::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "global-id")
    {
        global_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "tunnel-id")
    {
        tunnel_id = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::Destination::Destination()
    :
    	global_id{YType::uint32, "global-id"},
	 node_id{YType::str, "node-id"},
	 tunnel_id{YType::uint32, "tunnel-id"}
{
    yang_name = "destination"; yang_parent_name = "midpoint";
}

MplsTe::TransportProfile::Midpoints::Midpoint::Destination::~Destination()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::Destination::has_data() const
{
    return global_id.is_set
	|| node_id.is_set
	|| tunnel_id.is_set;
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::Destination::has_operation() const
{
    return is_set(operation)
	|| is_set(global_id.operation)
	|| is_set(node_id.operation)
	|| is_set(tunnel_id.operation);
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::Destination::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "destination";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::Destination::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (global_id.is_set || is_set(global_id.operation)) leaf_name_data.push_back(global_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (tunnel_id.is_set || is_set(tunnel_id.operation)) leaf_name_data.push_back(tunnel_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::Destination::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::Destination::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::Destination::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "global-id")
    {
        global_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "tunnel-id")
    {
        tunnel_id = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::ForwardIoMap()
    :
    	in_label{YType::uint32, "in-label"},
	 out_label{YType::uint32, "out-label"},
	 out_link{YType::uint32, "out-link"}
{
    yang_name = "forward-io-map"; yang_parent_name = "forward-lsp";
}

MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::~ForwardIoMap()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::has_data() const
{
    return in_label.is_set
	|| out_label.is_set
	|| out_link.is_set;
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::has_operation() const
{
    return is_set(operation)
	|| is_set(in_label.operation)
	|| is_set(out_label.operation)
	|| is_set(out_link.operation);
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "forward-io-map";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (in_label.is_set || is_set(in_label.operation)) leaf_name_data.push_back(in_label.get_name_leafdata());
    if (out_label.is_set || is_set(out_label.operation)) leaf_name_data.push_back(out_label.get_name_leafdata());
    if (out_link.is_set || is_set(out_link.operation)) leaf_name_data.push_back(out_link.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "in-label")
    {
        in_label = value;
    }
    if(value_path == "out-label")
    {
        out_label = value;
    }
    if(value_path == "out-link")
    {
        out_link = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardLsp()
    :
    	forward_bandwidth{YType::uint32, "forward-bandwidth"}
    	,
    forward_io_map(nullptr) // presence node
{
    yang_name = "forward-lsp"; yang_parent_name = "midpoint";
}

MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::~ForwardLsp()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::has_data() const
{
    return forward_bandwidth.is_set
	|| (forward_io_map !=  nullptr && forward_io_map->has_data());
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::has_operation() const
{
    return is_set(operation)
	|| is_set(forward_bandwidth.operation)
	|| (forward_io_map !=  nullptr && forward_io_map->has_operation());
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "forward-lsp";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (forward_bandwidth.is_set || is_set(forward_bandwidth.operation)) leaf_name_data.push_back(forward_bandwidth.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "forward-io-map")
    {
        if(forward_io_map != nullptr)
        {
            children["forward-io-map"] = forward_io_map.get();
        }
        else
        {
            forward_io_map = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::ForwardIoMap>();
            forward_io_map->parent = this;
            children["forward-io-map"] = forward_io_map.get();
        }
        return children.at("forward-io-map");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::get_children()
{
    if(children.find("forward-io-map") == children.end())
    {
        if(forward_io_map != nullptr)
        {
            children["forward-io-map"] = forward_io_map.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "forward-bandwidth")
    {
        forward_bandwidth = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::ReverseIoMap()
    :
    	in_label{YType::uint32, "in-label"},
	 out_label{YType::uint32, "out-label"},
	 out_link{YType::uint32, "out-link"}
{
    yang_name = "reverse-io-map"; yang_parent_name = "reverse-lsp";
}

MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::~ReverseIoMap()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::has_data() const
{
    return in_label.is_set
	|| out_label.is_set
	|| out_link.is_set;
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::has_operation() const
{
    return is_set(operation)
	|| is_set(in_label.operation)
	|| is_set(out_label.operation)
	|| is_set(out_link.operation);
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reverse-io-map";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (in_label.is_set || is_set(in_label.operation)) leaf_name_data.push_back(in_label.get_name_leafdata());
    if (out_label.is_set || is_set(out_label.operation)) leaf_name_data.push_back(out_label.get_name_leafdata());
    if (out_link.is_set || is_set(out_link.operation)) leaf_name_data.push_back(out_link.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::get_children()
{
    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "in-label")
    {
        in_label = value;
    }
    if(value_path == "out-label")
    {
        out_label = value;
    }
    if(value_path == "out-link")
    {
        out_link = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseLsp()
    :
    	reverse_bandwidth{YType::uint32, "reverse-bandwidth"}
    	,
    reverse_io_map(nullptr) // presence node
{
    yang_name = "reverse-lsp"; yang_parent_name = "midpoint";
}

MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::~ReverseLsp()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::has_data() const
{
    return reverse_bandwidth.is_set
	|| (reverse_io_map !=  nullptr && reverse_io_map->has_data());
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::has_operation() const
{
    return is_set(operation)
	|| is_set(reverse_bandwidth.operation)
	|| (reverse_io_map !=  nullptr && reverse_io_map->has_operation());
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "reverse-lsp";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (reverse_bandwidth.is_set || is_set(reverse_bandwidth.operation)) leaf_name_data.push_back(reverse_bandwidth.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "reverse-io-map")
    {
        if(reverse_io_map != nullptr)
        {
            children["reverse-io-map"] = reverse_io_map.get();
        }
        else
        {
            reverse_io_map = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::ReverseIoMap>();
            reverse_io_map->parent = this;
            children["reverse-io-map"] = reverse_io_map.get();
        }
        return children.at("reverse-io-map");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::get_children()
{
    if(children.find("reverse-io-map") == children.end())
    {
        if(reverse_io_map != nullptr)
        {
            children["reverse-io-map"] = reverse_io_map.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "reverse-bandwidth")
    {
        reverse_bandwidth = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoint::Midpoint()
    :
    	midpoint_name{YType::str, "midpoint-name"},
	 lsp_id{YType::uint32, "lsp-id"},
	 lsp_protect{YType::empty, "lsp-protect"},
	 tunnel_name{YType::str, "tunnel-name"}
    	,
    destination(nullptr) // presence node
	,forward_lsp(std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp>())
	,reverse_lsp(std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp>())
	,source(nullptr) // presence node
{
    forward_lsp->parent = this;
    children["forward-lsp"] = forward_lsp.get();

    reverse_lsp->parent = this;
    children["reverse-lsp"] = reverse_lsp.get();

    yang_name = "midpoint"; yang_parent_name = "midpoints";
}

MplsTe::TransportProfile::Midpoints::Midpoint::~Midpoint()
{
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::has_data() const
{
    return midpoint_name.is_set
	|| lsp_id.is_set
	|| lsp_protect.is_set
	|| tunnel_name.is_set
	|| (destination !=  nullptr && destination->has_data())
	|| (forward_lsp !=  nullptr && forward_lsp->has_data())
	|| (reverse_lsp !=  nullptr && reverse_lsp->has_data())
	|| (source !=  nullptr && source->has_data());
}

bool MplsTe::TransportProfile::Midpoints::Midpoint::has_operation() const
{
    return is_set(operation)
	|| is_set(midpoint_name.operation)
	|| is_set(lsp_id.operation)
	|| is_set(lsp_protect.operation)
	|| is_set(tunnel_name.operation)
	|| (destination !=  nullptr && destination->has_operation())
	|| (forward_lsp !=  nullptr && forward_lsp->has_operation())
	|| (reverse_lsp !=  nullptr && reverse_lsp->has_operation())
	|| (source !=  nullptr && source->has_operation());
}

std::string MplsTe::TransportProfile::Midpoints::Midpoint::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "midpoint" <<"[midpoint-name='" <<midpoint_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::Midpoint::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/midpoints/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (midpoint_name.is_set || is_set(midpoint_name.operation)) leaf_name_data.push_back(midpoint_name.get_name_leafdata());
    if (lsp_id.is_set || is_set(lsp_id.operation)) leaf_name_data.push_back(lsp_id.get_name_leafdata());
    if (lsp_protect.is_set || is_set(lsp_protect.operation)) leaf_name_data.push_back(lsp_protect.get_name_leafdata());
    if (tunnel_name.is_set || is_set(tunnel_name.operation)) leaf_name_data.push_back(tunnel_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::Midpoint::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "destination")
    {
        if(destination != nullptr)
        {
            children["destination"] = destination.get();
        }
        else
        {
            destination = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::Destination>();
            destination->parent = this;
            children["destination"] = destination.get();
        }
        return children.at("destination");
    }

    if(child_yang_name == "forward-lsp")
    {
        if(forward_lsp != nullptr)
        {
            children["forward-lsp"] = forward_lsp.get();
        }
        else
        {
            forward_lsp = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::ForwardLsp>();
            forward_lsp->parent = this;
            children["forward-lsp"] = forward_lsp.get();
        }
        return children.at("forward-lsp");
    }

    if(child_yang_name == "reverse-lsp")
    {
        if(reverse_lsp != nullptr)
        {
            children["reverse-lsp"] = reverse_lsp.get();
        }
        else
        {
            reverse_lsp = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::ReverseLsp>();
            reverse_lsp->parent = this;
            children["reverse-lsp"] = reverse_lsp.get();
        }
        return children.at("reverse-lsp");
    }

    if(child_yang_name == "source")
    {
        if(source != nullptr)
        {
            children["source"] = source.get();
        }
        else
        {
            source = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint::Source>();
            source->parent = this;
            children["source"] = source.get();
        }
        return children.at("source");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::Midpoint::get_children()
{
    if(children.find("destination") == children.end())
    {
        if(destination != nullptr)
        {
            children["destination"] = destination.get();
        }
    }

    if(children.find("forward-lsp") == children.end())
    {
        if(forward_lsp != nullptr)
        {
            children["forward-lsp"] = forward_lsp.get();
        }
    }

    if(children.find("reverse-lsp") == children.end())
    {
        if(reverse_lsp != nullptr)
        {
            children["reverse-lsp"] = reverse_lsp.get();
        }
    }

    if(children.find("source") == children.end())
    {
        if(source != nullptr)
        {
            children["source"] = source.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Midpoints::Midpoint::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "midpoint-name")
    {
        midpoint_name = value;
    }
    if(value_path == "lsp-id")
    {
        lsp_id = value;
    }
    if(value_path == "lsp-protect")
    {
        lsp_protect = value;
    }
    if(value_path == "tunnel-name")
    {
        tunnel_name = value;
    }
}

MplsTe::TransportProfile::Midpoints::Midpoints()
{
    yang_name = "midpoints"; yang_parent_name = "transport-profile";
}

MplsTe::TransportProfile::Midpoints::~Midpoints()
{
}

bool MplsTe::TransportProfile::Midpoints::has_data() const
{
    for (std::size_t index=0; index<midpoint.size(); index++)
    {
        if(midpoint[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::TransportProfile::Midpoints::has_operation() const
{
    for (std::size_t index=0; index<midpoint.size(); index++)
    {
        if(midpoint[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::TransportProfile::Midpoints::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "midpoints";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::Midpoints::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/transport-profile/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::Midpoints::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "midpoint")
    {
        for(auto const & c : midpoint)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::TransportProfile::Midpoints::Midpoint>();
        c->parent = this;
        midpoint.push_back(std::move(c));
        children[segment_path] = midpoint.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::Midpoints::get_children()
{
    for (auto const & c : midpoint)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::Midpoints::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::TransportProfile::TransportProfile()
    :
    	global_id{YType::uint32, "global-id"},
	 node_id{YType::str, "node-id"}
    	,
    alarm(std::make_unique<MplsTe::TransportProfile::Alarm>())
	,bfd(std::make_unique<MplsTe::TransportProfile::Bfd>())
	,fault(std::make_unique<MplsTe::TransportProfile::Fault>())
	,midpoints(std::make_unique<MplsTe::TransportProfile::Midpoints>())
{
    alarm->parent = this;
    children["alarm"] = alarm.get();

    bfd->parent = this;
    children["bfd"] = bfd.get();

    fault->parent = this;
    children["fault"] = fault.get();

    midpoints->parent = this;
    children["midpoints"] = midpoints.get();

    yang_name = "transport-profile"; yang_parent_name = "mpls-te";
}

MplsTe::TransportProfile::~TransportProfile()
{
}

bool MplsTe::TransportProfile::has_data() const
{
    return global_id.is_set
	|| node_id.is_set
	|| (alarm !=  nullptr && alarm->has_data())
	|| (bfd !=  nullptr && bfd->has_data())
	|| (fault !=  nullptr && fault->has_data())
	|| (midpoints !=  nullptr && midpoints->has_data());
}

bool MplsTe::TransportProfile::has_operation() const
{
    return is_set(operation)
	|| is_set(global_id.operation)
	|| is_set(node_id.operation)
	|| (alarm !=  nullptr && alarm->has_operation())
	|| (bfd !=  nullptr && bfd->has_operation())
	|| (fault !=  nullptr && fault->has_operation())
	|| (midpoints !=  nullptr && midpoints->has_operation());
}

std::string MplsTe::TransportProfile::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transport-profile";

    return path_buffer.str();

}

EntityPath MplsTe::TransportProfile::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (global_id.is_set || is_set(global_id.operation)) leaf_name_data.push_back(global_id.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::TransportProfile::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "alarm")
    {
        if(alarm != nullptr)
        {
            children["alarm"] = alarm.get();
        }
        else
        {
            alarm = std::make_unique<MplsTe::TransportProfile::Alarm>();
            alarm->parent = this;
            children["alarm"] = alarm.get();
        }
        return children.at("alarm");
    }

    if(child_yang_name == "bfd")
    {
        if(bfd != nullptr)
        {
            children["bfd"] = bfd.get();
        }
        else
        {
            bfd = std::make_unique<MplsTe::TransportProfile::Bfd>();
            bfd->parent = this;
            children["bfd"] = bfd.get();
        }
        return children.at("bfd");
    }

    if(child_yang_name == "fault")
    {
        if(fault != nullptr)
        {
            children["fault"] = fault.get();
        }
        else
        {
            fault = std::make_unique<MplsTe::TransportProfile::Fault>();
            fault->parent = this;
            children["fault"] = fault.get();
        }
        return children.at("fault");
    }

    if(child_yang_name == "midpoints")
    {
        if(midpoints != nullptr)
        {
            children["midpoints"] = midpoints.get();
        }
        else
        {
            midpoints = std::make_unique<MplsTe::TransportProfile::Midpoints>();
            midpoints->parent = this;
            children["midpoints"] = midpoints.get();
        }
        return children.at("midpoints");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::TransportProfile::get_children()
{
    if(children.find("alarm") == children.end())
    {
        if(alarm != nullptr)
        {
            children["alarm"] = alarm.get();
        }
    }

    if(children.find("bfd") == children.end())
    {
        if(bfd != nullptr)
        {
            children["bfd"] = bfd.get();
        }
    }

    if(children.find("fault") == children.end())
    {
        if(fault != nullptr)
        {
            children["fault"] = fault.get();
        }
    }

    if(children.find("midpoints") == children.end())
    {
        if(midpoints != nullptr)
        {
            children["midpoints"] = midpoints.get();
        }
    }

    return children;
}

void MplsTe::TransportProfile::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "global-id")
    {
        global_id = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
}

MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::Link()
    :
    	link_id{YType::uint32, "link-id"},
	 next_hop_address{YType::str, "next-hop-address"},
	 next_hop_type{YType::enumeration, "next-hop-type"}
{
    yang_name = "link"; yang_parent_name = "links";
}

MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::~Link()
{
}

bool MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::has_data() const
{
    return link_id.is_set
	|| next_hop_address.is_set
	|| next_hop_type.is_set;
}

bool MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::has_operation() const
{
    return is_set(operation)
	|| is_set(link_id.operation)
	|| is_set(next_hop_address.operation)
	|| is_set(next_hop_type.operation);
}

std::string MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link" <<"[link-id='" <<link_id.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (link_id.is_set || is_set(link_id.operation)) leaf_name_data.push_back(link_id.get_name_leafdata());
    if (next_hop_address.is_set || is_set(next_hop_address.operation)) leaf_name_data.push_back(next_hop_address.get_name_leafdata());
    if (next_hop_type.is_set || is_set(next_hop_type.operation)) leaf_name_data.push_back(next_hop_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "link-id")
    {
        link_id = value;
    }
    if(value_path == "next-hop-address")
    {
        next_hop_address = value;
    }
    if(value_path == "next-hop-type")
    {
        next_hop_type = value;
    }
}

MplsTe::Interfaces::Interface::TransportProfileLink::Links::Links()
{
    yang_name = "links"; yang_parent_name = "transport-profile-link";
}

MplsTe::Interfaces::Interface::TransportProfileLink::Links::~Links()
{
}

bool MplsTe::Interfaces::Interface::TransportProfileLink::Links::has_data() const
{
    for (std::size_t index=0; index<link.size(); index++)
    {
        if(link[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::TransportProfileLink::Links::has_operation() const
{
    for (std::size_t index=0; index<link.size(); index++)
    {
        if(link[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::Interface::TransportProfileLink::Links::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "links";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::TransportProfileLink::Links::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::TransportProfileLink::Links::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "link")
    {
        for(auto const & c : link)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface::TransportProfileLink::Links::Link>();
        c->parent = this;
        link.push_back(std::move(c));
        children[segment_path] = link.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::TransportProfileLink::Links::get_children()
{
    for (auto const & c : link)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::TransportProfileLink::Links::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::TransportProfileLink::TransportProfileLink()
    :
    links(std::make_unique<MplsTe::Interfaces::Interface::TransportProfileLink::Links>())
{
    links->parent = this;
    children["links"] = links.get();

    yang_name = "transport-profile-link"; yang_parent_name = "interface";
}

MplsTe::Interfaces::Interface::TransportProfileLink::~TransportProfileLink()
{
}

bool MplsTe::Interfaces::Interface::TransportProfileLink::has_data() const
{
    return (links !=  nullptr && links->has_data());
}

bool MplsTe::Interfaces::Interface::TransportProfileLink::has_operation() const
{
    return is_set(operation)
	|| (links !=  nullptr && links->has_operation());
}

std::string MplsTe::Interfaces::Interface::TransportProfileLink::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transport-profile-link";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::TransportProfileLink::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::TransportProfileLink::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "links")
    {
        if(links != nullptr)
        {
            children["links"] = links.get();
        }
        else
        {
            links = std::make_unique<MplsTe::Interfaces::Interface::TransportProfileLink::Links>();
            links->parent = this;
            children["links"] = links.get();
        }
        return children.at("links");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::TransportProfileLink::get_children()
{
    if(children.find("links") == children.end())
    {
        if(links != nullptr)
        {
            children["links"] = links.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::TransportProfileLink::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::Switching()
    :
    	switching_id{YType::str, "switching-id"},
	 capability{YType::enumeration, "capability"},
	 encoding{YType::enumeration, "encoding"}
{
    yang_name = "switching"; yang_parent_name = "switchings";
}

MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::~Switching()
{
}

bool MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::has_data() const
{
    return switching_id.is_set
	|| capability.is_set
	|| encoding.is_set;
}

bool MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::has_operation() const
{
    return is_set(operation)
	|| is_set(switching_id.operation)
	|| is_set(capability.operation)
	|| is_set(encoding.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "switching" <<"[switching-id='" <<switching_id.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (switching_id.is_set || is_set(switching_id.operation)) leaf_name_data.push_back(switching_id.get_name_leafdata());
    if (capability.is_set || is_set(capability.operation)) leaf_name_data.push_back(capability.get_name_leafdata());
    if (encoding.is_set || is_set(encoding.operation)) leaf_name_data.push_back(encoding.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::Switchings::Switching::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "switching-id")
    {
        switching_id = value;
    }
    if(value_path == "capability")
    {
        capability = value;
    }
    if(value_path == "encoding")
    {
        encoding = value;
    }
}

MplsTe::Interfaces::Interface::Lcac::Switchings::Switchings()
{
    yang_name = "switchings"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::Switchings::~Switchings()
{
}

bool MplsTe::Interfaces::Interface::Lcac::Switchings::has_data() const
{
    for (std::size_t index=0; index<switching.size(); index++)
    {
        if(switching[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::Lcac::Switchings::has_operation() const
{
    for (std::size_t index=0; index<switching.size(); index++)
    {
        if(switching[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::Switchings::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "switchings";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::Switchings::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::Switchings::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "switching")
    {
        for(auto const & c : switching)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface::Lcac::Switchings::Switching>();
        c->parent = this;
        switching.push_back(std::move(c));
        children[segment_path] = switching.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::Switchings::get_children()
{
    for (auto const & c : switching)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::Lcac::Switchings::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::Lcac::FloodArea::FloodArea()
    :
    	area_id{YType::int32, "area-id"},
	 igp_type{YType::enumeration, "igp-type"},
	 process_name{YType::str, "process-name"}
{
    yang_name = "flood-area"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::FloodArea::~FloodArea()
{
}

bool MplsTe::Interfaces::Interface::Lcac::FloodArea::has_data() const
{
    return area_id.is_set
	|| igp_type.is_set
	|| process_name.is_set;
}

bool MplsTe::Interfaces::Interface::Lcac::FloodArea::has_operation() const
{
    return is_set(operation)
	|| is_set(area_id.operation)
	|| is_set(igp_type.operation)
	|| is_set(process_name.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::FloodArea::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "flood-area";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::FloodArea::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (area_id.is_set || is_set(area_id.operation)) leaf_name_data.push_back(area_id.get_name_leafdata());
    if (igp_type.is_set || is_set(igp_type.operation)) leaf_name_data.push_back(igp_type.get_name_leafdata());
    if (process_name.is_set || is_set(process_name.operation)) leaf_name_data.push_back(process_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::FloodArea::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::FloodArea::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::FloodArea::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "area-id")
    {
        area_id = value;
    }
    if(value_path == "igp-type")
    {
        igp_type = value;
    }
    if(value_path == "process-name")
    {
        process_name = value;
    }
}

MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::AttributeNameXr()
    :
    	attribute_name{YType::str, "attribute-name"}
{
    yang_name = "attribute-name-xr"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::~AttributeNameXr()
{
}

bool MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::has_data() const
{
    for (auto const & leaf : attribute_name.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::has_operation() const
{
    for (auto const & leaf : attribute_name.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(attribute_name.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "attribute-name-xr";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto attribute_name_name_datas = attribute_name.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), attribute_name_name_datas.begin(), attribute_name_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::AttributeNameXr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-name")
    {
        attribute_name.append(value);
    }
}

MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::AttributeName()
    :
    	affinity_index{YType::uint32, "affinity-index"},
	 value_{YType::str, "value"}
{
    yang_name = "attribute-name"; yang_parent_name = "attribute-names";
}

MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::~AttributeName()
{
}

bool MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::has_data() const
{
    for (auto const & leaf : value_.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return affinity_index.is_set;
}

bool MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::has_operation() const
{
    for (auto const & leaf : value_.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(affinity_index.operation)
	|| is_set(value_.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "attribute-name" <<"[affinity-index='" <<affinity_index.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (affinity_index.is_set || is_set(affinity_index.operation)) leaf_name_data.push_back(affinity_index.get_name_leafdata());

    auto value__name_datas = value_.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), value__name_datas.begin(), value__name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "affinity-index")
    {
        affinity_index = value;
    }
    if(value_path == "value")
    {
        value_.append(value);
    }
}

MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeNames()
{
    yang_name = "attribute-names"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::AttributeNames::~AttributeNames()
{
}

bool MplsTe::Interfaces::Interface::Lcac::AttributeNames::has_data() const
{
    for (std::size_t index=0; index<attribute_name.size(); index++)
    {
        if(attribute_name[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::Lcac::AttributeNames::has_operation() const
{
    for (std::size_t index=0; index<attribute_name.size(); index++)
    {
        if(attribute_name[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::AttributeNames::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "attribute-names";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::AttributeNames::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::AttributeNames::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "attribute-name")
    {
        for(auto const & c : attribute_name)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface::Lcac::AttributeNames::AttributeName>();
        c->parent = this;
        attribute_name.push_back(std::move(c));
        children[segment_path] = attribute_name.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::AttributeNames::get_children()
{
    for (auto const & c : attribute_name)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::Lcac::AttributeNames::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::Srlg()
    :
    	srlg_number{YType::uint32, "srlg-number"}
{
    yang_name = "srlg"; yang_parent_name = "srlgs";
}

MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::~Srlg()
{
}

bool MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::has_data() const
{
    return srlg_number.is_set;
}

bool MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::has_operation() const
{
    return is_set(operation)
	|| is_set(srlg_number.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srlg" <<"[srlg-number='" <<srlg_number.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srlg_number.is_set || is_set(srlg_number.operation)) leaf_name_data.push_back(srlg_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srlg-number")
    {
        srlg_number = value;
    }
}

MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlgs()
{
    yang_name = "srlgs"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::Srlgs::~Srlgs()
{
}

bool MplsTe::Interfaces::Interface::Lcac::Srlgs::has_data() const
{
    for (std::size_t index=0; index<srlg.size(); index++)
    {
        if(srlg[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::Lcac::Srlgs::has_operation() const
{
    for (std::size_t index=0; index<srlg.size(); index++)
    {
        if(srlg[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::Srlgs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "srlgs";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::Srlgs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::Srlgs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "srlg")
    {
        for(auto const & c : srlg)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface::Lcac::Srlgs::Srlg>();
        c->parent = this;
        srlg.push_back(std::move(c));
        children[segment_path] = srlg.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::Srlgs::get_children()
{
    for (auto const & c : srlg)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::Lcac::Srlgs::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::Lcac::UpThresholds::UpThresholds()
    :
    	up_threshold{YType::uint32, "up-threshold"}
{
    yang_name = "up-thresholds"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::UpThresholds::~UpThresholds()
{
}

bool MplsTe::Interfaces::Interface::Lcac::UpThresholds::has_data() const
{
    for (auto const & leaf : up_threshold.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::Lcac::UpThresholds::has_operation() const
{
    for (auto const & leaf : up_threshold.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(up_threshold.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::UpThresholds::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "up-thresholds";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::UpThresholds::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto up_threshold_name_datas = up_threshold.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), up_threshold_name_datas.begin(), up_threshold_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::UpThresholds::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::UpThresholds::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::UpThresholds::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "up-threshold")
    {
        up_threshold.append(value);
    }
}

MplsTe::Interfaces::Interface::Lcac::DownThresholds::DownThresholds()
    :
    	down_threshold{YType::uint32, "down-threshold"}
{
    yang_name = "down-thresholds"; yang_parent_name = "lcac";
}

MplsTe::Interfaces::Interface::Lcac::DownThresholds::~DownThresholds()
{
}

bool MplsTe::Interfaces::Interface::Lcac::DownThresholds::has_data() const
{
    for (auto const & leaf : down_threshold.getYLeafs())
    {
        if(leaf.is_set)
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::Lcac::DownThresholds::has_operation() const
{
    for (auto const & leaf : down_threshold.getYLeafs())
    {
        if(is_set(leaf.operation))
            return true;
    }
    return is_set(operation)
	|| is_set(down_threshold.operation);
}

std::string MplsTe::Interfaces::Interface::Lcac::DownThresholds::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "down-thresholds";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::DownThresholds::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    auto down_threshold_name_datas = down_threshold.get_name_leafdata();
    leaf_name_data.insert(leaf_name_data.end(), down_threshold_name_datas.begin(), down_threshold_name_datas.end());

    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::DownThresholds::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::DownThresholds::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::Lcac::DownThresholds::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-threshold")
    {
        down_threshold.append(value);
    }
}

MplsTe::Interfaces::Interface::Lcac::Lcac()
    :
    	admin_weight{YType::int32, "admin-weight"},
	 attribute_flags{YType::str, "attribute-flags"},
	 bfd{YType::empty, "bfd"},
	 enable{YType::empty, "enable"},
	 fault_oam_lockout{YType::empty, "fault-oam-lockout"}
    	,
    attribute_name_xr(std::make_unique<MplsTe::Interfaces::Interface::Lcac::AttributeNameXr>())
	,attribute_names(std::make_unique<MplsTe::Interfaces::Interface::Lcac::AttributeNames>())
	,down_thresholds(std::make_unique<MplsTe::Interfaces::Interface::Lcac::DownThresholds>())
	,flood_area(std::make_unique<MplsTe::Interfaces::Interface::Lcac::FloodArea>())
	,srlgs(std::make_unique<MplsTe::Interfaces::Interface::Lcac::Srlgs>())
	,switchings(std::make_unique<MplsTe::Interfaces::Interface::Lcac::Switchings>())
	,up_thresholds(std::make_unique<MplsTe::Interfaces::Interface::Lcac::UpThresholds>())
{
    attribute_name_xr->parent = this;
    children["attribute-name-xr"] = attribute_name_xr.get();

    attribute_names->parent = this;
    children["attribute-names"] = attribute_names.get();

    down_thresholds->parent = this;
    children["down-thresholds"] = down_thresholds.get();

    flood_area->parent = this;
    children["flood-area"] = flood_area.get();

    srlgs->parent = this;
    children["srlgs"] = srlgs.get();

    switchings->parent = this;
    children["switchings"] = switchings.get();

    up_thresholds->parent = this;
    children["up-thresholds"] = up_thresholds.get();

    yang_name = "lcac"; yang_parent_name = "interface";
}

MplsTe::Interfaces::Interface::Lcac::~Lcac()
{
}

bool MplsTe::Interfaces::Interface::Lcac::has_data() const
{
    return admin_weight.is_set
	|| attribute_flags.is_set
	|| bfd.is_set
	|| enable.is_set
	|| fault_oam_lockout.is_set
	|| (attribute_name_xr !=  nullptr && attribute_name_xr->has_data())
	|| (attribute_names !=  nullptr && attribute_names->has_data())
	|| (down_thresholds !=  nullptr && down_thresholds->has_data())
	|| (flood_area !=  nullptr && flood_area->has_data())
	|| (srlgs !=  nullptr && srlgs->has_data())
	|| (switchings !=  nullptr && switchings->has_data())
	|| (up_thresholds !=  nullptr && up_thresholds->has_data());
}

bool MplsTe::Interfaces::Interface::Lcac::has_operation() const
{
    return is_set(operation)
	|| is_set(admin_weight.operation)
	|| is_set(attribute_flags.operation)
	|| is_set(bfd.operation)
	|| is_set(enable.operation)
	|| is_set(fault_oam_lockout.operation)
	|| (attribute_name_xr !=  nullptr && attribute_name_xr->has_operation())
	|| (attribute_names !=  nullptr && attribute_names->has_operation())
	|| (down_thresholds !=  nullptr && down_thresholds->has_operation())
	|| (flood_area !=  nullptr && flood_area->has_operation())
	|| (srlgs !=  nullptr && srlgs->has_operation())
	|| (switchings !=  nullptr && switchings->has_operation())
	|| (up_thresholds !=  nullptr && up_thresholds->has_operation());
}

std::string MplsTe::Interfaces::Interface::Lcac::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lcac";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::Lcac::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (admin_weight.is_set || is_set(admin_weight.operation)) leaf_name_data.push_back(admin_weight.get_name_leafdata());
    if (attribute_flags.is_set || is_set(attribute_flags.operation)) leaf_name_data.push_back(attribute_flags.get_name_leafdata());
    if (bfd.is_set || is_set(bfd.operation)) leaf_name_data.push_back(bfd.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (fault_oam_lockout.is_set || is_set(fault_oam_lockout.operation)) leaf_name_data.push_back(fault_oam_lockout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::Lcac::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "attribute-name-xr")
    {
        if(attribute_name_xr != nullptr)
        {
            children["attribute-name-xr"] = attribute_name_xr.get();
        }
        else
        {
            attribute_name_xr = std::make_unique<MplsTe::Interfaces::Interface::Lcac::AttributeNameXr>();
            attribute_name_xr->parent = this;
            children["attribute-name-xr"] = attribute_name_xr.get();
        }
        return children.at("attribute-name-xr");
    }

    if(child_yang_name == "attribute-names")
    {
        if(attribute_names != nullptr)
        {
            children["attribute-names"] = attribute_names.get();
        }
        else
        {
            attribute_names = std::make_unique<MplsTe::Interfaces::Interface::Lcac::AttributeNames>();
            attribute_names->parent = this;
            children["attribute-names"] = attribute_names.get();
        }
        return children.at("attribute-names");
    }

    if(child_yang_name == "down-thresholds")
    {
        if(down_thresholds != nullptr)
        {
            children["down-thresholds"] = down_thresholds.get();
        }
        else
        {
            down_thresholds = std::make_unique<MplsTe::Interfaces::Interface::Lcac::DownThresholds>();
            down_thresholds->parent = this;
            children["down-thresholds"] = down_thresholds.get();
        }
        return children.at("down-thresholds");
    }

    if(child_yang_name == "flood-area")
    {
        if(flood_area != nullptr)
        {
            children["flood-area"] = flood_area.get();
        }
        else
        {
            flood_area = std::make_unique<MplsTe::Interfaces::Interface::Lcac::FloodArea>();
            flood_area->parent = this;
            children["flood-area"] = flood_area.get();
        }
        return children.at("flood-area");
    }

    if(child_yang_name == "srlgs")
    {
        if(srlgs != nullptr)
        {
            children["srlgs"] = srlgs.get();
        }
        else
        {
            srlgs = std::make_unique<MplsTe::Interfaces::Interface::Lcac::Srlgs>();
            srlgs->parent = this;
            children["srlgs"] = srlgs.get();
        }
        return children.at("srlgs");
    }

    if(child_yang_name == "switchings")
    {
        if(switchings != nullptr)
        {
            children["switchings"] = switchings.get();
        }
        else
        {
            switchings = std::make_unique<MplsTe::Interfaces::Interface::Lcac::Switchings>();
            switchings->parent = this;
            children["switchings"] = switchings.get();
        }
        return children.at("switchings");
    }

    if(child_yang_name == "up-thresholds")
    {
        if(up_thresholds != nullptr)
        {
            children["up-thresholds"] = up_thresholds.get();
        }
        else
        {
            up_thresholds = std::make_unique<MplsTe::Interfaces::Interface::Lcac::UpThresholds>();
            up_thresholds->parent = this;
            children["up-thresholds"] = up_thresholds.get();
        }
        return children.at("up-thresholds");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::Lcac::get_children()
{
    if(children.find("attribute-name-xr") == children.end())
    {
        if(attribute_name_xr != nullptr)
        {
            children["attribute-name-xr"] = attribute_name_xr.get();
        }
    }

    if(children.find("attribute-names") == children.end())
    {
        if(attribute_names != nullptr)
        {
            children["attribute-names"] = attribute_names.get();
        }
    }

    if(children.find("down-thresholds") == children.end())
    {
        if(down_thresholds != nullptr)
        {
            children["down-thresholds"] = down_thresholds.get();
        }
    }

    if(children.find("flood-area") == children.end())
    {
        if(flood_area != nullptr)
        {
            children["flood-area"] = flood_area.get();
        }
    }

    if(children.find("srlgs") == children.end())
    {
        if(srlgs != nullptr)
        {
            children["srlgs"] = srlgs.get();
        }
    }

    if(children.find("switchings") == children.end())
    {
        if(switchings != nullptr)
        {
            children["switchings"] = switchings.get();
        }
    }

    if(children.find("up-thresholds") == children.end())
    {
        if(up_thresholds != nullptr)
        {
            children["up-thresholds"] = up_thresholds.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::Lcac::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "admin-weight")
    {
        admin_weight = value;
    }
    if(value_path == "attribute-flags")
    {
        attribute_flags = value;
    }
    if(value_path == "bfd")
    {
        bfd = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "fault-oam-lockout")
    {
        fault_oam_lockout = value;
    }
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::BackupTunnel()
    :
    	tunnel_name{YType::str, "tunnel-name"}
{
    yang_name = "backup-tunnel"; yang_parent_name = "backup-tunnels";
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::~BackupTunnel()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::has_data() const
{
    return tunnel_name.is_set;
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::has_operation() const
{
    return is_set(operation)
	|| is_set(tunnel_name.operation);
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-tunnel" <<"[tunnel-name='" <<tunnel_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tunnel_name.is_set || is_set(tunnel_name.operation)) leaf_name_data.push_back(tunnel_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tunnel-name")
    {
        tunnel_name = value;
    }
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnels()
{
    yang_name = "backup-tunnels"; yang_parent_name = "global-attributes";
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::~BackupTunnels()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::has_data() const
{
    for (std::size_t index=0; index<backup_tunnel.size(); index++)
    {
        if(backup_tunnel[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::has_operation() const
{
    for (std::size_t index=0; index<backup_tunnel.size(); index++)
    {
        if(backup_tunnel[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-tunnels";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-tunnel")
    {
        for(auto const & c : backup_tunnel)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::BackupTunnel>();
        c->parent = this;
        backup_tunnel.push_back(std::move(c));
        children[segment_path] = backup_tunnel.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::get_children()
{
    for (auto const & c : backup_tunnel)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::Exclude()
    :
    	srlg_mode{YType::enumeration, "srlg-mode"}
{
    yang_name = "exclude"; yang_parent_name = "backup";
}

MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::~Exclude()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::has_data() const
{
    return srlg_mode.is_set;
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::has_operation() const
{
    return is_set(operation)
	|| is_set(srlg_mode.operation);
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "exclude";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (srlg_mode.is_set || is_set(srlg_mode.operation)) leaf_name_data.push_back(srlg_mode.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "srlg-mode")
    {
        srlg_mode = value;
    }
}

MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Backup()
    :
    	attribute_set{YType::str, "attribute-set"},
	 enable{YType::empty, "enable"},
	 next_hop_only{YType::empty, "next-hop-only"}
    	,
    exclude(std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude>())
{
    exclude->parent = this;
    children["exclude"] = exclude.get();

    yang_name = "backup"; yang_parent_name = "auto-tunnel";
}

MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::~Backup()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::has_data() const
{
    return attribute_set.is_set
	|| enable.is_set
	|| next_hop_only.is_set
	|| (exclude !=  nullptr && exclude->has_data());
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::has_operation() const
{
    return is_set(operation)
	|| is_set(attribute_set.operation)
	|| is_set(enable.operation)
	|| is_set(next_hop_only.operation)
	|| (exclude !=  nullptr && exclude->has_operation());
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (attribute_set.is_set || is_set(attribute_set.operation)) leaf_name_data.push_back(attribute_set.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (next_hop_only.is_set || is_set(next_hop_only.operation)) leaf_name_data.push_back(next_hop_only.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "exclude")
    {
        if(exclude != nullptr)
        {
            children["exclude"] = exclude.get();
        }
        else
        {
            exclude = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::Exclude>();
            exclude->parent = this;
            children["exclude"] = exclude.get();
        }
        return children.at("exclude");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::get_children()
{
    if(children.find("exclude") == children.end())
    {
        if(exclude != nullptr)
        {
            children["exclude"] = exclude.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "attribute-set")
    {
        attribute_set = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "next-hop-only")
    {
        next_hop_only = value;
    }
}

MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::AutoTunnel()
    :
    backup(std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup>())
{
    backup->parent = this;
    children["backup"] = backup.get();

    yang_name = "auto-tunnel"; yang_parent_name = "global-attributes";
}

MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::~AutoTunnel()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::has_data() const
{
    return (backup !=  nullptr && backup->has_data());
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::has_operation() const
{
    return is_set(operation)
	|| (backup !=  nullptr && backup->has_operation());
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "auto-tunnel";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup")
    {
        if(backup != nullptr)
        {
            children["backup"] = backup.get();
        }
        else
        {
            backup = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::Backup>();
            backup->parent = this;
            children["backup"] = backup.get();
        }
        return children.at("backup");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::get_children()
{
    if(children.find("backup") == children.end())
    {
        if(backup != nullptr)
        {
            children["backup"] = backup.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::BackupPath()
    :
    	tunnel_number{YType::uint32, "tunnel-number"}
{
    yang_name = "backup-path"; yang_parent_name = "backup-paths";
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::~BackupPath()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::has_data() const
{
    return tunnel_number.is_set;
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::has_operation() const
{
    return is_set(operation)
	|| is_set(tunnel_number.operation);
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-path" <<"[tunnel-number='" <<tunnel_number.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tunnel_number.is_set || is_set(tunnel_number.operation)) leaf_name_data.push_back(tunnel_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::get_children()
{
    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tunnel-number")
    {
        tunnel_number = value;
    }
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPaths()
{
    yang_name = "backup-paths"; yang_parent_name = "global-attributes";
}

MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::~BackupPaths()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::has_data() const
{
    for (std::size_t index=0; index<backup_path.size(); index++)
    {
        if(backup_path[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::has_operation() const
{
    for (std::size_t index=0; index<backup_path.size(); index++)
    {
        if(backup_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "backup-paths";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "backup-path")
    {
        for(auto const & c : backup_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::BackupPath>();
        c->parent = this;
        backup_path.push_back(std::move(c));
        children[segment_path] = backup_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::get_children()
{
    for (auto const & c : backup_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::GlobalAttributes::GlobalAttributes()
    :
    auto_tunnel(std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel>())
	,backup_paths(std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths>())
	,backup_tunnels(std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels>())
{
    auto_tunnel->parent = this;
    children["auto-tunnel"] = auto_tunnel.get();

    backup_paths->parent = this;
    children["backup-paths"] = backup_paths.get();

    backup_tunnels->parent = this;
    children["backup-tunnels"] = backup_tunnels.get();

    yang_name = "global-attributes"; yang_parent_name = "interface";
}

MplsTe::Interfaces::Interface::GlobalAttributes::~GlobalAttributes()
{
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::has_data() const
{
    return (auto_tunnel !=  nullptr && auto_tunnel->has_data())
	|| (backup_paths !=  nullptr && backup_paths->has_data())
	|| (backup_tunnels !=  nullptr && backup_tunnels->has_data());
}

bool MplsTe::Interfaces::Interface::GlobalAttributes::has_operation() const
{
    return is_set(operation)
	|| (auto_tunnel !=  nullptr && auto_tunnel->has_operation())
	|| (backup_paths !=  nullptr && backup_paths->has_operation())
	|| (backup_tunnels !=  nullptr && backup_tunnels->has_operation());
}

std::string MplsTe::Interfaces::Interface::GlobalAttributes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "global-attributes";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::GlobalAttributes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::GlobalAttributes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "auto-tunnel")
    {
        if(auto_tunnel != nullptr)
        {
            children["auto-tunnel"] = auto_tunnel.get();
        }
        else
        {
            auto_tunnel = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::AutoTunnel>();
            auto_tunnel->parent = this;
            children["auto-tunnel"] = auto_tunnel.get();
        }
        return children.at("auto-tunnel");
    }

    if(child_yang_name == "backup-paths")
    {
        if(backup_paths != nullptr)
        {
            children["backup-paths"] = backup_paths.get();
        }
        else
        {
            backup_paths = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::BackupPaths>();
            backup_paths->parent = this;
            children["backup-paths"] = backup_paths.get();
        }
        return children.at("backup-paths");
    }

    if(child_yang_name == "backup-tunnels")
    {
        if(backup_tunnels != nullptr)
        {
            children["backup-tunnels"] = backup_tunnels.get();
        }
        else
        {
            backup_tunnels = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes::BackupTunnels>();
            backup_tunnels->parent = this;
            children["backup-tunnels"] = backup_tunnels.get();
        }
        return children.at("backup-tunnels");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::GlobalAttributes::get_children()
{
    if(children.find("auto-tunnel") == children.end())
    {
        if(auto_tunnel != nullptr)
        {
            children["auto-tunnel"] = auto_tunnel.get();
        }
    }

    if(children.find("backup-paths") == children.end())
    {
        if(backup_paths != nullptr)
        {
            children["backup-paths"] = backup_paths.get();
        }
    }

    if(children.find("backup-tunnels") == children.end())
    {
        if(backup_tunnels != nullptr)
        {
            children["backup-tunnels"] = backup_tunnels.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::GlobalAttributes::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::Interfaces::Interface::Interface()
    :
    	interface_name{YType::str, "interface-name"}
    	,
    global_attributes(std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes>())
	,lcac(std::make_unique<MplsTe::Interfaces::Interface::Lcac>())
	,transport_profile_link(std::make_unique<MplsTe::Interfaces::Interface::TransportProfileLink>())
{
    global_attributes->parent = this;
    children["global-attributes"] = global_attributes.get();

    lcac->parent = this;
    children["lcac"] = lcac.get();

    transport_profile_link->parent = this;
    children["transport-profile-link"] = transport_profile_link.get();

    yang_name = "interface"; yang_parent_name = "interfaces";
}

MplsTe::Interfaces::Interface::~Interface()
{
}

bool MplsTe::Interfaces::Interface::has_data() const
{
    return interface_name.is_set
	|| (global_attributes !=  nullptr && global_attributes->has_data())
	|| (lcac !=  nullptr && lcac->has_data())
	|| (transport_profile_link !=  nullptr && transport_profile_link->has_data());
}

bool MplsTe::Interfaces::Interface::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| (global_attributes !=  nullptr && global_attributes->has_operation())
	|| (lcac !=  nullptr && lcac->has_operation())
	|| (transport_profile_link !=  nullptr && transport_profile_link->has_operation());
}

std::string MplsTe::Interfaces::Interface::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::Interface::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/interfaces/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::Interface::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "global-attributes")
    {
        if(global_attributes != nullptr)
        {
            children["global-attributes"] = global_attributes.get();
        }
        else
        {
            global_attributes = std::make_unique<MplsTe::Interfaces::Interface::GlobalAttributes>();
            global_attributes->parent = this;
            children["global-attributes"] = global_attributes.get();
        }
        return children.at("global-attributes");
    }

    if(child_yang_name == "lcac")
    {
        if(lcac != nullptr)
        {
            children["lcac"] = lcac.get();
        }
        else
        {
            lcac = std::make_unique<MplsTe::Interfaces::Interface::Lcac>();
            lcac->parent = this;
            children["lcac"] = lcac.get();
        }
        return children.at("lcac");
    }

    if(child_yang_name == "transport-profile-link")
    {
        if(transport_profile_link != nullptr)
        {
            children["transport-profile-link"] = transport_profile_link.get();
        }
        else
        {
            transport_profile_link = std::make_unique<MplsTe::Interfaces::Interface::TransportProfileLink>();
            transport_profile_link->parent = this;
            children["transport-profile-link"] = transport_profile_link.get();
        }
        return children.at("transport-profile-link");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::Interface::get_children()
{
    if(children.find("global-attributes") == children.end())
    {
        if(global_attributes != nullptr)
        {
            children["global-attributes"] = global_attributes.get();
        }
    }

    if(children.find("lcac") == children.end())
    {
        if(lcac != nullptr)
        {
            children["lcac"] = lcac.get();
        }
    }

    if(children.find("transport-profile-link") == children.end())
    {
        if(transport_profile_link != nullptr)
        {
            children["transport-profile-link"] = transport_profile_link.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::Interface::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
}

MplsTe::Interfaces::Interfaces()
{
    yang_name = "interfaces"; yang_parent_name = "mpls-te";
}

MplsTe::Interfaces::~Interfaces()
{
}

bool MplsTe::Interfaces::has_data() const
{
    for (std::size_t index=0; index<interface.size(); index++)
    {
        if(interface[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::Interfaces::has_operation() const
{
    for (std::size_t index=0; index<interface.size(); index++)
    {
        if(interface[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::Interfaces::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interfaces";

    return path_buffer.str();

}

EntityPath MplsTe::Interfaces::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Interfaces::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "interface")
    {
        for(auto const & c : interface)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::Interfaces::Interface>();
        c->parent = this;
        interface.push_back(std::move(c));
        children[segment_path] = interface.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Interfaces::get_children()
{
    for (auto const & c : interface)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::Interfaces::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::TtiMode()
    :
    	tcmid{YType::uint32, "tcmid"},
	 tti_mode_type{YType::enumeration, "tti-mode-type"}
{
    yang_name = "tti-mode"; yang_parent_name = "controller";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::~TtiMode()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::has_data() const
{
    return tcmid.is_set
	|| tti_mode_type.is_set;
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::has_operation() const
{
    return is_set(operation)
	|| is_set(tcmid.operation)
	|| is_set(tti_mode_type.operation);
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tti-mode";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tcmid.is_set || is_set(tcmid.operation)) leaf_name_data.push_back(tcmid.get_name_leafdata());
    if (tti_mode_type.is_set || is_set(tti_mode_type.operation)) leaf_name_data.push_back(tti_mode_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tcmid")
    {
        tcmid = value;
    }
    if(value_path == "tti-mode-type")
    {
        tti_mode_type = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::Controller()
    :
    	controller_name{YType::str, "controller-name"},
	 admin_weight{YType::uint32, "admin-weight"},
	 delay{YType::uint32, "delay"},
	 enable{YType::empty, "enable"}
    	,
    tti_mode(std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode>())
{
    tti_mode->parent = this;
    children["tti-mode"] = tti_mode.get();

    yang_name = "controller"; yang_parent_name = "controllers";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::~Controller()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::has_data() const
{
    return controller_name.is_set
	|| admin_weight.is_set
	|| delay.is_set
	|| enable.is_set
	|| (tti_mode !=  nullptr && tti_mode->has_data());
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::has_operation() const
{
    return is_set(operation)
	|| is_set(controller_name.operation)
	|| is_set(admin_weight.operation)
	|| is_set(delay.operation)
	|| is_set(enable.operation)
	|| (tti_mode !=  nullptr && tti_mode->has_operation());
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controller" <<"[controller-name='" <<controller_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (controller_name.is_set || is_set(controller_name.operation)) leaf_name_data.push_back(controller_name.get_name_leafdata());
    if (admin_weight.is_set || is_set(admin_weight.operation)) leaf_name_data.push_back(admin_weight.get_name_leafdata());
    if (delay.is_set || is_set(delay.operation)) leaf_name_data.push_back(delay.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tti-mode")
    {
        if(tti_mode != nullptr)
        {
            children["tti-mode"] = tti_mode.get();
        }
        else
        {
            tti_mode = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::TtiMode>();
            tti_mode->parent = this;
            children["tti-mode"] = tti_mode.get();
        }
        return children.at("tti-mode");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::get_children()
{
    if(children.find("tti-mode") == children.end())
    {
        if(tti_mode != nullptr)
        {
            children["tti-mode"] = tti_mode.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "controller-name")
    {
        controller_name = value;
    }
    if(value_path == "admin-weight")
    {
        admin_weight = value;
    }
    if(value_path == "delay")
    {
        delay = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controllers()
{
    yang_name = "controllers"; yang_parent_name = "ospf-int";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::~Controllers()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::has_data() const
{
    for (std::size_t index=0; index<controller.size(); index++)
    {
        if(controller[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::has_operation() const
{
    for (std::size_t index=0; index<controller.size(); index++)
    {
        if(controller[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controllers";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "controller")
    {
        for(auto const & c : controller)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::Controller>();
        c->parent = this;
        controller.push_back(std::move(c));
        children[segment_path] = controller.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::get_children()
{
    for (auto const & c : controller)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::OspfInt()
    :
    	igp_area{YType::int32, "igp-area"}
    	,
    controllers(std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers>())
{
    controllers->parent = this;
    children["controllers"] = controllers.get();

    yang_name = "ospf-int"; yang_parent_name = "topology-instance";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::~OspfInt()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::has_data() const
{
    return igp_area.is_set
	|| (controllers !=  nullptr && controllers->has_data());
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::has_operation() const
{
    return is_set(operation)
	|| is_set(igp_area.operation)
	|| (controllers !=  nullptr && controllers->has_operation());
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ospf-int" <<"[igp-area='" <<igp_area.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (igp_area.is_set || is_set(igp_area.operation)) leaf_name_data.push_back(igp_area.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "controllers")
    {
        if(controllers != nullptr)
        {
            children["controllers"] = controllers.get();
        }
        else
        {
            controllers = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::Controllers>();
            controllers->parent = this;
            children["controllers"] = controllers.get();
        }
        return children.at("controllers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::get_children()
{
    if(children.find("controllers") == children.end())
    {
        if(controllers != nullptr)
        {
            children["controllers"] = controllers.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "igp-area")
    {
        igp_area = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::TtiMode()
    :
    	tcmid{YType::uint32, "tcmid"},
	 tti_mode_type{YType::enumeration, "tti-mode-type"}
{
    yang_name = "tti-mode"; yang_parent_name = "controller";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::~TtiMode()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::has_data() const
{
    return tcmid.is_set
	|| tti_mode_type.is_set;
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::has_operation() const
{
    return is_set(operation)
	|| is_set(tcmid.operation)
	|| is_set(tti_mode_type.operation);
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tti-mode";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tcmid.is_set || is_set(tcmid.operation)) leaf_name_data.push_back(tcmid.get_name_leafdata());
    if (tti_mode_type.is_set || is_set(tti_mode_type.operation)) leaf_name_data.push_back(tti_mode_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tcmid")
    {
        tcmid = value;
    }
    if(value_path == "tti-mode-type")
    {
        tti_mode_type = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::Controller()
    :
    	controller_name{YType::str, "controller-name"},
	 admin_weight{YType::uint32, "admin-weight"},
	 delay{YType::uint32, "delay"},
	 enable{YType::empty, "enable"}
    	,
    tti_mode(std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode>())
{
    tti_mode->parent = this;
    children["tti-mode"] = tti_mode.get();

    yang_name = "controller"; yang_parent_name = "controllers";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::~Controller()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::has_data() const
{
    return controller_name.is_set
	|| admin_weight.is_set
	|| delay.is_set
	|| enable.is_set
	|| (tti_mode !=  nullptr && tti_mode->has_data());
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::has_operation() const
{
    return is_set(operation)
	|| is_set(controller_name.operation)
	|| is_set(admin_weight.operation)
	|| is_set(delay.operation)
	|| is_set(enable.operation)
	|| (tti_mode !=  nullptr && tti_mode->has_operation());
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controller" <<"[controller-name='" <<controller_name.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (controller_name.is_set || is_set(controller_name.operation)) leaf_name_data.push_back(controller_name.get_name_leafdata());
    if (admin_weight.is_set || is_set(admin_weight.operation)) leaf_name_data.push_back(admin_weight.get_name_leafdata());
    if (delay.is_set || is_set(delay.operation)) leaf_name_data.push_back(delay.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tti-mode")
    {
        if(tti_mode != nullptr)
        {
            children["tti-mode"] = tti_mode.get();
        }
        else
        {
            tti_mode = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::TtiMode>();
            tti_mode->parent = this;
            children["tti-mode"] = tti_mode.get();
        }
        return children.at("tti-mode");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::get_children()
{
    if(children.find("tti-mode") == children.end())
    {
        if(tti_mode != nullptr)
        {
            children["tti-mode"] = tti_mode.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "controller-name")
    {
        controller_name = value;
    }
    if(value_path == "admin-weight")
    {
        admin_weight = value;
    }
    if(value_path == "delay")
    {
        delay = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controllers()
{
    yang_name = "controllers"; yang_parent_name = "ospfip-addr";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::~Controllers()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::has_data() const
{
    for (std::size_t index=0; index<controller.size(); index++)
    {
        if(controller[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::has_operation() const
{
    for (std::size_t index=0; index<controller.size(); index++)
    {
        if(controller[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "controllers";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "controller")
    {
        for(auto const & c : controller)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::Controller>();
        c->parent = this;
        controller.push_back(std::move(c));
        children[segment_path] = controller.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::get_children()
{
    for (auto const & c : controller)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::OspfipAddr()
    :
    	address{YType::str, "address"}
    	,
    controllers(std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers>())
{
    controllers->parent = this;
    children["controllers"] = controllers.get();

    yang_name = "ospfip-addr"; yang_parent_name = "topology-instance";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::~OspfipAddr()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::has_data() const
{
    return address.is_set
	|| (controllers !=  nullptr && controllers->has_data());
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::has_operation() const
{
    return is_set(operation)
	|| is_set(address.operation)
	|| (controllers !=  nullptr && controllers->has_operation());
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ospfip-addr" <<"[address='" <<address.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address.is_set || is_set(address.operation)) leaf_name_data.push_back(address.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "controllers")
    {
        if(controllers != nullptr)
        {
            children["controllers"] = controllers.get();
        }
        else
        {
            controllers = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::Controllers>();
            controllers->parent = this;
            children["controllers"] = controllers.get();
        }
        return children.at("controllers");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::get_children()
{
    if(children.find("controllers") == children.end())
    {
        if(controllers != nullptr)
        {
            children["controllers"] = controllers.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "address")
    {
        address = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::TopologyInstance()
    :
    	igp_instance_name{YType::str, "igp-instance-name"},
	 igp_type{YType::enumeration, "igp-type"},
	 ospf_area_type{YType::enumeration, "ospf-area-type"}
{
    yang_name = "topology-instance"; yang_parent_name = "topology-instances";
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstance::~TopologyInstance()
{
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::has_data() const
{
    for (std::size_t index=0; index<ospf_int.size(); index++)
    {
        if(ospf_int[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<ospfip_addr.size(); index++)
    {
        if(ospfip_addr[index]->has_data())
            return true;
    }
    return igp_instance_name.is_set
	|| igp_type.is_set
	|| ospf_area_type.is_set;
}

bool MplsTe::GmplsNni::TopologyInstances::TopologyInstance::has_operation() const
{
    for (std::size_t index=0; index<ospf_int.size(); index++)
    {
        if(ospf_int[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<ospfip_addr.size(); index++)
    {
        if(ospfip_addr[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(igp_instance_name.operation)
	|| is_set(igp_type.operation)
	|| is_set(ospf_area_type.operation);
}

std::string MplsTe::GmplsNni::TopologyInstances::TopologyInstance::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology-instance" <<"[igp-instance-name='" <<igp_instance_name.get() <<"']" <<"[igp-type='" <<igp_type.get() <<"']" <<"[ospf-area-type='" <<ospf_area_type.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::TopologyInstance::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/topology-instances/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (igp_instance_name.is_set || is_set(igp_instance_name.operation)) leaf_name_data.push_back(igp_instance_name.get_name_leafdata());
    if (igp_type.is_set || is_set(igp_type.operation)) leaf_name_data.push_back(igp_type.get_name_leafdata());
    if (ospf_area_type.is_set || is_set(ospf_area_type.operation)) leaf_name_data.push_back(ospf_area_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::TopologyInstance::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ospf-int")
    {
        for(auto const & c : ospf_int)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfInt>();
        c->parent = this;
        ospf_int.push_back(std::move(c));
        children[segment_path] = ospf_int.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "ospfip-addr")
    {
        for(auto const & c : ospfip_addr)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance::OspfipAddr>();
        c->parent = this;
        ospfip_addr.push_back(std::move(c));
        children[segment_path] = ospfip_addr.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::TopologyInstance::get_children()
{
    for (auto const & c : ospf_int)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : ospfip_addr)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::TopologyInstance::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "igp-instance-name")
    {
        igp_instance_name = value;
    }
    if(value_path == "igp-type")
    {
        igp_type = value;
    }
    if(value_path == "ospf-area-type")
    {
        ospf_area_type = value;
    }
}

MplsTe::GmplsNni::TopologyInstances::TopologyInstances()
{
    yang_name = "topology-instances"; yang_parent_name = "gmpls-nni";
}

MplsTe::GmplsNni::TopologyInstances::~TopologyInstances()
{
}

bool MplsTe::GmplsNni::TopologyInstances::has_data() const
{
    for (std::size_t index=0; index<topology_instance.size(); index++)
    {
        if(topology_instance[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsNni::TopologyInstances::has_operation() const
{
    for (std::size_t index=0; index<topology_instance.size(); index++)
    {
        if(topology_instance[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsNni::TopologyInstances::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "topology-instances";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TopologyInstances::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TopologyInstances::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "topology-instance")
    {
        for(auto const & c : topology_instance)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TopologyInstances::TopologyInstance>();
        c->parent = this;
        topology_instance.push_back(std::move(c));
        children[segment_path] = topology_instance.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TopologyInstances::get_children()
{
    for (auto const & c : topology_instance)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TopologyInstances::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::SignalledBandwidth()
    :
    	bitrate{YType::int32, "bitrate"},
	 od_uflex_framing_type{YType::enumeration, "od-uflex-framing-type"},
	 signalled_bandwidth_type{YType::enumeration, "signalled-bandwidth-type"}
{
    yang_name = "signalled-bandwidth"; yang_parent_name = "tunnel-head";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::~SignalledBandwidth()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::has_data() const
{
    return bitrate.is_set
	|| od_uflex_framing_type.is_set
	|| signalled_bandwidth_type.is_set;
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::has_operation() const
{
    return is_set(operation)
	|| is_set(bitrate.operation)
	|| is_set(od_uflex_framing_type.operation)
	|| is_set(signalled_bandwidth_type.operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "signalled-bandwidth";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bitrate.is_set || is_set(bitrate.operation)) leaf_name_data.push_back(bitrate.get_name_leafdata());
    if (od_uflex_framing_type.is_set || is_set(od_uflex_framing_type.operation)) leaf_name_data.push_back(od_uflex_framing_type.get_name_leafdata());
    if (signalled_bandwidth_type.is_set || is_set(signalled_bandwidth_type.operation)) leaf_name_data.push_back(signalled_bandwidth_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bitrate")
    {
        bitrate = value;
    }
    if(value_path == "od-uflex-framing-type")
    {
        od_uflex_framing_type = value;
    }
    if(value_path == "signalled-bandwidth-type")
    {
        signalled_bandwidth_type = value;
    }
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::ProtectionSwitching()
    :
    	lockout{YType::enumeration, "lockout"}
{
    yang_name = "protection-switching"; yang_parent_name = "tunnel-head";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::~ProtectionSwitching()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::has_data() const
{
    return lockout.is_set;
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::has_operation() const
{
    return is_set(operation)
	|| is_set(lockout.operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "protection-switching";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lockout.is_set || is_set(lockout.operation)) leaf_name_data.push_back(lockout.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lockout")
    {
        lockout = value;
    }
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::Logging()
    :
    	active_lsp_message{YType::empty, "active-lsp-message"},
	 homepath_state_message{YType::empty, "homepath-state-message"},
	 insufficient_bw_message{YType::empty, "insufficient-bw-message"},
	 path_change_message{YType::empty, "path-change-message"},
	 signalling_state_message{YType::empty, "signalling-state-message"},
	 static_cross_connect_message{YType::empty, "static-cross-connect-message"},
	 tunnel_state_message{YType::empty, "tunnel-state-message"}
{
    yang_name = "logging"; yang_parent_name = "tunnel-head";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::~Logging()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::has_data() const
{
    return active_lsp_message.is_set
	|| homepath_state_message.is_set
	|| insufficient_bw_message.is_set
	|| path_change_message.is_set
	|| signalling_state_message.is_set
	|| static_cross_connect_message.is_set
	|| tunnel_state_message.is_set;
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::has_operation() const
{
    return is_set(operation)
	|| is_set(active_lsp_message.operation)
	|| is_set(homepath_state_message.operation)
	|| is_set(insufficient_bw_message.operation)
	|| is_set(path_change_message.operation)
	|| is_set(signalling_state_message.operation)
	|| is_set(static_cross_connect_message.operation)
	|| is_set(tunnel_state_message.operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "logging";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (active_lsp_message.is_set || is_set(active_lsp_message.operation)) leaf_name_data.push_back(active_lsp_message.get_name_leafdata());
    if (homepath_state_message.is_set || is_set(homepath_state_message.operation)) leaf_name_data.push_back(homepath_state_message.get_name_leafdata());
    if (insufficient_bw_message.is_set || is_set(insufficient_bw_message.operation)) leaf_name_data.push_back(insufficient_bw_message.get_name_leafdata());
    if (path_change_message.is_set || is_set(path_change_message.operation)) leaf_name_data.push_back(path_change_message.get_name_leafdata());
    if (signalling_state_message.is_set || is_set(signalling_state_message.operation)) leaf_name_data.push_back(signalling_state_message.get_name_leafdata());
    if (static_cross_connect_message.is_set || is_set(static_cross_connect_message.operation)) leaf_name_data.push_back(static_cross_connect_message.get_name_leafdata());
    if (tunnel_state_message.is_set || is_set(tunnel_state_message.operation)) leaf_name_data.push_back(tunnel_state_message.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "active-lsp-message")
    {
        active_lsp_message = value;
    }
    if(value_path == "homepath-state-message")
    {
        homepath_state_message = value;
    }
    if(value_path == "insufficient-bw-message")
    {
        insufficient_bw_message = value;
    }
    if(value_path == "path-change-message")
    {
        path_change_message = value;
    }
    if(value_path == "signalling-state-message")
    {
        signalling_state_message = value;
    }
    if(value_path == "static-cross-connect-message")
    {
        static_cross_connect_message = value;
    }
    if(value_path == "tunnel-state-message")
    {
        tunnel_state_message = value;
    }
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::PathOption()
    :
    	preference_level{YType::uint32, "preference-level"},
	 lockdown{YType::enumeration, "lockdown"},
	 path_id{YType::uint32, "path-id"},
	 path_name{YType::str, "path-name"},
	 path_type{YType::enumeration, "path-type"},
	 protected_by_preference_level{YType::uint32, "protected-by-preference-level"},
	 restore_by_preference_level{YType::uint32, "restore-by-preference-level"},
	 xro_attribute_set_name{YType::str, "xro-attribute-set-name"},
	 xro_type{YType::empty, "xro-type"}
{
    yang_name = "path-option"; yang_parent_name = "path-options";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::~PathOption()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::has_data() const
{
    return preference_level.is_set
	|| lockdown.is_set
	|| path_id.is_set
	|| path_name.is_set
	|| path_type.is_set
	|| protected_by_preference_level.is_set
	|| restore_by_preference_level.is_set
	|| xro_attribute_set_name.is_set
	|| xro_type.is_set;
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::has_operation() const
{
    return is_set(operation)
	|| is_set(preference_level.operation)
	|| is_set(lockdown.operation)
	|| is_set(path_id.operation)
	|| is_set(path_name.operation)
	|| is_set(path_type.operation)
	|| is_set(protected_by_preference_level.operation)
	|| is_set(restore_by_preference_level.operation)
	|| is_set(xro_attribute_set_name.operation)
	|| is_set(xro_type.operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-option" <<"[preference-level='" <<preference_level.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (preference_level.is_set || is_set(preference_level.operation)) leaf_name_data.push_back(preference_level.get_name_leafdata());
    if (lockdown.is_set || is_set(lockdown.operation)) leaf_name_data.push_back(lockdown.get_name_leafdata());
    if (path_id.is_set || is_set(path_id.operation)) leaf_name_data.push_back(path_id.get_name_leafdata());
    if (path_name.is_set || is_set(path_name.operation)) leaf_name_data.push_back(path_name.get_name_leafdata());
    if (path_type.is_set || is_set(path_type.operation)) leaf_name_data.push_back(path_type.get_name_leafdata());
    if (protected_by_preference_level.is_set || is_set(protected_by_preference_level.operation)) leaf_name_data.push_back(protected_by_preference_level.get_name_leafdata());
    if (restore_by_preference_level.is_set || is_set(restore_by_preference_level.operation)) leaf_name_data.push_back(restore_by_preference_level.get_name_leafdata());
    if (xro_attribute_set_name.is_set || is_set(xro_attribute_set_name.operation)) leaf_name_data.push_back(xro_attribute_set_name.get_name_leafdata());
    if (xro_type.is_set || is_set(xro_type.operation)) leaf_name_data.push_back(xro_type.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "preference-level")
    {
        preference_level = value;
    }
    if(value_path == "lockdown")
    {
        lockdown = value;
    }
    if(value_path == "path-id")
    {
        path_id = value;
    }
    if(value_path == "path-name")
    {
        path_name = value;
    }
    if(value_path == "path-type")
    {
        path_type = value;
    }
    if(value_path == "protected-by-preference-level")
    {
        protected_by_preference_level = value;
    }
    if(value_path == "restore-by-preference-level")
    {
        restore_by_preference_level = value;
    }
    if(value_path == "xro-attribute-set-name")
    {
        xro_attribute_set_name = value;
    }
    if(value_path == "xro-type")
    {
        xro_type = value;
    }
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOptions()
{
    yang_name = "path-options"; yang_parent_name = "tunnel-head";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::~PathOptions()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::has_data() const
{
    for (std::size_t index=0; index<path_option.size(); index++)
    {
        if(path_option[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::has_operation() const
{
    for (std::size_t index=0; index<path_option.size(); index++)
    {
        if(path_option[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "path-options";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "path-option")
    {
        for(auto const & c : path_option)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::PathOption>();
        c->parent = this;
        path_option.push_back(std::move(c));
        children[segment_path] = path_option.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::get_children()
{
    for (auto const & c : path_option)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::StaticUni()
    :
    	egress_controller_if_index{YType::int32, "egress-controller-if-index"},
	 ingress_controller_name{YType::str, "ingress-controller-name"}
{
    yang_name = "static-uni"; yang_parent_name = "tunnel-head";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::~StaticUni()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::has_data() const
{
    return egress_controller_if_index.is_set
	|| ingress_controller_name.is_set;
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::has_operation() const
{
    return is_set(operation)
	|| is_set(egress_controller_if_index.operation)
	|| is_set(ingress_controller_name.operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "static-uni";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (egress_controller_if_index.is_set || is_set(egress_controller_if_index.operation)) leaf_name_data.push_back(egress_controller_if_index.get_name_leafdata());
    if (ingress_controller_name.is_set || is_set(ingress_controller_name.operation)) leaf_name_data.push_back(ingress_controller_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::get_children()
{
    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "egress-controller-if-index")
    {
        egress_controller_if_index = value;
    }
    if(value_path == "ingress-controller-name")
    {
        ingress_controller_name = value;
    }
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::TunnelHead()
    :
    	tunnel_id{YType::uint32, "tunnel-id"},
	 current_lsp_shutdown{YType::empty, "current-lsp-shutdown"},
	 destination{YType::str, "destination"},
	 enable{YType::empty, "enable"},
	 path_protection_attribute_set_profile{YType::str, "path-protection-attribute-set-profile"},
	 path_selection_metric{YType::enumeration, "path-selection-metric"},
	 payload{YType::enumeration, "payload"},
	 record_route{YType::empty, "record-route"},
	 restore_lsp_shutdown{YType::empty, "restore-lsp-shutdown"},
	 shutdown{YType::empty, "shutdown"},
	 signalled_name{YType::str, "signalled-name"},
	 standby_lsp_shutdown{YType::empty, "standby-lsp-shutdown"}
    	,
    logging(std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging>())
	,path_options(std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions>())
	,protection_switching(std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching>())
	,signalled_bandwidth(std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth>())
	,static_uni(std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni>())
{
    logging->parent = this;
    children["logging"] = logging.get();

    path_options->parent = this;
    children["path-options"] = path_options.get();

    protection_switching->parent = this;
    children["protection-switching"] = protection_switching.get();

    signalled_bandwidth->parent = this;
    children["signalled-bandwidth"] = signalled_bandwidth.get();

    static_uni->parent = this;
    children["static-uni"] = static_uni.get();

    yang_name = "tunnel-head"; yang_parent_name = "tunnel-heads";
}

MplsTe::GmplsNni::TunnelHeads::TunnelHead::~TunnelHead()
{
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::has_data() const
{
    return tunnel_id.is_set
	|| current_lsp_shutdown.is_set
	|| destination.is_set
	|| enable.is_set
	|| path_protection_attribute_set_profile.is_set
	|| path_selection_metric.is_set
	|| payload.is_set
	|| record_route.is_set
	|| restore_lsp_shutdown.is_set
	|| shutdown.is_set
	|| signalled_name.is_set
	|| standby_lsp_shutdown.is_set
	|| (logging !=  nullptr && logging->has_data())
	|| (path_options !=  nullptr && path_options->has_data())
	|| (protection_switching !=  nullptr && protection_switching->has_data())
	|| (signalled_bandwidth !=  nullptr && signalled_bandwidth->has_data())
	|| (static_uni !=  nullptr && static_uni->has_data());
}

bool MplsTe::GmplsNni::TunnelHeads::TunnelHead::has_operation() const
{
    return is_set(operation)
	|| is_set(tunnel_id.operation)
	|| is_set(current_lsp_shutdown.operation)
	|| is_set(destination.operation)
	|| is_set(enable.operation)
	|| is_set(path_protection_attribute_set_profile.operation)
	|| is_set(path_selection_metric.operation)
	|| is_set(payload.operation)
	|| is_set(record_route.operation)
	|| is_set(restore_lsp_shutdown.operation)
	|| is_set(shutdown.operation)
	|| is_set(signalled_name.operation)
	|| is_set(standby_lsp_shutdown.operation)
	|| (logging !=  nullptr && logging->has_operation())
	|| (path_options !=  nullptr && path_options->has_operation())
	|| (protection_switching !=  nullptr && protection_switching->has_operation())
	|| (signalled_bandwidth !=  nullptr && signalled_bandwidth->has_operation())
	|| (static_uni !=  nullptr && static_uni->has_operation());
}

std::string MplsTe::GmplsNni::TunnelHeads::TunnelHead::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-head" <<"[tunnel-id='" <<tunnel_id.get() <<"']";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::TunnelHead::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/tunnel-heads/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (tunnel_id.is_set || is_set(tunnel_id.operation)) leaf_name_data.push_back(tunnel_id.get_name_leafdata());
    if (current_lsp_shutdown.is_set || is_set(current_lsp_shutdown.operation)) leaf_name_data.push_back(current_lsp_shutdown.get_name_leafdata());
    if (destination.is_set || is_set(destination.operation)) leaf_name_data.push_back(destination.get_name_leafdata());
    if (enable.is_set || is_set(enable.operation)) leaf_name_data.push_back(enable.get_name_leafdata());
    if (path_protection_attribute_set_profile.is_set || is_set(path_protection_attribute_set_profile.operation)) leaf_name_data.push_back(path_protection_attribute_set_profile.get_name_leafdata());
    if (path_selection_metric.is_set || is_set(path_selection_metric.operation)) leaf_name_data.push_back(path_selection_metric.get_name_leafdata());
    if (payload.is_set || is_set(payload.operation)) leaf_name_data.push_back(payload.get_name_leafdata());
    if (record_route.is_set || is_set(record_route.operation)) leaf_name_data.push_back(record_route.get_name_leafdata());
    if (restore_lsp_shutdown.is_set || is_set(restore_lsp_shutdown.operation)) leaf_name_data.push_back(restore_lsp_shutdown.get_name_leafdata());
    if (shutdown.is_set || is_set(shutdown.operation)) leaf_name_data.push_back(shutdown.get_name_leafdata());
    if (signalled_name.is_set || is_set(signalled_name.operation)) leaf_name_data.push_back(signalled_name.get_name_leafdata());
    if (standby_lsp_shutdown.is_set || is_set(standby_lsp_shutdown.operation)) leaf_name_data.push_back(standby_lsp_shutdown.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::TunnelHead::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "logging")
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
        else
        {
            logging = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::Logging>();
            logging->parent = this;
            children["logging"] = logging.get();
        }
        return children.at("logging");
    }

    if(child_yang_name == "path-options")
    {
        if(path_options != nullptr)
        {
            children["path-options"] = path_options.get();
        }
        else
        {
            path_options = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::PathOptions>();
            path_options->parent = this;
            children["path-options"] = path_options.get();
        }
        return children.at("path-options");
    }

    if(child_yang_name == "protection-switching")
    {
        if(protection_switching != nullptr)
        {
            children["protection-switching"] = protection_switching.get();
        }
        else
        {
            protection_switching = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::ProtectionSwitching>();
            protection_switching->parent = this;
            children["protection-switching"] = protection_switching.get();
        }
        return children.at("protection-switching");
    }

    if(child_yang_name == "signalled-bandwidth")
    {
        if(signalled_bandwidth != nullptr)
        {
            children["signalled-bandwidth"] = signalled_bandwidth.get();
        }
        else
        {
            signalled_bandwidth = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::SignalledBandwidth>();
            signalled_bandwidth->parent = this;
            children["signalled-bandwidth"] = signalled_bandwidth.get();
        }
        return children.at("signalled-bandwidth");
    }

    if(child_yang_name == "static-uni")
    {
        if(static_uni != nullptr)
        {
            children["static-uni"] = static_uni.get();
        }
        else
        {
            static_uni = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead::StaticUni>();
            static_uni->parent = this;
            children["static-uni"] = static_uni.get();
        }
        return children.at("static-uni");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::TunnelHead::get_children()
{
    if(children.find("logging") == children.end())
    {
        if(logging != nullptr)
        {
            children["logging"] = logging.get();
        }
    }

    if(children.find("path-options") == children.end())
    {
        if(path_options != nullptr)
        {
            children["path-options"] = path_options.get();
        }
    }

    if(children.find("protection-switching") == children.end())
    {
        if(protection_switching != nullptr)
        {
            children["protection-switching"] = protection_switching.get();
        }
    }

    if(children.find("signalled-bandwidth") == children.end())
    {
        if(signalled_bandwidth != nullptr)
        {
            children["signalled-bandwidth"] = signalled_bandwidth.get();
        }
    }

    if(children.find("static-uni") == children.end())
    {
        if(static_uni != nullptr)
        {
            children["static-uni"] = static_uni.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TunnelHeads::TunnelHead::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "tunnel-id")
    {
        tunnel_id = value;
    }
    if(value_path == "current-lsp-shutdown")
    {
        current_lsp_shutdown = value;
    }
    if(value_path == "destination")
    {
        destination = value;
    }
    if(value_path == "enable")
    {
        enable = value;
    }
    if(value_path == "path-protection-attribute-set-profile")
    {
        path_protection_attribute_set_profile = value;
    }
    if(value_path == "path-selection-metric")
    {
        path_selection_metric = value;
    }
    if(value_path == "payload")
    {
        payload = value;
    }
    if(value_path == "record-route")
    {
        record_route = value;
    }
    if(value_path == "restore-lsp-shutdown")
    {
        restore_lsp_shutdown = value;
    }
    if(value_path == "shutdown")
    {
        shutdown = value;
    }
    if(value_path == "signalled-name")
    {
        signalled_name = value;
    }
    if(value_path == "standby-lsp-shutdown")
    {
        standby_lsp_shutdown = value;
    }
}

MplsTe::GmplsNni::TunnelHeads::TunnelHeads()
{
    yang_name = "tunnel-heads"; yang_parent_name = "gmpls-nni";
}

MplsTe::GmplsNni::TunnelHeads::~TunnelHeads()
{
}

bool MplsTe::GmplsNni::TunnelHeads::has_data() const
{
    for (std::size_t index=0; index<tunnel_head.size(); index++)
    {
        if(tunnel_head[index]->has_data())
            return true;
    }
    return false;
}

bool MplsTe::GmplsNni::TunnelHeads::has_operation() const
{
    for (std::size_t index=0; index<tunnel_head.size(); index++)
    {
        if(tunnel_head[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string MplsTe::GmplsNni::TunnelHeads::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tunnel-heads";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::TunnelHeads::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/gmpls-nni/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::TunnelHeads::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "tunnel-head")
    {
        for(auto const & c : tunnel_head)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<MplsTe::GmplsNni::TunnelHeads::TunnelHead>();
        c->parent = this;
        tunnel_head.push_back(std::move(c));
        children[segment_path] = tunnel_head.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::TunnelHeads::get_children()
{
    for (auto const & c : tunnel_head)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::TunnelHeads::set_value(const std::string & value_path, std::string value)
{
}

MplsTe::GmplsNni::GmplsNni()
    :
    	enable_gmpls_nni{YType::empty, "enable-gmpls-nni"},
	 path_selection_metric{YType::enumeration, "path-selection-metric"}
    	,
    topology_instances(std::make_unique<MplsTe::GmplsNni::TopologyInstances>())
	,tunnel_heads(std::make_unique<MplsTe::GmplsNni::TunnelHeads>())
{
    topology_instances->parent = this;
    children["topology-instances"] = topology_instances.get();

    tunnel_heads->parent = this;
    children["tunnel-heads"] = tunnel_heads.get();

    yang_name = "gmpls-nni"; yang_parent_name = "mpls-te";
}

MplsTe::GmplsNni::~GmplsNni()
{
}

bool MplsTe::GmplsNni::has_data() const
{
    return enable_gmpls_nni.is_set
	|| path_selection_metric.is_set
	|| (topology_instances !=  nullptr && topology_instances->has_data())
	|| (tunnel_heads !=  nullptr && tunnel_heads->has_data());
}

bool MplsTe::GmplsNni::has_operation() const
{
    return is_set(operation)
	|| is_set(enable_gmpls_nni.operation)
	|| is_set(path_selection_metric.operation)
	|| (topology_instances !=  nullptr && topology_instances->has_operation())
	|| (tunnel_heads !=  nullptr && tunnel_heads->has_operation());
}

std::string MplsTe::GmplsNni::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "gmpls-nni";

    return path_buffer.str();

}

EntityPath MplsTe::GmplsNni::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable_gmpls_nni.is_set || is_set(enable_gmpls_nni.operation)) leaf_name_data.push_back(enable_gmpls_nni.get_name_leafdata());
    if (path_selection_metric.is_set || is_set(path_selection_metric.operation)) leaf_name_data.push_back(path_selection_metric.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::GmplsNni::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "topology-instances")
    {
        if(topology_instances != nullptr)
        {
            children["topology-instances"] = topology_instances.get();
        }
        else
        {
            topology_instances = std::make_unique<MplsTe::GmplsNni::TopologyInstances>();
            topology_instances->parent = this;
            children["topology-instances"] = topology_instances.get();
        }
        return children.at("topology-instances");
    }

    if(child_yang_name == "tunnel-heads")
    {
        if(tunnel_heads != nullptr)
        {
            children["tunnel-heads"] = tunnel_heads.get();
        }
        else
        {
            tunnel_heads = std::make_unique<MplsTe::GmplsNni::TunnelHeads>();
            tunnel_heads->parent = this;
            children["tunnel-heads"] = tunnel_heads.get();
        }
        return children.at("tunnel-heads");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::GmplsNni::get_children()
{
    if(children.find("topology-instances") == children.end())
    {
        if(topology_instances != nullptr)
        {
            children["topology-instances"] = topology_instances.get();
        }
    }

    if(children.find("tunnel-heads") == children.end())
    {
        if(tunnel_heads != nullptr)
        {
            children["tunnel-heads"] = tunnel_heads.get();
        }
    }

    return children;
}

void MplsTe::GmplsNni::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable-gmpls-nni")
    {
        enable_gmpls_nni = value;
    }
    if(value_path == "path-selection-metric")
    {
        path_selection_metric = value;
    }
}

MplsTe::Lcac::Bfd::Bfd()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"}
{
    yang_name = "bfd"; yang_parent_name = "lcac";
}

MplsTe::Lcac::Bfd::~Bfd()
{
}

bool MplsTe::Lcac::Bfd::has_data() const
{
    return detection_multiplier.is_set
	|| interval.is_set;
}

bool MplsTe::Lcac::Bfd::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation);
}

std::string MplsTe::Lcac::Bfd::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfd";

    return path_buffer.str();

}

EntityPath MplsTe::Lcac::Bfd::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/lcac/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Lcac::Bfd::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Lcac::Bfd::get_children()
{
    return children;
}

void MplsTe::Lcac::Bfd::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
}

MplsTe::Lcac::FloodingThreshold::FloodingThreshold()
    :
    	down_stream{YType::uint32, "down-stream"},
	 up_stream{YType::uint32, "up-stream"}
{
    yang_name = "flooding-threshold"; yang_parent_name = "lcac";
}

MplsTe::Lcac::FloodingThreshold::~FloodingThreshold()
{
}

bool MplsTe::Lcac::FloodingThreshold::has_data() const
{
    return down_stream.is_set
	|| up_stream.is_set;
}

bool MplsTe::Lcac::FloodingThreshold::has_operation() const
{
    return is_set(operation)
	|| is_set(down_stream.operation)
	|| is_set(up_stream.operation);
}

std::string MplsTe::Lcac::FloodingThreshold::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "flooding-threshold";

    return path_buffer.str();

}

EntityPath MplsTe::Lcac::FloodingThreshold::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/lcac/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_stream.is_set || is_set(down_stream.operation)) leaf_name_data.push_back(down_stream.get_name_leafdata());
    if (up_stream.is_set || is_set(up_stream.operation)) leaf_name_data.push_back(up_stream.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Lcac::FloodingThreshold::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Lcac::FloodingThreshold::get_children()
{
    return children;
}

void MplsTe::Lcac::FloodingThreshold::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-stream")
    {
        down_stream = value;
    }
    if(value_path == "up-stream")
    {
        up_stream = value;
    }
}

MplsTe::Lcac::Lcac()
    :
    	bandwidth_hold_timer{YType::uint32, "bandwidth-hold-timer"},
	 delay_preempt_bundle_capacity_timer{YType::uint32, "delay-preempt-bundle-capacity-timer"},
	 periodic_flooding_timer{YType::uint32, "periodic-flooding-timer"}
    	,
    bfd(std::make_unique<MplsTe::Lcac::Bfd>())
	,flooding_threshold(std::make_unique<MplsTe::Lcac::FloodingThreshold>())
{
    bfd->parent = this;
    children["bfd"] = bfd.get();

    flooding_threshold->parent = this;
    children["flooding-threshold"] = flooding_threshold.get();

    yang_name = "lcac"; yang_parent_name = "mpls-te";
}

MplsTe::Lcac::~Lcac()
{
}

bool MplsTe::Lcac::has_data() const
{
    return bandwidth_hold_timer.is_set
	|| delay_preempt_bundle_capacity_timer.is_set
	|| periodic_flooding_timer.is_set
	|| (bfd !=  nullptr && bfd->has_data())
	|| (flooding_threshold !=  nullptr && flooding_threshold->has_data());
}

bool MplsTe::Lcac::has_operation() const
{
    return is_set(operation)
	|| is_set(bandwidth_hold_timer.operation)
	|| is_set(delay_preempt_bundle_capacity_timer.operation)
	|| is_set(periodic_flooding_timer.operation)
	|| (bfd !=  nullptr && bfd->has_operation())
	|| (flooding_threshold !=  nullptr && flooding_threshold->has_operation());
}

std::string MplsTe::Lcac::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lcac";

    return path_buffer.str();

}

EntityPath MplsTe::Lcac::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bandwidth_hold_timer.is_set || is_set(bandwidth_hold_timer.operation)) leaf_name_data.push_back(bandwidth_hold_timer.get_name_leafdata());
    if (delay_preempt_bundle_capacity_timer.is_set || is_set(delay_preempt_bundle_capacity_timer.operation)) leaf_name_data.push_back(delay_preempt_bundle_capacity_timer.get_name_leafdata());
    if (periodic_flooding_timer.is_set || is_set(periodic_flooding_timer.operation)) leaf_name_data.push_back(periodic_flooding_timer.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::Lcac::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfd")
    {
        if(bfd != nullptr)
        {
            children["bfd"] = bfd.get();
        }
        else
        {
            bfd = std::make_unique<MplsTe::Lcac::Bfd>();
            bfd->parent = this;
            children["bfd"] = bfd.get();
        }
        return children.at("bfd");
    }

    if(child_yang_name == "flooding-threshold")
    {
        if(flooding_threshold != nullptr)
        {
            children["flooding-threshold"] = flooding_threshold.get();
        }
        else
        {
            flooding_threshold = std::make_unique<MplsTe::Lcac::FloodingThreshold>();
            flooding_threshold->parent = this;
            children["flooding-threshold"] = flooding_threshold.get();
        }
        return children.at("flooding-threshold");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::Lcac::get_children()
{
    if(children.find("bfd") == children.end())
    {
        if(bfd != nullptr)
        {
            children["bfd"] = bfd.get();
        }
    }

    if(children.find("flooding-threshold") == children.end())
    {
        if(flooding_threshold != nullptr)
        {
            children["flooding-threshold"] = flooding_threshold.get();
        }
    }

    return children;
}

void MplsTe::Lcac::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bandwidth-hold-timer")
    {
        bandwidth_hold_timer = value;
    }
    if(value_path == "delay-preempt-bundle-capacity-timer")
    {
        delay_preempt_bundle_capacity_timer = value;
    }
    if(value_path == "periodic-flooding-timer")
    {
        periodic_flooding_timer = value;
    }
}

MplsTe::MplsTe()
    :
    	enable_traffic_engineering{YType::empty, "enable-traffic-engineering"}
    	,
    diff_serv_traffic_engineering(std::make_unique<MplsTe::DiffServTrafficEngineering>())
	,global_attributes(std::make_unique<MplsTe::GlobalAttributes>())
	,gmpls_nni(std::make_unique<MplsTe::GmplsNni>())
	,gmpls_uni(std::make_unique<MplsTe::GmplsUni>())
	,interfaces(std::make_unique<MplsTe::Interfaces>())
	,lcac(std::make_unique<MplsTe::Lcac>())
	,named_tunnels(std::make_unique<MplsTe::NamedTunnels>())
	,transport_profile(std::make_unique<MplsTe::TransportProfile>())
{
    diff_serv_traffic_engineering->parent = this;
    children["diff-serv-traffic-engineering"] = diff_serv_traffic_engineering.get();

    global_attributes->parent = this;
    children["global-attributes"] = global_attributes.get();

    gmpls_nni->parent = this;
    children["gmpls-nni"] = gmpls_nni.get();

    gmpls_uni->parent = this;
    children["gmpls-uni"] = gmpls_uni.get();

    interfaces->parent = this;
    children["interfaces"] = interfaces.get();

    lcac->parent = this;
    children["lcac"] = lcac.get();

    named_tunnels->parent = this;
    children["named-tunnels"] = named_tunnels.get();

    transport_profile->parent = this;
    children["transport-profile"] = transport_profile.get();

    yang_name = "mpls-te"; yang_parent_name = "Cisco-IOS-XR-mpls-te-cfg";
}

MplsTe::~MplsTe()
{
}

bool MplsTe::has_data() const
{
    return enable_traffic_engineering.is_set
	|| (diff_serv_traffic_engineering !=  nullptr && diff_serv_traffic_engineering->has_data())
	|| (global_attributes !=  nullptr && global_attributes->has_data())
	|| (gmpls_nni !=  nullptr && gmpls_nni->has_data())
	|| (gmpls_uni !=  nullptr && gmpls_uni->has_data())
	|| (interfaces !=  nullptr && interfaces->has_data())
	|| (lcac !=  nullptr && lcac->has_data())
	|| (named_tunnels !=  nullptr && named_tunnels->has_data())
	|| (transport_profile !=  nullptr && transport_profile->has_data());
}

bool MplsTe::has_operation() const
{
    return is_set(operation)
	|| is_set(enable_traffic_engineering.operation)
	|| (diff_serv_traffic_engineering !=  nullptr && diff_serv_traffic_engineering->has_operation())
	|| (global_attributes !=  nullptr && global_attributes->has_operation())
	|| (gmpls_nni !=  nullptr && gmpls_nni->has_operation())
	|| (gmpls_uni !=  nullptr && gmpls_uni->has_operation())
	|| (interfaces !=  nullptr && interfaces->has_operation())
	|| (lcac !=  nullptr && lcac->has_operation())
	|| (named_tunnels !=  nullptr && named_tunnels->has_operation())
	|| (transport_profile !=  nullptr && transport_profile->has_operation());
}

std::string MplsTe::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-mpls-te-cfg:mpls-te";

    return path_buffer.str();

}

EntityPath MplsTe::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (enable_traffic_engineering.is_set || is_set(enable_traffic_engineering.operation)) leaf_name_data.push_back(enable_traffic_engineering.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* MplsTe::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "diff-serv-traffic-engineering")
    {
        if(diff_serv_traffic_engineering != nullptr)
        {
            children["diff-serv-traffic-engineering"] = diff_serv_traffic_engineering.get();
        }
        else
        {
            diff_serv_traffic_engineering = std::make_unique<MplsTe::DiffServTrafficEngineering>();
            diff_serv_traffic_engineering->parent = this;
            children["diff-serv-traffic-engineering"] = diff_serv_traffic_engineering.get();
        }
        return children.at("diff-serv-traffic-engineering");
    }

    if(child_yang_name == "global-attributes")
    {
        if(global_attributes != nullptr)
        {
            children["global-attributes"] = global_attributes.get();
        }
        else
        {
            global_attributes = std::make_unique<MplsTe::GlobalAttributes>();
            global_attributes->parent = this;
            children["global-attributes"] = global_attributes.get();
        }
        return children.at("global-attributes");
    }

    if(child_yang_name == "gmpls-nni")
    {
        if(gmpls_nni != nullptr)
        {
            children["gmpls-nni"] = gmpls_nni.get();
        }
        else
        {
            gmpls_nni = std::make_unique<MplsTe::GmplsNni>();
            gmpls_nni->parent = this;
            children["gmpls-nni"] = gmpls_nni.get();
        }
        return children.at("gmpls-nni");
    }

    if(child_yang_name == "gmpls-uni")
    {
        if(gmpls_uni != nullptr)
        {
            children["gmpls-uni"] = gmpls_uni.get();
        }
        else
        {
            gmpls_uni = std::make_unique<MplsTe::GmplsUni>();
            gmpls_uni->parent = this;
            children["gmpls-uni"] = gmpls_uni.get();
        }
        return children.at("gmpls-uni");
    }

    if(child_yang_name == "interfaces")
    {
        if(interfaces != nullptr)
        {
            children["interfaces"] = interfaces.get();
        }
        else
        {
            interfaces = std::make_unique<MplsTe::Interfaces>();
            interfaces->parent = this;
            children["interfaces"] = interfaces.get();
        }
        return children.at("interfaces");
    }

    if(child_yang_name == "lcac")
    {
        if(lcac != nullptr)
        {
            children["lcac"] = lcac.get();
        }
        else
        {
            lcac = std::make_unique<MplsTe::Lcac>();
            lcac->parent = this;
            children["lcac"] = lcac.get();
        }
        return children.at("lcac");
    }

    if(child_yang_name == "named-tunnels")
    {
        if(named_tunnels != nullptr)
        {
            children["named-tunnels"] = named_tunnels.get();
        }
        else
        {
            named_tunnels = std::make_unique<MplsTe::NamedTunnels>();
            named_tunnels->parent = this;
            children["named-tunnels"] = named_tunnels.get();
        }
        return children.at("named-tunnels");
    }

    if(child_yang_name == "transport-profile")
    {
        if(transport_profile != nullptr)
        {
            children["transport-profile"] = transport_profile.get();
        }
        else
        {
            transport_profile = std::make_unique<MplsTe::TransportProfile>();
            transport_profile->parent = this;
            children["transport-profile"] = transport_profile.get();
        }
        return children.at("transport-profile");
    }

    return nullptr;
}

std::map<std::string, Entity*> & MplsTe::get_children()
{
    if(children.find("diff-serv-traffic-engineering") == children.end())
    {
        if(diff_serv_traffic_engineering != nullptr)
        {
            children["diff-serv-traffic-engineering"] = diff_serv_traffic_engineering.get();
        }
    }

    if(children.find("global-attributes") == children.end())
    {
        if(global_attributes != nullptr)
        {
            children["global-attributes"] = global_attributes.get();
        }
    }

    if(children.find("gmpls-nni") == children.end())
    {
        if(gmpls_nni != nullptr)
        {
            children["gmpls-nni"] = gmpls_nni.get();
        }
    }

    if(children.find("gmpls-uni") == children.end())
    {
        if(gmpls_uni != nullptr)
        {
            children["gmpls-uni"] = gmpls_uni.get();
        }
    }

    if(children.find("interfaces") == children.end())
    {
        if(interfaces != nullptr)
        {
            children["interfaces"] = interfaces.get();
        }
    }

    if(children.find("lcac") == children.end())
    {
        if(lcac != nullptr)
        {
            children["lcac"] = lcac.get();
        }
    }

    if(children.find("named-tunnels") == children.end())
    {
        if(named_tunnels != nullptr)
        {
            children["named-tunnels"] = named_tunnels.get();
        }
    }

    if(children.find("transport-profile") == children.end())
    {
        if(transport_profile != nullptr)
        {
            children["transport-profile"] = transport_profile.get();
        }
    }

    return children;
}

void MplsTe::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "enable-traffic-engineering")
    {
        enable_traffic_engineering = value;
    }
}

std::unique_ptr<Entity> MplsTe::clone_ptr()
{
    return std::make_unique<MplsTe>();
}

const Enum::YLeaf MplsTeBackupBandwidthClassEnum::class0 {0, "class0"};
const Enum::YLeaf MplsTeBackupBandwidthClassEnum::class1 {1, "class1"};
const Enum::YLeaf MplsTeBackupBandwidthClassEnum::any_class {9, "any-class"};

const Enum::YLeaf SrPrependEnum::none_type {0, "none-type"};
const Enum::YLeaf SrPrependEnum::next_label {1, "next-label"};
const Enum::YLeaf SrPrependEnum::bgp_n_hop {2, "bgp-n-hop"};

const Enum::YLeaf MplsTePathComputationMethodEnum::not_set {0, "not-set"};
const Enum::YLeaf MplsTePathComputationMethodEnum::dynamic {1, "dynamic"};
const Enum::YLeaf MplsTePathComputationMethodEnum::pce {2, "pce"};
const Enum::YLeaf MplsTePathComputationMethodEnum::explicit_ {3, "explicit"};

const Enum::YLeaf MplsTeSwitchingCapEnum::psc1 {1, "psc1"};
const Enum::YLeaf MplsTeSwitchingCapEnum::lsc {150, "lsc"};
const Enum::YLeaf MplsTeSwitchingCapEnum::fsc {200, "fsc"};

const Enum::YLeaf MplsTeBfdSessionDownActionEnum::re_setup {1, "re-setup"};

const Enum::YLeaf RoutePriorityRoleEnum::route_priority_role_head_back_up {0, "route-priority-role-head-back-up"};
const Enum::YLeaf RoutePriorityRoleEnum::route_priority_role_head_primary {1, "route-priority-role-head-primary"};
const Enum::YLeaf RoutePriorityRoleEnum::route_priority_role_middle {2, "route-priority-role-middle"};

const Enum::YLeaf MplsTebfdSessionEnum::regular_bfd {1, "regular-bfd"};
const Enum::YLeaf MplsTebfdSessionEnum::sbfd {2, "sbfd"};
const Enum::YLeaf MplsTebfdSessionEnum::redundant_sbfd {3, "redundant-sbfd"};

const Enum::YLeaf MplsTeLogFrrProtectionEnum::frr_active_primary {1, "frr-active-primary"};
const Enum::YLeaf MplsTeLogFrrProtectionEnum::backup {256, "backup"};
const Enum::YLeaf MplsTeLogFrrProtectionEnum::frr_ready_primary {512, "frr-ready-primary"};
const Enum::YLeaf MplsTeLogFrrProtectionEnum::primary {513, "primary"};
const Enum::YLeaf MplsTeLogFrrProtectionEnum::all {769, "all"};

const Enum::YLeaf MplsTeTunnelAffinityEnum::include {1, "include"};
const Enum::YLeaf MplsTeTunnelAffinityEnum::include_strict {2, "include-strict"};
const Enum::YLeaf MplsTeTunnelAffinityEnum::exclude {3, "exclude"};
const Enum::YLeaf MplsTeTunnelAffinityEnum::exclude_all {4, "exclude-all"};
const Enum::YLeaf MplsTeTunnelAffinityEnum::ignore {5, "ignore"};

const Enum::YLeaf IetfModeEnum::standard {3, "standard"};

const Enum::YLeaf MplsTePathOptionPropertyEnum::none {0, "none"};
const Enum::YLeaf MplsTePathOptionPropertyEnum::lockdown {1, "lockdown"};
const Enum::YLeaf MplsTePathOptionPropertyEnum::verbatim {4, "verbatim"};
const Enum::YLeaf MplsTePathOptionPropertyEnum::pce {8, "pce"};
const Enum::YLeaf MplsTePathOptionPropertyEnum::segment_routing {16, "segment-routing"};

const Enum::YLeaf GmplsttiModeEnum::sm {1, "sm"};
const Enum::YLeaf GmplsttiModeEnum::pm {2, "pm"};
const Enum::YLeaf GmplsttiModeEnum::tcm {3, "tcm"};

const Enum::YLeaf MplsTePathSelectionInvalidationTimerExpireEnum::tunnel_action_tear {1, "tunnel-action-tear"};
const Enum::YLeaf MplsTePathSelectionInvalidationTimerExpireEnum::tunnel_action_drop {2, "tunnel-action-drop"};

const Enum::YLeaf MplsTeOtnApsProtectionEnum::Y_1plus1_unidir_no_aps {4, "1plus1-unidir-no-aps"};
const Enum::YLeaf MplsTeOtnApsProtectionEnum::Y_1plus1_unidir_aps {8, "1plus1-unidir-aps"};
const Enum::YLeaf MplsTeOtnApsProtectionEnum::Y_1plus1_bdir_aps {16, "1plus1-bdir-aps"};

const Enum::YLeaf MplsTeSwitchingEncodingEnum::packet {1, "packet"};
const Enum::YLeaf MplsTeSwitchingEncodingEnum::ethernet {2, "ethernet"};
const Enum::YLeaf MplsTeSwitchingEncodingEnum::sondet_sdh {5, "sondet-sdh"};

const Enum::YLeaf MplsTeSigNameOptionEnum::none {0, "none"};
const Enum::YLeaf MplsTeSigNameOptionEnum::address {1, "address"};
const Enum::YLeaf MplsTeSigNameOptionEnum::name {2, "name"};

const Enum::YLeaf OtnProtectionSwitchLockoutEnum::none {0, "none"};
const Enum::YLeaf OtnProtectionSwitchLockoutEnum::working {1, "working"};

const Enum::YLeaf MplsTeTunnelIdEnum::auto_ {0, "auto"};
const Enum::YLeaf MplsTeTunnelIdEnum::explicit_ {1, "explicit"};

const Enum::YLeaf MplsTeAffinityValueEnum::hex_value {1, "hex-value"};
const Enum::YLeaf MplsTeAffinityValueEnum::bit_position {2, "bit-position"};

const Enum::YLeaf MplsTeOtnSncModeEnum::snc_n {1, "snc-n"};
const Enum::YLeaf MplsTeOtnSncModeEnum::snc_i {2, "snc-i"};
const Enum::YLeaf MplsTeOtnSncModeEnum::snc_s {3, "snc-s"};

const Enum::YLeaf OtnPayloadEnum::unknown {0, "unknown"};
const Enum::YLeaf OtnPayloadEnum::bmp {50, "bmp"};
const Enum::YLeaf OtnPayloadEnum::gfp_f {54, "gfp-f"};
const Enum::YLeaf OtnPayloadEnum::gmp {55, "gmp"};
const Enum::YLeaf OtnPayloadEnum::gfp_f_ext {70, "gfp-f-ext"};

const Enum::YLeaf OspfAreaModeEnum::ospf_int {0, "ospf-int"};
const Enum::YLeaf OspfAreaModeEnum::ospfip_addr {1, "ospfip-addr"};

const Enum::YLeaf MplsTeIgpProtocolEnum::none {0, "none"};
const Enum::YLeaf MplsTeIgpProtocolEnum::isis {1, "isis"};
const Enum::YLeaf MplsTeIgpProtocolEnum::ospf {2, "ospf"};

const Enum::YLeaf MplsTePathSelectionTiebreakerEnum::min_fill {1, "min-fill"};
const Enum::YLeaf MplsTePathSelectionTiebreakerEnum::max_fill {2, "max-fill"};
const Enum::YLeaf MplsTePathSelectionTiebreakerEnum::random {3, "random"};

const Enum::YLeaf MplsTePathOptionEnum::not_set {0, "not-set"};
const Enum::YLeaf MplsTePathOptionEnum::dynamic {1, "dynamic"};
const Enum::YLeaf MplsTePathOptionEnum::explicit_name {3, "explicit-name"};
const Enum::YLeaf MplsTePathOptionEnum::explicit_number {4, "explicit-number"};
const Enum::YLeaf MplsTePathOptionEnum::no_ero {5, "no-ero"};
const Enum::YLeaf MplsTePathOptionEnum::sr {6, "sr"};

const Enum::YLeaf PathInvalidationActionEnum::tear {1, "tear"};
const Enum::YLeaf PathInvalidationActionEnum::drop {2, "drop"};

const Enum::YLeaf OtnSignaledBandwidthEnum::odu1 {1, "odu1"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu2 {2, "odu2"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu3 {3, "odu3"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu4 {4, "odu4"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu0 {10, "odu0"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu2e {11, "odu2e"};
const Enum::YLeaf OtnSignaledBandwidthEnum::od_uflex_cbr {20, "od-uflex-cbr"};
const Enum::YLeaf OtnSignaledBandwidthEnum::od_uflex_gfp_resize {21, "od-uflex-gfp-resize"};
const Enum::YLeaf OtnSignaledBandwidthEnum::od_uflex_gfp_not_resize {22, "od-uflex-gfp-not-resize"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu1e {23, "odu1e"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu1f {24, "odu1f"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu2f {25, "odu2f"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu3e1 {26, "odu3e1"};
const Enum::YLeaf OtnSignaledBandwidthEnum::odu3e2 {27, "odu3e2"};

const Enum::YLeaf MplsTeAutorouteMetricEnum::relative {1, "relative"};
const Enum::YLeaf MplsTeAutorouteMetricEnum::absolute {2, "absolute"};
const Enum::YLeaf MplsTeAutorouteMetricEnum::constant {3, "constant"};

const Enum::YLeaf BindingSegmentIdEnum::any_label {1, "any-label"};
const Enum::YLeaf BindingSegmentIdEnum::specified_label {2, "specified-label"};

const Enum::YLeaf MplsTesrlgExcludeEnum::mandatory {1, "mandatory"};
const Enum::YLeaf MplsTesrlgExcludeEnum::preferred {2, "preferred"};
const Enum::YLeaf MplsTesrlgExcludeEnum::weighted {3, "weighted"};

const Enum::YLeaf MplsTeSignaledLabelEnum::not_set {0, "not-set"};
const Enum::YLeaf MplsTeSignaledLabelEnum::dwdm {1, "dwdm"};

const Enum::YLeaf BandwidthConstraintEnum::bandwidth_constraint_maximum_allocation_model {1, "bandwidth-constraint-maximum-allocation-model"};

const Enum::YLeaf MplsTeSwitchingEncodeEnum::none {0, "none"};
const Enum::YLeaf MplsTeSwitchingEncodeEnum::packet {1, "packet"};
const Enum::YLeaf MplsTeSwitchingEncodeEnum::ethernet {2, "ethernet"};
const Enum::YLeaf MplsTeSwitchingEncodeEnum::sondet_sdh {5, "sondet-sdh"};

const Enum::YLeaf MplsTePathSelectionMetricEnum::igp {1, "igp"};
const Enum::YLeaf MplsTePathSelectionMetricEnum::te {2, "te"};
const Enum::YLeaf MplsTePathSelectionMetricEnum::delay {4, "delay"};

const Enum::YLeaf MplsTePathOptionProtectionEnum::active {0, "active"};
const Enum::YLeaf MplsTePathOptionProtectionEnum::protecting {1, "protecting"};

const Enum::YLeaf OtnSignaledBandwidthFlexFramingEnum::cbr {20, "cbr"};
const Enum::YLeaf OtnSignaledBandwidthFlexFramingEnum::framed_gfp_fixed {21, "framed-gfp-fixed"};
const Enum::YLeaf OtnSignaledBandwidthFlexFramingEnum::framed_gfp_resize {22, "framed-gfp-resize"};

const Enum::YLeaf MplsTeBandwidthLimitEnum::unlimited {64, "unlimited"};
const Enum::YLeaf MplsTeBandwidthLimitEnum::limited {128, "limited"};

const Enum::YLeaf MplsTePathSelectionSegmentRoutingAdjacencyProtectionEnum::not_set {0, "not-set"};
const Enum::YLeaf MplsTePathSelectionSegmentRoutingAdjacencyProtectionEnum::adj_unprotected {1, "adj-unprotected"};
const Enum::YLeaf MplsTePathSelectionSegmentRoutingAdjacencyProtectionEnum::adj_protected {2, "adj-protected"};

const Enum::YLeaf LinkNextHopEnum::none {1, "none"};
const Enum::YLeaf LinkNextHopEnum::ipv4_address {2, "ipv4-address"};

const Enum::YLeaf MplsLcacFloodingIgpEnum::ospf {0, "ospf"};

const Enum::YLeaf BfdReversePathEnum::bfd_reverse_path_binding_label {1, "bfd-reverse-path-binding-label"};

const Enum::YLeaf MplsTeOtnApsRestorationStyleEnum::keep_failed_lsp {1, "keep-failed-lsp"};
const Enum::YLeaf MplsTeOtnApsRestorationStyleEnum::delete_failed_lsp {2, "delete-failed-lsp"};

const Enum::YLeaf MplsTeBandwidthDsteEnum::standard_dste {0, "standard-dste"};
const Enum::YLeaf MplsTeBandwidthDsteEnum::pre_standard_dste {1, "pre-standard-dste"};

const Enum::YLeaf MplsTePathDiversityConformanceEnum::strict {0, "strict"};
const Enum::YLeaf MplsTePathDiversityConformanceEnum::best_effort {1, "best-effort"};

const Enum::YLeaf MplsTeBackupBandwidthPoolEnum::any_pool {1, "any-pool"};
const Enum::YLeaf MplsTeBackupBandwidthPoolEnum::global_pool {2, "global-pool"};
const Enum::YLeaf MplsTeBackupBandwidthPoolEnum::sub_pool {4, "sub-pool"};

const Enum::YLeaf MplsTeOtnApsProtectionModeEnum::revertive {1, "revertive"};
const Enum::YLeaf MplsTeOtnApsProtectionModeEnum::non_revertive {2, "non-revertive"};

const Enum::YLeaf MplsTeSwitchingIndexEnum::link {255, "link"};

const Enum::YLeaf MplsTeConfigTunnelEnum::p2p {0, "p2p"};
const Enum::YLeaf MplsTeConfigTunnelEnum::p2mp {1, "p2mp"};


}
}

