
#include <sstream>
#include <iostream>
#include "ydk/entity_util.hpp"
#include "Cisco_IOS_XR_ip_bfd_oper.hpp"

namespace ydk {
namespace Cisco_IOS_XR_ip_bfd_oper {

Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/label-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/label-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "label-session-brief";
}

Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/label-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelSessionBriefs::LabelSessionBrief::LabelSessionBrief()
    :
    	incoming_label{YType::int32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 state{YType::enumeration, "state"}
    	,
    status_brief_information(std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "label-session-brief"; yang_parent_name = "label-session-briefs";
}

Bfd::LabelSessionBriefs::LabelSessionBrief::~LabelSessionBrief()
{
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| state.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::LabelSessionBriefs::LabelSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(state.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::LabelSessionBriefs::LabelSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionBriefs::LabelSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionBriefs::LabelSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionBriefs::LabelSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::LabelSessionBriefs::LabelSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::LabelSessionBriefs::LabelSessionBriefs()
{
    yang_name = "label-session-briefs"; yang_parent_name = "bfd";
}

Bfd::LabelSessionBriefs::~LabelSessionBriefs()
{
}

bool Bfd::LabelSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<label_session_brief.size(); index++)
    {
        if(label_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::LabelSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<label_session_brief.size(); index++)
    {
        if(label_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::LabelSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "label-session-brief")
    {
        for(auto const & c : label_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelSessionBriefs::LabelSessionBrief>();
        c->parent = this;
        label_session_brief.push_back(std::move(c));
        children[segment_path] = label_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionBriefs::get_children()
{
    for (auto const & c : label_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::LabelSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4bf-do-mplste-tail-summary";
}

Bfd::Ipv4BfDoMplsteTailSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4BfDoMplsteTailSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSummary::Ipv4BfDoMplsteTailSummary()
    :
    session_state(std::make_unique<Bfd::Ipv4BfDoMplsteTailSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4bf-do-mplste-tail-summary"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteTailSummary::~Ipv4BfDoMplsteTailSummary()
{
}

bool Bfd::Ipv4BfDoMplsteTailSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-summary";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4BfDoMplsteTailSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::Ipv6SingleHopPacketCounter()
    :
    	interface_name{YType::str, "interface-name"},
	 display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"}
{
    yang_name = "ipv6-single-hop-packet-counter"; yang_parent_name = "ipv6-single-hop-packet-counters";
}

Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::~Ipv6SingleHopPacketCounter()
{
}

bool Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::has_data() const
{
    return interface_name.is_set
	|| display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set;
}

bool Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation);
}

std::string Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-packet-counter" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-counters/ipv6-single-hop-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
}

Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounters()
{
    yang_name = "ipv6-single-hop-packet-counters"; yang_parent_name = "ipv6-single-hop-counters";
}

Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::~Ipv6SingleHopPacketCounters()
{
}

bool Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::has_data() const
{
    for (std::size_t index=0; index<ipv6_single_hop_packet_counter.size(); index++)
    {
        if(ipv6_single_hop_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<ipv6_single_hop_packet_counter.size(); index++)
    {
        if(ipv6_single_hop_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-packet-counter")
    {
        for(auto const & c : ipv6_single_hop_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::Ipv6SingleHopPacketCounter>();
        c->parent = this;
        ipv6_single_hop_packet_counter.push_back(std::move(c));
        children[segment_path] = ipv6_single_hop_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::get_children()
{
    for (auto const & c : ipv6_single_hop_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopCounters::Ipv6SingleHopCounters()
    :
    ipv6_single_hop_packet_counters(std::make_unique<Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters>())
{
    ipv6_single_hop_packet_counters->parent = this;
    children["ipv6-single-hop-packet-counters"] = ipv6_single_hop_packet_counters.get();

    yang_name = "ipv6-single-hop-counters"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopCounters::~Ipv6SingleHopCounters()
{
}

bool Bfd::Ipv6SingleHopCounters::has_data() const
{
    return (ipv6_single_hop_packet_counters !=  nullptr && ipv6_single_hop_packet_counters->has_data());
}

bool Bfd::Ipv6SingleHopCounters::has_operation() const
{
    return is_set(operation)
	|| (ipv6_single_hop_packet_counters !=  nullptr && ipv6_single_hop_packet_counters->has_operation());
}

std::string Bfd::Ipv6SingleHopCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-packet-counters")
    {
        if(ipv6_single_hop_packet_counters != nullptr)
        {
            children["ipv6-single-hop-packet-counters"] = ipv6_single_hop_packet_counters.get();
        }
        else
        {
            ipv6_single_hop_packet_counters = std::make_unique<Bfd::Ipv6SingleHopCounters::Ipv6SingleHopPacketCounters>();
            ipv6_single_hop_packet_counters->parent = this;
            children["ipv6-single-hop-packet-counters"] = ipv6_single_hop_packet_counters.get();
        }
        return children.at("ipv6-single-hop-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopCounters::get_children()
{
    if(children.find("ipv6-single-hop-packet-counters") == children.end())
    {
        if(ipv6_single_hop_packet_counters != nullptr)
        {
            children["ipv6-single-hop-packet-counters"] = ipv6_single_hop_packet_counters.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Counters::PacketCounters::PacketCounter::PacketCounter()
    :
    	interface_name{YType::str, "interface-name"},
	 display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"}
{
    yang_name = "packet-counter"; yang_parent_name = "packet-counters";
}

Bfd::Counters::PacketCounters::PacketCounter::~PacketCounter()
{
}

bool Bfd::Counters::PacketCounters::PacketCounter::has_data() const
{
    return interface_name.is_set
	|| display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set;
}

bool Bfd::Counters::PacketCounters::PacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation);
}

std::string Bfd::Counters::PacketCounters::PacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "packet-counter" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Counters::PacketCounters::PacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/counters/packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Counters::PacketCounters::PacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Counters::PacketCounters::PacketCounter::get_children()
{
    return children;
}

void Bfd::Counters::PacketCounters::PacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
}

Bfd::Counters::PacketCounters::PacketCounters()
{
    yang_name = "packet-counters"; yang_parent_name = "counters";
}

Bfd::Counters::PacketCounters::~PacketCounters()
{
}

bool Bfd::Counters::PacketCounters::has_data() const
{
    for (std::size_t index=0; index<packet_counter.size(); index++)
    {
        if(packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Counters::PacketCounters::has_operation() const
{
    for (std::size_t index=0; index<packet_counter.size(); index++)
    {
        if(packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Counters::PacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Counters::PacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Counters::PacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "packet-counter")
    {
        for(auto const & c : packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Counters::PacketCounters::PacketCounter>();
        c->parent = this;
        packet_counter.push_back(std::move(c));
        children[segment_path] = packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Counters::PacketCounters::get_children()
{
    for (auto const & c : packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Counters::PacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Counters::Counters()
    :
    packet_counters(std::make_unique<Bfd::Counters::PacketCounters>())
{
    packet_counters->parent = this;
    children["packet-counters"] = packet_counters.get();

    yang_name = "counters"; yang_parent_name = "bfd";
}

Bfd::Counters::~Counters()
{
}

bool Bfd::Counters::has_data() const
{
    return (packet_counters !=  nullptr && packet_counters->has_data());
}

bool Bfd::Counters::has_operation() const
{
    return is_set(operation)
	|| (packet_counters !=  nullptr && packet_counters->has_operation());
}

std::string Bfd::Counters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "counters";

    return path_buffer.str();

}

EntityPath Bfd::Counters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Counters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "packet-counters")
    {
        if(packet_counters != nullptr)
        {
            children["packet-counters"] = packet_counters.get();
        }
        else
        {
            packet_counters = std::make_unique<Bfd::Counters::PacketCounters>();
            packet_counters->parent = this;
            children["packet-counters"] = packet_counters.get();
        }
        return children.at("packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Counters::get_children()
{
    if(children.find("packet-counters") == children.end())
    {
        if(packet_counters != nullptr)
        {
            children["packet-counters"] = packet_counters.get();
        }
    }

    return children;
}

void Bfd::Counters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::ClientDetails::ClientDetail::Brief::Brief()
    :
    	name_xr{YType::str, "name-xr"},
	 node_id{YType::str, "node-id"},
	 session_count{YType::uint32, "session-count"}
{
    yang_name = "brief"; yang_parent_name = "client-detail";
}

Bfd::ClientDetails::ClientDetail::Brief::~Brief()
{
}

bool Bfd::ClientDetails::ClientDetail::Brief::has_data() const
{
    return name_xr.is_set
	|| node_id.is_set
	|| session_count.is_set;
}

bool Bfd::ClientDetails::ClientDetail::Brief::has_operation() const
{
    return is_set(operation)
	|| is_set(name_xr.operation)
	|| is_set(node_id.operation)
	|| is_set(session_count.operation);
}

std::string Bfd::ClientDetails::ClientDetail::Brief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "brief";

    return path_buffer.str();

}

EntityPath Bfd::ClientDetails::ClientDetail::Brief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (name_xr.is_set || is_set(name_xr.operation)) leaf_name_data.push_back(name_xr.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_count.is_set || is_set(session_count.operation)) leaf_name_data.push_back(session_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::ClientDetails::ClientDetail::Brief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::ClientDetails::ClientDetail::Brief::get_children()
{
    return children;
}

void Bfd::ClientDetails::ClientDetail::Brief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "name-xr")
    {
        name_xr = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-count")
    {
        session_count = value;
    }
}

Bfd::ClientDetails::ClientDetail::Flags::Flags()
    :
    	is_recreate_state{YType::int32, "is-recreate-state"},
	 is_zombie_state{YType::int32, "is-zombie-state"}
{
    yang_name = "flags"; yang_parent_name = "client-detail";
}

Bfd::ClientDetails::ClientDetail::Flags::~Flags()
{
}

bool Bfd::ClientDetails::ClientDetail::Flags::has_data() const
{
    return is_recreate_state.is_set
	|| is_zombie_state.is_set;
}

bool Bfd::ClientDetails::ClientDetail::Flags::has_operation() const
{
    return is_set(operation)
	|| is_set(is_recreate_state.operation)
	|| is_set(is_zombie_state.operation);
}

std::string Bfd::ClientDetails::ClientDetail::Flags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "flags";

    return path_buffer.str();

}

EntityPath Bfd::ClientDetails::ClientDetail::Flags::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (is_recreate_state.is_set || is_set(is_recreate_state.operation)) leaf_name_data.push_back(is_recreate_state.get_name_leafdata());
    if (is_zombie_state.is_set || is_set(is_zombie_state.operation)) leaf_name_data.push_back(is_zombie_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::ClientDetails::ClientDetail::Flags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::ClientDetails::ClientDetail::Flags::get_children()
{
    return children;
}

void Bfd::ClientDetails::ClientDetail::Flags::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "is-recreate-state")
    {
        is_recreate_state = value;
    }
    if(value_path == "is-zombie-state")
    {
        is_zombie_state = value;
    }
}

Bfd::ClientDetails::ClientDetail::ClientDetail()
    :
    	client_name{YType::str, "client-name"},
	 recreate_time{YType::uint32, "recreate-time"}
    	,
    brief(std::make_unique<Bfd::ClientDetails::ClientDetail::Brief>())
	,flags(std::make_unique<Bfd::ClientDetails::ClientDetail::Flags>())
{
    brief->parent = this;
    children["brief"] = brief.get();

    flags->parent = this;
    children["flags"] = flags.get();

    yang_name = "client-detail"; yang_parent_name = "client-details";
}

Bfd::ClientDetails::ClientDetail::~ClientDetail()
{
}

bool Bfd::ClientDetails::ClientDetail::has_data() const
{
    return client_name.is_set
	|| recreate_time.is_set
	|| (brief !=  nullptr && brief->has_data())
	|| (flags !=  nullptr && flags->has_data());
}

bool Bfd::ClientDetails::ClientDetail::has_operation() const
{
    return is_set(operation)
	|| is_set(client_name.operation)
	|| is_set(recreate_time.operation)
	|| (brief !=  nullptr && brief->has_operation())
	|| (flags !=  nullptr && flags->has_operation());
}

std::string Bfd::ClientDetails::ClientDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "client-detail" <<"[client-name='" <<client_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::ClientDetails::ClientDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/client-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (client_name.is_set || is_set(client_name.operation)) leaf_name_data.push_back(client_name.get_name_leafdata());
    if (recreate_time.is_set || is_set(recreate_time.operation)) leaf_name_data.push_back(recreate_time.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::ClientDetails::ClientDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "brief")
    {
        if(brief != nullptr)
        {
            children["brief"] = brief.get();
        }
        else
        {
            brief = std::make_unique<Bfd::ClientDetails::ClientDetail::Brief>();
            brief->parent = this;
            children["brief"] = brief.get();
        }
        return children.at("brief");
    }

    if(child_yang_name == "flags")
    {
        if(flags != nullptr)
        {
            children["flags"] = flags.get();
        }
        else
        {
            flags = std::make_unique<Bfd::ClientDetails::ClientDetail::Flags>();
            flags->parent = this;
            children["flags"] = flags.get();
        }
        return children.at("flags");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::ClientDetails::ClientDetail::get_children()
{
    if(children.find("brief") == children.end())
    {
        if(brief != nullptr)
        {
            children["brief"] = brief.get();
        }
    }

    if(children.find("flags") == children.end())
    {
        if(flags != nullptr)
        {
            children["flags"] = flags.get();
        }
    }

    return children;
}

void Bfd::ClientDetails::ClientDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "client-name")
    {
        client_name = value;
    }
    if(value_path == "recreate-time")
    {
        recreate_time = value;
    }
}

Bfd::ClientDetails::ClientDetails()
{
    yang_name = "client-details"; yang_parent_name = "bfd";
}

Bfd::ClientDetails::~ClientDetails()
{
}

bool Bfd::ClientDetails::has_data() const
{
    for (std::size_t index=0; index<client_detail.size(); index++)
    {
        if(client_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::ClientDetails::has_operation() const
{
    for (std::size_t index=0; index<client_detail.size(); index++)
    {
        if(client_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::ClientDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "client-details";

    return path_buffer.str();

}

EntityPath Bfd::ClientDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::ClientDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "client-detail")
    {
        for(auto const & c : client_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::ClientDetails::ClientDetail>();
        c->parent = this;
        client_detail.push_back(std::move(c));
        children[segment_path] = client_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::ClientDetails::get_children()
{
    for (auto const & c : client_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::ClientDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4-single-hop-summary";
}

Bfd::Ipv4SingleHopSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4SingleHopSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4SingleHopSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4SingleHopSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4SingleHopSummary::Ipv4SingleHopSummary()
    :
    session_state(std::make_unique<Bfd::Ipv4SingleHopSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4-single-hop-summary"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopSummary::~Ipv4SingleHopSummary()
{
}

bool Bfd::Ipv4SingleHopSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4SingleHopSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4SingleHopSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-summary";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4SingleHopSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv6-single-hop-summary";
}

Bfd::Ipv6SingleHopSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv6SingleHopSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv6SingleHopSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv6SingleHopSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv6SingleHopSummary::Ipv6SingleHopSummary()
    :
    session_state(std::make_unique<Bfd::Ipv6SingleHopSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv6-single-hop-summary"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopSummary::~Ipv6SingleHopSummary()
{
}

bool Bfd::Ipv6SingleHopSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv6SingleHopSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv6SingleHopSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-summary";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv6SingleHopSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelMultiPaths::LabelMultiPath::LabelMultiPath()
    :
    	incoming_label{YType::int32, "incoming-label"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 interface_name{YType::str, "interface-name"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 state{YType::enumeration, "state"}
{
    yang_name = "label-multi-path"; yang_parent_name = "label-multi-paths";
}

Bfd::LabelMultiPaths::LabelMultiPath::~LabelMultiPath()
{
}

bool Bfd::LabelMultiPaths::LabelMultiPath::has_data() const
{
    return incoming_label.is_set
	|| incoming_label_xr.is_set
	|| interface_name.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| state.is_set;
}

bool Bfd::LabelMultiPaths::LabelMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(interface_name.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(state.operation);
}

std::string Bfd::LabelMultiPaths::LabelMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::LabelMultiPaths::LabelMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelMultiPaths::LabelMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelMultiPaths::LabelMultiPath::get_children()
{
    return children;
}

void Bfd::LabelMultiPaths::LabelMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::LabelMultiPaths::LabelMultiPaths()
{
    yang_name = "label-multi-paths"; yang_parent_name = "bfd";
}

Bfd::LabelMultiPaths::~LabelMultiPaths()
{
}

bool Bfd::LabelMultiPaths::has_data() const
{
    for (std::size_t index=0; index<label_multi_path.size(); index++)
    {
        if(label_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::LabelMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<label_multi_path.size(); index++)
    {
        if(label_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::LabelMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::LabelMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "label-multi-path")
    {
        for(auto const & c : label_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelMultiPaths::LabelMultiPath>();
        c->parent = this;
        label_multi_path.push_back(std::move(c));
        children[segment_path] = label_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelMultiPaths::get_children()
{
    for (auto const & c : label_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::LabelMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "ipv4-multi-hop-session-detail";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "ipv4-multi-hop-session-detail";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "ipv4-multi-hop-session-detail";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "ipv4-multi-hop-session-detail";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "ipv4-multi-hop-session-detail";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/ipv4-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::Ipv4MultiHopSessionDetail()
    :
    	destination_address{YType::str, "destination-address"},
	 location{YType::str, "location"},
	 source_address{YType::str, "source-address"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    lsp_ping_info(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "ipv4-multi-hop-session-detail"; yang_parent_name = "ipv4-multi-hop-session-details";
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::~Ipv4MultiHopSessionDetail()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| location.is_set
	|| source_address.is_set
	|| vrf_name.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(location.operation)
	|| is_set(source_address.operation)
	|| is_set(vrf_name.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetails()
{
    yang_name = "ipv4-multi-hop-session-details"; yang_parent_name = "bfd";
}

Bfd::Ipv4MultiHopSessionDetails::~Ipv4MultiHopSessionDetails()
{
}

bool Bfd::Ipv4MultiHopSessionDetails::has_data() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_session_detail.size(); index++)
    {
        if(ipv4_multi_hop_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4MultiHopSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_session_detail.size(); index++)
    {
        if(ipv4_multi_hop_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4MultiHopSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-session-details";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-multi-hop-session-detail")
    {
        for(auto const & c : ipv4_multi_hop_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopSessionDetails::Ipv4MultiHopSessionDetail>();
        c->parent = this;
        ipv4_multi_hop_session_detail.push_back(std::move(c));
        children[segment_path] = ipv4_multi_hop_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionDetails::get_children()
{
    for (auto const & c : ipv4_multi_hop_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "ipv4-single-hop-session-detail";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "ipv4-single-hop-session-detail";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "ipv4-single-hop-session-detail";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "ipv4-single-hop-session-detail";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "ipv4-single-hop-session-detail";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/ipv4-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::Ipv4SingleHopSessionDetail()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"}
    	,
    lsp_ping_info(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "ipv4-single-hop-session-detail"; yang_parent_name = "ipv4-single-hop-session-details";
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::~Ipv4SingleHopSessionDetail()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| interface_name.is_set
	|| location.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetails()
{
    yang_name = "ipv4-single-hop-session-details"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopSessionDetails::~Ipv4SingleHopSessionDetails()
{
}

bool Bfd::Ipv4SingleHopSessionDetails::has_data() const
{
    for (std::size_t index=0; index<ipv4_single_hop_session_detail.size(); index++)
    {
        if(ipv4_single_hop_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4SingleHopSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<ipv4_single_hop_session_detail.size(); index++)
    {
        if(ipv4_single_hop_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4SingleHopSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-session-details";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-session-detail")
    {
        for(auto const & c : ipv4_single_hop_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopSessionDetails::Ipv4SingleHopSessionDetail>();
        c->parent = this;
        ipv4_single_hop_session_detail.push_back(std::move(c));
        children[segment_path] = ipv4_single_hop_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionDetails::get_children()
{
    for (auto const & c : ipv4_single_hop_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/ipv4-multi-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/ipv4-multi-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "ipv4-multi-hop-session-brief";
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/ipv4-multi-hop-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::Ipv4MultiHopSessionBrief()
    :
    	destination_address{YType::str, "destination-address"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 source_address{YType::str, "source-address"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    status_brief_information(std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "ipv4-multi-hop-session-brief"; yang_parent_name = "ipv4-multi-hop-session-briefs";
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::~Ipv4MultiHopSessionBrief()
{
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::has_data() const
{
    return destination_address.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| source_address.is_set
	|| state.is_set
	|| vrf_name.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(source_address.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBriefs()
{
    yang_name = "ipv4-multi-hop-session-briefs"; yang_parent_name = "bfd";
}

Bfd::Ipv4MultiHopSessionBriefs::~Ipv4MultiHopSessionBriefs()
{
}

bool Bfd::Ipv4MultiHopSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_session_brief.size(); index++)
    {
        if(ipv4_multi_hop_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4MultiHopSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_session_brief.size(); index++)
    {
        if(ipv4_multi_hop_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4MultiHopSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-multi-hop-session-brief")
    {
        for(auto const & c : ipv4_multi_hop_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopSessionBriefs::Ipv4MultiHopSessionBrief>();
        c->parent = this;
        ipv4_multi_hop_session_brief.push_back(std::move(c));
        children[segment_path] = ipv4_multi_hop_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSessionBriefs::get_children()
{
    for (auto const & c : ipv4_multi_hop_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::GenericSummaries::GenericSummary::GenericSummary()
    :
    	location{YType::str, "location"},
	 max_session_number{YType::uint32, "max-session-number"},
	 mp_session_number{YType::uint32, "mp-session-number"},
	 node_id{YType::str, "node-id"},
	 pps_allocated_value{YType::uint32, "pps-allocated-value"},
	 pps_max_value{YType::uint32, "pps-max-value"},
	 ppsmp_allocated_value{YType::uint32, "ppsmp-allocated-value"},
	 ppsmp_max_value{YType::uint32, "ppsmp-max-value"},
	 total_session_number{YType::uint32, "total-session-number"}
{
    yang_name = "generic-summary"; yang_parent_name = "generic-summaries";
}

Bfd::GenericSummaries::GenericSummary::~GenericSummary()
{
}

bool Bfd::GenericSummaries::GenericSummary::has_data() const
{
    return location.is_set
	|| max_session_number.is_set
	|| mp_session_number.is_set
	|| node_id.is_set
	|| pps_allocated_value.is_set
	|| pps_max_value.is_set
	|| ppsmp_allocated_value.is_set
	|| ppsmp_max_value.is_set
	|| total_session_number.is_set;
}

bool Bfd::GenericSummaries::GenericSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location.operation)
	|| is_set(max_session_number.operation)
	|| is_set(mp_session_number.operation)
	|| is_set(node_id.operation)
	|| is_set(pps_allocated_value.operation)
	|| is_set(pps_max_value.operation)
	|| is_set(ppsmp_allocated_value.operation)
	|| is_set(ppsmp_max_value.operation)
	|| is_set(total_session_number.operation);
}

std::string Bfd::GenericSummaries::GenericSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-summary" <<"[location='" <<location.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::GenericSummaries::GenericSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/generic-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (max_session_number.is_set || is_set(max_session_number.operation)) leaf_name_data.push_back(max_session_number.get_name_leafdata());
    if (mp_session_number.is_set || is_set(mp_session_number.operation)) leaf_name_data.push_back(mp_session_number.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (pps_allocated_value.is_set || is_set(pps_allocated_value.operation)) leaf_name_data.push_back(pps_allocated_value.get_name_leafdata());
    if (pps_max_value.is_set || is_set(pps_max_value.operation)) leaf_name_data.push_back(pps_max_value.get_name_leafdata());
    if (ppsmp_allocated_value.is_set || is_set(ppsmp_allocated_value.operation)) leaf_name_data.push_back(ppsmp_allocated_value.get_name_leafdata());
    if (ppsmp_max_value.is_set || is_set(ppsmp_max_value.operation)) leaf_name_data.push_back(ppsmp_max_value.get_name_leafdata());
    if (total_session_number.is_set || is_set(total_session_number.operation)) leaf_name_data.push_back(total_session_number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::GenericSummaries::GenericSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::GenericSummaries::GenericSummary::get_children()
{
    return children;
}

void Bfd::GenericSummaries::GenericSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "max-session-number")
    {
        max_session_number = value;
    }
    if(value_path == "mp-session-number")
    {
        mp_session_number = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "pps-allocated-value")
    {
        pps_allocated_value = value;
    }
    if(value_path == "pps-max-value")
    {
        pps_max_value = value;
    }
    if(value_path == "ppsmp-allocated-value")
    {
        ppsmp_allocated_value = value;
    }
    if(value_path == "ppsmp-max-value")
    {
        ppsmp_max_value = value;
    }
    if(value_path == "total-session-number")
    {
        total_session_number = value;
    }
}

Bfd::GenericSummaries::GenericSummaries()
{
    yang_name = "generic-summaries"; yang_parent_name = "bfd";
}

Bfd::GenericSummaries::~GenericSummaries()
{
}

bool Bfd::GenericSummaries::has_data() const
{
    for (std::size_t index=0; index<generic_summary.size(); index++)
    {
        if(generic_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::GenericSummaries::has_operation() const
{
    for (std::size_t index=0; index<generic_summary.size(); index++)
    {
        if(generic_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::GenericSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "generic-summaries";

    return path_buffer.str();

}

EntityPath Bfd::GenericSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::GenericSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "generic-summary")
    {
        for(auto const & c : generic_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::GenericSummaries::GenericSummary>();
        c->parent = this;
        generic_summary.push_back(std::move(c));
        children[segment_path] = generic_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::GenericSummaries::get_children()
{
    for (auto const & c : generic_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::GenericSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::Ipv6SingleHopMultiPath()
    :
    	destination_address{YType::str, "destination-address"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 interface_name{YType::str, "interface-name"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 state{YType::enumeration, "state"}
{
    yang_name = "ipv6-single-hop-multi-path"; yang_parent_name = "ipv6-single-hop-multi-paths";
}

Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::~Ipv6SingleHopMultiPath()
{
}

bool Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::has_data() const
{
    return destination_address.is_set
	|| incoming_label_xr.is_set
	|| interface_name.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| state.is_set;
}

bool Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(interface_name.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(state.operation);
}

std::string Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPaths()
{
    yang_name = "ipv6-single-hop-multi-paths"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopMultiPaths::~Ipv6SingleHopMultiPaths()
{
}

bool Bfd::Ipv6SingleHopMultiPaths::has_data() const
{
    for (std::size_t index=0; index<ipv6_single_hop_multi_path.size(); index++)
    {
        if(ipv6_single_hop_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6SingleHopMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<ipv6_single_hop_multi_path.size(); index++)
    {
        if(ipv6_single_hop_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6SingleHopMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-multi-path")
    {
        for(auto const & c : ipv6_single_hop_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopMultiPaths::Ipv6SingleHopMultiPath>();
        c->parent = this;
        ipv6_single_hop_multi_path.push_back(std::move(c));
        children[segment_path] = ipv6_single_hop_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopMultiPaths::get_children()
{
    for (auto const & c : ipv6_single_hop_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4-single-hop-node-location-summary";
}

Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::Ipv4SingleHopNodeLocationSummary()
    :
    	location{YType::str, "location"}
    	,
    session_state(std::make_unique<Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4-single-hop-node-location-summary"; yang_parent_name = "ipv4-single-hop-node-location-summaries";
}

Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::~Ipv4SingleHopNodeLocationSummary()
{
}

bool Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::has_data() const
{
    return location.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-node-location-summary" <<"[location='" <<location.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-node-location-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummaries()
{
    yang_name = "ipv4-single-hop-node-location-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopNodeLocationSummaries::~Ipv4SingleHopNodeLocationSummaries()
{
}

bool Bfd::Ipv4SingleHopNodeLocationSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv4_single_hop_node_location_summary.size(); index++)
    {
        if(ipv4_single_hop_node_location_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4SingleHopNodeLocationSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv4_single_hop_node_location_summary.size(); index++)
    {
        if(ipv4_single_hop_node_location_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4SingleHopNodeLocationSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-node-location-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopNodeLocationSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopNodeLocationSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-node-location-summary")
    {
        for(auto const & c : ipv4_single_hop_node_location_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopNodeLocationSummaries::Ipv4SingleHopNodeLocationSummary>();
        c->parent = this;
        ipv4_single_hop_node_location_summary.push_back(std::move(c));
        children[segment_path] = ipv4_single_hop_node_location_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopNodeLocationSummaries::get_children()
{
    for (auto const & c : ipv4_single_hop_node_location_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopNodeLocationSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "label-summary";
}

Bfd::LabelSummary::SessionState::~SessionState()
{
}

bool Bfd::LabelSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::LabelSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::LabelSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::LabelSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSummary::SessionState::get_children()
{
    return children;
}

void Bfd::LabelSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::LabelSummary::LabelSummary()
    :
    session_state(std::make_unique<Bfd::LabelSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "label-summary"; yang_parent_name = "bfd";
}

Bfd::LabelSummary::~LabelSummary()
{
}

bool Bfd::LabelSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::LabelSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::LabelSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-summary";

    return path_buffer.str();

}

EntityPath Bfd::LabelSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::LabelSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::LabelSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/ipv4bf-do-mplste-head-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/ipv4bf-do-mplste-head-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "ipv4bf-do-mplste-head-session-brief";
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/ipv4bf-do-mplste-head-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::Ipv4BfDoMplsteHeadSessionBrief()
    :
    	fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 incoming_label{YType::int32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    status_brief_information(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "ipv4bf-do-mplste-head-session-brief"; yang_parent_name = "ipv4bf-do-mplste-head-session-briefs";
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::~Ipv4BfDoMplsteHeadSessionBrief()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::has_data() const
{
    return fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| incoming_label.is_set
	|| interface_name.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| state.is_set
	|| vrf_name.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBriefs()
{
    yang_name = "ipv4bf-do-mplste-head-session-briefs"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteHeadSessionBriefs::~Ipv4BfDoMplsteHeadSessionBriefs()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_session_brief.size(); index++)
    {
        if(ipv4bf_do_mplste_head_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_session_brief.size(); index++)
    {
        if(ipv4bf_do_mplste_head_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-session-brief")
    {
        for(auto const & c : ipv4bf_do_mplste_head_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs::Ipv4BfDoMplsteHeadSessionBrief>();
        c->parent = this;
        ipv4bf_do_mplste_head_session_brief.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_head_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionBriefs::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_head_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "ipv4bf-do-mplste-tail-session-detail";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "ipv4bf-do-mplste-tail-session-detail";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "ipv4bf-do-mplste-tail-session-detail";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "ipv4bf-do-mplste-tail-session-detail";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "ipv4bf-do-mplste-tail-session-detail";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/ipv4bf-do-mplste-tail-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::Ipv4BfDoMplsteTailSessionDetail()
    :
    	fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 incoming_label{YType::int32, "incoming-label"},
	 location{YType::str, "location"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    lsp_ping_info(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "ipv4bf-do-mplste-tail-session-detail"; yang_parent_name = "ipv4bf-do-mplste-tail-session-details";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::~Ipv4BfDoMplsteTailSessionDetail()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| incoming_label.is_set
	|| location.is_set
	|| vrf_name.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(incoming_label.operation)
	|| is_set(location.operation)
	|| is_set(vrf_name.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetails()
{
    yang_name = "ipv4bf-do-mplste-tail-session-details"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteTailSessionDetails::~Ipv4BfDoMplsteTailSessionDetails()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_session_detail.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteTailSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_session_detail.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-session-details";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-session-detail")
    {
        for(auto const & c : ipv4bf_do_mplste_tail_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails::Ipv4BfDoMplsteTailSessionDetail>();
        c->parent = this;
        ipv4bf_do_mplste_tail_session_detail.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_tail_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionDetails::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_tail_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4-multi-hop-node-location-summary";
}

Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::Ipv4MultiHopNodeLocationSummary()
    :
    	location{YType::str, "location"}
    	,
    session_state(std::make_unique<Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4-multi-hop-node-location-summary"; yang_parent_name = "ipv4-multi-hop-node-location-summaries";
}

Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::~Ipv4MultiHopNodeLocationSummary()
{
}

bool Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::has_data() const
{
    return location.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-node-location-summary" <<"[location='" <<location.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-node-location-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummaries()
{
    yang_name = "ipv4-multi-hop-node-location-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv4MultiHopNodeLocationSummaries::~Ipv4MultiHopNodeLocationSummaries()
{
}

bool Bfd::Ipv4MultiHopNodeLocationSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_node_location_summary.size(); index++)
    {
        if(ipv4_multi_hop_node_location_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4MultiHopNodeLocationSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_node_location_summary.size(); index++)
    {
        if(ipv4_multi_hop_node_location_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4MultiHopNodeLocationSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-node-location-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopNodeLocationSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopNodeLocationSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-multi-hop-node-location-summary")
    {
        for(auto const & c : ipv4_multi_hop_node_location_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopNodeLocationSummaries::Ipv4MultiHopNodeLocationSummary>();
        c->parent = this;
        ipv4_multi_hop_node_location_summary.push_back(std::move(c));
        children[segment_path] = ipv4_multi_hop_node_location_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopNodeLocationSummaries::get_children()
{
    for (auto const & c : ipv4_multi_hop_node_location_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopNodeLocationSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/ipv4bf-do-mplste-tail-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/ipv4bf-do-mplste-tail-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "ipv4bf-do-mplste-tail-session-brief";
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/ipv4bf-do-mplste-tail-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::Ipv4BfDoMplsteTailSessionBrief()
    :
    	fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 incoming_label{YType::int32, "incoming-label"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    status_brief_information(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "ipv4bf-do-mplste-tail-session-brief"; yang_parent_name = "ipv4bf-do-mplste-tail-session-briefs";
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::~Ipv4BfDoMplsteTailSessionBrief()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::has_data() const
{
    return fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| incoming_label.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| state.is_set
	|| vrf_name.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(incoming_label.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBriefs()
{
    yang_name = "ipv4bf-do-mplste-tail-session-briefs"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteTailSessionBriefs::~Ipv4BfDoMplsteTailSessionBriefs()
{
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_session_brief.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteTailSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_session_brief.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteTailSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-session-brief")
    {
        for(auto const & c : ipv4bf_do_mplste_tail_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs::Ipv4BfDoMplsteTailSessionBrief>();
        c->parent = this;
        ipv4bf_do_mplste_tail_session_brief.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_tail_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailSessionBriefs::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_tail_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv6-multi-hop-node-location-summary";
}

Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::Ipv6MultiHopNodeLocationSummary()
    :
    	location{YType::str, "location"}
    	,
    session_state(std::make_unique<Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv6-multi-hop-node-location-summary"; yang_parent_name = "ipv6-multi-hop-node-location-summaries";
}

Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::~Ipv6MultiHopNodeLocationSummary()
{
}

bool Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::has_data() const
{
    return location.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-node-location-summary" <<"[location='" <<location.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-node-location-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummaries()
{
    yang_name = "ipv6-multi-hop-node-location-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv6MultiHopNodeLocationSummaries::~Ipv6MultiHopNodeLocationSummaries()
{
}

bool Bfd::Ipv6MultiHopNodeLocationSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_node_location_summary.size(); index++)
    {
        if(ipv6_multi_hop_node_location_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6MultiHopNodeLocationSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_node_location_summary.size(); index++)
    {
        if(ipv6_multi_hop_node_location_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6MultiHopNodeLocationSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-node-location-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopNodeLocationSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopNodeLocationSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-multi-hop-node-location-summary")
    {
        for(auto const & c : ipv6_multi_hop_node_location_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopNodeLocationSummaries::Ipv6MultiHopNodeLocationSummary>();
        c->parent = this;
        ipv6_multi_hop_node_location_summary.push_back(std::move(c));
        children[segment_path] = ipv6_multi_hop_node_location_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopNodeLocationSummaries::get_children()
{
    for (auto const & c : ipv6_multi_hop_node_location_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopNodeLocationSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4-multi-hop-summary";
}

Bfd::Ipv4MultiHopSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4MultiHopSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4MultiHopSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4MultiHopSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4MultiHopSummary::Ipv4MultiHopSummary()
    :
    session_state(std::make_unique<Bfd::Ipv4MultiHopSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4-multi-hop-summary"; yang_parent_name = "bfd";
}

Bfd::Ipv4MultiHopSummary::~Ipv4MultiHopSummary()
{
}

bool Bfd::Ipv4MultiHopSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4MultiHopSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4MultiHopSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-summary";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4MultiHopSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::Ipv4SingleHopPacketCounter()
    :
    	interface_name{YType::str, "interface-name"},
	 display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"}
{
    yang_name = "ipv4-single-hop-packet-counter"; yang_parent_name = "ipv4-single-hop-packet-counters";
}

Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::~Ipv4SingleHopPacketCounter()
{
}

bool Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::has_data() const
{
    return interface_name.is_set
	|| display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set;
}

bool Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation);
}

std::string Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-packet-counter" <<"[interface-name='" <<interface_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-counters/ipv4-single-hop-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
}

Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounters()
{
    yang_name = "ipv4-single-hop-packet-counters"; yang_parent_name = "ipv4-single-hop-counters";
}

Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::~Ipv4SingleHopPacketCounters()
{
}

bool Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::has_data() const
{
    for (std::size_t index=0; index<ipv4_single_hop_packet_counter.size(); index++)
    {
        if(ipv4_single_hop_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<ipv4_single_hop_packet_counter.size(); index++)
    {
        if(ipv4_single_hop_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-packet-counter")
    {
        for(auto const & c : ipv4_single_hop_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::Ipv4SingleHopPacketCounter>();
        c->parent = this;
        ipv4_single_hop_packet_counter.push_back(std::move(c));
        children[segment_path] = ipv4_single_hop_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::get_children()
{
    for (auto const & c : ipv4_single_hop_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopCounters::Ipv4SingleHopCounters()
    :
    ipv4_single_hop_packet_counters(std::make_unique<Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters>())
{
    ipv4_single_hop_packet_counters->parent = this;
    children["ipv4-single-hop-packet-counters"] = ipv4_single_hop_packet_counters.get();

    yang_name = "ipv4-single-hop-counters"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopCounters::~Ipv4SingleHopCounters()
{
}

bool Bfd::Ipv4SingleHopCounters::has_data() const
{
    return (ipv4_single_hop_packet_counters !=  nullptr && ipv4_single_hop_packet_counters->has_data());
}

bool Bfd::Ipv4SingleHopCounters::has_operation() const
{
    return is_set(operation)
	|| (ipv4_single_hop_packet_counters !=  nullptr && ipv4_single_hop_packet_counters->has_operation());
}

std::string Bfd::Ipv4SingleHopCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-packet-counters")
    {
        if(ipv4_single_hop_packet_counters != nullptr)
        {
            children["ipv4-single-hop-packet-counters"] = ipv4_single_hop_packet_counters.get();
        }
        else
        {
            ipv4_single_hop_packet_counters = std::make_unique<Bfd::Ipv4SingleHopCounters::Ipv4SingleHopPacketCounters>();
            ipv4_single_hop_packet_counters->parent = this;
            children["ipv4-single-hop-packet-counters"] = ipv4_single_hop_packet_counters.get();
        }
        return children.at("ipv4-single-hop-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopCounters::get_children()
{
    if(children.find("ipv4-single-hop-packet-counters") == children.end())
    {
        if(ipv4_single_hop_packet_counters != nullptr)
        {
            children["ipv4-single-hop-packet-counters"] = ipv4_single_hop_packet_counters.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "ipv6-multi-hop-session-detail";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "ipv6-multi-hop-session-detail";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "ipv6-multi-hop-session-detail";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "ipv6-multi-hop-session-detail";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "ipv6-multi-hop-session-detail";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/ipv6-multi-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::Ipv6MultiHopSessionDetail()
    :
    	destination_address{YType::str, "destination-address"},
	 location{YType::str, "location"},
	 source_address{YType::str, "source-address"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    lsp_ping_info(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "ipv6-multi-hop-session-detail"; yang_parent_name = "ipv6-multi-hop-session-details";
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::~Ipv6MultiHopSessionDetail()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| location.is_set
	|| source_address.is_set
	|| vrf_name.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(location.operation)
	|| is_set(source_address.operation)
	|| is_set(vrf_name.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetails()
{
    yang_name = "ipv6-multi-hop-session-details"; yang_parent_name = "bfd";
}

Bfd::Ipv6MultiHopSessionDetails::~Ipv6MultiHopSessionDetails()
{
}

bool Bfd::Ipv6MultiHopSessionDetails::has_data() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_session_detail.size(); index++)
    {
        if(ipv6_multi_hop_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6MultiHopSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_session_detail.size(); index++)
    {
        if(ipv6_multi_hop_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6MultiHopSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-session-details";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-multi-hop-session-detail")
    {
        for(auto const & c : ipv6_multi_hop_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopSessionDetails::Ipv6MultiHopSessionDetail>();
        c->parent = this;
        ipv6_multi_hop_session_detail.push_back(std::move(c));
        children[segment_path] = ipv6_multi_hop_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionDetails::get_children()
{
    for (auto const & c : ipv6_multi_hop_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::Ipv6MultiHopMultiPath()
    :
    	destination_address{YType::str, "destination-address"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 source_address{YType::str, "source-address"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv6-multi-hop-multi-path"; yang_parent_name = "ipv6-multi-hop-multi-paths";
}

Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::~Ipv6MultiHopMultiPath()
{
}

bool Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::has_data() const
{
    return destination_address.is_set
	|| incoming_label_xr.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| source_address.is_set
	|| state.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(source_address.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPaths()
{
    yang_name = "ipv6-multi-hop-multi-paths"; yang_parent_name = "bfd";
}

Bfd::Ipv6MultiHopMultiPaths::~Ipv6MultiHopMultiPaths()
{
}

bool Bfd::Ipv6MultiHopMultiPaths::has_data() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_multi_path.size(); index++)
    {
        if(ipv6_multi_hop_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6MultiHopMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_multi_path.size(); index++)
    {
        if(ipv6_multi_hop_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6MultiHopMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-multi-hop-multi-path")
    {
        for(auto const & c : ipv6_multi_hop_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopMultiPaths::Ipv6MultiHopMultiPath>();
        c->parent = this;
        ipv6_multi_hop_multi_path.push_back(std::move(c));
        children[segment_path] = ipv6_multi_hop_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopMultiPaths::get_children()
{
    for (auto const & c : ipv6_multi_hop_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::Ipv4BfDoMplsteHeadPacketCounter()
    :
    	display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"}
{
    yang_name = "ipv4bf-do-mplste-head-packet-counter"; yang_parent_name = "ipv4bf-do-mplste-head-packet-counters";
}

Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::~Ipv4BfDoMplsteHeadPacketCounter()
{
}

bool Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::has_data() const
{
    return display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set
	|| interface_name.is_set
	|| location.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-packet-counter";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-counters/ipv4bf-do-mplste-head-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounters()
{
    yang_name = "ipv4bf-do-mplste-head-packet-counters"; yang_parent_name = "ipv4bf-do-mplste-head-counters";
}

Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::~Ipv4BfDoMplsteHeadPacketCounters()
{
}

bool Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_packet_counter.size(); index++)
    {
        if(ipv4bf_do_mplste_head_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_packet_counter.size(); index++)
    {
        if(ipv4bf_do_mplste_head_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-packet-counter")
    {
        for(auto const & c : ipv4bf_do_mplste_head_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::Ipv4BfDoMplsteHeadPacketCounter>();
        c->parent = this;
        ipv4bf_do_mplste_head_packet_counter.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_head_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_head_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadCounters()
    :
    ipv4bf_do_mplste_head_packet_counters(std::make_unique<Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters>())
{
    ipv4bf_do_mplste_head_packet_counters->parent = this;
    children["ipv4bf-do-mplste-head-packet-counters"] = ipv4bf_do_mplste_head_packet_counters.get();

    yang_name = "ipv4bf-do-mplste-head-counters"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteHeadCounters::~Ipv4BfDoMplsteHeadCounters()
{
}

bool Bfd::Ipv4BfDoMplsteHeadCounters::has_data() const
{
    return (ipv4bf_do_mplste_head_packet_counters !=  nullptr && ipv4bf_do_mplste_head_packet_counters->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadCounters::has_operation() const
{
    return is_set(operation)
	|| (ipv4bf_do_mplste_head_packet_counters !=  nullptr && ipv4bf_do_mplste_head_packet_counters->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-packet-counters")
    {
        if(ipv4bf_do_mplste_head_packet_counters != nullptr)
        {
            children["ipv4bf-do-mplste-head-packet-counters"] = ipv4bf_do_mplste_head_packet_counters.get();
        }
        else
        {
            ipv4bf_do_mplste_head_packet_counters = std::make_unique<Bfd::Ipv4BfDoMplsteHeadCounters::Ipv4BfDoMplsteHeadPacketCounters>();
            ipv4bf_do_mplste_head_packet_counters->parent = this;
            children["ipv4bf-do-mplste-head-packet-counters"] = ipv4bf_do_mplste_head_packet_counters.get();
        }
        return children.at("ipv4bf-do-mplste-head-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadCounters::get_children()
{
    if(children.find("ipv4bf-do-mplste-head-packet-counters") == children.end())
    {
        if(ipv4bf_do_mplste_head_packet_counters != nullptr)
        {
            children["ipv4bf-do-mplste-head-packet-counters"] = ipv4bf_do_mplste_head_packet_counters.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::SessionMibs::SessionMib::DestAddress::DestAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "dest-address"; yang_parent_name = "session-mib";
}

Bfd::SessionMibs::SessionMib::DestAddress::~DestAddress()
{
}

bool Bfd::SessionMibs::SessionMib::DestAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::SessionMibs::SessionMib::DestAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::SessionMibs::SessionMib::DestAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dest-address";

    return path_buffer.str();

}

EntityPath Bfd::SessionMibs::SessionMib::DestAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionMibs::SessionMib::DestAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionMibs::SessionMib::DestAddress::get_children()
{
    return children;
}

void Bfd::SessionMibs::SessionMib::DestAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::SessionMibs::SessionMib::SessionMib()
    :
    	discriminator{YType::int32, "discriminator"},
	 desired_min_tx_interval{YType::uint32, "desired-min-tx-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 int_handle{YType::uint32, "int-handle"},
	 interface_name{YType::str, "interface-name"},
	 last_down_diag{YType::enumeration, "last-down-diag"},
	 last_down_time_nsec{YType::uint32, "last-down-time-nsec"},
	 last_down_time_sec{YType::uint64, "last-down-time-sec"},
	 last_time_cached{YType::uint64, "last-time-cached"},
	 last_up_time_nsec{YType::uint32, "last-up-time-nsec"},
	 last_up_time_sec{YType::uint64, "last-up-time-sec"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 pkt_in{YType::uint64, "pkt-in"},
	 pkt_out{YType::uint64, "pkt-out"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 required_min_rx_echo_interval{YType::uint32, "required-min-rx-echo-interval"},
	 required_min_rx_interval{YType::uint32, "required-min-rx-interval"},
	 session_state{YType::uint32, "session-state"},
	 sessionversion{YType::uint32, "sessionversion"},
	 trap_bitmap{YType::uint32, "trap-bitmap"},
	 up_counter{YType::uint32, "up-counter"}
    	,
    dest_address(std::make_unique<Bfd::SessionMibs::SessionMib::DestAddress>())
{
    dest_address->parent = this;
    children["dest-address"] = dest_address.get();

    yang_name = "session-mib"; yang_parent_name = "session-mibs";
}

Bfd::SessionMibs::SessionMib::~SessionMib()
{
}

bool Bfd::SessionMibs::SessionMib::has_data() const
{
    return discriminator.is_set
	|| desired_min_tx_interval.is_set
	|| detection_multiplier.is_set
	|| int_handle.is_set
	|| interface_name.is_set
	|| last_down_diag.is_set
	|| last_down_time_nsec.is_set
	|| last_down_time_sec.is_set
	|| last_time_cached.is_set
	|| last_up_time_nsec.is_set
	|| last_up_time_sec.is_set
	|| local_discriminator.is_set
	|| pkt_in.is_set
	|| pkt_out.is_set
	|| remote_discriminator.is_set
	|| required_min_rx_echo_interval.is_set
	|| required_min_rx_interval.is_set
	|| session_state.is_set
	|| sessionversion.is_set
	|| trap_bitmap.is_set
	|| up_counter.is_set
	|| (dest_address !=  nullptr && dest_address->has_data());
}

bool Bfd::SessionMibs::SessionMib::has_operation() const
{
    return is_set(operation)
	|| is_set(discriminator.operation)
	|| is_set(desired_min_tx_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(int_handle.operation)
	|| is_set(interface_name.operation)
	|| is_set(last_down_diag.operation)
	|| is_set(last_down_time_nsec.operation)
	|| is_set(last_down_time_sec.operation)
	|| is_set(last_time_cached.operation)
	|| is_set(last_up_time_nsec.operation)
	|| is_set(last_up_time_sec.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(pkt_in.operation)
	|| is_set(pkt_out.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(required_min_rx_echo_interval.operation)
	|| is_set(required_min_rx_interval.operation)
	|| is_set(session_state.operation)
	|| is_set(sessionversion.operation)
	|| is_set(trap_bitmap.operation)
	|| is_set(up_counter.operation)
	|| (dest_address !=  nullptr && dest_address->has_operation());
}

std::string Bfd::SessionMibs::SessionMib::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-mib" <<"[discriminator='" <<discriminator.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::SessionMibs::SessionMib::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-mibs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (discriminator.is_set || is_set(discriminator.operation)) leaf_name_data.push_back(discriminator.get_name_leafdata());
    if (desired_min_tx_interval.is_set || is_set(desired_min_tx_interval.operation)) leaf_name_data.push_back(desired_min_tx_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (int_handle.is_set || is_set(int_handle.operation)) leaf_name_data.push_back(int_handle.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (last_down_diag.is_set || is_set(last_down_diag.operation)) leaf_name_data.push_back(last_down_diag.get_name_leafdata());
    if (last_down_time_nsec.is_set || is_set(last_down_time_nsec.operation)) leaf_name_data.push_back(last_down_time_nsec.get_name_leafdata());
    if (last_down_time_sec.is_set || is_set(last_down_time_sec.operation)) leaf_name_data.push_back(last_down_time_sec.get_name_leafdata());
    if (last_time_cached.is_set || is_set(last_time_cached.operation)) leaf_name_data.push_back(last_time_cached.get_name_leafdata());
    if (last_up_time_nsec.is_set || is_set(last_up_time_nsec.operation)) leaf_name_data.push_back(last_up_time_nsec.get_name_leafdata());
    if (last_up_time_sec.is_set || is_set(last_up_time_sec.operation)) leaf_name_data.push_back(last_up_time_sec.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (pkt_in.is_set || is_set(pkt_in.operation)) leaf_name_data.push_back(pkt_in.get_name_leafdata());
    if (pkt_out.is_set || is_set(pkt_out.operation)) leaf_name_data.push_back(pkt_out.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (required_min_rx_echo_interval.is_set || is_set(required_min_rx_echo_interval.operation)) leaf_name_data.push_back(required_min_rx_echo_interval.get_name_leafdata());
    if (required_min_rx_interval.is_set || is_set(required_min_rx_interval.operation)) leaf_name_data.push_back(required_min_rx_interval.get_name_leafdata());
    if (session_state.is_set || is_set(session_state.operation)) leaf_name_data.push_back(session_state.get_name_leafdata());
    if (sessionversion.is_set || is_set(sessionversion.operation)) leaf_name_data.push_back(sessionversion.get_name_leafdata());
    if (trap_bitmap.is_set || is_set(trap_bitmap.operation)) leaf_name_data.push_back(trap_bitmap.get_name_leafdata());
    if (up_counter.is_set || is_set(up_counter.operation)) leaf_name_data.push_back(up_counter.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionMibs::SessionMib::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dest-address")
    {
        if(dest_address != nullptr)
        {
            children["dest-address"] = dest_address.get();
        }
        else
        {
            dest_address = std::make_unique<Bfd::SessionMibs::SessionMib::DestAddress>();
            dest_address->parent = this;
            children["dest-address"] = dest_address.get();
        }
        return children.at("dest-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionMibs::SessionMib::get_children()
{
    if(children.find("dest-address") == children.end())
    {
        if(dest_address != nullptr)
        {
            children["dest-address"] = dest_address.get();
        }
    }

    return children;
}

void Bfd::SessionMibs::SessionMib::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "discriminator")
    {
        discriminator = value;
    }
    if(value_path == "desired-min-tx-interval")
    {
        desired_min_tx_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "int-handle")
    {
        int_handle = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "last-down-diag")
    {
        last_down_diag = value;
    }
    if(value_path == "last-down-time-nsec")
    {
        last_down_time_nsec = value;
    }
    if(value_path == "last-down-time-sec")
    {
        last_down_time_sec = value;
    }
    if(value_path == "last-time-cached")
    {
        last_time_cached = value;
    }
    if(value_path == "last-up-time-nsec")
    {
        last_up_time_nsec = value;
    }
    if(value_path == "last-up-time-sec")
    {
        last_up_time_sec = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "pkt-in")
    {
        pkt_in = value;
    }
    if(value_path == "pkt-out")
    {
        pkt_out = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "required-min-rx-echo-interval")
    {
        required_min_rx_echo_interval = value;
    }
    if(value_path == "required-min-rx-interval")
    {
        required_min_rx_interval = value;
    }
    if(value_path == "session-state")
    {
        session_state = value;
    }
    if(value_path == "sessionversion")
    {
        sessionversion = value;
    }
    if(value_path == "trap-bitmap")
    {
        trap_bitmap = value;
    }
    if(value_path == "up-counter")
    {
        up_counter = value;
    }
}

Bfd::SessionMibs::SessionMibs()
{
    yang_name = "session-mibs"; yang_parent_name = "bfd";
}

Bfd::SessionMibs::~SessionMibs()
{
}

bool Bfd::SessionMibs::has_data() const
{
    for (std::size_t index=0; index<session_mib.size(); index++)
    {
        if(session_mib[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::SessionMibs::has_operation() const
{
    for (std::size_t index=0; index<session_mib.size(); index++)
    {
        if(session_mib[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::SessionMibs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-mibs";

    return path_buffer.str();

}

EntityPath Bfd::SessionMibs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionMibs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-mib")
    {
        for(auto const & c : session_mib)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::SessionMibs::SessionMib>();
        c->parent = this;
        session_mib.push_back(std::move(c));
        children[segment_path] = session_mib.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionMibs::get_children()
{
    for (auto const & c : session_mib)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::SessionMibs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv6-multi-hop-summary";
}

Bfd::Ipv6MultiHopSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv6MultiHopSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv6MultiHopSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv6MultiHopSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv6MultiHopSummary::Ipv6MultiHopSummary()
    :
    session_state(std::make_unique<Bfd::Ipv6MultiHopSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv6-multi-hop-summary"; yang_parent_name = "bfd";
}

Bfd::Ipv6MultiHopSummary::~Ipv6MultiHopSummary()
{
}

bool Bfd::Ipv6MultiHopSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv6MultiHopSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv6MultiHopSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-summary";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv6MultiHopSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "label-summary-node";
}

Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::~SessionState()
{
}

bool Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::get_children()
{
    return children;
}

void Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::LabelSummaryNodes::LabelSummaryNode::LabelSummaryNode()
    :
    	location_name{YType::str, "location-name"}
    	,
    session_state(std::make_unique<Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "label-summary-node"; yang_parent_name = "label-summary-nodes";
}

Bfd::LabelSummaryNodes::LabelSummaryNode::~LabelSummaryNode()
{
}

bool Bfd::LabelSummaryNodes::LabelSummaryNode::has_data() const
{
    return location_name.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::LabelSummaryNodes::LabelSummaryNode::has_operation() const
{
    return is_set(operation)
	|| is_set(location_name.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::LabelSummaryNodes::LabelSummaryNode::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-summary-node" <<"[location-name='" <<location_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::LabelSummaryNodes::LabelSummaryNode::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-summary-nodes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location_name.is_set || is_set(location_name.operation)) leaf_name_data.push_back(location_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSummaryNodes::LabelSummaryNode::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::LabelSummaryNodes::LabelSummaryNode::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSummaryNodes::LabelSummaryNode::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::LabelSummaryNodes::LabelSummaryNode::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location-name")
    {
        location_name = value;
    }
}

Bfd::LabelSummaryNodes::LabelSummaryNodes()
{
    yang_name = "label-summary-nodes"; yang_parent_name = "bfd";
}

Bfd::LabelSummaryNodes::~LabelSummaryNodes()
{
}

bool Bfd::LabelSummaryNodes::has_data() const
{
    for (std::size_t index=0; index<label_summary_node.size(); index++)
    {
        if(label_summary_node[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::LabelSummaryNodes::has_operation() const
{
    for (std::size_t index=0; index<label_summary_node.size(); index++)
    {
        if(label_summary_node[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::LabelSummaryNodes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-summary-nodes";

    return path_buffer.str();

}

EntityPath Bfd::LabelSummaryNodes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSummaryNodes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "label-summary-node")
    {
        for(auto const & c : label_summary_node)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelSummaryNodes::LabelSummaryNode>();
        c->parent = this;
        label_summary_node.push_back(std::move(c));
        children[segment_path] = label_summary_node.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSummaryNodes::get_children()
{
    for (auto const & c : label_summary_node)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::LabelSummaryNodes::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/ipv6-multi-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/ipv6-multi-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "ipv6-multi-hop-session-brief";
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/ipv6-multi-hop-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::Ipv6MultiHopSessionBrief()
    :
    	destination_address{YType::str, "destination-address"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 source_address{YType::str, "source-address"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    status_brief_information(std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "ipv6-multi-hop-session-brief"; yang_parent_name = "ipv6-multi-hop-session-briefs";
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::~Ipv6MultiHopSessionBrief()
{
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::has_data() const
{
    return destination_address.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| source_address.is_set
	|| state.is_set
	|| vrf_name.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(source_address.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBriefs()
{
    yang_name = "ipv6-multi-hop-session-briefs"; yang_parent_name = "bfd";
}

Bfd::Ipv6MultiHopSessionBriefs::~Ipv6MultiHopSessionBriefs()
{
}

bool Bfd::Ipv6MultiHopSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_session_brief.size(); index++)
    {
        if(ipv6_multi_hop_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6MultiHopSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_session_brief.size(); index++)
    {
        if(ipv6_multi_hop_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6MultiHopSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-multi-hop-session-brief")
    {
        for(auto const & c : ipv6_multi_hop_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopSessionBriefs::Ipv6MultiHopSessionBrief>();
        c->parent = this;
        ipv6_multi_hop_session_brief.push_back(std::move(c));
        children[segment_path] = ipv6_multi_hop_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopSessionBriefs::get_children()
{
    for (auto const & c : ipv6_multi_hop_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "session-brief";
}

Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::SessionBriefs::SessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::SessionBriefs::SessionBrief::SessionBrief()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 state{YType::enumeration, "state"}
    	,
    status_brief_information(std::make_unique<Bfd::SessionBriefs::SessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "session-brief"; yang_parent_name = "session-briefs";
}

Bfd::SessionBriefs::SessionBrief::~SessionBrief()
{
}

bool Bfd::SessionBriefs::SessionBrief::has_data() const
{
    return destination_address.is_set
	|| interface_name.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| state.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::SessionBriefs::SessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(state.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::SessionBriefs::SessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-brief";

    return path_buffer.str();

}

EntityPath Bfd::SessionBriefs::SessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionBriefs::SessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::SessionBriefs::SessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionBriefs::SessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::SessionBriefs::SessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::SessionBriefs::SessionBriefs()
{
    yang_name = "session-briefs"; yang_parent_name = "bfd";
}

Bfd::SessionBriefs::~SessionBriefs()
{
}

bool Bfd::SessionBriefs::has_data() const
{
    for (std::size_t index=0; index<session_brief.size(); index++)
    {
        if(session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::SessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<session_brief.size(); index++)
    {
        if(session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::SessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::SessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-brief")
    {
        for(auto const & c : session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::SessionBriefs::SessionBrief>();
        c->parent = this;
        session_brief.push_back(std::move(c));
        children[segment_path] = session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionBriefs::get_children()
{
    for (auto const & c : session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::SessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv6-single-hop-node-location-summary";
}

Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::Ipv6SingleHopNodeLocationSummary()
    :
    	location{YType::str, "location"}
    	,
    session_state(std::make_unique<Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv6-single-hop-node-location-summary"; yang_parent_name = "ipv6-single-hop-node-location-summaries";
}

Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::~Ipv6SingleHopNodeLocationSummary()
{
}

bool Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::has_data() const
{
    return location.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-node-location-summary" <<"[location='" <<location.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-node-location-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummaries()
{
    yang_name = "ipv6-single-hop-node-location-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopNodeLocationSummaries::~Ipv6SingleHopNodeLocationSummaries()
{
}

bool Bfd::Ipv6SingleHopNodeLocationSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv6_single_hop_node_location_summary.size(); index++)
    {
        if(ipv6_single_hop_node_location_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6SingleHopNodeLocationSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv6_single_hop_node_location_summary.size(); index++)
    {
        if(ipv6_single_hop_node_location_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6SingleHopNodeLocationSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-node-location-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopNodeLocationSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopNodeLocationSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-node-location-summary")
    {
        for(auto const & c : ipv6_single_hop_node_location_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopNodeLocationSummaries::Ipv6SingleHopNodeLocationSummary>();
        c->parent = this;
        ipv6_single_hop_node_location_summary.push_back(std::move(c));
        children[segment_path] = ipv6_single_hop_node_location_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopNodeLocationSummaries::get_children()
{
    for (auto const & c : ipv6_single_hop_node_location_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopNodeLocationSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Summary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "summary";
}

Bfd::Summary::SessionState::~SessionState()
{
}

bool Bfd::Summary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Summary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Summary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Summary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Summary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Summary::SessionState::get_children()
{
    return children;
}

void Bfd::Summary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Summary::Summary()
    :
    session_state(std::make_unique<Bfd::Summary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "summary"; yang_parent_name = "bfd";
}

Bfd::Summary::~Summary()
{
}

bool Bfd::Summary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Summary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Summary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "summary";

    return path_buffer.str();

}

EntityPath Bfd::Summary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Summary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Summary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Summary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Summary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4bfd-mplste-tail-node-summary";
}

Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::Ipv4BfdMplsteTailNodeSummary()
    :
    	location_name{YType::str, "location-name"}
    	,
    session_state(std::make_unique<Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4bfd-mplste-tail-node-summary"; yang_parent_name = "ipv4bfd-mplste-tail-node-summaries";
}

Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::~Ipv4BfdMplsteTailNodeSummary()
{
}

bool Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::has_data() const
{
    return location_name.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location_name.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bfd-mplste-tail-node-summary" <<"[location-name='" <<location_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bfd-mplste-tail-node-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location_name.is_set || is_set(location_name.operation)) leaf_name_data.push_back(location_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location-name")
    {
        location_name = value;
    }
}

Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummaries()
{
    yang_name = "ipv4bfd-mplste-tail-node-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfdMplsteTailNodeSummaries::~Ipv4BfdMplsteTailNodeSummaries()
{
}

bool Bfd::Ipv4BfdMplsteTailNodeSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv4bfd_mplste_tail_node_summary.size(); index++)
    {
        if(ipv4bfd_mplste_tail_node_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfdMplsteTailNodeSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv4bfd_mplste_tail_node_summary.size(); index++)
    {
        if(ipv4bfd_mplste_tail_node_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfdMplsteTailNodeSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bfd-mplste-tail-node-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfdMplsteTailNodeSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfdMplsteTailNodeSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bfd-mplste-tail-node-summary")
    {
        for(auto const & c : ipv4bfd_mplste_tail_node_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfdMplsteTailNodeSummaries::Ipv4BfdMplsteTailNodeSummary>();
        c->parent = this;
        ipv4bfd_mplste_tail_node_summary.push_back(std::move(c));
        children[segment_path] = ipv4bfd_mplste_tail_node_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfdMplsteTailNodeSummaries::get_children()
{
    for (auto const & c : ipv4bfd_mplste_tail_node_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfdMplsteTailNodeSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4-single-hop-location-summary";
}

Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::Ipv4SingleHopLocationSummary()
    :
    	location_name{YType::str, "location-name"}
    	,
    session_state(std::make_unique<Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4-single-hop-location-summary"; yang_parent_name = "ipv4-single-hop-location-summaries";
}

Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::~Ipv4SingleHopLocationSummary()
{
}

bool Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::has_data() const
{
    return location_name.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location_name.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-location-summary" <<"[location-name='" <<location_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-location-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location_name.is_set || is_set(location_name.operation)) leaf_name_data.push_back(location_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location-name")
    {
        location_name = value;
    }
}

Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummaries()
{
    yang_name = "ipv4-single-hop-location-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopLocationSummaries::~Ipv4SingleHopLocationSummaries()
{
}

bool Bfd::Ipv4SingleHopLocationSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv4_single_hop_location_summary.size(); index++)
    {
        if(ipv4_single_hop_location_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4SingleHopLocationSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv4_single_hop_location_summary.size(); index++)
    {
        if(ipv4_single_hop_location_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4SingleHopLocationSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-location-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopLocationSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopLocationSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-location-summary")
    {
        for(auto const & c : ipv4_single_hop_location_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopLocationSummaries::Ipv4SingleHopLocationSummary>();
        c->parent = this;
        ipv4_single_hop_location_summary.push_back(std::move(c));
        children[segment_path] = ipv4_single_hop_location_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopLocationSummaries::get_children()
{
    for (auto const & c : ipv4_single_hop_location_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopLocationSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4bfd-mplste-head-summary-node";
}

Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::~SessionState()
{
}

bool Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::Ipv4BfdMplsteHeadSummaryNode()
    :
    	location_name{YType::str, "location-name"}
    	,
    session_state(std::make_unique<Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4bfd-mplste-head-summary-node"; yang_parent_name = "ipv4bfd-mplste-head-summary-nodes";
}

Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::~Ipv4BfdMplsteHeadSummaryNode()
{
}

bool Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::has_data() const
{
    return location_name.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::has_operation() const
{
    return is_set(operation)
	|| is_set(location_name.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bfd-mplste-head-summary-node" <<"[location-name='" <<location_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bfd-mplste-head-summary-nodes/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location_name.is_set || is_set(location_name.operation)) leaf_name_data.push_back(location_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location-name")
    {
        location_name = value;
    }
}

Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNodes()
{
    yang_name = "ipv4bfd-mplste-head-summary-nodes"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfdMplsteHeadSummaryNodes::~Ipv4BfdMplsteHeadSummaryNodes()
{
}

bool Bfd::Ipv4BfdMplsteHeadSummaryNodes::has_data() const
{
    for (std::size_t index=0; index<ipv4bfd_mplste_head_summary_node.size(); index++)
    {
        if(ipv4bfd_mplste_head_summary_node[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfdMplsteHeadSummaryNodes::has_operation() const
{
    for (std::size_t index=0; index<ipv4bfd_mplste_head_summary_node.size(); index++)
    {
        if(ipv4bfd_mplste_head_summary_node[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfdMplsteHeadSummaryNodes::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bfd-mplste-head-summary-nodes";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfdMplsteHeadSummaryNodes::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfdMplsteHeadSummaryNodes::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bfd-mplste-head-summary-node")
    {
        for(auto const & c : ipv4bfd_mplste_head_summary_node)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfdMplsteHeadSummaryNodes::Ipv4BfdMplsteHeadSummaryNode>();
        c->parent = this;
        ipv4bfd_mplste_head_summary_node.push_back(std::move(c));
        children[segment_path] = ipv4bfd_mplste_head_summary_node.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfdMplsteHeadSummaryNodes::get_children()
{
    for (auto const & c : ipv4bfd_mplste_head_summary_node)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfdMplsteHeadSummaryNodes::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "label-session-detail";
}

Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "label-session-detail";
}

Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "label-session-detail";
}

Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "label-session-detail";
}

Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "label-session-detail";
}

Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/label-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetail::LabelSessionDetail()
    :
    	incoming_label{YType::int32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"}
    	,
    lsp_ping_info(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "label-session-detail"; yang_parent_name = "label-session-details";
}

Bfd::LabelSessionDetails::LabelSessionDetail::~LabelSessionDetail()
{
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return incoming_label.is_set
	|| interface_name.is_set
	|| location.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::LabelSessionDetails::LabelSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::LabelSessionDetails::LabelSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::LabelSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::LabelSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::LabelSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::LabelSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::LabelSessionDetails::LabelSessionDetails()
{
    yang_name = "label-session-details"; yang_parent_name = "bfd";
}

Bfd::LabelSessionDetails::~LabelSessionDetails()
{
}

bool Bfd::LabelSessionDetails::has_data() const
{
    for (std::size_t index=0; index<label_session_detail.size(); index++)
    {
        if(label_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::LabelSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<label_session_detail.size(); index++)
    {
        if(label_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::LabelSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-session-details";

    return path_buffer.str();

}

EntityPath Bfd::LabelSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "label-session-detail")
    {
        for(auto const & c : label_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelSessionDetails::LabelSessionDetail>();
        c->parent = this;
        label_session_detail.push_back(std::move(c));
        children[segment_path] = label_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelSessionDetails::get_children()
{
    for (auto const & c : label_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::LabelSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "ipv6-single-hop-session-detail";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "ipv6-single-hop-session-detail";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "ipv6-single-hop-session-detail";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "ipv6-single-hop-session-detail";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "ipv6-single-hop-session-detail";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/ipv6-single-hop-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::Ipv6SingleHopSessionDetail()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"}
    	,
    lsp_ping_info(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "ipv6-single-hop-session-detail"; yang_parent_name = "ipv6-single-hop-session-details";
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::~Ipv6SingleHopSessionDetail()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| interface_name.is_set
	|| location.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetails()
{
    yang_name = "ipv6-single-hop-session-details"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopSessionDetails::~Ipv6SingleHopSessionDetails()
{
}

bool Bfd::Ipv6SingleHopSessionDetails::has_data() const
{
    for (std::size_t index=0; index<ipv6_single_hop_session_detail.size(); index++)
    {
        if(ipv6_single_hop_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6SingleHopSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<ipv6_single_hop_session_detail.size(); index++)
    {
        if(ipv6_single_hop_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6SingleHopSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-session-details";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-session-detail")
    {
        for(auto const & c : ipv6_single_hop_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopSessionDetails::Ipv6SingleHopSessionDetail>();
        c->parent = this;
        ipv6_single_hop_session_detail.push_back(std::move(c));
        children[segment_path] = ipv6_single_hop_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionDetails::get_children()
{
    for (auto const & c : ipv6_single_hop_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::Ipv4MultiHopPacketCounter()
    :
    	destination_address{YType::str, "destination-address"},
	 display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"},
	 location{YType::str, "location"},
	 source_address{YType::str, "source-address"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv4-multi-hop-packet-counter"; yang_parent_name = "ipv4-multi-hop-packet-counters";
}

Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::~Ipv4MultiHopPacketCounter()
{
}

bool Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::has_data() const
{
    return destination_address.is_set
	|| display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set
	|| location.is_set
	|| source_address.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation)
	|| is_set(location.operation)
	|| is_set(source_address.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-packet-counter";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-counters/ipv4-multi-hop-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounters()
{
    yang_name = "ipv4-multi-hop-packet-counters"; yang_parent_name = "ipv4-multi-hop-counters";
}

Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::~Ipv4MultiHopPacketCounters()
{
}

bool Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::has_data() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_packet_counter.size(); index++)
    {
        if(ipv4_multi_hop_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_packet_counter.size(); index++)
    {
        if(ipv4_multi_hop_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-multi-hop-packet-counter")
    {
        for(auto const & c : ipv4_multi_hop_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::Ipv4MultiHopPacketCounter>();
        c->parent = this;
        ipv4_multi_hop_packet_counter.push_back(std::move(c));
        children[segment_path] = ipv4_multi_hop_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::get_children()
{
    for (auto const & c : ipv4_multi_hop_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopCounters::Ipv4MultiHopCounters()
    :
    ipv4_multi_hop_packet_counters(std::make_unique<Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters>())
{
    ipv4_multi_hop_packet_counters->parent = this;
    children["ipv4-multi-hop-packet-counters"] = ipv4_multi_hop_packet_counters.get();

    yang_name = "ipv4-multi-hop-counters"; yang_parent_name = "bfd";
}

Bfd::Ipv4MultiHopCounters::~Ipv4MultiHopCounters()
{
}

bool Bfd::Ipv4MultiHopCounters::has_data() const
{
    return (ipv4_multi_hop_packet_counters !=  nullptr && ipv4_multi_hop_packet_counters->has_data());
}

bool Bfd::Ipv4MultiHopCounters::has_operation() const
{
    return is_set(operation)
	|| (ipv4_multi_hop_packet_counters !=  nullptr && ipv4_multi_hop_packet_counters->has_operation());
}

std::string Bfd::Ipv4MultiHopCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-multi-hop-packet-counters")
    {
        if(ipv4_multi_hop_packet_counters != nullptr)
        {
            children["ipv4-multi-hop-packet-counters"] = ipv4_multi_hop_packet_counters.get();
        }
        else
        {
            ipv4_multi_hop_packet_counters = std::make_unique<Bfd::Ipv4MultiHopCounters::Ipv4MultiHopPacketCounters>();
            ipv4_multi_hop_packet_counters->parent = this;
            children["ipv4-multi-hop-packet-counters"] = ipv4_multi_hop_packet_counters.get();
        }
        return children.at("ipv4-multi-hop-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopCounters::get_children()
{
    if(children.find("ipv4-multi-hop-packet-counters") == children.end())
    {
        if(ipv4_multi_hop_packet_counters != nullptr)
        {
            children["ipv4-multi-hop-packet-counters"] = ipv4_multi_hop_packet_counters.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::SessionDetails::SessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "session-detail";
}

Bfd::SessionDetails::SessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::SessionDetails::SessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::SessionDetails::SessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "session-detail";
}

Bfd::SessionDetails::SessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::SessionDetails::SessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::SessionDetails::SessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::SessionDetails::SessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "session-detail";
}

Bfd::SessionDetails::SessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::SessionDetails::SessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::SessionDetails::SessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "session-detail";
}

Bfd::SessionDetails::SessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::SessionDetails::SessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::SessionDetails::SessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::SessionDetails::SessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "session-detail";
}

Bfd::SessionDetails::SessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::SessionDetails::SessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::SessionDetails::SessionDetail::SessionDetail()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"}
    	,
    lsp_ping_info(std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::SessionDetails::SessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "session-detail"; yang_parent_name = "session-details";
}

Bfd::SessionDetails::SessionDetail::~SessionDetail()
{
}

bool Bfd::SessionDetails::SessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| interface_name.is_set
	|| location.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::SessionDetails::SessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::SessionDetails::SessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-detail";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::SessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::SessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::SessionDetails::SessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::SessionDetails::SessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::SessionDetails::SessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::SessionDetails::SessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::SessionDetails::SessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::SessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::SessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::SessionDetails::SessionDetails()
{
    yang_name = "session-details"; yang_parent_name = "bfd";
}

Bfd::SessionDetails::~SessionDetails()
{
}

bool Bfd::SessionDetails::has_data() const
{
    for (std::size_t index=0; index<session_detail.size(); index++)
    {
        if(session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::SessionDetails::has_operation() const
{
    for (std::size_t index=0; index<session_detail.size(); index++)
    {
        if(session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::SessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-details";

    return path_buffer.str();

}

EntityPath Bfd::SessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::SessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-detail")
    {
        for(auto const & c : session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::SessionDetails::SessionDetail>();
        c->parent = this;
        session_detail.push_back(std::move(c));
        children[segment_path] = session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::SessionDetails::get_children()
{
    for (auto const & c : session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::SessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::Ipv4SingleHopMultiPath()
    :
    	destination_address{YType::str, "destination-address"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 interface_name{YType::str, "interface-name"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 state{YType::enumeration, "state"}
{
    yang_name = "ipv4-single-hop-multi-path"; yang_parent_name = "ipv4-single-hop-multi-paths";
}

Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::~Ipv4SingleHopMultiPath()
{
}

bool Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::has_data() const
{
    return destination_address.is_set
	|| incoming_label_xr.is_set
	|| interface_name.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| state.is_set;
}

bool Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(interface_name.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(state.operation);
}

std::string Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPaths()
{
    yang_name = "ipv4-single-hop-multi-paths"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopMultiPaths::~Ipv4SingleHopMultiPaths()
{
}

bool Bfd::Ipv4SingleHopMultiPaths::has_data() const
{
    for (std::size_t index=0; index<ipv4_single_hop_multi_path.size(); index++)
    {
        if(ipv4_single_hop_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4SingleHopMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<ipv4_single_hop_multi_path.size(); index++)
    {
        if(ipv4_single_hop_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4SingleHopMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-multi-path")
    {
        for(auto const & c : ipv4_single_hop_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopMultiPaths::Ipv4SingleHopMultiPath>();
        c->parent = this;
        ipv4_single_hop_multi_path.push_back(std::move(c));
        children[segment_path] = ipv4_single_hop_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopMultiPaths::get_children()
{
    for (auto const & c : ipv4_single_hop_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/ipv4-single-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/ipv4-single-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "ipv4-single-hop-session-brief";
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/ipv4-single-hop-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::Ipv4SingleHopSessionBrief()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 state{YType::enumeration, "state"}
    	,
    status_brief_information(std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "ipv4-single-hop-session-brief"; yang_parent_name = "ipv4-single-hop-session-briefs";
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::~Ipv4SingleHopSessionBrief()
{
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::has_data() const
{
    return destination_address.is_set
	|| interface_name.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| state.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(state.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-single-hop-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBriefs()
{
    yang_name = "ipv4-single-hop-session-briefs"; yang_parent_name = "bfd";
}

Bfd::Ipv4SingleHopSessionBriefs::~Ipv4SingleHopSessionBriefs()
{
}

bool Bfd::Ipv4SingleHopSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<ipv4_single_hop_session_brief.size(); index++)
    {
        if(ipv4_single_hop_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4SingleHopSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<ipv4_single_hop_session_brief.size(); index++)
    {
        if(ipv4_single_hop_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4SingleHopSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-single-hop-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4SingleHopSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4SingleHopSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-single-hop-session-brief")
    {
        for(auto const & c : ipv4_single_hop_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4SingleHopSessionBriefs::Ipv4SingleHopSessionBrief>();
        c->parent = this;
        ipv4_single_hop_session_brief.push_back(std::move(c));
        children[segment_path] = ipv4_single_hop_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4SingleHopSessionBriefs::get_children()
{
    for (auto const & c : ipv4_single_hop_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4SingleHopSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::Ipv6MultiHopPacketCounter()
    :
    	destination_address{YType::str, "destination-address"},
	 display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"},
	 location{YType::str, "location"},
	 source_address{YType::str, "source-address"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv6-multi-hop-packet-counter"; yang_parent_name = "ipv6-multi-hop-packet-counters";
}

Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::~Ipv6MultiHopPacketCounter()
{
}

bool Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::has_data() const
{
    return destination_address.is_set
	|| display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set
	|| location.is_set
	|| source_address.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation)
	|| is_set(location.operation)
	|| is_set(source_address.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-packet-counter";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-counters/ipv6-multi-hop-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::get_children()
{
    return children;
}

void Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounters()
{
    yang_name = "ipv6-multi-hop-packet-counters"; yang_parent_name = "ipv6-multi-hop-counters";
}

Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::~Ipv6MultiHopPacketCounters()
{
}

bool Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::has_data() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_packet_counter.size(); index++)
    {
        if(ipv6_multi_hop_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<ipv6_multi_hop_packet_counter.size(); index++)
    {
        if(ipv6_multi_hop_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-multi-hop-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-multi-hop-packet-counter")
    {
        for(auto const & c : ipv6_multi_hop_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::Ipv6MultiHopPacketCounter>();
        c->parent = this;
        ipv6_multi_hop_packet_counter.push_back(std::move(c));
        children[segment_path] = ipv6_multi_hop_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::get_children()
{
    for (auto const & c : ipv6_multi_hop_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6MultiHopCounters::Ipv6MultiHopCounters()
    :
    ipv6_multi_hop_packet_counters(std::make_unique<Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters>())
{
    ipv6_multi_hop_packet_counters->parent = this;
    children["ipv6-multi-hop-packet-counters"] = ipv6_multi_hop_packet_counters.get();

    yang_name = "ipv6-multi-hop-counters"; yang_parent_name = "bfd";
}

Bfd::Ipv6MultiHopCounters::~Ipv6MultiHopCounters()
{
}

bool Bfd::Ipv6MultiHopCounters::has_data() const
{
    return (ipv6_multi_hop_packet_counters !=  nullptr && ipv6_multi_hop_packet_counters->has_data());
}

bool Bfd::Ipv6MultiHopCounters::has_operation() const
{
    return is_set(operation)
	|| (ipv6_multi_hop_packet_counters !=  nullptr && ipv6_multi_hop_packet_counters->has_operation());
}

std::string Bfd::Ipv6MultiHopCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-multi-hop-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6MultiHopCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6MultiHopCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-multi-hop-packet-counters")
    {
        if(ipv6_multi_hop_packet_counters != nullptr)
        {
            children["ipv6-multi-hop-packet-counters"] = ipv6_multi_hop_packet_counters.get();
        }
        else
        {
            ipv6_multi_hop_packet_counters = std::make_unique<Bfd::Ipv6MultiHopCounters::Ipv6MultiHopPacketCounters>();
            ipv6_multi_hop_packet_counters->parent = this;
            children["ipv6-multi-hop-packet-counters"] = ipv6_multi_hop_packet_counters.get();
        }
        return children.at("ipv6-multi-hop-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6MultiHopCounters::get_children()
{
    if(children.find("ipv6-multi-hop-packet-counters") == children.end())
    {
        if(ipv6_multi_hop_packet_counters != nullptr)
        {
            children["ipv6-multi-hop-packet-counters"] = ipv6_multi_hop_packet_counters.get();
        }
    }

    return children;
}

void Bfd::Ipv6MultiHopCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 retry_count{YType::uint32, "retry-count"},
	 standby_count{YType::uint32, "standby-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv6-single-hop-location-summary";
}

Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| retry_count.is_set
	|| standby_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(retry_count.operation)
	|| is_set(standby_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor cannot be nullptr as one of the ancestors is a list"});
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (retry_count.is_set || is_set(retry_count.operation)) leaf_name_data.push_back(retry_count.get_name_leafdata());
    if (standby_count.is_set || is_set(standby_count.operation)) leaf_name_data.push_back(standby_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "retry-count")
    {
        retry_count = value;
    }
    if(value_path == "standby-count")
    {
        standby_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::Ipv6SingleHopLocationSummary()
    :
    	location_name{YType::str, "location-name"}
    	,
    session_state(std::make_unique<Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv6-single-hop-location-summary"; yang_parent_name = "ipv6-single-hop-location-summaries";
}

Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::~Ipv6SingleHopLocationSummary()
{
}

bool Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::has_data() const
{
    return location_name.is_set
	|| (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::has_operation() const
{
    return is_set(operation)
	|| is_set(location_name.operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-location-summary" <<"[location-name='" <<location_name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-location-summaries/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (location_name.is_set || is_set(location_name.operation)) leaf_name_data.push_back(location_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "location-name")
    {
        location_name = value;
    }
}

Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummaries()
{
    yang_name = "ipv6-single-hop-location-summaries"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopLocationSummaries::~Ipv6SingleHopLocationSummaries()
{
}

bool Bfd::Ipv6SingleHopLocationSummaries::has_data() const
{
    for (std::size_t index=0; index<ipv6_single_hop_location_summary.size(); index++)
    {
        if(ipv6_single_hop_location_summary[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6SingleHopLocationSummaries::has_operation() const
{
    for (std::size_t index=0; index<ipv6_single_hop_location_summary.size(); index++)
    {
        if(ipv6_single_hop_location_summary[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6SingleHopLocationSummaries::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-location-summaries";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopLocationSummaries::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopLocationSummaries::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-location-summary")
    {
        for(auto const & c : ipv6_single_hop_location_summary)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopLocationSummaries::Ipv6SingleHopLocationSummary>();
        c->parent = this;
        ipv6_single_hop_location_summary.push_back(std::move(c));
        children[segment_path] = ipv6_single_hop_location_summary.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopLocationSummaries::get_children()
{
    for (auto const & c : ipv6_single_hop_location_summary)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopLocationSummaries::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::LabelPacketCounter()
    :
    	display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"}
{
    yang_name = "label-packet-counter"; yang_parent_name = "label-packet-counters";
}

Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::~LabelPacketCounter()
{
}

bool Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::has_data() const
{
    return display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set
	|| interface_name.is_set
	|| location.is_set;
}

bool Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation);
}

std::string Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-packet-counter";

    return path_buffer.str();

}

EntityPath Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-counters/label-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::get_children()
{
    return children;
}

void Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
}

Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounters()
{
    yang_name = "label-packet-counters"; yang_parent_name = "label-counters";
}

Bfd::LabelCounters::LabelPacketCounters::~LabelPacketCounters()
{
}

bool Bfd::LabelCounters::LabelPacketCounters::has_data() const
{
    for (std::size_t index=0; index<label_packet_counter.size(); index++)
    {
        if(label_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::LabelCounters::LabelPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<label_packet_counter.size(); index++)
    {
        if(label_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::LabelCounters::LabelPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::LabelCounters::LabelPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/label-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelCounters::LabelPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "label-packet-counter")
    {
        for(auto const & c : label_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::LabelCounters::LabelPacketCounters::LabelPacketCounter>();
        c->parent = this;
        label_packet_counter.push_back(std::move(c));
        children[segment_path] = label_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelCounters::LabelPacketCounters::get_children()
{
    for (auto const & c : label_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::LabelCounters::LabelPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::LabelCounters::LabelCounters()
    :
    label_packet_counters(std::make_unique<Bfd::LabelCounters::LabelPacketCounters>())
{
    label_packet_counters->parent = this;
    children["label-packet-counters"] = label_packet_counters.get();

    yang_name = "label-counters"; yang_parent_name = "bfd";
}

Bfd::LabelCounters::~LabelCounters()
{
}

bool Bfd::LabelCounters::has_data() const
{
    return (label_packet_counters !=  nullptr && label_packet_counters->has_data());
}

bool Bfd::LabelCounters::has_operation() const
{
    return is_set(operation)
	|| (label_packet_counters !=  nullptr && label_packet_counters->has_operation());
}

std::string Bfd::LabelCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "label-counters";

    return path_buffer.str();

}

EntityPath Bfd::LabelCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::LabelCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "label-packet-counters")
    {
        if(label_packet_counters != nullptr)
        {
            children["label-packet-counters"] = label_packet_counters.get();
        }
        else
        {
            label_packet_counters = std::make_unique<Bfd::LabelCounters::LabelPacketCounters>();
            label_packet_counters->parent = this;
            children["label-packet-counters"] = label_packet_counters.get();
        }
        return children.at("label-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::LabelCounters::get_children()
{
    if(children.find("label-packet-counters") == children.end())
    {
        if(label_packet_counters != nullptr)
        {
            children["label-packet-counters"] = label_packet_counters.get();
        }
    }

    return children;
}

void Bfd::LabelCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::SourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "source-address"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::~SourceAddress()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::LastStateChange()
    :
    	days{YType::uint32, "days"},
	 hours{YType::uint8, "hours"},
	 minutes{YType::uint8, "minutes"},
	 seconds{YType::uint8, "seconds"}
{
    yang_name = "last-state-change"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::~LastStateChange()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::has_data() const
{
    return days.is_set
	|| hours.is_set
	|| minutes.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::has_operation() const
{
    return is_set(operation)
	|| is_set(days.operation)
	|| is_set(hours.operation)
	|| is_set(minutes.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "last-state-change";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (days.is_set || is_set(days.operation)) leaf_name_data.push_back(days.get_name_leafdata());
    if (hours.is_set || is_set(hours.operation)) leaf_name_data.push_back(hours.get_name_leafdata());
    if (minutes.is_set || is_set(minutes.operation)) leaf_name_data.push_back(minutes.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "days")
    {
        days = value;
    }
    if(value_path == "hours")
    {
        hours = value;
    }
    if(value_path == "minutes")
    {
        minutes = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::TransmitPacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "transmit-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::~TransmitPacket()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "transmit-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::ReceivePacket()
    :
    	authentication_present{YType::int32, "authentication-present"},
	 control_plane_independent{YType::int32, "control-plane-independent"},
	 demand{YType::int32, "demand"},
	 desired_minimum_transmit_interval{YType::uint32, "desired-minimum-transmit-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 diagnostic{YType::enumeration, "diagnostic"},
	 final_{YType::int32, "final"},
	 ihear_you{YType::int32, "ihear-you"},
	 length{YType::uint32, "length"},
	 my_discriminator{YType::uint32, "my-discriminator"},
	 poll{YType::int32, "poll"},
	 required_minimum_echo_receive_interval{YType::uint32, "required-minimum-echo-receive-interval"},
	 required_minimum_receive_interval{YType::uint32, "required-minimum-receive-interval"},
	 state{YType::enumeration, "state"},
	 version{YType::uint8, "version"},
	 your_discriminator{YType::uint32, "your-discriminator"}
{
    yang_name = "receive-packet"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::~ReceivePacket()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::has_data() const
{
    return authentication_present.is_set
	|| control_plane_independent.is_set
	|| demand.is_set
	|| desired_minimum_transmit_interval.is_set
	|| detection_multiplier.is_set
	|| diagnostic.is_set
	|| final_.is_set
	|| ihear_you.is_set
	|| length.is_set
	|| my_discriminator.is_set
	|| poll.is_set
	|| required_minimum_echo_receive_interval.is_set
	|| required_minimum_receive_interval.is_set
	|| state.is_set
	|| version.is_set
	|| your_discriminator.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::has_operation() const
{
    return is_set(operation)
	|| is_set(authentication_present.operation)
	|| is_set(control_plane_independent.operation)
	|| is_set(demand.operation)
	|| is_set(desired_minimum_transmit_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(diagnostic.operation)
	|| is_set(final_.operation)
	|| is_set(ihear_you.operation)
	|| is_set(length.operation)
	|| is_set(my_discriminator.operation)
	|| is_set(poll.operation)
	|| is_set(required_minimum_echo_receive_interval.operation)
	|| is_set(required_minimum_receive_interval.operation)
	|| is_set(state.operation)
	|| is_set(version.operation)
	|| is_set(your_discriminator.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "receive-packet";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (authentication_present.is_set || is_set(authentication_present.operation)) leaf_name_data.push_back(authentication_present.get_name_leafdata());
    if (control_plane_independent.is_set || is_set(control_plane_independent.operation)) leaf_name_data.push_back(control_plane_independent.get_name_leafdata());
    if (demand.is_set || is_set(demand.operation)) leaf_name_data.push_back(demand.get_name_leafdata());
    if (desired_minimum_transmit_interval.is_set || is_set(desired_minimum_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_transmit_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (diagnostic.is_set || is_set(diagnostic.operation)) leaf_name_data.push_back(diagnostic.get_name_leafdata());
    if (final_.is_set || is_set(final_.operation)) leaf_name_data.push_back(final_.get_name_leafdata());
    if (ihear_you.is_set || is_set(ihear_you.operation)) leaf_name_data.push_back(ihear_you.get_name_leafdata());
    if (length.is_set || is_set(length.operation)) leaf_name_data.push_back(length.get_name_leafdata());
    if (my_discriminator.is_set || is_set(my_discriminator.operation)) leaf_name_data.push_back(my_discriminator.get_name_leafdata());
    if (poll.is_set || is_set(poll.operation)) leaf_name_data.push_back(poll.get_name_leafdata());
    if (required_minimum_echo_receive_interval.is_set || is_set(required_minimum_echo_receive_interval.operation)) leaf_name_data.push_back(required_minimum_echo_receive_interval.get_name_leafdata());
    if (required_minimum_receive_interval.is_set || is_set(required_minimum_receive_interval.operation)) leaf_name_data.push_back(required_minimum_receive_interval.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (version.is_set || is_set(version.operation)) leaf_name_data.push_back(version.get_name_leafdata());
    if (your_discriminator.is_set || is_set(your_discriminator.operation)) leaf_name_data.push_back(your_discriminator.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "authentication-present")
    {
        authentication_present = value;
    }
    if(value_path == "control-plane-independent")
    {
        control_plane_independent = value;
    }
    if(value_path == "demand")
    {
        demand = value;
    }
    if(value_path == "desired-minimum-transmit-interval")
    {
        desired_minimum_transmit_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "diagnostic")
    {
        diagnostic = value;
    }
    if(value_path == "final")
    {
        final_ = value;
    }
    if(value_path == "ihear-you")
    {
        ihear_you = value;
    }
    if(value_path == "length")
    {
        length = value;
    }
    if(value_path == "my-discriminator")
    {
        my_discriminator = value;
    }
    if(value_path == "poll")
    {
        poll = value;
    }
    if(value_path == "required-minimum-echo-receive-interval")
    {
        required_minimum_echo_receive_interval = value;
    }
    if(value_path == "required-minimum-receive-interval")
    {
        required_minimum_receive_interval = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "version")
    {
        version = value;
    }
    if(value_path == "your-discriminator")
    {
        your_discriminator = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::AsyncTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::~AsyncTransmitStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::AsyncReceiveStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "async-receive-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::~AsyncReceiveStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-receive-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::EchoTransmitStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-transmit-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::~EchoTransmitStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-transmit-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::EchoReceivedStatistics()
    :
    	average{YType::uint32, "average"},
	 last{YType::uint32, "last"},
	 maximum{YType::uint32, "maximum"},
	 minimum{YType::uint32, "minimum"},
	 number{YType::uint32, "number"}
{
    yang_name = "echo-received-statistics"; yang_parent_name = "status-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::~EchoReceivedStatistics()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::has_data() const
{
    return average.is_set
	|| last.is_set
	|| maximum.is_set
	|| minimum.is_set
	|| number.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::has_operation() const
{
    return is_set(operation)
	|| is_set(average.operation)
	|| is_set(last.operation)
	|| is_set(maximum.operation)
	|| is_set(minimum.operation)
	|| is_set(number.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-received-statistics";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/status-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (average.is_set || is_set(average.operation)) leaf_name_data.push_back(average.get_name_leafdata());
    if (last.is_set || is_set(last.operation)) leaf_name_data.push_back(last.get_name_leafdata());
    if (maximum.is_set || is_set(maximum.operation)) leaf_name_data.push_back(maximum.get_name_leafdata());
    if (minimum.is_set || is_set(minimum.operation)) leaf_name_data.push_back(minimum.get_name_leafdata());
    if (number.is_set || is_set(number.operation)) leaf_name_data.push_back(number.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "average")
    {
        average = value;
    }
    if(value_path == "last")
    {
        last = value;
    }
    if(value_path == "maximum")
    {
        maximum = value;
    }
    if(value_path == "minimum")
    {
        minimum = value;
    }
    if(value_path == "number")
    {
        number = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusInformation()
    :
    	desired_minimum_echo_transmit_interval{YType::uint32, "desired-minimum-echo-transmit-interval"},
	 internal_label{YType::uint32, "internal-label"},
	 latency_average{YType::uint32, "latency-average"},
	 latency_maximum{YType::uint32, "latency-maximum"},
	 latency_minimum{YType::uint32, "latency-minimum"},
	 latency_number{YType::uint32, "latency-number"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 node_id{YType::str, "node-id"},
	 remote_discriminator{YType::uint32, "remote-discriminator"},
	 remote_negotiated_interval{YType::uint32, "remote-negotiated-interval"},
	 session_subtype{YType::str, "session-subtype"},
	 sessiontype{YType::enumeration, "sessiontype"},
	 state{YType::enumeration, "state"},
	 to_up_state_count{YType::uint32, "to-up-state-count"}
    	,
    async_receive_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics>())
	,async_transmit_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics>())
	,echo_received_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics>())
	,echo_transmit_statistics(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics>())
	,last_state_change(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange>())
	,receive_packet(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket>())
	,source_address(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress>())
	,status_brief_information(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation>())
	,transmit_packet(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket>())
{
    async_receive_statistics->parent = this;
    children["async-receive-statistics"] = async_receive_statistics.get();

    async_transmit_statistics->parent = this;
    children["async-transmit-statistics"] = async_transmit_statistics.get();

    echo_received_statistics->parent = this;
    children["echo-received-statistics"] = echo_received_statistics.get();

    echo_transmit_statistics->parent = this;
    children["echo-transmit-statistics"] = echo_transmit_statistics.get();

    last_state_change->parent = this;
    children["last-state-change"] = last_state_change.get();

    receive_packet->parent = this;
    children["receive-packet"] = receive_packet.get();

    source_address->parent = this;
    children["source-address"] = source_address.get();

    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    transmit_packet->parent = this;
    children["transmit-packet"] = transmit_packet.get();

    yang_name = "status-information"; yang_parent_name = "ipv4bf-do-mplste-head-session-detail";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::~StatusInformation()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::has_data() const
{
    return desired_minimum_echo_transmit_interval.is_set
	|| internal_label.is_set
	|| latency_average.is_set
	|| latency_maximum.is_set
	|| latency_minimum.is_set
	|| latency_number.is_set
	|| local_discriminator.is_set
	|| node_id.is_set
	|| remote_discriminator.is_set
	|| remote_negotiated_interval.is_set
	|| session_subtype.is_set
	|| sessiontype.is_set
	|| state.is_set
	|| to_up_state_count.is_set
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_data())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_data())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_data())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_data())
	|| (last_state_change !=  nullptr && last_state_change->has_data())
	|| (receive_packet !=  nullptr && receive_packet->has_data())
	|| (source_address !=  nullptr && source_address->has_data())
	|| (status_brief_information !=  nullptr && status_brief_information->has_data())
	|| (transmit_packet !=  nullptr && transmit_packet->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(desired_minimum_echo_transmit_interval.operation)
	|| is_set(internal_label.operation)
	|| is_set(latency_average.operation)
	|| is_set(latency_maximum.operation)
	|| is_set(latency_minimum.operation)
	|| is_set(latency_number.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(node_id.operation)
	|| is_set(remote_discriminator.operation)
	|| is_set(remote_negotiated_interval.operation)
	|| is_set(session_subtype.operation)
	|| is_set(sessiontype.operation)
	|| is_set(state.operation)
	|| is_set(to_up_state_count.operation)
	|| (async_receive_statistics !=  nullptr && async_receive_statistics->has_operation())
	|| (async_transmit_statistics !=  nullptr && async_transmit_statistics->has_operation())
	|| (echo_received_statistics !=  nullptr && echo_received_statistics->has_operation())
	|| (echo_transmit_statistics !=  nullptr && echo_transmit_statistics->has_operation())
	|| (last_state_change !=  nullptr && last_state_change->has_operation())
	|| (receive_packet !=  nullptr && receive_packet->has_operation())
	|| (source_address !=  nullptr && source_address->has_operation())
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation())
	|| (transmit_packet !=  nullptr && transmit_packet->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (desired_minimum_echo_transmit_interval.is_set || is_set(desired_minimum_echo_transmit_interval.operation)) leaf_name_data.push_back(desired_minimum_echo_transmit_interval.get_name_leafdata());
    if (internal_label.is_set || is_set(internal_label.operation)) leaf_name_data.push_back(internal_label.get_name_leafdata());
    if (latency_average.is_set || is_set(latency_average.operation)) leaf_name_data.push_back(latency_average.get_name_leafdata());
    if (latency_maximum.is_set || is_set(latency_maximum.operation)) leaf_name_data.push_back(latency_maximum.get_name_leafdata());
    if (latency_minimum.is_set || is_set(latency_minimum.operation)) leaf_name_data.push_back(latency_minimum.get_name_leafdata());
    if (latency_number.is_set || is_set(latency_number.operation)) leaf_name_data.push_back(latency_number.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (remote_discriminator.is_set || is_set(remote_discriminator.operation)) leaf_name_data.push_back(remote_discriminator.get_name_leafdata());
    if (remote_negotiated_interval.is_set || is_set(remote_negotiated_interval.operation)) leaf_name_data.push_back(remote_negotiated_interval.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (to_up_state_count.is_set || is_set(to_up_state_count.operation)) leaf_name_data.push_back(to_up_state_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-receive-statistics")
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        else
        {
            async_receive_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncReceiveStatistics>();
            async_receive_statistics->parent = this;
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
        return children.at("async-receive-statistics");
    }

    if(child_yang_name == "async-transmit-statistics")
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        else
        {
            async_transmit_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::AsyncTransmitStatistics>();
            async_transmit_statistics->parent = this;
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
        return children.at("async-transmit-statistics");
    }

    if(child_yang_name == "echo-received-statistics")
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        else
        {
            echo_received_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoReceivedStatistics>();
            echo_received_statistics->parent = this;
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
        return children.at("echo-received-statistics");
    }

    if(child_yang_name == "echo-transmit-statistics")
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        else
        {
            echo_transmit_statistics = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::EchoTransmitStatistics>();
            echo_transmit_statistics->parent = this;
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
        return children.at("echo-transmit-statistics");
    }

    if(child_yang_name == "last-state-change")
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
        else
        {
            last_state_change = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::LastStateChange>();
            last_state_change->parent = this;
            children["last-state-change"] = last_state_change.get();
        }
        return children.at("last-state-change");
    }

    if(child_yang_name == "receive-packet")
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
        else
        {
            receive_packet = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::ReceivePacket>();
            receive_packet->parent = this;
            children["receive-packet"] = receive_packet.get();
        }
        return children.at("receive-packet");
    }

    if(child_yang_name == "source-address")
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
        else
        {
            source_address = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::SourceAddress>();
            source_address->parent = this;
            children["source-address"] = source_address.get();
        }
        return children.at("source-address");
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    if(child_yang_name == "transmit-packet")
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
        else
        {
            transmit_packet = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::TransmitPacket>();
            transmit_packet->parent = this;
            children["transmit-packet"] = transmit_packet.get();
        }
        return children.at("transmit-packet");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::get_children()
{
    if(children.find("async-receive-statistics") == children.end())
    {
        if(async_receive_statistics != nullptr)
        {
            children["async-receive-statistics"] = async_receive_statistics.get();
        }
    }

    if(children.find("async-transmit-statistics") == children.end())
    {
        if(async_transmit_statistics != nullptr)
        {
            children["async-transmit-statistics"] = async_transmit_statistics.get();
        }
    }

    if(children.find("echo-received-statistics") == children.end())
    {
        if(echo_received_statistics != nullptr)
        {
            children["echo-received-statistics"] = echo_received_statistics.get();
        }
    }

    if(children.find("echo-transmit-statistics") == children.end())
    {
        if(echo_transmit_statistics != nullptr)
        {
            children["echo-transmit-statistics"] = echo_transmit_statistics.get();
        }
    }

    if(children.find("last-state-change") == children.end())
    {
        if(last_state_change != nullptr)
        {
            children["last-state-change"] = last_state_change.get();
        }
    }

    if(children.find("receive-packet") == children.end())
    {
        if(receive_packet != nullptr)
        {
            children["receive-packet"] = receive_packet.get();
        }
    }

    if(children.find("source-address") == children.end())
    {
        if(source_address != nullptr)
        {
            children["source-address"] = source_address.get();
        }
    }

    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    if(children.find("transmit-packet") == children.end())
    {
        if(transmit_packet != nullptr)
        {
            children["transmit-packet"] = transmit_packet.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "desired-minimum-echo-transmit-interval")
    {
        desired_minimum_echo_transmit_interval = value;
    }
    if(value_path == "internal-label")
    {
        internal_label = value;
    }
    if(value_path == "latency-average")
    {
        latency_average = value;
    }
    if(value_path == "latency-maximum")
    {
        latency_maximum = value;
    }
    if(value_path == "latency-minimum")
    {
        latency_minimum = value;
    }
    if(value_path == "latency-number")
    {
        latency_number = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "remote-discriminator")
    {
        remote_discriminator = value;
    }
    if(value_path == "remote-negotiated-interval")
    {
        remote_negotiated_interval = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "to-up-state-count")
    {
        to_up_state_count = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::ChangeTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "change-time"; yang_parent_name = "mp-download-state";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::~ChangeTime()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "change-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/mp-download-state/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::MpDownloadState()
    :
    	mp_download_state{YType::enumeration, "mp-download-state"}
    	,
    change_time(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime>())
{
    change_time->parent = this;
    children["change-time"] = change_time.get();

    yang_name = "mp-download-state"; yang_parent_name = "ipv4bf-do-mplste-head-session-detail";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::~MpDownloadState()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::has_data() const
{
    return mp_download_state.is_set
	|| (change_time !=  nullptr && change_time->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::has_operation() const
{
    return is_set(operation)
	|| is_set(mp_download_state.operation)
	|| (change_time !=  nullptr && change_time->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mp-download-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (mp_download_state.is_set || is_set(mp_download_state.operation)) leaf_name_data.push_back(mp_download_state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "change-time")
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
        else
        {
            change_time = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::ChangeTime>();
            change_time->parent = this;
            children["change-time"] = change_time.get();
        }
        return children.at("change-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::get_children()
{
    if(children.find("change-time") == children.end())
    {
        if(change_time != nullptr)
        {
            children["change-time"] = change_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "mp-download-state")
    {
        mp_download_state = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::LspPingTxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::~LspPingTxLastTime()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::LspPingTxLastErrorTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-tx-last-error-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::~LspPingTxLastErrorTime()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-tx-last-error-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::LspPingRxLastTime()
    :
    	nanoseconds{YType::uint32, "nanoseconds"},
	 seconds{YType::uint64, "seconds"}
{
    yang_name = "lsp-ping-rx-last-time"; yang_parent_name = "lsp-ping-info";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::~LspPingRxLastTime()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::has_data() const
{
    return nanoseconds.is_set
	|| seconds.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::has_operation() const
{
    return is_set(operation)
	|| is_set(nanoseconds.operation)
	|| is_set(seconds.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-rx-last-time";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/lsp-ping-info/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (nanoseconds.is_set || is_set(nanoseconds.operation)) leaf_name_data.push_back(nanoseconds.get_name_leafdata());
    if (seconds.is_set || is_set(seconds.operation)) leaf_name_data.push_back(seconds.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "nanoseconds")
    {
        nanoseconds = value;
    }
    if(value_path == "seconds")
    {
        seconds = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingInfo()
    :
    	lsp_ping_rx_count{YType::uint32, "lsp-ping-rx-count"},
	 lsp_ping_rx_last_code{YType::uint8, "lsp-ping-rx-last-code"},
	 lsp_ping_rx_last_discr{YType::uint32, "lsp-ping-rx-last-discr"},
	 lsp_ping_rx_last_output{YType::str, "lsp-ping-rx-last-output"},
	 lsp_ping_rx_last_subcode{YType::uint8, "lsp-ping-rx-last-subcode"},
	 lsp_ping_tx_count{YType::uint32, "lsp-ping-tx-count"},
	 lsp_ping_tx_error_count{YType::uint32, "lsp-ping-tx-error-count"},
	 lsp_ping_tx_last_error_rc{YType::str, "lsp-ping-tx-last-error-rc"},
	 lsp_ping_tx_last_rc{YType::str, "lsp-ping-tx-last-rc"}
    	,
    lsp_ping_rx_last_time(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime>())
	,lsp_ping_tx_last_error_time(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime>())
	,lsp_ping_tx_last_time(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime>())
{
    lsp_ping_rx_last_time->parent = this;
    children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();

    lsp_ping_tx_last_error_time->parent = this;
    children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();

    lsp_ping_tx_last_time->parent = this;
    children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();

    yang_name = "lsp-ping-info"; yang_parent_name = "ipv4bf-do-mplste-head-session-detail";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::~LspPingInfo()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::has_data() const
{
    return lsp_ping_rx_count.is_set
	|| lsp_ping_rx_last_code.is_set
	|| lsp_ping_rx_last_discr.is_set
	|| lsp_ping_rx_last_output.is_set
	|| lsp_ping_rx_last_subcode.is_set
	|| lsp_ping_tx_count.is_set
	|| lsp_ping_tx_error_count.is_set
	|| lsp_ping_tx_last_error_rc.is_set
	|| lsp_ping_tx_last_rc.is_set
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_data())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_data())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::has_operation() const
{
    return is_set(operation)
	|| is_set(lsp_ping_rx_count.operation)
	|| is_set(lsp_ping_rx_last_code.operation)
	|| is_set(lsp_ping_rx_last_discr.operation)
	|| is_set(lsp_ping_rx_last_output.operation)
	|| is_set(lsp_ping_rx_last_subcode.operation)
	|| is_set(lsp_ping_tx_count.operation)
	|| is_set(lsp_ping_tx_error_count.operation)
	|| is_set(lsp_ping_tx_last_error_rc.operation)
	|| is_set(lsp_ping_tx_last_rc.operation)
	|| (lsp_ping_rx_last_time !=  nullptr && lsp_ping_rx_last_time->has_operation())
	|| (lsp_ping_tx_last_error_time !=  nullptr && lsp_ping_tx_last_error_time->has_operation())
	|| (lsp_ping_tx_last_time !=  nullptr && lsp_ping_tx_last_time->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "lsp-ping-info";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (lsp_ping_rx_count.is_set || is_set(lsp_ping_rx_count.operation)) leaf_name_data.push_back(lsp_ping_rx_count.get_name_leafdata());
    if (lsp_ping_rx_last_code.is_set || is_set(lsp_ping_rx_last_code.operation)) leaf_name_data.push_back(lsp_ping_rx_last_code.get_name_leafdata());
    if (lsp_ping_rx_last_discr.is_set || is_set(lsp_ping_rx_last_discr.operation)) leaf_name_data.push_back(lsp_ping_rx_last_discr.get_name_leafdata());
    if (lsp_ping_rx_last_output.is_set || is_set(lsp_ping_rx_last_output.operation)) leaf_name_data.push_back(lsp_ping_rx_last_output.get_name_leafdata());
    if (lsp_ping_rx_last_subcode.is_set || is_set(lsp_ping_rx_last_subcode.operation)) leaf_name_data.push_back(lsp_ping_rx_last_subcode.get_name_leafdata());
    if (lsp_ping_tx_count.is_set || is_set(lsp_ping_tx_count.operation)) leaf_name_data.push_back(lsp_ping_tx_count.get_name_leafdata());
    if (lsp_ping_tx_error_count.is_set || is_set(lsp_ping_tx_error_count.operation)) leaf_name_data.push_back(lsp_ping_tx_error_count.get_name_leafdata());
    if (lsp_ping_tx_last_error_rc.is_set || is_set(lsp_ping_tx_last_error_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_error_rc.get_name_leafdata());
    if (lsp_ping_tx_last_rc.is_set || is_set(lsp_ping_tx_last_rc.operation)) leaf_name_data.push_back(lsp_ping_tx_last_rc.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-rx-last-time")
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        else
        {
            lsp_ping_rx_last_time = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingRxLastTime>();
            lsp_ping_rx_last_time->parent = this;
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
        return children.at("lsp-ping-rx-last-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-error-time")
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        else
        {
            lsp_ping_tx_last_error_time = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastErrorTime>();
            lsp_ping_tx_last_error_time->parent = this;
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
        return children.at("lsp-ping-tx-last-error-time");
    }

    if(child_yang_name == "lsp-ping-tx-last-time")
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        else
        {
            lsp_ping_tx_last_time = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::LspPingTxLastTime>();
            lsp_ping_tx_last_time->parent = this;
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
        return children.at("lsp-ping-tx-last-time");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::get_children()
{
    if(children.find("lsp-ping-rx-last-time") == children.end())
    {
        if(lsp_ping_rx_last_time != nullptr)
        {
            children["lsp-ping-rx-last-time"] = lsp_ping_rx_last_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-error-time") == children.end())
    {
        if(lsp_ping_tx_last_error_time != nullptr)
        {
            children["lsp-ping-tx-last-error-time"] = lsp_ping_tx_last_error_time.get();
        }
    }

    if(children.find("lsp-ping-tx-last-time") == children.end())
    {
        if(lsp_ping_tx_last_time != nullptr)
        {
            children["lsp-ping-tx-last-time"] = lsp_ping_tx_last_time.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "lsp-ping-rx-count")
    {
        lsp_ping_rx_count = value;
    }
    if(value_path == "lsp-ping-rx-last-code")
    {
        lsp_ping_rx_last_code = value;
    }
    if(value_path == "lsp-ping-rx-last-discr")
    {
        lsp_ping_rx_last_discr = value;
    }
    if(value_path == "lsp-ping-rx-last-output")
    {
        lsp_ping_rx_last_output = value;
    }
    if(value_path == "lsp-ping-rx-last-subcode")
    {
        lsp_ping_rx_last_subcode = value;
    }
    if(value_path == "lsp-ping-tx-count")
    {
        lsp_ping_tx_count = value;
    }
    if(value_path == "lsp-ping-tx-error-count")
    {
        lsp_ping_tx_error_count = value;
    }
    if(value_path == "lsp-ping-tx-last-error-rc")
    {
        lsp_ping_tx_last_error_rc = value;
    }
    if(value_path == "lsp-ping-tx-last-rc")
    {
        lsp_ping_tx_last_rc = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "ipv4bf-do-mplste-head-session-detail";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "ipv4bf-do-mplste-head-session-detail";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/ipv4bf-do-mplste-head-session-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::Ipv4BfDoMplsteHeadSessionDetail()
    :
    	fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 incoming_label{YType::int32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    lsp_ping_info(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo>())
	,mp_download_state(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState>())
	,status_information(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation>())
{
    lsp_ping_info->parent = this;
    children["lsp-ping-info"] = lsp_ping_info.get();

    mp_download_state->parent = this;
    children["mp-download-state"] = mp_download_state.get();

    status_information->parent = this;
    children["status-information"] = status_information.get();

    yang_name = "ipv4bf-do-mplste-head-session-detail"; yang_parent_name = "ipv4bf-do-mplste-head-session-details";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::~Ipv4BfDoMplsteHeadSessionDetail()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| incoming_label.is_set
	|| interface_name.is_set
	|| location.is_set
	|| vrf_name.is_set
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_data())
	|| (mp_download_state !=  nullptr && mp_download_state->has_data())
	|| (status_information !=  nullptr && status_information->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| is_set(vrf_name.operation)
	|| (lsp_ping_info !=  nullptr && lsp_ping_info->has_operation())
	|| (mp_download_state !=  nullptr && mp_download_state->has_operation())
	|| (status_information !=  nullptr && status_information->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-session-detail";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-session-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "lsp-ping-info")
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        else
        {
            lsp_ping_info = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::LspPingInfo>();
            lsp_ping_info->parent = this;
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
        return children.at("lsp-ping-info");
    }

    if(child_yang_name == "mp-download-state")
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
        else
        {
            mp_download_state = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::MpDownloadState>();
            mp_download_state->parent = this;
            children["mp-download-state"] = mp_download_state.get();
        }
        return children.at("mp-download-state");
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "status-information")
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
        else
        {
            status_information = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::StatusInformation>();
            status_information->parent = this;
            children["status-information"] = status_information.get();
        }
        return children.at("status-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("lsp-ping-info") == children.end())
    {
        if(lsp_ping_info != nullptr)
        {
            children["lsp-ping-info"] = lsp_ping_info.get();
        }
    }

    if(children.find("mp-download-state") == children.end())
    {
        if(mp_download_state != nullptr)
        {
            children["mp-download-state"] = mp_download_state.get();
        }
    }

    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("status-information") == children.end())
    {
        if(status_information != nullptr)
        {
            children["status-information"] = status_information.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetails()
{
    yang_name = "ipv4bf-do-mplste-head-session-details"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteHeadSessionDetails::~Ipv4BfDoMplsteHeadSessionDetails()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_session_detail.size(); index++)
    {
        if(ipv4bf_do_mplste_head_session_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteHeadSessionDetails::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_session_detail.size(); index++)
    {
        if(ipv4bf_do_mplste_head_session_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSessionDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-session-details";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSessionDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSessionDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-session-detail")
    {
        for(auto const & c : ipv4bf_do_mplste_head_session_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails::Ipv4BfDoMplsteHeadSessionDetail>();
        c->parent = this;
        ipv4bf_do_mplste_head_session_detail.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_head_session_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSessionDetails::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_head_session_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSessionDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::RelationBriefs::RelationBrief::LinkInformation::LinkInformation()
    :
    	interface_name{YType::str, "interface-name"},
	 state{YType::enumeration, "state"}
{
    yang_name = "link-information"; yang_parent_name = "relation-brief";
}

Bfd::RelationBriefs::RelationBrief::LinkInformation::~LinkInformation()
{
}

bool Bfd::RelationBriefs::RelationBrief::LinkInformation::has_data() const
{
    return interface_name.is_set
	|| state.is_set;
}

bool Bfd::RelationBriefs::RelationBrief::LinkInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(state.operation);
}

std::string Bfd::RelationBriefs::RelationBrief::LinkInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-information";

    return path_buffer.str();

}

EntityPath Bfd::RelationBriefs::RelationBrief::LinkInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-briefs/relation-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationBriefs::RelationBrief::LinkInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationBriefs::RelationBrief::LinkInformation::get_children()
{
    return children;
}

void Bfd::RelationBriefs::RelationBrief::LinkInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::RelationBriefs::RelationBrief::RelationBrief()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 state{YType::enumeration, "state"}
{
    yang_name = "relation-brief"; yang_parent_name = "relation-briefs";
}

Bfd::RelationBriefs::RelationBrief::~RelationBrief()
{
}

bool Bfd::RelationBriefs::RelationBrief::has_data() const
{
    for (std::size_t index=0; index<link_information.size(); index++)
    {
        if(link_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| interface_name.is_set
	|| state.is_set;
}

bool Bfd::RelationBriefs::RelationBrief::has_operation() const
{
    for (std::size_t index=0; index<link_information.size(); index++)
    {
        if(link_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(state.operation);
}

std::string Bfd::RelationBriefs::RelationBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "relation-brief";

    return path_buffer.str();

}

EntityPath Bfd::RelationBriefs::RelationBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationBriefs::RelationBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "link-information")
    {
        for(auto const & c : link_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::RelationBriefs::RelationBrief::LinkInformation>();
        c->parent = this;
        link_information.push_back(std::move(c));
        children[segment_path] = link_information.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationBriefs::RelationBrief::get_children()
{
    for (auto const & c : link_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::RelationBriefs::RelationBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::RelationBriefs::RelationBriefs()
{
    yang_name = "relation-briefs"; yang_parent_name = "bfd";
}

Bfd::RelationBriefs::~RelationBriefs()
{
}

bool Bfd::RelationBriefs::has_data() const
{
    for (std::size_t index=0; index<relation_brief.size(); index++)
    {
        if(relation_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::RelationBriefs::has_operation() const
{
    for (std::size_t index=0; index<relation_brief.size(); index++)
    {
        if(relation_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::RelationBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "relation-briefs";

    return path_buffer.str();

}

EntityPath Bfd::RelationBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "relation-brief")
    {
        for(auto const & c : relation_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::RelationBriefs::RelationBrief>();
        c->parent = this;
        relation_brief.push_back(std::move(c));
        children[segment_path] = relation_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationBriefs::get_children()
{
    for (auto const & c : relation_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::RelationBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::ClientBriefs::ClientBrief::ClientBrief()
    :
    	name{YType::str, "name"},
	 name_xr{YType::str, "name-xr"},
	 node_id{YType::str, "node-id"},
	 session_count{YType::uint32, "session-count"}
{
    yang_name = "client-brief"; yang_parent_name = "client-briefs";
}

Bfd::ClientBriefs::ClientBrief::~ClientBrief()
{
}

bool Bfd::ClientBriefs::ClientBrief::has_data() const
{
    return name.is_set
	|| name_xr.is_set
	|| node_id.is_set
	|| session_count.is_set;
}

bool Bfd::ClientBriefs::ClientBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(name.operation)
	|| is_set(name_xr.operation)
	|| is_set(node_id.operation)
	|| is_set(session_count.operation);
}

std::string Bfd::ClientBriefs::ClientBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "client-brief" <<"[name='" <<name.get() <<"']";

    return path_buffer.str();

}

EntityPath Bfd::ClientBriefs::ClientBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/client-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());
    if (name_xr.is_set || is_set(name_xr.operation)) leaf_name_data.push_back(name_xr.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_count.is_set || is_set(session_count.operation)) leaf_name_data.push_back(session_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::ClientBriefs::ClientBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::ClientBriefs::ClientBrief::get_children()
{
    return children;
}

void Bfd::ClientBriefs::ClientBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "name")
    {
        name = value;
    }
    if(value_path == "name-xr")
    {
        name_xr = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-count")
    {
        session_count = value;
    }
}

Bfd::ClientBriefs::ClientBriefs()
{
    yang_name = "client-briefs"; yang_parent_name = "bfd";
}

Bfd::ClientBriefs::~ClientBriefs()
{
}

bool Bfd::ClientBriefs::has_data() const
{
    for (std::size_t index=0; index<client_brief.size(); index++)
    {
        if(client_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::ClientBriefs::has_operation() const
{
    for (std::size_t index=0; index<client_brief.size(); index++)
    {
        if(client_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::ClientBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "client-briefs";

    return path_buffer.str();

}

EntityPath Bfd::ClientBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::ClientBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "client-brief")
    {
        for(auto const & c : client_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::ClientBriefs::ClientBrief>();
        c->parent = this;
        client_brief.push_back(std::move(c));
        children[segment_path] = client_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::ClientBriefs::get_children()
{
    for (auto const & c : client_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::ClientBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::Ipv4BfDoMplsteHeadMultiPath()
    :
    	fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 incoming_label{YType::int32, "incoming-label"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 interface_name{YType::str, "interface-name"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv4bf-do-mplste-head-multi-path"; yang_parent_name = "ipv4bf-do-mplste-head-multi-paths";
}

Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::~Ipv4BfDoMplsteHeadMultiPath()
{
}

bool Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::has_data() const
{
    return fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| incoming_label.is_set
	|| incoming_label_xr.is_set
	|| interface_name.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| state.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(incoming_label.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(interface_name.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPaths()
{
    yang_name = "ipv4bf-do-mplste-head-multi-paths"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteHeadMultiPaths::~Ipv4BfDoMplsteHeadMultiPaths()
{
}

bool Bfd::Ipv4BfDoMplsteHeadMultiPaths::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_multi_path.size(); index++)
    {
        if(ipv4bf_do_mplste_head_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteHeadMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_head_multi_path.size(); index++)
    {
        if(ipv4bf_do_mplste_head_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-multi-path")
    {
        for(auto const & c : ipv4bf_do_mplste_head_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteHeadMultiPaths::Ipv4BfDoMplsteHeadMultiPath>();
        c->parent = this;
        ipv4bf_do_mplste_head_multi_path.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_head_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadMultiPaths::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_head_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::RelationDetails::RelationDetail::LinkInformation::LinkInformation()
    :
    	interface_name{YType::str, "interface-name"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 state{YType::enumeration, "state"}
{
    yang_name = "link-information"; yang_parent_name = "relation-detail";
}

Bfd::RelationDetails::RelationDetail::LinkInformation::~LinkInformation()
{
}

bool Bfd::RelationDetails::RelationDetail::LinkInformation::has_data() const
{
    return interface_name.is_set
	|| local_discriminator.is_set
	|| state.is_set;
}

bool Bfd::RelationDetails::RelationDetail::LinkInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(interface_name.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(state.operation);
}

std::string Bfd::RelationDetails::RelationDetail::LinkInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "link-information";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::LinkInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::LinkInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::LinkInformation::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::LinkInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::IpDestinationAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-destination-address"; yang_parent_name = "session-key";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::~IpDestinationAddress()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-destination-address";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::IpSourceAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "ip-source-address"; yang_parent_name = "session-key";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::~IpSourceAddress()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ip-source-address";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::Dummy()
    :
    	dummy{YType::str, "dummy"}
{
    yang_name = "dummy"; yang_parent_name = "bfdfec";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::~Dummy()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_data() const
{
    return dummy.is_set;
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::has_operation() const
{
    return is_set(operation)
	|| is_set(dummy.operation);
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "dummy";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "dummy")
    {
        dummy = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::TeS2LFec()
    :
    	s2l_fec_ctype{YType::enumeration, "s2l-fec-ctype"},
	 s2l_fec_dest{YType::str, "s2l-fec-dest"},
	 s2l_fec_extended_tunnel_id{YType::str, "s2l-fec-extended-tunnel-id"},
	 s2l_fec_lsp_id{YType::uint16, "s2l-fec-lsp-id"},
	 s2l_fec_p2mp_id{YType::uint32, "s2l-fec-p2mp-id"},
	 s2l_fec_source{YType::str, "s2l-fec-source"},
	 s2l_fec_subgroup_id{YType::uint16, "s2l-fec-subgroup-id"},
	 s2l_fec_subgroup_originator{YType::str, "s2l-fec-subgroup-originator"},
	 s2l_fec_tunnel_id{YType::uint16, "s2l-fec-tunnel-id"},
	 s2l_fec_vrf{YType::str, "s2l-fec-vrf"}
{
    yang_name = "te-s2l-fec"; yang_parent_name = "bfdfec";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::~TeS2LFec()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_data() const
{
    return s2l_fec_ctype.is_set
	|| s2l_fec_dest.is_set
	|| s2l_fec_extended_tunnel_id.is_set
	|| s2l_fec_lsp_id.is_set
	|| s2l_fec_p2mp_id.is_set
	|| s2l_fec_source.is_set
	|| s2l_fec_subgroup_id.is_set
	|| s2l_fec_subgroup_originator.is_set
	|| s2l_fec_tunnel_id.is_set
	|| s2l_fec_vrf.is_set;
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::has_operation() const
{
    return is_set(operation)
	|| is_set(s2l_fec_ctype.operation)
	|| is_set(s2l_fec_dest.operation)
	|| is_set(s2l_fec_extended_tunnel_id.operation)
	|| is_set(s2l_fec_lsp_id.operation)
	|| is_set(s2l_fec_p2mp_id.operation)
	|| is_set(s2l_fec_source.operation)
	|| is_set(s2l_fec_subgroup_id.operation)
	|| is_set(s2l_fec_subgroup_originator.operation)
	|| is_set(s2l_fec_tunnel_id.operation)
	|| is_set(s2l_fec_vrf.operation);
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "te-s2l-fec";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/bfdfec/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (s2l_fec_ctype.is_set || is_set(s2l_fec_ctype.operation)) leaf_name_data.push_back(s2l_fec_ctype.get_name_leafdata());
    if (s2l_fec_dest.is_set || is_set(s2l_fec_dest.operation)) leaf_name_data.push_back(s2l_fec_dest.get_name_leafdata());
    if (s2l_fec_extended_tunnel_id.is_set || is_set(s2l_fec_extended_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_extended_tunnel_id.get_name_leafdata());
    if (s2l_fec_lsp_id.is_set || is_set(s2l_fec_lsp_id.operation)) leaf_name_data.push_back(s2l_fec_lsp_id.get_name_leafdata());
    if (s2l_fec_p2mp_id.is_set || is_set(s2l_fec_p2mp_id.operation)) leaf_name_data.push_back(s2l_fec_p2mp_id.get_name_leafdata());
    if (s2l_fec_source.is_set || is_set(s2l_fec_source.operation)) leaf_name_data.push_back(s2l_fec_source.get_name_leafdata());
    if (s2l_fec_subgroup_id.is_set || is_set(s2l_fec_subgroup_id.operation)) leaf_name_data.push_back(s2l_fec_subgroup_id.get_name_leafdata());
    if (s2l_fec_subgroup_originator.is_set || is_set(s2l_fec_subgroup_originator.operation)) leaf_name_data.push_back(s2l_fec_subgroup_originator.get_name_leafdata());
    if (s2l_fec_tunnel_id.is_set || is_set(s2l_fec_tunnel_id.operation)) leaf_name_data.push_back(s2l_fec_tunnel_id.get_name_leafdata());
    if (s2l_fec_vrf.is_set || is_set(s2l_fec_vrf.operation)) leaf_name_data.push_back(s2l_fec_vrf.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "s2l-fec-ctype")
    {
        s2l_fec_ctype = value;
    }
    if(value_path == "s2l-fec-dest")
    {
        s2l_fec_dest = value;
    }
    if(value_path == "s2l-fec-extended-tunnel-id")
    {
        s2l_fec_extended_tunnel_id = value;
    }
    if(value_path == "s2l-fec-lsp-id")
    {
        s2l_fec_lsp_id = value;
    }
    if(value_path == "s2l-fec-p2mp-id")
    {
        s2l_fec_p2mp_id = value;
    }
    if(value_path == "s2l-fec-source")
    {
        s2l_fec_source = value;
    }
    if(value_path == "s2l-fec-subgroup-id")
    {
        s2l_fec_subgroup_id = value;
    }
    if(value_path == "s2l-fec-subgroup-originator")
    {
        s2l_fec_subgroup_originator = value;
    }
    if(value_path == "s2l-fec-tunnel-id")
    {
        s2l_fec_tunnel_id = value;
    }
    if(value_path == "s2l-fec-vrf")
    {
        s2l_fec_vrf = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Bfdfec()
    :
    	bfdfe_ctype{YType::enumeration, "bfdfe-ctype"}
    	,
    dummy(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>())
	,te_s2l_fec(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>())
{
    dummy->parent = this;
    children["dummy"] = dummy.get();

    te_s2l_fec->parent = this;
    children["te-s2l-fec"] = te_s2l_fec.get();

    yang_name = "bfdfec"; yang_parent_name = "session-key";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::~Bfdfec()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::has_data() const
{
    return bfdfe_ctype.is_set
	|| (dummy !=  nullptr && dummy->has_data())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_data());
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::has_operation() const
{
    return is_set(operation)
	|| is_set(bfdfe_ctype.operation)
	|| (dummy !=  nullptr && dummy->has_operation())
	|| (te_s2l_fec !=  nullptr && te_s2l_fec->has_operation());
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "bfdfec";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (bfdfe_ctype.is_set || is_set(bfdfe_ctype.operation)) leaf_name_data.push_back(bfdfe_ctype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "dummy")
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
        else
        {
            dummy = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::Dummy>();
            dummy->parent = this;
            children["dummy"] = dummy.get();
        }
        return children.at("dummy");
    }

    if(child_yang_name == "te-s2l-fec")
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        else
        {
            te_s2l_fec = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::TeS2LFec>();
            te_s2l_fec->parent = this;
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
        return children.at("te-s2l-fec");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::get_children()
{
    if(children.find("dummy") == children.end())
    {
        if(dummy != nullptr)
        {
            children["dummy"] = dummy.get();
        }
    }

    if(children.find("te-s2l-fec") == children.end())
    {
        if(te_s2l_fec != nullptr)
        {
            children["te-s2l-fec"] = te_s2l_fec.get();
        }
    }

    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "bfdfe-ctype")
    {
        bfdfe_ctype = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::TargetAddress()
    :
    	afi{YType::enumeration, "afi"},
	 dummy{YType::uint8, "dummy"},
	 ipv4{YType::str, "ipv4"},
	 ipv6{YType::str, "ipv6"}
{
    yang_name = "target-address"; yang_parent_name = "session-key";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::~TargetAddress()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::has_data() const
{
    return afi.is_set
	|| dummy.is_set
	|| ipv4.is_set
	|| ipv6.is_set;
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::has_operation() const
{
    return is_set(operation)
	|| is_set(afi.operation)
	|| is_set(dummy.operation)
	|| is_set(ipv4.operation)
	|| is_set(ipv6.operation);
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "target-address";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/session-key/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (afi.is_set || is_set(afi.operation)) leaf_name_data.push_back(afi.get_name_leafdata());
    if (dummy.is_set || is_set(dummy.operation)) leaf_name_data.push_back(dummy.get_name_leafdata());
    if (ipv4.is_set || is_set(ipv4.operation)) leaf_name_data.push_back(ipv4.get_name_leafdata());
    if (ipv6.is_set || is_set(ipv6.operation)) leaf_name_data.push_back(ipv6.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "afi")
    {
        afi = value;
    }
    if(value_path == "dummy")
    {
        dummy = value;
    }
    if(value_path == "ipv4")
    {
        ipv4 = value;
    }
    if(value_path == "ipv6")
    {
        ipv6 = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::SessionKey()
    :
    	incoming_label{YType::uint32, "incoming-label"},
	 interface_name{YType::str, "interface-name"},
	 sbfd_enabled{YType::int32, "sbfd-enabled"},
	 sbfd_target_type{YType::uint32, "sbfd-target-type"},
	 session_key_type{YType::uint32, "session-key-type"},
	 vrf_name{YType::str, "vrf-name"}
    	,
    bfdfec(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec>())
	,ip_destination_address(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress>())
	,ip_source_address(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress>())
	,target_address(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress>())
{
    bfdfec->parent = this;
    children["bfdfec"] = bfdfec.get();

    ip_destination_address->parent = this;
    children["ip-destination-address"] = ip_destination_address.get();

    ip_source_address->parent = this;
    children["ip-source-address"] = ip_source_address.get();

    target_address->parent = this;
    children["target-address"] = target_address.get();

    yang_name = "session-key"; yang_parent_name = "association-information";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::~SessionKey()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::has_data() const
{
    return incoming_label.is_set
	|| interface_name.is_set
	|| sbfd_enabled.is_set
	|| sbfd_target_type.is_set
	|| session_key_type.is_set
	|| vrf_name.is_set
	|| (bfdfec !=  nullptr && bfdfec->has_data())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_data())
	|| (ip_source_address !=  nullptr && ip_source_address->has_data())
	|| (target_address !=  nullptr && target_address->has_data());
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::has_operation() const
{
    return is_set(operation)
	|| is_set(incoming_label.operation)
	|| is_set(interface_name.operation)
	|| is_set(sbfd_enabled.operation)
	|| is_set(sbfd_target_type.operation)
	|| is_set(session_key_type.operation)
	|| is_set(vrf_name.operation)
	|| (bfdfec !=  nullptr && bfdfec->has_operation())
	|| (ip_destination_address !=  nullptr && ip_destination_address->has_operation())
	|| (ip_source_address !=  nullptr && ip_source_address->has_operation())
	|| (target_address !=  nullptr && target_address->has_operation());
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-key";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (sbfd_enabled.is_set || is_set(sbfd_enabled.operation)) leaf_name_data.push_back(sbfd_enabled.get_name_leafdata());
    if (sbfd_target_type.is_set || is_set(sbfd_target_type.operation)) leaf_name_data.push_back(sbfd_target_type.get_name_leafdata());
    if (session_key_type.is_set || is_set(session_key_type.operation)) leaf_name_data.push_back(session_key_type.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "bfdfec")
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
        else
        {
            bfdfec = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::Bfdfec>();
            bfdfec->parent = this;
            children["bfdfec"] = bfdfec.get();
        }
        return children.at("bfdfec");
    }

    if(child_yang_name == "ip-destination-address")
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
        else
        {
            ip_destination_address = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpDestinationAddress>();
            ip_destination_address->parent = this;
            children["ip-destination-address"] = ip_destination_address.get();
        }
        return children.at("ip-destination-address");
    }

    if(child_yang_name == "ip-source-address")
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
        else
        {
            ip_source_address = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::IpSourceAddress>();
            ip_source_address->parent = this;
            children["ip-source-address"] = ip_source_address.get();
        }
        return children.at("ip-source-address");
    }

    if(child_yang_name == "target-address")
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
        else
        {
            target_address = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::TargetAddress>();
            target_address->parent = this;
            children["target-address"] = target_address.get();
        }
        return children.at("target-address");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::get_children()
{
    if(children.find("bfdfec") == children.end())
    {
        if(bfdfec != nullptr)
        {
            children["bfdfec"] = bfdfec.get();
        }
    }

    if(children.find("ip-destination-address") == children.end())
    {
        if(ip_destination_address != nullptr)
        {
            children["ip-destination-address"] = ip_destination_address.get();
        }
    }

    if(children.find("ip-source-address") == children.end())
    {
        if(ip_source_address != nullptr)
        {
            children["ip-source-address"] = ip_source_address.get();
        }
    }

    if(children.find("target-address") == children.end())
    {
        if(target_address != nullptr)
        {
            children["target-address"] = target_address.get();
        }
    }

    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "sbfd-enabled")
    {
        sbfd_enabled = value;
    }
    if(value_path == "sbfd-target-type")
    {
        sbfd_target_type = value;
    }
    if(value_path == "session-key-type")
    {
        session_key_type = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::OwnerInformation()
    :
    	adjusted_detection_multiplier{YType::uint32, "adjusted-detection-multiplier"},
	 adjusted_interval{YType::uint32, "adjusted-interval"},
	 detection_multiplier{YType::uint32, "detection-multiplier"},
	 interval{YType::uint32, "interval"},
	 name{YType::str, "name"}
{
    yang_name = "owner-information"; yang_parent_name = "association-information";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::~OwnerInformation()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::has_data() const
{
    return adjusted_detection_multiplier.is_set
	|| adjusted_interval.is_set
	|| detection_multiplier.is_set
	|| interval.is_set
	|| name.is_set;
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::has_operation() const
{
    return is_set(operation)
	|| is_set(adjusted_detection_multiplier.operation)
	|| is_set(adjusted_interval.operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(interval.operation)
	|| is_set(name.operation);
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "owner-information";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/association-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (adjusted_detection_multiplier.is_set || is_set(adjusted_detection_multiplier.operation)) leaf_name_data.push_back(adjusted_detection_multiplier.get_name_leafdata());
    if (adjusted_interval.is_set || is_set(adjusted_interval.operation)) leaf_name_data.push_back(adjusted_interval.get_name_leafdata());
    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (interval.is_set || is_set(interval.operation)) leaf_name_data.push_back(interval.get_name_leafdata());
    if (name.is_set || is_set(name.operation)) leaf_name_data.push_back(name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::get_children()
{
    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "adjusted-detection-multiplier")
    {
        adjusted_detection_multiplier = value;
    }
    if(value_path == "adjusted-interval")
    {
        adjusted_interval = value;
    }
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "interval")
    {
        interval = value;
    }
    if(value_path == "name")
    {
        name = value;
    }
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::AssociationInformation()
    :
    	local_discriminator{YType::uint32, "local-discriminator"},
	 sessiontype{YType::enumeration, "sessiontype"}
    	,
    session_key(std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey>())
{
    session_key->parent = this;
    children["session-key"] = session_key.get();

    yang_name = "association-information"; yang_parent_name = "relation-detail";
}

Bfd::RelationDetails::RelationDetail::AssociationInformation::~AssociationInformation()
{
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::has_data() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_data())
            return true;
    }
    return local_discriminator.is_set
	|| sessiontype.is_set
	|| (session_key !=  nullptr && session_key->has_data());
}

bool Bfd::RelationDetails::RelationDetail::AssociationInformation::has_operation() const
{
    for (std::size_t index=0; index<owner_information.size(); index++)
    {
        if(owner_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(local_discriminator.operation)
	|| is_set(sessiontype.operation)
	|| (session_key !=  nullptr && session_key->has_operation());
}

std::string Bfd::RelationDetails::RelationDetail::AssociationInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "association-information";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::AssociationInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/relation-detail/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (sessiontype.is_set || is_set(sessiontype.operation)) leaf_name_data.push_back(sessiontype.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::AssociationInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "owner-information")
    {
        for(auto const & c : owner_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::OwnerInformation>();
        c->parent = this;
        owner_information.push_back(std::move(c));
        children[segment_path] = owner_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "session-key")
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
        else
        {
            session_key = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation::SessionKey>();
            session_key->parent = this;
            children["session-key"] = session_key.get();
        }
        return children.at("session-key");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::AssociationInformation::get_children()
{
    for (auto const & c : owner_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    if(children.find("session-key") == children.end())
    {
        if(session_key != nullptr)
        {
            children["session-key"] = session_key.get();
        }
    }

    return children;
}

void Bfd::RelationDetails::RelationDetail::AssociationInformation::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "sessiontype")
    {
        sessiontype = value;
    }
}

Bfd::RelationDetails::RelationDetail::RelationDetail()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 state{YType::enumeration, "state"}
{
    yang_name = "relation-detail"; yang_parent_name = "relation-details";
}

Bfd::RelationDetails::RelationDetail::~RelationDetail()
{
}

bool Bfd::RelationDetails::RelationDetail::has_data() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<link_information.size(); index++)
    {
        if(link_information[index]->has_data())
            return true;
    }
    return destination_address.is_set
	|| interface_name.is_set
	|| local_discriminator.is_set
	|| state.is_set;
}

bool Bfd::RelationDetails::RelationDetail::has_operation() const
{
    for (std::size_t index=0; index<association_information.size(); index++)
    {
        if(association_information[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<link_information.size(); index++)
    {
        if(link_information[index]->has_operation())
            return true;
    }
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(state.operation);
}

std::string Bfd::RelationDetails::RelationDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "relation-detail";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::RelationDetail::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/relation-details/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::RelationDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "association-information")
    {
        for(auto const & c : association_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::RelationDetails::RelationDetail::AssociationInformation>();
        c->parent = this;
        association_information.push_back(std::move(c));
        children[segment_path] = association_information.back().get();
        return children.at(segment_path);
    }

    if(child_yang_name == "link-information")
    {
        for(auto const & c : link_information)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::RelationDetails::RelationDetail::LinkInformation>();
        c->parent = this;
        link_information.push_back(std::move(c));
        children[segment_path] = link_information.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::RelationDetail::get_children()
{
    for (auto const & c : association_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    for (auto const & c : link_information)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::RelationDetails::RelationDetail::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::RelationDetails::RelationDetails()
{
    yang_name = "relation-details"; yang_parent_name = "bfd";
}

Bfd::RelationDetails::~RelationDetails()
{
}

bool Bfd::RelationDetails::has_data() const
{
    for (std::size_t index=0; index<relation_detail.size(); index++)
    {
        if(relation_detail[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::RelationDetails::has_operation() const
{
    for (std::size_t index=0; index<relation_detail.size(); index++)
    {
        if(relation_detail[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::RelationDetails::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "relation-details";

    return path_buffer.str();

}

EntityPath Bfd::RelationDetails::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::RelationDetails::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "relation-detail")
    {
        for(auto const & c : relation_detail)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::RelationDetails::RelationDetail>();
        c->parent = this;
        relation_detail.push_back(std::move(c));
        children[segment_path] = relation_detail.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::RelationDetails::get_children()
{
    for (auto const & c : relation_detail)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::RelationDetails::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::Ipv4BfDoMplsteTailPacketCounter()
    :
    	display_type{YType::enumeration, "display-type"},
	 echo_receive_count{YType::uint32, "echo-receive-count"},
	 echo_transmit_count{YType::uint32, "echo-transmit-count"},
	 fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 hello_receive_count{YType::uint32, "hello-receive-count"},
	 hello_transmit_count{YType::uint32, "hello-transmit-count"},
	 incoming_label{YType::int32, "incoming-label"},
	 location{YType::str, "location"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv4bf-do-mplste-tail-packet-counter"; yang_parent_name = "ipv4bf-do-mplste-tail-packet-counters";
}

Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::~Ipv4BfDoMplsteTailPacketCounter()
{
}

bool Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::has_data() const
{
    return display_type.is_set
	|| echo_receive_count.is_set
	|| echo_transmit_count.is_set
	|| fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| hello_receive_count.is_set
	|| hello_transmit_count.is_set
	|| incoming_label.is_set
	|| location.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::has_operation() const
{
    return is_set(operation)
	|| is_set(display_type.operation)
	|| is_set(echo_receive_count.operation)
	|| is_set(echo_transmit_count.operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(hello_receive_count.operation)
	|| is_set(hello_transmit_count.operation)
	|| is_set(incoming_label.operation)
	|| is_set(location.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-packet-counter";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-counters/ipv4bf-do-mplste-tail-packet-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (display_type.is_set || is_set(display_type.operation)) leaf_name_data.push_back(display_type.get_name_leafdata());
    if (echo_receive_count.is_set || is_set(echo_receive_count.operation)) leaf_name_data.push_back(echo_receive_count.get_name_leafdata());
    if (echo_transmit_count.is_set || is_set(echo_transmit_count.operation)) leaf_name_data.push_back(echo_transmit_count.get_name_leafdata());
    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (hello_receive_count.is_set || is_set(hello_receive_count.operation)) leaf_name_data.push_back(hello_receive_count.get_name_leafdata());
    if (hello_transmit_count.is_set || is_set(hello_transmit_count.operation)) leaf_name_data.push_back(hello_transmit_count.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "display-type")
    {
        display_type = value;
    }
    if(value_path == "echo-receive-count")
    {
        echo_receive_count = value;
    }
    if(value_path == "echo-transmit-count")
    {
        echo_transmit_count = value;
    }
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "hello-receive-count")
    {
        hello_receive_count = value;
    }
    if(value_path == "hello-transmit-count")
    {
        hello_transmit_count = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounters()
{
    yang_name = "ipv4bf-do-mplste-tail-packet-counters"; yang_parent_name = "ipv4bf-do-mplste-tail-counters";
}

Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::~Ipv4BfDoMplsteTailPacketCounters()
{
}

bool Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_packet_counter.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_packet_counter[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_packet_counter.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_packet_counter[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-packet-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-counters/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-packet-counter")
    {
        for(auto const & c : ipv4bf_do_mplste_tail_packet_counter)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::Ipv4BfDoMplsteTailPacketCounter>();
        c->parent = this;
        ipv4bf_do_mplste_tail_packet_counter.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_tail_packet_counter.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_tail_packet_counter)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailCounters()
    :
    ipv4bf_do_mplste_tail_packet_counters(std::make_unique<Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters>())
{
    ipv4bf_do_mplste_tail_packet_counters->parent = this;
    children["ipv4bf-do-mplste-tail-packet-counters"] = ipv4bf_do_mplste_tail_packet_counters.get();

    yang_name = "ipv4bf-do-mplste-tail-counters"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteTailCounters::~Ipv4BfDoMplsteTailCounters()
{
}

bool Bfd::Ipv4BfDoMplsteTailCounters::has_data() const
{
    return (ipv4bf_do_mplste_tail_packet_counters !=  nullptr && ipv4bf_do_mplste_tail_packet_counters->has_data());
}

bool Bfd::Ipv4BfDoMplsteTailCounters::has_operation() const
{
    return is_set(operation)
	|| (ipv4bf_do_mplste_tail_packet_counters !=  nullptr && ipv4bf_do_mplste_tail_packet_counters->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteTailCounters::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-counters";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailCounters::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailCounters::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-packet-counters")
    {
        if(ipv4bf_do_mplste_tail_packet_counters != nullptr)
        {
            children["ipv4bf-do-mplste-tail-packet-counters"] = ipv4bf_do_mplste_tail_packet_counters.get();
        }
        else
        {
            ipv4bf_do_mplste_tail_packet_counters = std::make_unique<Bfd::Ipv4BfDoMplsteTailCounters::Ipv4BfDoMplsteTailPacketCounters>();
            ipv4bf_do_mplste_tail_packet_counters->parent = this;
            children["ipv4bf-do-mplste-tail-packet-counters"] = ipv4bf_do_mplste_tail_packet_counters.get();
        }
        return children.at("ipv4bf-do-mplste-tail-packet-counters");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailCounters::get_children()
{
    if(children.find("ipv4bf-do-mplste-tail-packet-counters") == children.end())
    {
        if(ipv4bf_do_mplste_tail_packet_counters != nullptr)
        {
            children["ipv4bf-do-mplste-tail-packet-counters"] = ipv4bf_do_mplste_tail_packet_counters.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailCounters::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::AsyncIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_local_transmit_interval{YType::uint32, "negotiated-local-transmit-interval"},
	 negotiated_remote_transmit_interval{YType::uint32, "negotiated-remote-transmit-interval"}
{
    yang_name = "async-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::~AsyncIntervalMultiplier()
{
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_local_transmit_interval.is_set
	|| negotiated_remote_transmit_interval.is_set;
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_local_transmit_interval.operation)
	|| is_set(negotiated_remote_transmit_interval.operation);
}

std::string Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "async-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/ipv6-single-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_local_transmit_interval.is_set || is_set(negotiated_local_transmit_interval.operation)) leaf_name_data.push_back(negotiated_local_transmit_interval.get_name_leafdata());
    if (negotiated_remote_transmit_interval.is_set || is_set(negotiated_remote_transmit_interval.operation)) leaf_name_data.push_back(negotiated_remote_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-local-transmit-interval")
    {
        negotiated_local_transmit_interval = value;
    }
    if(value_path == "negotiated-remote-transmit-interval")
    {
        negotiated_remote_transmit_interval = value;
    }
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::EchoIntervalMultiplier()
    :
    	detection_multiplier{YType::uint32, "detection-multiplier"},
	 detection_time{YType::uint32, "detection-time"},
	 negotiated_transmit_interval{YType::uint32, "negotiated-transmit-interval"}
{
    yang_name = "echo-interval-multiplier"; yang_parent_name = "status-brief-information";
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::~EchoIntervalMultiplier()
{
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_data() const
{
    return detection_multiplier.is_set
	|| detection_time.is_set
	|| negotiated_transmit_interval.is_set;
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::has_operation() const
{
    return is_set(operation)
	|| is_set(detection_multiplier.operation)
	|| is_set(detection_time.operation)
	|| is_set(negotiated_transmit_interval.operation);
}

std::string Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "echo-interval-multiplier";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/ipv6-single-hop-session-brief/status-brief-information/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (detection_multiplier.is_set || is_set(detection_multiplier.operation)) leaf_name_data.push_back(detection_multiplier.get_name_leafdata());
    if (detection_time.is_set || is_set(detection_time.operation)) leaf_name_data.push_back(detection_time.get_name_leafdata());
    if (negotiated_transmit_interval.is_set || is_set(negotiated_transmit_interval.operation)) leaf_name_data.push_back(negotiated_transmit_interval.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::get_children()
{
    return children;
}

void Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "detection-multiplier")
    {
        detection_multiplier = value;
    }
    if(value_path == "detection-time")
    {
        detection_time = value;
    }
    if(value_path == "negotiated-transmit-interval")
    {
        negotiated_transmit_interval = value;
    }
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::StatusBriefInformation()
    :
    async_interval_multiplier(std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>())
	,echo_interval_multiplier(std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>())
{
    async_interval_multiplier->parent = this;
    children["async-interval-multiplier"] = async_interval_multiplier.get();

    echo_interval_multiplier->parent = this;
    children["echo-interval-multiplier"] = echo_interval_multiplier.get();

    yang_name = "status-brief-information"; yang_parent_name = "ipv6-single-hop-session-brief";
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::~StatusBriefInformation()
{
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::has_data() const
{
    return (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_data())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_data());
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::has_operation() const
{
    return is_set(operation)
	|| (async_interval_multiplier !=  nullptr && async_interval_multiplier->has_operation())
	|| (echo_interval_multiplier !=  nullptr && echo_interval_multiplier->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "status-brief-information";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/ipv6-single-hop-session-brief/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "async-interval-multiplier")
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        else
        {
            async_interval_multiplier = std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::AsyncIntervalMultiplier>();
            async_interval_multiplier->parent = this;
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
        return children.at("async-interval-multiplier");
    }

    if(child_yang_name == "echo-interval-multiplier")
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        else
        {
            echo_interval_multiplier = std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::EchoIntervalMultiplier>();
            echo_interval_multiplier->parent = this;
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
        return children.at("echo-interval-multiplier");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::get_children()
{
    if(children.find("async-interval-multiplier") == children.end())
    {
        if(async_interval_multiplier != nullptr)
        {
            children["async-interval-multiplier"] = async_interval_multiplier.get();
        }
    }

    if(children.find("echo-interval-multiplier") == children.end())
    {
        if(echo_interval_multiplier != nullptr)
        {
            children["echo-interval-multiplier"] = echo_interval_multiplier.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::Ipv6SingleHopSessionBrief()
    :
    	destination_address{YType::str, "destination-address"},
	 interface_name{YType::str, "interface-name"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_flags{YType::uint32, "session-flags"},
	 session_subtype{YType::str, "session-subtype"},
	 session_type{YType::enumeration, "session-type"},
	 state{YType::enumeration, "state"}
    	,
    status_brief_information(std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation>())
{
    status_brief_information->parent = this;
    children["status-brief-information"] = status_brief_information.get();

    yang_name = "ipv6-single-hop-session-brief"; yang_parent_name = "ipv6-single-hop-session-briefs";
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::~Ipv6SingleHopSessionBrief()
{
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::has_data() const
{
    return destination_address.is_set
	|| interface_name.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_flags.is_set
	|| session_subtype.is_set
	|| session_type.is_set
	|| state.is_set
	|| (status_brief_information !=  nullptr && status_brief_information->has_data());
}

bool Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(interface_name.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_flags.operation)
	|| is_set(session_subtype.operation)
	|| is_set(session_type.operation)
	|| is_set(state.operation)
	|| (status_brief_information !=  nullptr && status_brief_information->has_operation());
}

std::string Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-session-brief";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv6-single-hop-session-briefs/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (interface_name.is_set || is_set(interface_name.operation)) leaf_name_data.push_back(interface_name.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_flags.is_set || is_set(session_flags.operation)) leaf_name_data.push_back(session_flags.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (session_type.is_set || is_set(session_type.operation)) leaf_name_data.push_back(session_type.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "status-brief-information")
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
        else
        {
            status_brief_information = std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::StatusBriefInformation>();
            status_brief_information->parent = this;
            children["status-brief-information"] = status_brief_information.get();
        }
        return children.at("status-brief-information");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::get_children()
{
    if(children.find("status-brief-information") == children.end())
    {
        if(status_brief_information != nullptr)
        {
            children["status-brief-information"] = status_brief_information.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "interface-name")
    {
        interface_name = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-flags")
    {
        session_flags = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "session-type")
    {
        session_type = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
}

Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBriefs()
{
    yang_name = "ipv6-single-hop-session-briefs"; yang_parent_name = "bfd";
}

Bfd::Ipv6SingleHopSessionBriefs::~Ipv6SingleHopSessionBriefs()
{
}

bool Bfd::Ipv6SingleHopSessionBriefs::has_data() const
{
    for (std::size_t index=0; index<ipv6_single_hop_session_brief.size(); index++)
    {
        if(ipv6_single_hop_session_brief[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv6SingleHopSessionBriefs::has_operation() const
{
    for (std::size_t index=0; index<ipv6_single_hop_session_brief.size(); index++)
    {
        if(ipv6_single_hop_session_brief[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv6SingleHopSessionBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6-single-hop-session-briefs";

    return path_buffer.str();

}

EntityPath Bfd::Ipv6SingleHopSessionBriefs::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv6SingleHopSessionBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv6-single-hop-session-brief")
    {
        for(auto const & c : ipv6_single_hop_session_brief)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv6SingleHopSessionBriefs::Ipv6SingleHopSessionBrief>();
        c->parent = this;
        ipv6_single_hop_session_brief.push_back(std::move(c));
        children[segment_path] = ipv6_single_hop_session_brief.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv6SingleHopSessionBriefs::get_children()
{
    for (auto const & c : ipv6_single_hop_session_brief)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv6SingleHopSessionBriefs::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::Ipv4BfDoMplsteTailMultiPath()
    :
    	fe_ctype{YType::int32, "fe-ctype"},
	 fec_ctype{YType::int32, "fec-ctype"},
	 fec_destination{YType::str, "fec-destination"},
	 fec_extended_tunnel_id{YType::str, "fec-extended-tunnel-id"},
	 fec_source{YType::str, "fec-source"},
	 fec_subgroup_id{YType::int32, "fec-subgroup-id"},
	 fec_subgroup_originator{YType::str, "fec-subgroup-originator"},
	 fec_tunnel_id{YType::int32, "fec-tunnel-id"},
	 feclspid{YType::int32, "feclspid"},
	 fecp2mpid{YType::int32, "fecp2mpid"},
	 incoming_label{YType::int32, "incoming-label"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv4bf-do-mplste-tail-multi-path"; yang_parent_name = "ipv4bf-do-mplste-tail-multi-paths";
}

Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::~Ipv4BfDoMplsteTailMultiPath()
{
}

bool Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::has_data() const
{
    return fe_ctype.is_set
	|| fec_ctype.is_set
	|| fec_destination.is_set
	|| fec_extended_tunnel_id.is_set
	|| fec_source.is_set
	|| fec_subgroup_id.is_set
	|| fec_subgroup_originator.is_set
	|| fec_tunnel_id.is_set
	|| feclspid.is_set
	|| fecp2mpid.is_set
	|| incoming_label.is_set
	|| incoming_label_xr.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| state.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(fe_ctype.operation)
	|| is_set(fec_ctype.operation)
	|| is_set(fec_destination.operation)
	|| is_set(fec_extended_tunnel_id.operation)
	|| is_set(fec_source.operation)
	|| is_set(fec_subgroup_id.operation)
	|| is_set(fec_subgroup_originator.operation)
	|| is_set(fec_tunnel_id.operation)
	|| is_set(feclspid.operation)
	|| is_set(fecp2mpid.operation)
	|| is_set(incoming_label.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-tail-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (fe_ctype.is_set || is_set(fe_ctype.operation)) leaf_name_data.push_back(fe_ctype.get_name_leafdata());
    if (fec_ctype.is_set || is_set(fec_ctype.operation)) leaf_name_data.push_back(fec_ctype.get_name_leafdata());
    if (fec_destination.is_set || is_set(fec_destination.operation)) leaf_name_data.push_back(fec_destination.get_name_leafdata());
    if (fec_extended_tunnel_id.is_set || is_set(fec_extended_tunnel_id.operation)) leaf_name_data.push_back(fec_extended_tunnel_id.get_name_leafdata());
    if (fec_source.is_set || is_set(fec_source.operation)) leaf_name_data.push_back(fec_source.get_name_leafdata());
    if (fec_subgroup_id.is_set || is_set(fec_subgroup_id.operation)) leaf_name_data.push_back(fec_subgroup_id.get_name_leafdata());
    if (fec_subgroup_originator.is_set || is_set(fec_subgroup_originator.operation)) leaf_name_data.push_back(fec_subgroup_originator.get_name_leafdata());
    if (fec_tunnel_id.is_set || is_set(fec_tunnel_id.operation)) leaf_name_data.push_back(fec_tunnel_id.get_name_leafdata());
    if (feclspid.is_set || is_set(feclspid.operation)) leaf_name_data.push_back(feclspid.get_name_leafdata());
    if (fecp2mpid.is_set || is_set(fecp2mpid.operation)) leaf_name_data.push_back(fecp2mpid.get_name_leafdata());
    if (incoming_label.is_set || is_set(incoming_label.operation)) leaf_name_data.push_back(incoming_label.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "fe-ctype")
    {
        fe_ctype = value;
    }
    if(value_path == "fec-ctype")
    {
        fec_ctype = value;
    }
    if(value_path == "fec-destination")
    {
        fec_destination = value;
    }
    if(value_path == "fec-extended-tunnel-id")
    {
        fec_extended_tunnel_id = value;
    }
    if(value_path == "fec-source")
    {
        fec_source = value;
    }
    if(value_path == "fec-subgroup-id")
    {
        fec_subgroup_id = value;
    }
    if(value_path == "fec-subgroup-originator")
    {
        fec_subgroup_originator = value;
    }
    if(value_path == "fec-tunnel-id")
    {
        fec_tunnel_id = value;
    }
    if(value_path == "feclspid")
    {
        feclspid = value;
    }
    if(value_path == "fecp2mpid")
    {
        fecp2mpid = value;
    }
    if(value_path == "incoming-label")
    {
        incoming_label = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPaths()
{
    yang_name = "ipv4bf-do-mplste-tail-multi-paths"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteTailMultiPaths::~Ipv4BfDoMplsteTailMultiPaths()
{
}

bool Bfd::Ipv4BfDoMplsteTailMultiPaths::has_data() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_multi_path.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4BfDoMplsteTailMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<ipv4bf_do_mplste_tail_multi_path.size(); index++)
    {
        if(ipv4bf_do_mplste_tail_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4BfDoMplsteTailMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-tail-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteTailMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteTailMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-multi-path")
    {
        for(auto const & c : ipv4bf_do_mplste_tail_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4BfDoMplsteTailMultiPaths::Ipv4BfDoMplsteTailMultiPath>();
        c->parent = this;
        ipv4bf_do_mplste_tail_multi_path.push_back(std::move(c));
        children[segment_path] = ipv4bf_do_mplste_tail_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteTailMultiPaths::get_children()
{
    for (auto const & c : ipv4bf_do_mplste_tail_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteTailMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::Ipv4MultiHopMultiPath()
    :
    	destination_address{YType::str, "destination-address"},
	 incoming_label_xr{YType::uint32, "incoming-label-xr"},
	 local_discriminator{YType::uint32, "local-discriminator"},
	 location{YType::str, "location"},
	 node_id{YType::str, "node-id"},
	 session_interface_name{YType::str, "session-interface-name"},
	 session_subtype{YType::str, "session-subtype"},
	 source_address{YType::str, "source-address"},
	 state{YType::enumeration, "state"},
	 vrf_name{YType::str, "vrf-name"}
{
    yang_name = "ipv4-multi-hop-multi-path"; yang_parent_name = "ipv4-multi-hop-multi-paths";
}

Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::~Ipv4MultiHopMultiPath()
{
}

bool Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::has_data() const
{
    return destination_address.is_set
	|| incoming_label_xr.is_set
	|| local_discriminator.is_set
	|| location.is_set
	|| node_id.is_set
	|| session_interface_name.is_set
	|| session_subtype.is_set
	|| source_address.is_set
	|| state.is_set
	|| vrf_name.is_set;
}

bool Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::has_operation() const
{
    return is_set(operation)
	|| is_set(destination_address.operation)
	|| is_set(incoming_label_xr.operation)
	|| is_set(local_discriminator.operation)
	|| is_set(location.operation)
	|| is_set(node_id.operation)
	|| is_set(session_interface_name.operation)
	|| is_set(session_subtype.operation)
	|| is_set(source_address.operation)
	|| is_set(state.operation)
	|| is_set(vrf_name.operation);
}

std::string Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-multi-path";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4-multi-hop-multi-paths/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (destination_address.is_set || is_set(destination_address.operation)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (incoming_label_xr.is_set || is_set(incoming_label_xr.operation)) leaf_name_data.push_back(incoming_label_xr.get_name_leafdata());
    if (local_discriminator.is_set || is_set(local_discriminator.operation)) leaf_name_data.push_back(local_discriminator.get_name_leafdata());
    if (location.is_set || is_set(location.operation)) leaf_name_data.push_back(location.get_name_leafdata());
    if (node_id.is_set || is_set(node_id.operation)) leaf_name_data.push_back(node_id.get_name_leafdata());
    if (session_interface_name.is_set || is_set(session_interface_name.operation)) leaf_name_data.push_back(session_interface_name.get_name_leafdata());
    if (session_subtype.is_set || is_set(session_subtype.operation)) leaf_name_data.push_back(session_subtype.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.operation)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (state.is_set || is_set(state.operation)) leaf_name_data.push_back(state.get_name_leafdata());
    if (vrf_name.is_set || is_set(vrf_name.operation)) leaf_name_data.push_back(vrf_name.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::get_children()
{
    return children;
}

void Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "destination-address")
    {
        destination_address = value;
    }
    if(value_path == "incoming-label-xr")
    {
        incoming_label_xr = value;
    }
    if(value_path == "local-discriminator")
    {
        local_discriminator = value;
    }
    if(value_path == "location")
    {
        location = value;
    }
    if(value_path == "node-id")
    {
        node_id = value;
    }
    if(value_path == "session-interface-name")
    {
        session_interface_name = value;
    }
    if(value_path == "session-subtype")
    {
        session_subtype = value;
    }
    if(value_path == "source-address")
    {
        source_address = value;
    }
    if(value_path == "state")
    {
        state = value;
    }
    if(value_path == "vrf-name")
    {
        vrf_name = value;
    }
}

Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPaths()
{
    yang_name = "ipv4-multi-hop-multi-paths"; yang_parent_name = "bfd";
}

Bfd::Ipv4MultiHopMultiPaths::~Ipv4MultiHopMultiPaths()
{
}

bool Bfd::Ipv4MultiHopMultiPaths::has_data() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_multi_path.size(); index++)
    {
        if(ipv4_multi_hop_multi_path[index]->has_data())
            return true;
    }
    return false;
}

bool Bfd::Ipv4MultiHopMultiPaths::has_operation() const
{
    for (std::size_t index=0; index<ipv4_multi_hop_multi_path.size(); index++)
    {
        if(ipv4_multi_hop_multi_path[index]->has_operation())
            return true;
    }
    return is_set(operation);
}

std::string Bfd::Ipv4MultiHopMultiPaths::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4-multi-hop-multi-paths";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4MultiHopMultiPaths::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4MultiHopMultiPaths::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "ipv4-multi-hop-multi-path")
    {
        for(auto const & c : ipv4_multi_hop_multi_path)
        {
            std::string segment = c->get_segment_path();
            if(segment_path == segment)
            {
                children[segment_path] = c.get();
                return children.at(segment_path);
            }
        }
        auto c = std::make_unique<Bfd::Ipv4MultiHopMultiPaths::Ipv4MultiHopMultiPath>();
        c->parent = this;
        ipv4_multi_hop_multi_path.push_back(std::move(c));
        children[segment_path] = ipv4_multi_hop_multi_path.back().get();
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4MultiHopMultiPaths::get_children()
{
    for (auto const & c : ipv4_multi_hop_multi_path)
    {
        if(children.find(c->get_segment_path()) == children.end())
        {
            children[c->get_segment_path()] = c.get();
        }
    }

    return children;
}

void Bfd::Ipv4MultiHopMultiPaths::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::SessionState()
    :
    	down_count{YType::uint32, "down-count"},
	 total_count{YType::uint32, "total-count"},
	 unknown_count{YType::uint32, "unknown-count"},
	 up_count{YType::uint32, "up-count"}
{
    yang_name = "session-state"; yang_parent_name = "ipv4bf-do-mplste-head-summary";
}

Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::~SessionState()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::has_data() const
{
    return down_count.is_set
	|| total_count.is_set
	|| unknown_count.is_set
	|| up_count.is_set;
}

bool Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::has_operation() const
{
    return is_set(operation)
	|| is_set(down_count.operation)
	|| is_set(total_count.operation)
	|| is_set(unknown_count.operation)
	|| is_set(up_count.operation);
}

std::string Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "session-state";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/ipv4bf-do-mplste-head-summary/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (down_count.is_set || is_set(down_count.operation)) leaf_name_data.push_back(down_count.get_name_leafdata());
    if (total_count.is_set || is_set(total_count.operation)) leaf_name_data.push_back(total_count.get_name_leafdata());
    if (unknown_count.is_set || is_set(unknown_count.operation)) leaf_name_data.push_back(unknown_count.get_name_leafdata());
    if (up_count.is_set || is_set(up_count.operation)) leaf_name_data.push_back(up_count.get_name_leafdata());


    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::get_children()
{
    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSummary::SessionState::set_value(const std::string & value_path, std::string value)
{
    if(value_path == "down-count")
    {
        down_count = value;
    }
    if(value_path == "total-count")
    {
        total_count = value;
    }
    if(value_path == "unknown-count")
    {
        unknown_count = value;
    }
    if(value_path == "up-count")
    {
        up_count = value;
    }
}

Bfd::Ipv4BfDoMplsteHeadSummary::Ipv4BfDoMplsteHeadSummary()
    :
    session_state(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSummary::SessionState>())
{
    session_state->parent = this;
    children["session-state"] = session_state.get();

    yang_name = "ipv4bf-do-mplste-head-summary"; yang_parent_name = "bfd";
}

Bfd::Ipv4BfDoMplsteHeadSummary::~Ipv4BfDoMplsteHeadSummary()
{
}

bool Bfd::Ipv4BfDoMplsteHeadSummary::has_data() const
{
    return (session_state !=  nullptr && session_state->has_data());
}

bool Bfd::Ipv4BfDoMplsteHeadSummary::has_operation() const
{
    return is_set(operation)
	|| (session_state !=  nullptr && session_state->has_operation());
}

std::string Bfd::Ipv4BfDoMplsteHeadSummary::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4bf-do-mplste-head-summary";

    return path_buffer.str();

}

EntityPath Bfd::Ipv4BfDoMplsteHeadSummary::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor == nullptr)
    {
        path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd/" << get_segment_path();
    }
    else
    {
        get_relative_entity_path(this, ancestor, path_buffer);
    }

    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::Ipv4BfDoMplsteHeadSummary::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "session-state")
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
        else
        {
            session_state = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSummary::SessionState>();
            session_state->parent = this;
            children["session-state"] = session_state.get();
        }
        return children.at("session-state");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::Ipv4BfDoMplsteHeadSummary::get_children()
{
    if(children.find("session-state") == children.end())
    {
        if(session_state != nullptr)
        {
            children["session-state"] = session_state.get();
        }
    }

    return children;
}

void Bfd::Ipv4BfDoMplsteHeadSummary::set_value(const std::string & value_path, std::string value)
{
}

Bfd::Bfd()
    :
    client_briefs(std::make_unique<Bfd::ClientBriefs>())
	,client_details(std::make_unique<Bfd::ClientDetails>())
	,counters(std::make_unique<Bfd::Counters>())
	,generic_summaries(std::make_unique<Bfd::GenericSummaries>())
	,ipv4_multi_hop_counters(std::make_unique<Bfd::Ipv4MultiHopCounters>())
	,ipv4_multi_hop_multi_paths(std::make_unique<Bfd::Ipv4MultiHopMultiPaths>())
	,ipv4_multi_hop_node_location_summaries(std::make_unique<Bfd::Ipv4MultiHopNodeLocationSummaries>())
	,ipv4_multi_hop_session_briefs(std::make_unique<Bfd::Ipv4MultiHopSessionBriefs>())
	,ipv4_multi_hop_session_details(std::make_unique<Bfd::Ipv4MultiHopSessionDetails>())
	,ipv4_multi_hop_summary(std::make_unique<Bfd::Ipv4MultiHopSummary>())
	,ipv4_single_hop_counters(std::make_unique<Bfd::Ipv4SingleHopCounters>())
	,ipv4_single_hop_location_summaries(std::make_unique<Bfd::Ipv4SingleHopLocationSummaries>())
	,ipv4_single_hop_multi_paths(std::make_unique<Bfd::Ipv4SingleHopMultiPaths>())
	,ipv4_single_hop_node_location_summaries(std::make_unique<Bfd::Ipv4SingleHopNodeLocationSummaries>())
	,ipv4_single_hop_session_briefs(std::make_unique<Bfd::Ipv4SingleHopSessionBriefs>())
	,ipv4_single_hop_session_details(std::make_unique<Bfd::Ipv4SingleHopSessionDetails>())
	,ipv4_single_hop_summary(std::make_unique<Bfd::Ipv4SingleHopSummary>())
	,ipv4bf_do_mplste_head_counters(std::make_unique<Bfd::Ipv4BfDoMplsteHeadCounters>())
	,ipv4bf_do_mplste_head_multi_paths(std::make_unique<Bfd::Ipv4BfDoMplsteHeadMultiPaths>())
	,ipv4bf_do_mplste_head_session_briefs(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs>())
	,ipv4bf_do_mplste_head_session_details(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails>())
	,ipv4bf_do_mplste_head_summary(std::make_unique<Bfd::Ipv4BfDoMplsteHeadSummary>())
	,ipv4bf_do_mplste_tail_counters(std::make_unique<Bfd::Ipv4BfDoMplsteTailCounters>())
	,ipv4bf_do_mplste_tail_multi_paths(std::make_unique<Bfd::Ipv4BfDoMplsteTailMultiPaths>())
	,ipv4bf_do_mplste_tail_session_briefs(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs>())
	,ipv4bf_do_mplste_tail_session_details(std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails>())
	,ipv4bf_do_mplste_tail_summary(std::make_unique<Bfd::Ipv4BfDoMplsteTailSummary>())
	,ipv4bfd_mplste_head_summary_nodes(std::make_unique<Bfd::Ipv4BfdMplsteHeadSummaryNodes>())
	,ipv4bfd_mplste_tail_node_summaries(std::make_unique<Bfd::Ipv4BfdMplsteTailNodeSummaries>())
	,ipv6_multi_hop_counters(std::make_unique<Bfd::Ipv6MultiHopCounters>())
	,ipv6_multi_hop_multi_paths(std::make_unique<Bfd::Ipv6MultiHopMultiPaths>())
	,ipv6_multi_hop_node_location_summaries(std::make_unique<Bfd::Ipv6MultiHopNodeLocationSummaries>())
	,ipv6_multi_hop_session_briefs(std::make_unique<Bfd::Ipv6MultiHopSessionBriefs>())
	,ipv6_multi_hop_session_details(std::make_unique<Bfd::Ipv6MultiHopSessionDetails>())
	,ipv6_multi_hop_summary(std::make_unique<Bfd::Ipv6MultiHopSummary>())
	,ipv6_single_hop_counters(std::make_unique<Bfd::Ipv6SingleHopCounters>())
	,ipv6_single_hop_location_summaries(std::make_unique<Bfd::Ipv6SingleHopLocationSummaries>())
	,ipv6_single_hop_multi_paths(std::make_unique<Bfd::Ipv6SingleHopMultiPaths>())
	,ipv6_single_hop_node_location_summaries(std::make_unique<Bfd::Ipv6SingleHopNodeLocationSummaries>())
	,ipv6_single_hop_session_briefs(std::make_unique<Bfd::Ipv6SingleHopSessionBriefs>())
	,ipv6_single_hop_session_details(std::make_unique<Bfd::Ipv6SingleHopSessionDetails>())
	,ipv6_single_hop_summary(std::make_unique<Bfd::Ipv6SingleHopSummary>())
	,label_counters(std::make_unique<Bfd::LabelCounters>())
	,label_multi_paths(std::make_unique<Bfd::LabelMultiPaths>())
	,label_session_briefs(std::make_unique<Bfd::LabelSessionBriefs>())
	,label_session_details(std::make_unique<Bfd::LabelSessionDetails>())
	,label_summary(std::make_unique<Bfd::LabelSummary>())
	,label_summary_nodes(std::make_unique<Bfd::LabelSummaryNodes>())
	,relation_briefs(std::make_unique<Bfd::RelationBriefs>())
	,relation_details(std::make_unique<Bfd::RelationDetails>())
	,session_briefs(std::make_unique<Bfd::SessionBriefs>())
	,session_details(std::make_unique<Bfd::SessionDetails>())
	,session_mibs(std::make_unique<Bfd::SessionMibs>())
	,summary(std::make_unique<Bfd::Summary>())
{
    client_briefs->parent = this;
    children["client-briefs"] = client_briefs.get();

    client_details->parent = this;
    children["client-details"] = client_details.get();

    counters->parent = this;
    children["counters"] = counters.get();

    generic_summaries->parent = this;
    children["generic-summaries"] = generic_summaries.get();

    ipv4_multi_hop_counters->parent = this;
    children["ipv4-multi-hop-counters"] = ipv4_multi_hop_counters.get();

    ipv4_multi_hop_multi_paths->parent = this;
    children["ipv4-multi-hop-multi-paths"] = ipv4_multi_hop_multi_paths.get();

    ipv4_multi_hop_node_location_summaries->parent = this;
    children["ipv4-multi-hop-node-location-summaries"] = ipv4_multi_hop_node_location_summaries.get();

    ipv4_multi_hop_session_briefs->parent = this;
    children["ipv4-multi-hop-session-briefs"] = ipv4_multi_hop_session_briefs.get();

    ipv4_multi_hop_session_details->parent = this;
    children["ipv4-multi-hop-session-details"] = ipv4_multi_hop_session_details.get();

    ipv4_multi_hop_summary->parent = this;
    children["ipv4-multi-hop-summary"] = ipv4_multi_hop_summary.get();

    ipv4_single_hop_counters->parent = this;
    children["ipv4-single-hop-counters"] = ipv4_single_hop_counters.get();

    ipv4_single_hop_location_summaries->parent = this;
    children["ipv4-single-hop-location-summaries"] = ipv4_single_hop_location_summaries.get();

    ipv4_single_hop_multi_paths->parent = this;
    children["ipv4-single-hop-multi-paths"] = ipv4_single_hop_multi_paths.get();

    ipv4_single_hop_node_location_summaries->parent = this;
    children["ipv4-single-hop-node-location-summaries"] = ipv4_single_hop_node_location_summaries.get();

    ipv4_single_hop_session_briefs->parent = this;
    children["ipv4-single-hop-session-briefs"] = ipv4_single_hop_session_briefs.get();

    ipv4_single_hop_session_details->parent = this;
    children["ipv4-single-hop-session-details"] = ipv4_single_hop_session_details.get();

    ipv4_single_hop_summary->parent = this;
    children["ipv4-single-hop-summary"] = ipv4_single_hop_summary.get();

    ipv4bf_do_mplste_head_counters->parent = this;
    children["ipv4bf-do-mplste-head-counters"] = ipv4bf_do_mplste_head_counters.get();

    ipv4bf_do_mplste_head_multi_paths->parent = this;
    children["ipv4bf-do-mplste-head-multi-paths"] = ipv4bf_do_mplste_head_multi_paths.get();

    ipv4bf_do_mplste_head_session_briefs->parent = this;
    children["ipv4bf-do-mplste-head-session-briefs"] = ipv4bf_do_mplste_head_session_briefs.get();

    ipv4bf_do_mplste_head_session_details->parent = this;
    children["ipv4bf-do-mplste-head-session-details"] = ipv4bf_do_mplste_head_session_details.get();

    ipv4bf_do_mplste_head_summary->parent = this;
    children["ipv4bf-do-mplste-head-summary"] = ipv4bf_do_mplste_head_summary.get();

    ipv4bf_do_mplste_tail_counters->parent = this;
    children["ipv4bf-do-mplste-tail-counters"] = ipv4bf_do_mplste_tail_counters.get();

    ipv4bf_do_mplste_tail_multi_paths->parent = this;
    children["ipv4bf-do-mplste-tail-multi-paths"] = ipv4bf_do_mplste_tail_multi_paths.get();

    ipv4bf_do_mplste_tail_session_briefs->parent = this;
    children["ipv4bf-do-mplste-tail-session-briefs"] = ipv4bf_do_mplste_tail_session_briefs.get();

    ipv4bf_do_mplste_tail_session_details->parent = this;
    children["ipv4bf-do-mplste-tail-session-details"] = ipv4bf_do_mplste_tail_session_details.get();

    ipv4bf_do_mplste_tail_summary->parent = this;
    children["ipv4bf-do-mplste-tail-summary"] = ipv4bf_do_mplste_tail_summary.get();

    ipv4bfd_mplste_head_summary_nodes->parent = this;
    children["ipv4bfd-mplste-head-summary-nodes"] = ipv4bfd_mplste_head_summary_nodes.get();

    ipv4bfd_mplste_tail_node_summaries->parent = this;
    children["ipv4bfd-mplste-tail-node-summaries"] = ipv4bfd_mplste_tail_node_summaries.get();

    ipv6_multi_hop_counters->parent = this;
    children["ipv6-multi-hop-counters"] = ipv6_multi_hop_counters.get();

    ipv6_multi_hop_multi_paths->parent = this;
    children["ipv6-multi-hop-multi-paths"] = ipv6_multi_hop_multi_paths.get();

    ipv6_multi_hop_node_location_summaries->parent = this;
    children["ipv6-multi-hop-node-location-summaries"] = ipv6_multi_hop_node_location_summaries.get();

    ipv6_multi_hop_session_briefs->parent = this;
    children["ipv6-multi-hop-session-briefs"] = ipv6_multi_hop_session_briefs.get();

    ipv6_multi_hop_session_details->parent = this;
    children["ipv6-multi-hop-session-details"] = ipv6_multi_hop_session_details.get();

    ipv6_multi_hop_summary->parent = this;
    children["ipv6-multi-hop-summary"] = ipv6_multi_hop_summary.get();

    ipv6_single_hop_counters->parent = this;
    children["ipv6-single-hop-counters"] = ipv6_single_hop_counters.get();

    ipv6_single_hop_location_summaries->parent = this;
    children["ipv6-single-hop-location-summaries"] = ipv6_single_hop_location_summaries.get();

    ipv6_single_hop_multi_paths->parent = this;
    children["ipv6-single-hop-multi-paths"] = ipv6_single_hop_multi_paths.get();

    ipv6_single_hop_node_location_summaries->parent = this;
    children["ipv6-single-hop-node-location-summaries"] = ipv6_single_hop_node_location_summaries.get();

    ipv6_single_hop_session_briefs->parent = this;
    children["ipv6-single-hop-session-briefs"] = ipv6_single_hop_session_briefs.get();

    ipv6_single_hop_session_details->parent = this;
    children["ipv6-single-hop-session-details"] = ipv6_single_hop_session_details.get();

    ipv6_single_hop_summary->parent = this;
    children["ipv6-single-hop-summary"] = ipv6_single_hop_summary.get();

    label_counters->parent = this;
    children["label-counters"] = label_counters.get();

    label_multi_paths->parent = this;
    children["label-multi-paths"] = label_multi_paths.get();

    label_session_briefs->parent = this;
    children["label-session-briefs"] = label_session_briefs.get();

    label_session_details->parent = this;
    children["label-session-details"] = label_session_details.get();

    label_summary->parent = this;
    children["label-summary"] = label_summary.get();

    label_summary_nodes->parent = this;
    children["label-summary-nodes"] = label_summary_nodes.get();

    relation_briefs->parent = this;
    children["relation-briefs"] = relation_briefs.get();

    relation_details->parent = this;
    children["relation-details"] = relation_details.get();

    session_briefs->parent = this;
    children["session-briefs"] = session_briefs.get();

    session_details->parent = this;
    children["session-details"] = session_details.get();

    session_mibs->parent = this;
    children["session-mibs"] = session_mibs.get();

    summary->parent = this;
    children["summary"] = summary.get();

    yang_name = "bfd"; yang_parent_name = "Cisco-IOS-XR-ip-bfd-oper";
}

Bfd::~Bfd()
{
}

bool Bfd::has_data() const
{
    return (client_briefs !=  nullptr && client_briefs->has_data())
	|| (client_details !=  nullptr && client_details->has_data())
	|| (counters !=  nullptr && counters->has_data())
	|| (generic_summaries !=  nullptr && generic_summaries->has_data())
	|| (ipv4_multi_hop_counters !=  nullptr && ipv4_multi_hop_counters->has_data())
	|| (ipv4_multi_hop_multi_paths !=  nullptr && ipv4_multi_hop_multi_paths->has_data())
	|| (ipv4_multi_hop_node_location_summaries !=  nullptr && ipv4_multi_hop_node_location_summaries->has_data())
	|| (ipv4_multi_hop_session_briefs !=  nullptr && ipv4_multi_hop_session_briefs->has_data())
	|| (ipv4_multi_hop_session_details !=  nullptr && ipv4_multi_hop_session_details->has_data())
	|| (ipv4_multi_hop_summary !=  nullptr && ipv4_multi_hop_summary->has_data())
	|| (ipv4_single_hop_counters !=  nullptr && ipv4_single_hop_counters->has_data())
	|| (ipv4_single_hop_location_summaries !=  nullptr && ipv4_single_hop_location_summaries->has_data())
	|| (ipv4_single_hop_multi_paths !=  nullptr && ipv4_single_hop_multi_paths->has_data())
	|| (ipv4_single_hop_node_location_summaries !=  nullptr && ipv4_single_hop_node_location_summaries->has_data())
	|| (ipv4_single_hop_session_briefs !=  nullptr && ipv4_single_hop_session_briefs->has_data())
	|| (ipv4_single_hop_session_details !=  nullptr && ipv4_single_hop_session_details->has_data())
	|| (ipv4_single_hop_summary !=  nullptr && ipv4_single_hop_summary->has_data())
	|| (ipv4bf_do_mplste_head_counters !=  nullptr && ipv4bf_do_mplste_head_counters->has_data())
	|| (ipv4bf_do_mplste_head_multi_paths !=  nullptr && ipv4bf_do_mplste_head_multi_paths->has_data())
	|| (ipv4bf_do_mplste_head_session_briefs !=  nullptr && ipv4bf_do_mplste_head_session_briefs->has_data())
	|| (ipv4bf_do_mplste_head_session_details !=  nullptr && ipv4bf_do_mplste_head_session_details->has_data())
	|| (ipv4bf_do_mplste_head_summary !=  nullptr && ipv4bf_do_mplste_head_summary->has_data())
	|| (ipv4bf_do_mplste_tail_counters !=  nullptr && ipv4bf_do_mplste_tail_counters->has_data())
	|| (ipv4bf_do_mplste_tail_multi_paths !=  nullptr && ipv4bf_do_mplste_tail_multi_paths->has_data())
	|| (ipv4bf_do_mplste_tail_session_briefs !=  nullptr && ipv4bf_do_mplste_tail_session_briefs->has_data())
	|| (ipv4bf_do_mplste_tail_session_details !=  nullptr && ipv4bf_do_mplste_tail_session_details->has_data())
	|| (ipv4bf_do_mplste_tail_summary !=  nullptr && ipv4bf_do_mplste_tail_summary->has_data())
	|| (ipv4bfd_mplste_head_summary_nodes !=  nullptr && ipv4bfd_mplste_head_summary_nodes->has_data())
	|| (ipv4bfd_mplste_tail_node_summaries !=  nullptr && ipv4bfd_mplste_tail_node_summaries->has_data())
	|| (ipv6_multi_hop_counters !=  nullptr && ipv6_multi_hop_counters->has_data())
	|| (ipv6_multi_hop_multi_paths !=  nullptr && ipv6_multi_hop_multi_paths->has_data())
	|| (ipv6_multi_hop_node_location_summaries !=  nullptr && ipv6_multi_hop_node_location_summaries->has_data())
	|| (ipv6_multi_hop_session_briefs !=  nullptr && ipv6_multi_hop_session_briefs->has_data())
	|| (ipv6_multi_hop_session_details !=  nullptr && ipv6_multi_hop_session_details->has_data())
	|| (ipv6_multi_hop_summary !=  nullptr && ipv6_multi_hop_summary->has_data())
	|| (ipv6_single_hop_counters !=  nullptr && ipv6_single_hop_counters->has_data())
	|| (ipv6_single_hop_location_summaries !=  nullptr && ipv6_single_hop_location_summaries->has_data())
	|| (ipv6_single_hop_multi_paths !=  nullptr && ipv6_single_hop_multi_paths->has_data())
	|| (ipv6_single_hop_node_location_summaries !=  nullptr && ipv6_single_hop_node_location_summaries->has_data())
	|| (ipv6_single_hop_session_briefs !=  nullptr && ipv6_single_hop_session_briefs->has_data())
	|| (ipv6_single_hop_session_details !=  nullptr && ipv6_single_hop_session_details->has_data())
	|| (ipv6_single_hop_summary !=  nullptr && ipv6_single_hop_summary->has_data())
	|| (label_counters !=  nullptr && label_counters->has_data())
	|| (label_multi_paths !=  nullptr && label_multi_paths->has_data())
	|| (label_session_briefs !=  nullptr && label_session_briefs->has_data())
	|| (label_session_details !=  nullptr && label_session_details->has_data())
	|| (label_summary !=  nullptr && label_summary->has_data())
	|| (label_summary_nodes !=  nullptr && label_summary_nodes->has_data())
	|| (relation_briefs !=  nullptr && relation_briefs->has_data())
	|| (relation_details !=  nullptr && relation_details->has_data())
	|| (session_briefs !=  nullptr && session_briefs->has_data())
	|| (session_details !=  nullptr && session_details->has_data())
	|| (session_mibs !=  nullptr && session_mibs->has_data())
	|| (summary !=  nullptr && summary->has_data());
}

bool Bfd::has_operation() const
{
    return is_set(operation)
	|| (client_briefs !=  nullptr && client_briefs->has_operation())
	|| (client_details !=  nullptr && client_details->has_operation())
	|| (counters !=  nullptr && counters->has_operation())
	|| (generic_summaries !=  nullptr && generic_summaries->has_operation())
	|| (ipv4_multi_hop_counters !=  nullptr && ipv4_multi_hop_counters->has_operation())
	|| (ipv4_multi_hop_multi_paths !=  nullptr && ipv4_multi_hop_multi_paths->has_operation())
	|| (ipv4_multi_hop_node_location_summaries !=  nullptr && ipv4_multi_hop_node_location_summaries->has_operation())
	|| (ipv4_multi_hop_session_briefs !=  nullptr && ipv4_multi_hop_session_briefs->has_operation())
	|| (ipv4_multi_hop_session_details !=  nullptr && ipv4_multi_hop_session_details->has_operation())
	|| (ipv4_multi_hop_summary !=  nullptr && ipv4_multi_hop_summary->has_operation())
	|| (ipv4_single_hop_counters !=  nullptr && ipv4_single_hop_counters->has_operation())
	|| (ipv4_single_hop_location_summaries !=  nullptr && ipv4_single_hop_location_summaries->has_operation())
	|| (ipv4_single_hop_multi_paths !=  nullptr && ipv4_single_hop_multi_paths->has_operation())
	|| (ipv4_single_hop_node_location_summaries !=  nullptr && ipv4_single_hop_node_location_summaries->has_operation())
	|| (ipv4_single_hop_session_briefs !=  nullptr && ipv4_single_hop_session_briefs->has_operation())
	|| (ipv4_single_hop_session_details !=  nullptr && ipv4_single_hop_session_details->has_operation())
	|| (ipv4_single_hop_summary !=  nullptr && ipv4_single_hop_summary->has_operation())
	|| (ipv4bf_do_mplste_head_counters !=  nullptr && ipv4bf_do_mplste_head_counters->has_operation())
	|| (ipv4bf_do_mplste_head_multi_paths !=  nullptr && ipv4bf_do_mplste_head_multi_paths->has_operation())
	|| (ipv4bf_do_mplste_head_session_briefs !=  nullptr && ipv4bf_do_mplste_head_session_briefs->has_operation())
	|| (ipv4bf_do_mplste_head_session_details !=  nullptr && ipv4bf_do_mplste_head_session_details->has_operation())
	|| (ipv4bf_do_mplste_head_summary !=  nullptr && ipv4bf_do_mplste_head_summary->has_operation())
	|| (ipv4bf_do_mplste_tail_counters !=  nullptr && ipv4bf_do_mplste_tail_counters->has_operation())
	|| (ipv4bf_do_mplste_tail_multi_paths !=  nullptr && ipv4bf_do_mplste_tail_multi_paths->has_operation())
	|| (ipv4bf_do_mplste_tail_session_briefs !=  nullptr && ipv4bf_do_mplste_tail_session_briefs->has_operation())
	|| (ipv4bf_do_mplste_tail_session_details !=  nullptr && ipv4bf_do_mplste_tail_session_details->has_operation())
	|| (ipv4bf_do_mplste_tail_summary !=  nullptr && ipv4bf_do_mplste_tail_summary->has_operation())
	|| (ipv4bfd_mplste_head_summary_nodes !=  nullptr && ipv4bfd_mplste_head_summary_nodes->has_operation())
	|| (ipv4bfd_mplste_tail_node_summaries !=  nullptr && ipv4bfd_mplste_tail_node_summaries->has_operation())
	|| (ipv6_multi_hop_counters !=  nullptr && ipv6_multi_hop_counters->has_operation())
	|| (ipv6_multi_hop_multi_paths !=  nullptr && ipv6_multi_hop_multi_paths->has_operation())
	|| (ipv6_multi_hop_node_location_summaries !=  nullptr && ipv6_multi_hop_node_location_summaries->has_operation())
	|| (ipv6_multi_hop_session_briefs !=  nullptr && ipv6_multi_hop_session_briefs->has_operation())
	|| (ipv6_multi_hop_session_details !=  nullptr && ipv6_multi_hop_session_details->has_operation())
	|| (ipv6_multi_hop_summary !=  nullptr && ipv6_multi_hop_summary->has_operation())
	|| (ipv6_single_hop_counters !=  nullptr && ipv6_single_hop_counters->has_operation())
	|| (ipv6_single_hop_location_summaries !=  nullptr && ipv6_single_hop_location_summaries->has_operation())
	|| (ipv6_single_hop_multi_paths !=  nullptr && ipv6_single_hop_multi_paths->has_operation())
	|| (ipv6_single_hop_node_location_summaries !=  nullptr && ipv6_single_hop_node_location_summaries->has_operation())
	|| (ipv6_single_hop_session_briefs !=  nullptr && ipv6_single_hop_session_briefs->has_operation())
	|| (ipv6_single_hop_session_details !=  nullptr && ipv6_single_hop_session_details->has_operation())
	|| (ipv6_single_hop_summary !=  nullptr && ipv6_single_hop_summary->has_operation())
	|| (label_counters !=  nullptr && label_counters->has_operation())
	|| (label_multi_paths !=  nullptr && label_multi_paths->has_operation())
	|| (label_session_briefs !=  nullptr && label_session_briefs->has_operation())
	|| (label_session_details !=  nullptr && label_session_details->has_operation())
	|| (label_summary !=  nullptr && label_summary->has_operation())
	|| (label_summary_nodes !=  nullptr && label_summary_nodes->has_operation())
	|| (relation_briefs !=  nullptr && relation_briefs->has_operation())
	|| (relation_details !=  nullptr && relation_details->has_operation())
	|| (session_briefs !=  nullptr && session_briefs->has_operation())
	|| (session_details !=  nullptr && session_details->has_operation())
	|| (session_mibs !=  nullptr && session_mibs->has_operation())
	|| (summary !=  nullptr && summary->has_operation());
}

std::string Bfd::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "Cisco-IOS-XR-ip-bfd-oper:bfd";

    return path_buffer.str();

}

EntityPath Bfd::get_entity_path(Entity* ancestor) const
{
    std::ostringstream path_buffer;
    if (ancestor != nullptr)
    {
        BOOST_THROW_EXCEPTION(YCPPInvalidArgumentError{"ancestor has to be nullptr for top-level node"});
    }

    path_buffer << get_segment_path();
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};



    EntityPath entity_path {path_buffer.str(), leaf_name_data};
    return entity_path;

}

Entity* Bfd::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(children.find(child_yang_name) != children.end())
    {
        return children.at(child_yang_name);
    }
    else if(children.find(segment_path) != children.end())
    {
        return children.at(segment_path);
    }

    if(child_yang_name == "client-briefs")
    {
        if(client_briefs != nullptr)
        {
            children["client-briefs"] = client_briefs.get();
        }
        else
        {
            client_briefs = std::make_unique<Bfd::ClientBriefs>();
            client_briefs->parent = this;
            children["client-briefs"] = client_briefs.get();
        }
        return children.at("client-briefs");
    }

    if(child_yang_name == "client-details")
    {
        if(client_details != nullptr)
        {
            children["client-details"] = client_details.get();
        }
        else
        {
            client_details = std::make_unique<Bfd::ClientDetails>();
            client_details->parent = this;
            children["client-details"] = client_details.get();
        }
        return children.at("client-details");
    }

    if(child_yang_name == "counters")
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
        else
        {
            counters = std::make_unique<Bfd::Counters>();
            counters->parent = this;
            children["counters"] = counters.get();
        }
        return children.at("counters");
    }

    if(child_yang_name == "generic-summaries")
    {
        if(generic_summaries != nullptr)
        {
            children["generic-summaries"] = generic_summaries.get();
        }
        else
        {
            generic_summaries = std::make_unique<Bfd::GenericSummaries>();
            generic_summaries->parent = this;
            children["generic-summaries"] = generic_summaries.get();
        }
        return children.at("generic-summaries");
    }

    if(child_yang_name == "ipv4-multi-hop-counters")
    {
        if(ipv4_multi_hop_counters != nullptr)
        {
            children["ipv4-multi-hop-counters"] = ipv4_multi_hop_counters.get();
        }
        else
        {
            ipv4_multi_hop_counters = std::make_unique<Bfd::Ipv4MultiHopCounters>();
            ipv4_multi_hop_counters->parent = this;
            children["ipv4-multi-hop-counters"] = ipv4_multi_hop_counters.get();
        }
        return children.at("ipv4-multi-hop-counters");
    }

    if(child_yang_name == "ipv4-multi-hop-multi-paths")
    {
        if(ipv4_multi_hop_multi_paths != nullptr)
        {
            children["ipv4-multi-hop-multi-paths"] = ipv4_multi_hop_multi_paths.get();
        }
        else
        {
            ipv4_multi_hop_multi_paths = std::make_unique<Bfd::Ipv4MultiHopMultiPaths>();
            ipv4_multi_hop_multi_paths->parent = this;
            children["ipv4-multi-hop-multi-paths"] = ipv4_multi_hop_multi_paths.get();
        }
        return children.at("ipv4-multi-hop-multi-paths");
    }

    if(child_yang_name == "ipv4-multi-hop-node-location-summaries")
    {
        if(ipv4_multi_hop_node_location_summaries != nullptr)
        {
            children["ipv4-multi-hop-node-location-summaries"] = ipv4_multi_hop_node_location_summaries.get();
        }
        else
        {
            ipv4_multi_hop_node_location_summaries = std::make_unique<Bfd::Ipv4MultiHopNodeLocationSummaries>();
            ipv4_multi_hop_node_location_summaries->parent = this;
            children["ipv4-multi-hop-node-location-summaries"] = ipv4_multi_hop_node_location_summaries.get();
        }
        return children.at("ipv4-multi-hop-node-location-summaries");
    }

    if(child_yang_name == "ipv4-multi-hop-session-briefs")
    {
        if(ipv4_multi_hop_session_briefs != nullptr)
        {
            children["ipv4-multi-hop-session-briefs"] = ipv4_multi_hop_session_briefs.get();
        }
        else
        {
            ipv4_multi_hop_session_briefs = std::make_unique<Bfd::Ipv4MultiHopSessionBriefs>();
            ipv4_multi_hop_session_briefs->parent = this;
            children["ipv4-multi-hop-session-briefs"] = ipv4_multi_hop_session_briefs.get();
        }
        return children.at("ipv4-multi-hop-session-briefs");
    }

    if(child_yang_name == "ipv4-multi-hop-session-details")
    {
        if(ipv4_multi_hop_session_details != nullptr)
        {
            children["ipv4-multi-hop-session-details"] = ipv4_multi_hop_session_details.get();
        }
        else
        {
            ipv4_multi_hop_session_details = std::make_unique<Bfd::Ipv4MultiHopSessionDetails>();
            ipv4_multi_hop_session_details->parent = this;
            children["ipv4-multi-hop-session-details"] = ipv4_multi_hop_session_details.get();
        }
        return children.at("ipv4-multi-hop-session-details");
    }

    if(child_yang_name == "ipv4-multi-hop-summary")
    {
        if(ipv4_multi_hop_summary != nullptr)
        {
            children["ipv4-multi-hop-summary"] = ipv4_multi_hop_summary.get();
        }
        else
        {
            ipv4_multi_hop_summary = std::make_unique<Bfd::Ipv4MultiHopSummary>();
            ipv4_multi_hop_summary->parent = this;
            children["ipv4-multi-hop-summary"] = ipv4_multi_hop_summary.get();
        }
        return children.at("ipv4-multi-hop-summary");
    }

    if(child_yang_name == "ipv4-single-hop-counters")
    {
        if(ipv4_single_hop_counters != nullptr)
        {
            children["ipv4-single-hop-counters"] = ipv4_single_hop_counters.get();
        }
        else
        {
            ipv4_single_hop_counters = std::make_unique<Bfd::Ipv4SingleHopCounters>();
            ipv4_single_hop_counters->parent = this;
            children["ipv4-single-hop-counters"] = ipv4_single_hop_counters.get();
        }
        return children.at("ipv4-single-hop-counters");
    }

    if(child_yang_name == "ipv4-single-hop-location-summaries")
    {
        if(ipv4_single_hop_location_summaries != nullptr)
        {
            children["ipv4-single-hop-location-summaries"] = ipv4_single_hop_location_summaries.get();
        }
        else
        {
            ipv4_single_hop_location_summaries = std::make_unique<Bfd::Ipv4SingleHopLocationSummaries>();
            ipv4_single_hop_location_summaries->parent = this;
            children["ipv4-single-hop-location-summaries"] = ipv4_single_hop_location_summaries.get();
        }
        return children.at("ipv4-single-hop-location-summaries");
    }

    if(child_yang_name == "ipv4-single-hop-multi-paths")
    {
        if(ipv4_single_hop_multi_paths != nullptr)
        {
            children["ipv4-single-hop-multi-paths"] = ipv4_single_hop_multi_paths.get();
        }
        else
        {
            ipv4_single_hop_multi_paths = std::make_unique<Bfd::Ipv4SingleHopMultiPaths>();
            ipv4_single_hop_multi_paths->parent = this;
            children["ipv4-single-hop-multi-paths"] = ipv4_single_hop_multi_paths.get();
        }
        return children.at("ipv4-single-hop-multi-paths");
    }

    if(child_yang_name == "ipv4-single-hop-node-location-summaries")
    {
        if(ipv4_single_hop_node_location_summaries != nullptr)
        {
            children["ipv4-single-hop-node-location-summaries"] = ipv4_single_hop_node_location_summaries.get();
        }
        else
        {
            ipv4_single_hop_node_location_summaries = std::make_unique<Bfd::Ipv4SingleHopNodeLocationSummaries>();
            ipv4_single_hop_node_location_summaries->parent = this;
            children["ipv4-single-hop-node-location-summaries"] = ipv4_single_hop_node_location_summaries.get();
        }
        return children.at("ipv4-single-hop-node-location-summaries");
    }

    if(child_yang_name == "ipv4-single-hop-session-briefs")
    {
        if(ipv4_single_hop_session_briefs != nullptr)
        {
            children["ipv4-single-hop-session-briefs"] = ipv4_single_hop_session_briefs.get();
        }
        else
        {
            ipv4_single_hop_session_briefs = std::make_unique<Bfd::Ipv4SingleHopSessionBriefs>();
            ipv4_single_hop_session_briefs->parent = this;
            children["ipv4-single-hop-session-briefs"] = ipv4_single_hop_session_briefs.get();
        }
        return children.at("ipv4-single-hop-session-briefs");
    }

    if(child_yang_name == "ipv4-single-hop-session-details")
    {
        if(ipv4_single_hop_session_details != nullptr)
        {
            children["ipv4-single-hop-session-details"] = ipv4_single_hop_session_details.get();
        }
        else
        {
            ipv4_single_hop_session_details = std::make_unique<Bfd::Ipv4SingleHopSessionDetails>();
            ipv4_single_hop_session_details->parent = this;
            children["ipv4-single-hop-session-details"] = ipv4_single_hop_session_details.get();
        }
        return children.at("ipv4-single-hop-session-details");
    }

    if(child_yang_name == "ipv4-single-hop-summary")
    {
        if(ipv4_single_hop_summary != nullptr)
        {
            children["ipv4-single-hop-summary"] = ipv4_single_hop_summary.get();
        }
        else
        {
            ipv4_single_hop_summary = std::make_unique<Bfd::Ipv4SingleHopSummary>();
            ipv4_single_hop_summary->parent = this;
            children["ipv4-single-hop-summary"] = ipv4_single_hop_summary.get();
        }
        return children.at("ipv4-single-hop-summary");
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-counters")
    {
        if(ipv4bf_do_mplste_head_counters != nullptr)
        {
            children["ipv4bf-do-mplste-head-counters"] = ipv4bf_do_mplste_head_counters.get();
        }
        else
        {
            ipv4bf_do_mplste_head_counters = std::make_unique<Bfd::Ipv4BfDoMplsteHeadCounters>();
            ipv4bf_do_mplste_head_counters->parent = this;
            children["ipv4bf-do-mplste-head-counters"] = ipv4bf_do_mplste_head_counters.get();
        }
        return children.at("ipv4bf-do-mplste-head-counters");
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-multi-paths")
    {
        if(ipv4bf_do_mplste_head_multi_paths != nullptr)
        {
            children["ipv4bf-do-mplste-head-multi-paths"] = ipv4bf_do_mplste_head_multi_paths.get();
        }
        else
        {
            ipv4bf_do_mplste_head_multi_paths = std::make_unique<Bfd::Ipv4BfDoMplsteHeadMultiPaths>();
            ipv4bf_do_mplste_head_multi_paths->parent = this;
            children["ipv4bf-do-mplste-head-multi-paths"] = ipv4bf_do_mplste_head_multi_paths.get();
        }
        return children.at("ipv4bf-do-mplste-head-multi-paths");
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-session-briefs")
    {
        if(ipv4bf_do_mplste_head_session_briefs != nullptr)
        {
            children["ipv4bf-do-mplste-head-session-briefs"] = ipv4bf_do_mplste_head_session_briefs.get();
        }
        else
        {
            ipv4bf_do_mplste_head_session_briefs = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionBriefs>();
            ipv4bf_do_mplste_head_session_briefs->parent = this;
            children["ipv4bf-do-mplste-head-session-briefs"] = ipv4bf_do_mplste_head_session_briefs.get();
        }
        return children.at("ipv4bf-do-mplste-head-session-briefs");
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-session-details")
    {
        if(ipv4bf_do_mplste_head_session_details != nullptr)
        {
            children["ipv4bf-do-mplste-head-session-details"] = ipv4bf_do_mplste_head_session_details.get();
        }
        else
        {
            ipv4bf_do_mplste_head_session_details = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSessionDetails>();
            ipv4bf_do_mplste_head_session_details->parent = this;
            children["ipv4bf-do-mplste-head-session-details"] = ipv4bf_do_mplste_head_session_details.get();
        }
        return children.at("ipv4bf-do-mplste-head-session-details");
    }

    if(child_yang_name == "ipv4bf-do-mplste-head-summary")
    {
        if(ipv4bf_do_mplste_head_summary != nullptr)
        {
            children["ipv4bf-do-mplste-head-summary"] = ipv4bf_do_mplste_head_summary.get();
        }
        else
        {
            ipv4bf_do_mplste_head_summary = std::make_unique<Bfd::Ipv4BfDoMplsteHeadSummary>();
            ipv4bf_do_mplste_head_summary->parent = this;
            children["ipv4bf-do-mplste-head-summary"] = ipv4bf_do_mplste_head_summary.get();
        }
        return children.at("ipv4bf-do-mplste-head-summary");
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-counters")
    {
        if(ipv4bf_do_mplste_tail_counters != nullptr)
        {
            children["ipv4bf-do-mplste-tail-counters"] = ipv4bf_do_mplste_tail_counters.get();
        }
        else
        {
            ipv4bf_do_mplste_tail_counters = std::make_unique<Bfd::Ipv4BfDoMplsteTailCounters>();
            ipv4bf_do_mplste_tail_counters->parent = this;
            children["ipv4bf-do-mplste-tail-counters"] = ipv4bf_do_mplste_tail_counters.get();
        }
        return children.at("ipv4bf-do-mplste-tail-counters");
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-multi-paths")
    {
        if(ipv4bf_do_mplste_tail_multi_paths != nullptr)
        {
            children["ipv4bf-do-mplste-tail-multi-paths"] = ipv4bf_do_mplste_tail_multi_paths.get();
        }
        else
        {
            ipv4bf_do_mplste_tail_multi_paths = std::make_unique<Bfd::Ipv4BfDoMplsteTailMultiPaths>();
            ipv4bf_do_mplste_tail_multi_paths->parent = this;
            children["ipv4bf-do-mplste-tail-multi-paths"] = ipv4bf_do_mplste_tail_multi_paths.get();
        }
        return children.at("ipv4bf-do-mplste-tail-multi-paths");
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-session-briefs")
    {
        if(ipv4bf_do_mplste_tail_session_briefs != nullptr)
        {
            children["ipv4bf-do-mplste-tail-session-briefs"] = ipv4bf_do_mplste_tail_session_briefs.get();
        }
        else
        {
            ipv4bf_do_mplste_tail_session_briefs = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionBriefs>();
            ipv4bf_do_mplste_tail_session_briefs->parent = this;
            children["ipv4bf-do-mplste-tail-session-briefs"] = ipv4bf_do_mplste_tail_session_briefs.get();
        }
        return children.at("ipv4bf-do-mplste-tail-session-briefs");
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-session-details")
    {
        if(ipv4bf_do_mplste_tail_session_details != nullptr)
        {
            children["ipv4bf-do-mplste-tail-session-details"] = ipv4bf_do_mplste_tail_session_details.get();
        }
        else
        {
            ipv4bf_do_mplste_tail_session_details = std::make_unique<Bfd::Ipv4BfDoMplsteTailSessionDetails>();
            ipv4bf_do_mplste_tail_session_details->parent = this;
            children["ipv4bf-do-mplste-tail-session-details"] = ipv4bf_do_mplste_tail_session_details.get();
        }
        return children.at("ipv4bf-do-mplste-tail-session-details");
    }

    if(child_yang_name == "ipv4bf-do-mplste-tail-summary")
    {
        if(ipv4bf_do_mplste_tail_summary != nullptr)
        {
            children["ipv4bf-do-mplste-tail-summary"] = ipv4bf_do_mplste_tail_summary.get();
        }
        else
        {
            ipv4bf_do_mplste_tail_summary = std::make_unique<Bfd::Ipv4BfDoMplsteTailSummary>();
            ipv4bf_do_mplste_tail_summary->parent = this;
            children["ipv4bf-do-mplste-tail-summary"] = ipv4bf_do_mplste_tail_summary.get();
        }
        return children.at("ipv4bf-do-mplste-tail-summary");
    }

    if(child_yang_name == "ipv4bfd-mplste-head-summary-nodes")
    {
        if(ipv4bfd_mplste_head_summary_nodes != nullptr)
        {
            children["ipv4bfd-mplste-head-summary-nodes"] = ipv4bfd_mplste_head_summary_nodes.get();
        }
        else
        {
            ipv4bfd_mplste_head_summary_nodes = std::make_unique<Bfd::Ipv4BfdMplsteHeadSummaryNodes>();
            ipv4bfd_mplste_head_summary_nodes->parent = this;
            children["ipv4bfd-mplste-head-summary-nodes"] = ipv4bfd_mplste_head_summary_nodes.get();
        }
        return children.at("ipv4bfd-mplste-head-summary-nodes");
    }

    if(child_yang_name == "ipv4bfd-mplste-tail-node-summaries")
    {
        if(ipv4bfd_mplste_tail_node_summaries != nullptr)
        {
            children["ipv4bfd-mplste-tail-node-summaries"] = ipv4bfd_mplste_tail_node_summaries.get();
        }
        else
        {
            ipv4bfd_mplste_tail_node_summaries = std::make_unique<Bfd::Ipv4BfdMplsteTailNodeSummaries>();
            ipv4bfd_mplste_tail_node_summaries->parent = this;
            children["ipv4bfd-mplste-tail-node-summaries"] = ipv4bfd_mplste_tail_node_summaries.get();
        }
        return children.at("ipv4bfd-mplste-tail-node-summaries");
    }

    if(child_yang_name == "ipv6-multi-hop-counters")
    {
        if(ipv6_multi_hop_counters != nullptr)
        {
            children["ipv6-multi-hop-counters"] = ipv6_multi_hop_counters.get();
        }
        else
        {
            ipv6_multi_hop_counters = std::make_unique<Bfd::Ipv6MultiHopCounters>();
            ipv6_multi_hop_counters->parent = this;
            children["ipv6-multi-hop-counters"] = ipv6_multi_hop_counters.get();
        }
        return children.at("ipv6-multi-hop-counters");
    }

    if(child_yang_name == "ipv6-multi-hop-multi-paths")
    {
        if(ipv6_multi_hop_multi_paths != nullptr)
        {
            children["ipv6-multi-hop-multi-paths"] = ipv6_multi_hop_multi_paths.get();
        }
        else
        {
            ipv6_multi_hop_multi_paths = std::make_unique<Bfd::Ipv6MultiHopMultiPaths>();
            ipv6_multi_hop_multi_paths->parent = this;
            children["ipv6-multi-hop-multi-paths"] = ipv6_multi_hop_multi_paths.get();
        }
        return children.at("ipv6-multi-hop-multi-paths");
    }

    if(child_yang_name == "ipv6-multi-hop-node-location-summaries")
    {
        if(ipv6_multi_hop_node_location_summaries != nullptr)
        {
            children["ipv6-multi-hop-node-location-summaries"] = ipv6_multi_hop_node_location_summaries.get();
        }
        else
        {
            ipv6_multi_hop_node_location_summaries = std::make_unique<Bfd::Ipv6MultiHopNodeLocationSummaries>();
            ipv6_multi_hop_node_location_summaries->parent = this;
            children["ipv6-multi-hop-node-location-summaries"] = ipv6_multi_hop_node_location_summaries.get();
        }
        return children.at("ipv6-multi-hop-node-location-summaries");
    }

    if(child_yang_name == "ipv6-multi-hop-session-briefs")
    {
        if(ipv6_multi_hop_session_briefs != nullptr)
        {
            children["ipv6-multi-hop-session-briefs"] = ipv6_multi_hop_session_briefs.get();
        }
        else
        {
            ipv6_multi_hop_session_briefs = std::make_unique<Bfd::Ipv6MultiHopSessionBriefs>();
            ipv6_multi_hop_session_briefs->parent = this;
            children["ipv6-multi-hop-session-briefs"] = ipv6_multi_hop_session_briefs.get();
        }
        return children.at("ipv6-multi-hop-session-briefs");
    }

    if(child_yang_name == "ipv6-multi-hop-session-details")
    {
        if(ipv6_multi_hop_session_details != nullptr)
        {
            children["ipv6-multi-hop-session-details"] = ipv6_multi_hop_session_details.get();
        }
        else
        {
            ipv6_multi_hop_session_details = std::make_unique<Bfd::Ipv6MultiHopSessionDetails>();
            ipv6_multi_hop_session_details->parent = this;
            children["ipv6-multi-hop-session-details"] = ipv6_multi_hop_session_details.get();
        }
        return children.at("ipv6-multi-hop-session-details");
    }

    if(child_yang_name == "ipv6-multi-hop-summary")
    {
        if(ipv6_multi_hop_summary != nullptr)
        {
            children["ipv6-multi-hop-summary"] = ipv6_multi_hop_summary.get();
        }
        else
        {
            ipv6_multi_hop_summary = std::make_unique<Bfd::Ipv6MultiHopSummary>();
            ipv6_multi_hop_summary->parent = this;
            children["ipv6-multi-hop-summary"] = ipv6_multi_hop_summary.get();
        }
        return children.at("ipv6-multi-hop-summary");
    }

    if(child_yang_name == "ipv6-single-hop-counters")
    {
        if(ipv6_single_hop_counters != nullptr)
        {
            children["ipv6-single-hop-counters"] = ipv6_single_hop_counters.get();
        }
        else
        {
            ipv6_single_hop_counters = std::make_unique<Bfd::Ipv6SingleHopCounters>();
            ipv6_single_hop_counters->parent = this;
            children["ipv6-single-hop-counters"] = ipv6_single_hop_counters.get();
        }
        return children.at("ipv6-single-hop-counters");
    }

    if(child_yang_name == "ipv6-single-hop-location-summaries")
    {
        if(ipv6_single_hop_location_summaries != nullptr)
        {
            children["ipv6-single-hop-location-summaries"] = ipv6_single_hop_location_summaries.get();
        }
        else
        {
            ipv6_single_hop_location_summaries = std::make_unique<Bfd::Ipv6SingleHopLocationSummaries>();
            ipv6_single_hop_location_summaries->parent = this;
            children["ipv6-single-hop-location-summaries"] = ipv6_single_hop_location_summaries.get();
        }
        return children.at("ipv6-single-hop-location-summaries");
    }

    if(child_yang_name == "ipv6-single-hop-multi-paths")
    {
        if(ipv6_single_hop_multi_paths != nullptr)
        {
            children["ipv6-single-hop-multi-paths"] = ipv6_single_hop_multi_paths.get();
        }
        else
        {
            ipv6_single_hop_multi_paths = std::make_unique<Bfd::Ipv6SingleHopMultiPaths>();
            ipv6_single_hop_multi_paths->parent = this;
            children["ipv6-single-hop-multi-paths"] = ipv6_single_hop_multi_paths.get();
        }
        return children.at("ipv6-single-hop-multi-paths");
    }

    if(child_yang_name == "ipv6-single-hop-node-location-summaries")
    {
        if(ipv6_single_hop_node_location_summaries != nullptr)
        {
            children["ipv6-single-hop-node-location-summaries"] = ipv6_single_hop_node_location_summaries.get();
        }
        else
        {
            ipv6_single_hop_node_location_summaries = std::make_unique<Bfd::Ipv6SingleHopNodeLocationSummaries>();
            ipv6_single_hop_node_location_summaries->parent = this;
            children["ipv6-single-hop-node-location-summaries"] = ipv6_single_hop_node_location_summaries.get();
        }
        return children.at("ipv6-single-hop-node-location-summaries");
    }

    if(child_yang_name == "ipv6-single-hop-session-briefs")
    {
        if(ipv6_single_hop_session_briefs != nullptr)
        {
            children["ipv6-single-hop-session-briefs"] = ipv6_single_hop_session_briefs.get();
        }
        else
        {
            ipv6_single_hop_session_briefs = std::make_unique<Bfd::Ipv6SingleHopSessionBriefs>();
            ipv6_single_hop_session_briefs->parent = this;
            children["ipv6-single-hop-session-briefs"] = ipv6_single_hop_session_briefs.get();
        }
        return children.at("ipv6-single-hop-session-briefs");
    }

    if(child_yang_name == "ipv6-single-hop-session-details")
    {
        if(ipv6_single_hop_session_details != nullptr)
        {
            children["ipv6-single-hop-session-details"] = ipv6_single_hop_session_details.get();
        }
        else
        {
            ipv6_single_hop_session_details = std::make_unique<Bfd::Ipv6SingleHopSessionDetails>();
            ipv6_single_hop_session_details->parent = this;
            children["ipv6-single-hop-session-details"] = ipv6_single_hop_session_details.get();
        }
        return children.at("ipv6-single-hop-session-details");
    }

    if(child_yang_name == "ipv6-single-hop-summary")
    {
        if(ipv6_single_hop_summary != nullptr)
        {
            children["ipv6-single-hop-summary"] = ipv6_single_hop_summary.get();
        }
        else
        {
            ipv6_single_hop_summary = std::make_unique<Bfd::Ipv6SingleHopSummary>();
            ipv6_single_hop_summary->parent = this;
            children["ipv6-single-hop-summary"] = ipv6_single_hop_summary.get();
        }
        return children.at("ipv6-single-hop-summary");
    }

    if(child_yang_name == "label-counters")
    {
        if(label_counters != nullptr)
        {
            children["label-counters"] = label_counters.get();
        }
        else
        {
            label_counters = std::make_unique<Bfd::LabelCounters>();
            label_counters->parent = this;
            children["label-counters"] = label_counters.get();
        }
        return children.at("label-counters");
    }

    if(child_yang_name == "label-multi-paths")
    {
        if(label_multi_paths != nullptr)
        {
            children["label-multi-paths"] = label_multi_paths.get();
        }
        else
        {
            label_multi_paths = std::make_unique<Bfd::LabelMultiPaths>();
            label_multi_paths->parent = this;
            children["label-multi-paths"] = label_multi_paths.get();
        }
        return children.at("label-multi-paths");
    }

    if(child_yang_name == "label-session-briefs")
    {
        if(label_session_briefs != nullptr)
        {
            children["label-session-briefs"] = label_session_briefs.get();
        }
        else
        {
            label_session_briefs = std::make_unique<Bfd::LabelSessionBriefs>();
            label_session_briefs->parent = this;
            children["label-session-briefs"] = label_session_briefs.get();
        }
        return children.at("label-session-briefs");
    }

    if(child_yang_name == "label-session-details")
    {
        if(label_session_details != nullptr)
        {
            children["label-session-details"] = label_session_details.get();
        }
        else
        {
            label_session_details = std::make_unique<Bfd::LabelSessionDetails>();
            label_session_details->parent = this;
            children["label-session-details"] = label_session_details.get();
        }
        return children.at("label-session-details");
    }

    if(child_yang_name == "label-summary")
    {
        if(label_summary != nullptr)
        {
            children["label-summary"] = label_summary.get();
        }
        else
        {
            label_summary = std::make_unique<Bfd::LabelSummary>();
            label_summary->parent = this;
            children["label-summary"] = label_summary.get();
        }
        return children.at("label-summary");
    }

    if(child_yang_name == "label-summary-nodes")
    {
        if(label_summary_nodes != nullptr)
        {
            children["label-summary-nodes"] = label_summary_nodes.get();
        }
        else
        {
            label_summary_nodes = std::make_unique<Bfd::LabelSummaryNodes>();
            label_summary_nodes->parent = this;
            children["label-summary-nodes"] = label_summary_nodes.get();
        }
        return children.at("label-summary-nodes");
    }

    if(child_yang_name == "relation-briefs")
    {
        if(relation_briefs != nullptr)
        {
            children["relation-briefs"] = relation_briefs.get();
        }
        else
        {
            relation_briefs = std::make_unique<Bfd::RelationBriefs>();
            relation_briefs->parent = this;
            children["relation-briefs"] = relation_briefs.get();
        }
        return children.at("relation-briefs");
    }

    if(child_yang_name == "relation-details")
    {
        if(relation_details != nullptr)
        {
            children["relation-details"] = relation_details.get();
        }
        else
        {
            relation_details = std::make_unique<Bfd::RelationDetails>();
            relation_details->parent = this;
            children["relation-details"] = relation_details.get();
        }
        return children.at("relation-details");
    }

    if(child_yang_name == "session-briefs")
    {
        if(session_briefs != nullptr)
        {
            children["session-briefs"] = session_briefs.get();
        }
        else
        {
            session_briefs = std::make_unique<Bfd::SessionBriefs>();
            session_briefs->parent = this;
            children["session-briefs"] = session_briefs.get();
        }
        return children.at("session-briefs");
    }

    if(child_yang_name == "session-details")
    {
        if(session_details != nullptr)
        {
            children["session-details"] = session_details.get();
        }
        else
        {
            session_details = std::make_unique<Bfd::SessionDetails>();
            session_details->parent = this;
            children["session-details"] = session_details.get();
        }
        return children.at("session-details");
    }

    if(child_yang_name == "session-mibs")
    {
        if(session_mibs != nullptr)
        {
            children["session-mibs"] = session_mibs.get();
        }
        else
        {
            session_mibs = std::make_unique<Bfd::SessionMibs>();
            session_mibs->parent = this;
            children["session-mibs"] = session_mibs.get();
        }
        return children.at("session-mibs");
    }

    if(child_yang_name == "summary")
    {
        if(summary != nullptr)
        {
            children["summary"] = summary.get();
        }
        else
        {
            summary = std::make_unique<Bfd::Summary>();
            summary->parent = this;
            children["summary"] = summary.get();
        }
        return children.at("summary");
    }

    return nullptr;
}

std::map<std::string, Entity*> & Bfd::get_children()
{
    if(children.find("client-briefs") == children.end())
    {
        if(client_briefs != nullptr)
        {
            children["client-briefs"] = client_briefs.get();
        }
    }

    if(children.find("client-details") == children.end())
    {
        if(client_details != nullptr)
        {
            children["client-details"] = client_details.get();
        }
    }

    if(children.find("counters") == children.end())
    {
        if(counters != nullptr)
        {
            children["counters"] = counters.get();
        }
    }

    if(children.find("generic-summaries") == children.end())
    {
        if(generic_summaries != nullptr)
        {
            children["generic-summaries"] = generic_summaries.get();
        }
    }

    if(children.find("ipv4-multi-hop-counters") == children.end())
    {
        if(ipv4_multi_hop_counters != nullptr)
        {
            children["ipv4-multi-hop-counters"] = ipv4_multi_hop_counters.get();
        }
    }

    if(children.find("ipv4-multi-hop-multi-paths") == children.end())
    {
        if(ipv4_multi_hop_multi_paths != nullptr)
        {
            children["ipv4-multi-hop-multi-paths"] = ipv4_multi_hop_multi_paths.get();
        }
    }

    if(children.find("ipv4-multi-hop-node-location-summaries") == children.end())
    {
        if(ipv4_multi_hop_node_location_summaries != nullptr)
        {
            children["ipv4-multi-hop-node-location-summaries"] = ipv4_multi_hop_node_location_summaries.get();
        }
    }

    if(children.find("ipv4-multi-hop-session-briefs") == children.end())
    {
        if(ipv4_multi_hop_session_briefs != nullptr)
        {
            children["ipv4-multi-hop-session-briefs"] = ipv4_multi_hop_session_briefs.get();
        }
    }

    if(children.find("ipv4-multi-hop-session-details") == children.end())
    {
        if(ipv4_multi_hop_session_details != nullptr)
        {
            children["ipv4-multi-hop-session-details"] = ipv4_multi_hop_session_details.get();
        }
    }

    if(children.find("ipv4-multi-hop-summary") == children.end())
    {
        if(ipv4_multi_hop_summary != nullptr)
        {
            children["ipv4-multi-hop-summary"] = ipv4_multi_hop_summary.get();
        }
    }

    if(children.find("ipv4-single-hop-counters") == children.end())
    {
        if(ipv4_single_hop_counters != nullptr)
        {
            children["ipv4-single-hop-counters"] = ipv4_single_hop_counters.get();
        }
    }

    if(children.find("ipv4-single-hop-location-summaries") == children.end())
    {
        if(ipv4_single_hop_location_summaries != nullptr)
        {
            children["ipv4-single-hop-location-summaries"] = ipv4_single_hop_location_summaries.get();
        }
    }

    if(children.find("ipv4-single-hop-multi-paths") == children.end())
    {
        if(ipv4_single_hop_multi_paths != nullptr)
        {
            children["ipv4-single-hop-multi-paths"] = ipv4_single_hop_multi_paths.get();
        }
    }

    if(children.find("ipv4-single-hop-node-location-summaries") == children.end())
    {
        if(ipv4_single_hop_node_location_summaries != nullptr)
        {
            children["ipv4-single-hop-node-location-summaries"] = ipv4_single_hop_node_location_summaries.get();
        }
    }

    if(children.find("ipv4-single-hop-session-briefs") == children.end())
    {
        if(ipv4_single_hop_session_briefs != nullptr)
        {
            children["ipv4-single-hop-session-briefs"] = ipv4_single_hop_session_briefs.get();
        }
    }

    if(children.find("ipv4-single-hop-session-details") == children.end())
    {
        if(ipv4_single_hop_session_details != nullptr)
        {
            children["ipv4-single-hop-session-details"] = ipv4_single_hop_session_details.get();
        }
    }

    if(children.find("ipv4-single-hop-summary") == children.end())
    {
        if(ipv4_single_hop_summary != nullptr)
        {
            children["ipv4-single-hop-summary"] = ipv4_single_hop_summary.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-head-counters") == children.end())
    {
        if(ipv4bf_do_mplste_head_counters != nullptr)
        {
            children["ipv4bf-do-mplste-head-counters"] = ipv4bf_do_mplste_head_counters.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-head-multi-paths") == children.end())
    {
        if(ipv4bf_do_mplste_head_multi_paths != nullptr)
        {
            children["ipv4bf-do-mplste-head-multi-paths"] = ipv4bf_do_mplste_head_multi_paths.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-head-session-briefs") == children.end())
    {
        if(ipv4bf_do_mplste_head_session_briefs != nullptr)
        {
            children["ipv4bf-do-mplste-head-session-briefs"] = ipv4bf_do_mplste_head_session_briefs.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-head-session-details") == children.end())
    {
        if(ipv4bf_do_mplste_head_session_details != nullptr)
        {
            children["ipv4bf-do-mplste-head-session-details"] = ipv4bf_do_mplste_head_session_details.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-head-summary") == children.end())
    {
        if(ipv4bf_do_mplste_head_summary != nullptr)
        {
            children["ipv4bf-do-mplste-head-summary"] = ipv4bf_do_mplste_head_summary.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-tail-counters") == children.end())
    {
        if(ipv4bf_do_mplste_tail_counters != nullptr)
        {
            children["ipv4bf-do-mplste-tail-counters"] = ipv4bf_do_mplste_tail_counters.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-tail-multi-paths") == children.end())
    {
        if(ipv4bf_do_mplste_tail_multi_paths != nullptr)
        {
            children["ipv4bf-do-mplste-tail-multi-paths"] = ipv4bf_do_mplste_tail_multi_paths.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-tail-session-briefs") == children.end())
    {
        if(ipv4bf_do_mplste_tail_session_briefs != nullptr)
        {
            children["ipv4bf-do-mplste-tail-session-briefs"] = ipv4bf_do_mplste_tail_session_briefs.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-tail-session-details") == children.end())
    {
        if(ipv4bf_do_mplste_tail_session_details != nullptr)
        {
            children["ipv4bf-do-mplste-tail-session-details"] = ipv4bf_do_mplste_tail_session_details.get();
        }
    }

    if(children.find("ipv4bf-do-mplste-tail-summary") == children.end())
    {
        if(ipv4bf_do_mplste_tail_summary != nullptr)
        {
            children["ipv4bf-do-mplste-tail-summary"] = ipv4bf_do_mplste_tail_summary.get();
        }
    }

    if(children.find("ipv4bfd-mplste-head-summary-nodes") == children.end())
    {
        if(ipv4bfd_mplste_head_summary_nodes != nullptr)
        {
            children["ipv4bfd-mplste-head-summary-nodes"] = ipv4bfd_mplste_head_summary_nodes.get();
        }
    }

    if(children.find("ipv4bfd-mplste-tail-node-summaries") == children.end())
    {
        if(ipv4bfd_mplste_tail_node_summaries != nullptr)
        {
            children["ipv4bfd-mplste-tail-node-summaries"] = ipv4bfd_mplste_tail_node_summaries.get();
        }
    }

    if(children.find("ipv6-multi-hop-counters") == children.end())
    {
        if(ipv6_multi_hop_counters != nullptr)
        {
            children["ipv6-multi-hop-counters"] = ipv6_multi_hop_counters.get();
        }
    }

    if(children.find("ipv6-multi-hop-multi-paths") == children.end())
    {
        if(ipv6_multi_hop_multi_paths != nullptr)
        {
            children["ipv6-multi-hop-multi-paths"] = ipv6_multi_hop_multi_paths.get();
        }
    }

    if(children.find("ipv6-multi-hop-node-location-summaries") == children.end())
    {
        if(ipv6_multi_hop_node_location_summaries != nullptr)
        {
            children["ipv6-multi-hop-node-location-summaries"] = ipv6_multi_hop_node_location_summaries.get();
        }
    }

    if(children.find("ipv6-multi-hop-session-briefs") == children.end())
    {
        if(ipv6_multi_hop_session_briefs != nullptr)
        {
            children["ipv6-multi-hop-session-briefs"] = ipv6_multi_hop_session_briefs.get();
        }
    }

    if(children.find("ipv6-multi-hop-session-details") == children.end())
    {
        if(ipv6_multi_hop_session_details != nullptr)
        {
            children["ipv6-multi-hop-session-details"] = ipv6_multi_hop_session_details.get();
        }
    }

    if(children.find("ipv6-multi-hop-summary") == children.end())
    {
        if(ipv6_multi_hop_summary != nullptr)
        {
            children["ipv6-multi-hop-summary"] = ipv6_multi_hop_summary.get();
        }
    }

    if(children.find("ipv6-single-hop-counters") == children.end())
    {
        if(ipv6_single_hop_counters != nullptr)
        {
            children["ipv6-single-hop-counters"] = ipv6_single_hop_counters.get();
        }
    }

    if(children.find("ipv6-single-hop-location-summaries") == children.end())
    {
        if(ipv6_single_hop_location_summaries != nullptr)
        {
            children["ipv6-single-hop-location-summaries"] = ipv6_single_hop_location_summaries.get();
        }
    }

    if(children.find("ipv6-single-hop-multi-paths") == children.end())
    {
        if(ipv6_single_hop_multi_paths != nullptr)
        {
            children["ipv6-single-hop-multi-paths"] = ipv6_single_hop_multi_paths.get();
        }
    }

    if(children.find("ipv6-single-hop-node-location-summaries") == children.end())
    {
        if(ipv6_single_hop_node_location_summaries != nullptr)
        {
            children["ipv6-single-hop-node-location-summaries"] = ipv6_single_hop_node_location_summaries.get();
        }
    }

    if(children.find("ipv6-single-hop-session-briefs") == children.end())
    {
        if(ipv6_single_hop_session_briefs != nullptr)
        {
            children["ipv6-single-hop-session-briefs"] = ipv6_single_hop_session_briefs.get();
        }
    }

    if(children.find("ipv6-single-hop-session-details") == children.end())
    {
        if(ipv6_single_hop_session_details != nullptr)
        {
            children["ipv6-single-hop-session-details"] = ipv6_single_hop_session_details.get();
        }
    }

    if(children.find("ipv6-single-hop-summary") == children.end())
    {
        if(ipv6_single_hop_summary != nullptr)
        {
            children["ipv6-single-hop-summary"] = ipv6_single_hop_summary.get();
        }
    }

    if(children.find("label-counters") == children.end())
    {
        if(label_counters != nullptr)
        {
            children["label-counters"] = label_counters.get();
        }
    }

    if(children.find("label-multi-paths") == children.end())
    {
        if(label_multi_paths != nullptr)
        {
            children["label-multi-paths"] = label_multi_paths.get();
        }
    }

    if(children.find("label-session-briefs") == children.end())
    {
        if(label_session_briefs != nullptr)
        {
            children["label-session-briefs"] = label_session_briefs.get();
        }
    }

    if(children.find("label-session-details") == children.end())
    {
        if(label_session_details != nullptr)
        {
            children["label-session-details"] = label_session_details.get();
        }
    }

    if(children.find("label-summary") == children.end())
    {
        if(label_summary != nullptr)
        {
            children["label-summary"] = label_summary.get();
        }
    }

    if(children.find("label-summary-nodes") == children.end())
    {
        if(label_summary_nodes != nullptr)
        {
            children["label-summary-nodes"] = label_summary_nodes.get();
        }
    }

    if(children.find("relation-briefs") == children.end())
    {
        if(relation_briefs != nullptr)
        {
            children["relation-briefs"] = relation_briefs.get();
        }
    }

    if(children.find("relation-details") == children.end())
    {
        if(relation_details != nullptr)
        {
            children["relation-details"] = relation_details.get();
        }
    }

    if(children.find("session-briefs") == children.end())
    {
        if(session_briefs != nullptr)
        {
            children["session-briefs"] = session_briefs.get();
        }
    }

    if(children.find("session-details") == children.end())
    {
        if(session_details != nullptr)
        {
            children["session-details"] = session_details.get();
        }
    }

    if(children.find("session-mibs") == children.end())
    {
        if(session_mibs != nullptr)
        {
            children["session-mibs"] = session_mibs.get();
        }
    }

    if(children.find("summary") == children.end())
    {
        if(summary != nullptr)
        {
            children["summary"] = summary.get();
        }
    }

    return children;
}

void Bfd::set_value(const std::string & value_path, std::string value)
{
}

std::unique_ptr<Entity> Bfd::clone_ptr()
{
    return std::make_unique<Bfd>();
}

const Enum::YLeaf BfdApiFecEnum::bfd_api_fec_type_none {0, "bfd-api-fec-type-none"};
const Enum::YLeaf BfdApiFecEnum::bfd_api_fec_type_p2p_te {1, "bfd-api-fec-type-p2p-te"};

const Enum::YLeaf BfdSessionEnum::undefined {0, "undefined"};
const Enum::YLeaf BfdSessionEnum::bundle_member {1, "bundle-member"};
const Enum::YLeaf BfdSessionEnum::bundle_interface {2, "bundle-interface"};
const Enum::YLeaf BfdSessionEnum::state_inheriting {3, "state-inheriting"};
const Enum::YLeaf BfdSessionEnum::bundle_vlan {4, "bundle-vlan"};
const Enum::YLeaf BfdSessionEnum::mpls_tp {5, "mpls-tp"};
const Enum::YLeaf BfdSessionEnum::gre {6, "gre"};
const Enum::YLeaf BfdSessionEnum::pseudowire_headend {7, "pseudowire-headend"};
const Enum::YLeaf BfdSessionEnum::ip_single_hop {8, "ip-single-hop"};

const Enum::YLeaf BfdAfIdEnum::bfd_af_id_none {0, "bfd-af-id-none"};
const Enum::YLeaf BfdAfIdEnum::bfd_af_id_ipv4 {2, "bfd-af-id-ipv4"};
const Enum::YLeaf BfdAfIdEnum::bfd_af_id_ipv6 {10, "bfd-af-id-ipv6"};

const Enum::YLeaf BfdMpDownloadStateEnum::bfd_mp_download_none {0, "bfd-mp-download-none"};
const Enum::YLeaf BfdMpDownloadStateEnum::bfd_mp_download_no_lc {1, "bfd-mp-download-no-lc"};
const Enum::YLeaf BfdMpDownloadStateEnum::bfd_mp_download_downloaded {2, "bfd-mp-download-downloaded"};
const Enum::YLeaf BfdMpDownloadStateEnum::bfd_mp_download_ack {3, "bfd-mp-download-ack"};
const Enum::YLeaf BfdMpDownloadStateEnum::bfd_mp_download_nack {4, "bfd-mp-download-nack"};
const Enum::YLeaf BfdMpDownloadStateEnum::bfd_mp_download_delete {5, "bfd-mp-download-delete"};

const Enum::YLeaf BfdMgmtSessionStateEnum::bfd_mgmt_session_state_admin_down {0, "bfd-mgmt-session-state-admin-down"};
const Enum::YLeaf BfdMgmtSessionStateEnum::bfd_mgmt_session_state_down {1, "bfd-mgmt-session-state-down"};
const Enum::YLeaf BfdMgmtSessionStateEnum::bfd_mgmt_session_state_init {2, "bfd-mgmt-session-state-init"};
const Enum::YLeaf BfdMgmtSessionStateEnum::bfd_mgmt_session_state_up {3, "bfd-mgmt-session-state-up"};
const Enum::YLeaf BfdMgmtSessionStateEnum::bfd_mgmt_session_state_failing {4, "bfd-mgmt-session-state-failing"};
const Enum::YLeaf BfdMgmtSessionStateEnum::bfd_mgmt_session_state_unknown {6, "bfd-mgmt-session-state-unknown"};

const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_none {0, "bfd-mgmt-session-diag-none"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_control_detect_expired {1, "bfd-mgmt-session-diag-control-detect-expired"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_echo_function_failed {2, "bfd-mgmt-session-diag-echo-function-failed"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_nb_or_signaled_down {3, "bfd-mgmt-session-diag-nb-or-signaled-down"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_fwding_plane_reset {4, "bfd-mgmt-session-diag-fwding-plane-reset"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_path_down {5, "bfd-mgmt-session-diag-path-down"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_conc_path_down {6, "bfd-mgmt-session-diag-conc-path-down"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_admin_down {7, "bfd-mgmt-session-diag-admin-down"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_rev_conc_path_down {8, "bfd-mgmt-session-diag-rev-conc-path-down"};
const Enum::YLeaf BfdMgmtSessionDiagEnum::bfd_mgmt_session_diag_num {10, "bfd-mgmt-session-diag-num"};

const Enum::YLeaf BfdMgmtPktDisplayEnum::bfd_mgmt_pkt_display_type_none {0, "bfd-mgmt-pkt-display-type-none"};
const Enum::YLeaf BfdMgmtPktDisplayEnum::bfd_mgmt_pkt_display_type_bob_mbr {1, "bfd-mgmt-pkt-display-type-bob-mbr"};
const Enum::YLeaf BfdMgmtPktDisplayEnum::bfd_mgmt_pkt_display_type_max {2, "bfd-mgmt-pkt-display-type-max"};

const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_null {0, "mpls-lib-c-type-null"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv4 {1, "mpls-lib-c-type-ipv4"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv4_p2p_tunnel {7, "mpls-lib-c-type-ipv4-p2p-tunnel"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv6_p2p_tunnel {8, "mpls-lib-c-type-ipv6-p2p-tunnel"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv4_uni {9, "mpls-lib-c-type-ipv4-uni"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv4_p2mp_tunnel {13, "mpls-lib-c-type-ipv4-p2mp-tunnel"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv6_p2mp_tunnel {14, "mpls-lib-c-type-ipv6-p2mp-tunnel"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv4_tp_tunnel {15, "mpls-lib-c-type-ipv4-tp-tunnel"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_ipv6_tp_tunnel {16, "mpls-lib-c-type-ipv6-tp-tunnel"};
const Enum::YLeaf MplsLibCEnum::mpls_lib_c_type_p2p_binding_label {17, "mpls-lib-c-type-p2p-binding-label"};


}
}

