
#include <sstream>
#include <iostream>
#include <ydk/entity_util.hpp>
#include "bundle_info.hpp"
#include "generated_entity_lookup.hpp"
#include "Cisco_IOS_XR_ncs6k_acl_oper_1.hpp"
#include "Cisco_IOS_XR_ncs6k_acl_oper_2.hpp"

using namespace ydk;

namespace cisco_ios_xr {
namespace Cisco_IOS_XR_ncs6k_acl_oper {

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::CommonAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::InterfaceAclDetail()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "interface-acl-detail"; yang_parent_name = "sequence-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::~InterfaceAclDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface-acl-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "interface-acl-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "interface-acl-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceDetails::SequenceDetail::InterfaceAclDetail::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBriefs()
    :
    sequence_brief(this, {"sequence_number"})
{

    yang_name = "sequence-briefs"; yang_parent_name = "access"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::~SequenceBriefs()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<sequence_brief.len(); index++)
    {
        if(sequence_brief[index]->has_data())
            return true;
    }
    return false;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::has_operation() const
{
    for (std::size_t index=0; index<sequence_brief.len(); index++)
    {
        if(sequence_brief[index]->has_operation())
            return true;
    }
    return is_set(yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "sequence-briefs";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "sequence-brief")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief>();
        c->parent = this;
        sequence_brief.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    count = 0;
    for (auto c : sequence_brief.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "sequence-brief")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::SequenceBrief()
    :
    sequence_number{YType::int32, "sequence-number"}
        ,
    common_acl(this, {})
    , interface_acl(this, {})
{

    yang_name = "sequence-brief"; yang_parent_name = "sequence-briefs"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::~SequenceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<common_acl.len(); index++)
    {
        if(common_acl[index]->has_data())
            return true;
    }
    for (std::size_t index=0; index<interface_acl.len(); index++)
    {
        if(interface_acl[index]->has_data())
            return true;
    }
    return sequence_number.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::has_operation() const
{
    for (std::size_t index=0; index<common_acl.len(); index++)
    {
        if(common_acl[index]->has_operation())
            return true;
    }
    for (std::size_t index=0; index<interface_acl.len(); index++)
    {
        if(interface_acl[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| ydk::is_set(sequence_number.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "sequence-brief";
    ADD_KEY_TOKEN(sequence_number, "sequence-number");
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (sequence_number.is_set || is_set(sequence_number.yfilter)) leaf_name_data.push_back(sequence_number.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "common-acl")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl>();
        c->parent = this;
        common_acl.append(c);
        return c;
    }

    if(child_yang_name == "interface-acl")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl>();
        c->parent = this;
        interface_acl.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    count = 0;
    for (auto c : common_acl.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    count = 0;
    for (auto c : interface_acl.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "sequence-number")
    {
        sequence_number = value;
        sequence_number.value_namespace = name_space;
        sequence_number.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "sequence-number")
    {
        sequence_number.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "common-acl" || name == "interface-acl" || name == "sequence-number")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::CommonAcl()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "common-acl"; yang_parent_name = "sequence-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::~CommonAcl()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "common-acl";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "common-acl"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::CommonAcl::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::InterfaceAcl()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "interface-acl"; yang_parent_name = "sequence-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::~InterfaceAcl()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface-acl";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "interface-acl"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv4::Accesses::Access::SequenceBriefs::SequenceBrief::InterfaceAcl::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Ipv6()
    :
    accesses(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses>())
{
    accesses->parent = this;

    yang_name = "ipv6"; yang_parent_name = "egress"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::~Ipv6()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::has_data() const
{
    if (is_presence_container) return true;
    return (accesses !=  nullptr && accesses->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::has_operation() const
{
    return is_set(yfilter)
	|| (accesses !=  nullptr && accesses->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "accesses")
    {
        if(accesses == nullptr)
        {
            accesses = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses>();
        }
        return accesses;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(accesses != nullptr)
    {
        children["accesses"] = accesses;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "accesses")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Accesses()
    :
    access(this, {"access_list_name"})
{

    yang_name = "accesses"; yang_parent_name = "ipv6"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::~Accesses()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<access.len(); index++)
    {
        if(access[index]->has_data())
            return true;
    }
    return false;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::has_operation() const
{
    for (std::size_t index=0; index<access.len(); index++)
    {
        if(access[index]->has_operation())
            return true;
    }
    return is_set(yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "accesses";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "access")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access>();
        c->parent = this;
        access.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    count = 0;
    for (auto c : access.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "access")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Access()
    :
    access_list_name{YType::str, "access-list-name"}
        ,
    implicit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit>())
    , sequence_details(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::SequenceDetails>())
    , sequence_briefs(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::SequenceBriefs>())
{
    implicit->parent = this;
    sequence_details->parent = this;
    sequence_briefs->parent = this;

    yang_name = "access"; yang_parent_name = "accesses"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::~Access()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::has_data() const
{
    if (is_presence_container) return true;
    return access_list_name.is_set
	|| (implicit !=  nullptr && implicit->has_data())
	|| (sequence_details !=  nullptr && sequence_details->has_data())
	|| (sequence_briefs !=  nullptr && sequence_briefs->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(access_list_name.yfilter)
	|| (implicit !=  nullptr && implicit->has_operation())
	|| (sequence_details !=  nullptr && sequence_details->has_operation())
	|| (sequence_briefs !=  nullptr && sequence_briefs->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "access";
    ADD_KEY_TOKEN(access_list_name, "access-list-name");
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (access_list_name.is_set || is_set(access_list_name.yfilter)) leaf_name_data.push_back(access_list_name.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "implicit")
    {
        if(implicit == nullptr)
        {
            implicit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit>();
        }
        return implicit;
    }

    if(child_yang_name == "sequence-details")
    {
        if(sequence_details == nullptr)
        {
            sequence_details = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::SequenceDetails>();
        }
        return sequence_details;
    }

    if(child_yang_name == "sequence-briefs")
    {
        if(sequence_briefs == nullptr)
        {
            sequence_briefs = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::SequenceBriefs>();
        }
        return sequence_briefs;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(implicit != nullptr)
    {
        children["implicit"] = implicit;
    }

    if(sequence_details != nullptr)
    {
        children["sequence-details"] = sequence_details;
    }

    if(sequence_briefs != nullptr)
    {
        children["sequence-briefs"] = sequence_briefs;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "access-list-name")
    {
        access_list_name = value;
        access_list_name.value_namespace = name_space;
        access_list_name.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "access-list-name")
    {
        access_list_name.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "implicit" || name == "sequence-details" || name == "sequence-briefs" || name == "access-list-name")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::Implicit()
    :
    implicit_acl(this, {})
{

    yang_name = "implicit"; yang_parent_name = "access"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::~Implicit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<implicit_acl.len(); index++)
    {
        if(implicit_acl[index]->has_data())
            return true;
    }
    return false;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::has_operation() const
{
    for (std::size_t index=0; index<implicit_acl.len(); index++)
    {
        if(implicit_acl[index]->has_operation())
            return true;
    }
    return is_set(yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "implicit-acl")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl>();
        c->parent = this;
        implicit_acl.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    count = 0;
    for (auto c : implicit_acl.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "implicit-acl")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::ImplicitAcl()
    :
    common_acl_implicit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit>())
    , interface_acl_implicit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit>())
{
    common_acl_implicit->parent = this;
    interface_acl_implicit->parent = this;

    yang_name = "implicit-acl"; yang_parent_name = "implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::~ImplicitAcl()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::has_data() const
{
    if (is_presence_container) return true;
    return (common_acl_implicit !=  nullptr && common_acl_implicit->has_data())
	|| (interface_acl_implicit !=  nullptr && interface_acl_implicit->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::has_operation() const
{
    return is_set(yfilter)
	|| (common_acl_implicit !=  nullptr && common_acl_implicit->has_operation())
	|| (interface_acl_implicit !=  nullptr && interface_acl_implicit->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-acl";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "common-acl-implicit")
    {
        if(common_acl_implicit == nullptr)
        {
            common_acl_implicit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit>();
        }
        return common_acl_implicit;
    }

    if(child_yang_name == "interface-acl-implicit")
    {
        if(interface_acl_implicit == nullptr)
        {
            interface_acl_implicit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit>();
        }
        return interface_acl_implicit;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(common_acl_implicit != nullptr)
    {
        children["common-acl-implicit"] = common_acl_implicit;
    }

    if(interface_acl_implicit != nullptr)
    {
        children["interface-acl-implicit"] = interface_acl_implicit;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "common-acl-implicit" || name == "interface-acl-implicit")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::CommonAclImplicit()
    :
    implicit_ndna_permit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit>())
    , implicit_ndns_permit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit>())
    , implicit_deny(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny>())
{
    implicit_ndna_permit->parent = this;
    implicit_ndns_permit->parent = this;
    implicit_deny->parent = this;

    yang_name = "common-acl-implicit"; yang_parent_name = "implicit-acl"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::~CommonAclImplicit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::has_data() const
{
    if (is_presence_container) return true;
    return (implicit_ndna_permit !=  nullptr && implicit_ndna_permit->has_data())
	|| (implicit_ndns_permit !=  nullptr && implicit_ndns_permit->has_data())
	|| (implicit_deny !=  nullptr && implicit_deny->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::has_operation() const
{
    return is_set(yfilter)
	|| (implicit_ndna_permit !=  nullptr && implicit_ndna_permit->has_operation())
	|| (implicit_ndns_permit !=  nullptr && implicit_ndns_permit->has_operation())
	|| (implicit_deny !=  nullptr && implicit_deny->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "common-acl-implicit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "implicit-ndna-permit")
    {
        if(implicit_ndna_permit == nullptr)
        {
            implicit_ndna_permit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit>();
        }
        return implicit_ndna_permit;
    }

    if(child_yang_name == "implicit-ndns-permit")
    {
        if(implicit_ndns_permit == nullptr)
        {
            implicit_ndns_permit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit>();
        }
        return implicit_ndns_permit;
    }

    if(child_yang_name == "implicit-deny")
    {
        if(implicit_deny == nullptr)
        {
            implicit_deny = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny>();
        }
        return implicit_deny;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(implicit_ndna_permit != nullptr)
    {
        children["implicit-ndna-permit"] = implicit_ndna_permit;
    }

    if(implicit_ndns_permit != nullptr)
    {
        children["implicit-ndns-permit"] = implicit_ndns_permit;
    }

    if(implicit_deny != nullptr)
    {
        children["implicit-deny"] = implicit_deny;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "implicit-ndna-permit" || name == "implicit-ndns-permit" || name == "implicit-deny")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::ImplicitNdnaPermit()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "implicit-ndna-permit"; yang_parent_name = "common-acl-implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::~ImplicitNdnaPermit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-ndna-permit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "implicit-ndna-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "implicit-ndna-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::ImplicitNdnsPermit()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "implicit-ndns-permit"; yang_parent_name = "common-acl-implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::~ImplicitNdnsPermit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-ndns-permit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "implicit-ndns-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "implicit-ndns-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::ImplicitDeny()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "implicit-deny"; yang_parent_name = "common-acl-implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::~ImplicitDeny()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-deny";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "implicit-deny"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "implicit-deny"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::CommonAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::InterfaceAclImplicit()
    :
    implicit_ndna_permit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit>())
    , implicit_ndns_permit(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit>())
    , implicit_deny(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny>())
{
    implicit_ndna_permit->parent = this;
    implicit_ndns_permit->parent = this;
    implicit_deny->parent = this;

    yang_name = "interface-acl-implicit"; yang_parent_name = "implicit-acl"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::~InterfaceAclImplicit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::has_data() const
{
    if (is_presence_container) return true;
    return (implicit_ndna_permit !=  nullptr && implicit_ndna_permit->has_data())
	|| (implicit_ndns_permit !=  nullptr && implicit_ndns_permit->has_data())
	|| (implicit_deny !=  nullptr && implicit_deny->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::has_operation() const
{
    return is_set(yfilter)
	|| (implicit_ndna_permit !=  nullptr && implicit_ndna_permit->has_operation())
	|| (implicit_ndns_permit !=  nullptr && implicit_ndns_permit->has_operation())
	|| (implicit_deny !=  nullptr && implicit_deny->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "interface-acl-implicit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "implicit-ndna-permit")
    {
        if(implicit_ndna_permit == nullptr)
        {
            implicit_ndna_permit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit>();
        }
        return implicit_ndna_permit;
    }

    if(child_yang_name == "implicit-ndns-permit")
    {
        if(implicit_ndns_permit == nullptr)
        {
            implicit_ndns_permit = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit>();
        }
        return implicit_ndns_permit;
    }

    if(child_yang_name == "implicit-deny")
    {
        if(implicit_deny == nullptr)
        {
            implicit_deny = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny>();
        }
        return implicit_deny;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(implicit_ndna_permit != nullptr)
    {
        children["implicit-ndna-permit"] = implicit_ndna_permit;
    }

    if(implicit_ndns_permit != nullptr)
    {
        children["implicit-ndns-permit"] = implicit_ndns_permit;
    }

    if(implicit_deny != nullptr)
    {
        children["implicit-deny"] = implicit_deny;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "implicit-ndna-permit" || name == "implicit-ndns-permit" || name == "implicit-deny")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::ImplicitNdnaPermit()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "implicit-ndna-permit"; yang_parent_name = "interface-acl-implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::~ImplicitNdnaPermit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-ndna-permit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "implicit-ndna-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "implicit-ndna-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnaPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::ImplicitNdnsPermit()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "implicit-ndns-permit"; yang_parent_name = "interface-acl-implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::~ImplicitNdnsPermit()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-ndns-permit";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "implicit-ndns-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "implicit-ndns-permit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    protocol{YType::uint8, "protocol"},
    layer4_source_port{YType::uint32, "layer4-source-port"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    source_range_id{YType::uint32, "source-range-id"},
    destination_range_id{YType::uint32, "destination-range-id"},
    destination_header{YType::uint8, "destination-header"},
    receive_transition_gap_header{YType::uint8, "receive-transition-gap-header"},
    authentication_header{YType::uint8, "authentication-header"},
    fragment{YType::uint8, "fragment"},
    tos{YType::uint8, "tos"},
    packet_length_range{YType::uint32, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| protocol.is_set
	|| layer4_source_port.is_set
	|| layer4_destination_port.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| destination_header.is_set
	|| receive_transition_gap_header.is_set
	|| authentication_header.is_set
	|| fragment.is_set
	|| tos.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(destination_header.yfilter)
	|| ydk::is_set(receive_transition_gap_header.yfilter)
	|| ydk::is_set(authentication_header.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(tos.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (destination_header.is_set || is_set(destination_header.yfilter)) leaf_name_data.push_back(destination_header.get_name_leafdata());
    if (receive_transition_gap_header.is_set || is_set(receive_transition_gap_header.yfilter)) leaf_name_data.push_back(receive_transition_gap_header.get_name_leafdata());
    if (authentication_header.is_set || is_set(authentication_header.yfilter)) leaf_name_data.push_back(authentication_header.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (tos.is_set || is_set(tos.yfilter)) leaf_name_data.push_back(tos.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-header")
    {
        destination_header = value;
        destination_header.value_namespace = name_space;
        destination_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header = value;
        receive_transition_gap_header.value_namespace = name_space;
        receive_transition_gap_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "authentication-header")
    {
        authentication_header = value;
        authentication_header.value_namespace = name_space;
        authentication_header.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "tos")
    {
        tos = value;
        tos.value_namespace = name_space;
        tos.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-header")
    {
        destination_header.yfilter = yfilter;
    }
    if(value_path == "receive-transition-gap-header")
    {
        receive_transition_gap_header.yfilter = yfilter;
    }
    if(value_path == "authentication-header")
    {
        authentication_header.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "tos")
    {
        tos.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "protocol" || name == "layer4-source-port" || name == "layer4-destination-port" || name == "source-range-id" || name == "destination-range-id" || name == "destination-header" || name == "receive-transition-gap-header" || name == "authentication-header" || name == "fragment" || name == "tos" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitNdnsPermit::AceDetail::Ipv6tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::ImplicitDeny()
    :
    ace_brief(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief>())
    , ace_detail(this, {})
{
    ace_brief->parent = this;

    yang_name = "implicit-deny"; yang_parent_name = "interface-acl-implicit"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::~ImplicitDeny()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::has_data() const
{
    if (is_presence_container) return true;
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_data())
            return true;
    }
    return (ace_brief !=  nullptr && ace_brief->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::has_operation() const
{
    for (std::size_t index=0; index<ace_detail.len(); index++)
    {
        if(ace_detail[index]->has_operation())
            return true;
    }
    return is_set(yfilter)
	|| (ace_brief !=  nullptr && ace_brief->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "implicit-deny";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ace-brief")
    {
        if(ace_brief == nullptr)
        {
            ace_brief = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief>();
        }
        return ace_brief;
    }

    if(child_yang_name == "ace-detail")
    {
        auto c = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail>();
        c->parent = this;
        ace_detail.append(c);
        return c;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ace_brief != nullptr)
    {
        children["ace-brief"] = ace_brief;
    }

    count = 0;
    for (auto c : ace_detail.entities())
    {
        if(children.find(c->get_segment_path()) == children.end())
            children[c->get_segment_path()] = c;
        else
            children[c->get_segment_path()+count++] = c;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ace-brief" || name == "ace-detail")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::AceBrief()
    :
    grant{YType::enumeration, "grant"},
    logging_enabled{YType::boolean, "logging-enabled"},
    per_ace_icmp_enabled{YType::boolean, "per-ace-icmp-enabled"},
    next_hop_enabled{YType::boolean, "next-hop-enabled"},
    default_next_hop_enabled{YType::boolean, "default-next-hop-enabled"},
    total_tcam_entries{YType::uint32, "total-tcam-entries"},
    hits{YType::uint64, "hits"},
    npu_id{YType::uint8, "npu-id"}
        ,
    next_hop_address(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress>())
{
    next_hop_address->parent = this;

    yang_name = "ace-brief"; yang_parent_name = "implicit-deny"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::~AceBrief()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::has_data() const
{
    if (is_presence_container) return true;
    return grant.is_set
	|| logging_enabled.is_set
	|| per_ace_icmp_enabled.is_set
	|| next_hop_enabled.is_set
	|| default_next_hop_enabled.is_set
	|| total_tcam_entries.is_set
	|| hits.is_set
	|| npu_id.is_set
	|| (next_hop_address !=  nullptr && next_hop_address->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(grant.yfilter)
	|| ydk::is_set(logging_enabled.yfilter)
	|| ydk::is_set(per_ace_icmp_enabled.yfilter)
	|| ydk::is_set(next_hop_enabled.yfilter)
	|| ydk::is_set(default_next_hop_enabled.yfilter)
	|| ydk::is_set(total_tcam_entries.yfilter)
	|| ydk::is_set(hits.yfilter)
	|| ydk::is_set(npu_id.yfilter)
	|| (next_hop_address !=  nullptr && next_hop_address->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-brief";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (grant.is_set || is_set(grant.yfilter)) leaf_name_data.push_back(grant.get_name_leafdata());
    if (logging_enabled.is_set || is_set(logging_enabled.yfilter)) leaf_name_data.push_back(logging_enabled.get_name_leafdata());
    if (per_ace_icmp_enabled.is_set || is_set(per_ace_icmp_enabled.yfilter)) leaf_name_data.push_back(per_ace_icmp_enabled.get_name_leafdata());
    if (next_hop_enabled.is_set || is_set(next_hop_enabled.yfilter)) leaf_name_data.push_back(next_hop_enabled.get_name_leafdata());
    if (default_next_hop_enabled.is_set || is_set(default_next_hop_enabled.yfilter)) leaf_name_data.push_back(default_next_hop_enabled.get_name_leafdata());
    if (total_tcam_entries.is_set || is_set(total_tcam_entries.yfilter)) leaf_name_data.push_back(total_tcam_entries.get_name_leafdata());
    if (hits.is_set || is_set(hits.yfilter)) leaf_name_data.push_back(hits.get_name_leafdata());
    if (npu_id.is_set || is_set(npu_id.yfilter)) leaf_name_data.push_back(npu_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "next-hop-address")
    {
        if(next_hop_address == nullptr)
        {
            next_hop_address = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress>();
        }
        return next_hop_address;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(next_hop_address != nullptr)
    {
        children["next-hop-address"] = next_hop_address;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "grant")
    {
        grant = value;
        grant.value_namespace = name_space;
        grant.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled = value;
        logging_enabled.value_namespace = name_space;
        logging_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled = value;
        per_ace_icmp_enabled.value_namespace = name_space;
        per_ace_icmp_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled = value;
        next_hop_enabled.value_namespace = name_space;
        next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled = value;
        default_next_hop_enabled.value_namespace = name_space;
        default_next_hop_enabled.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries = value;
        total_tcam_entries.value_namespace = name_space;
        total_tcam_entries.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "hits")
    {
        hits = value;
        hits.value_namespace = name_space;
        hits.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "npu-id")
    {
        npu_id = value;
        npu_id.value_namespace = name_space;
        npu_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "grant")
    {
        grant.yfilter = yfilter;
    }
    if(value_path == "logging-enabled")
    {
        logging_enabled.yfilter = yfilter;
    }
    if(value_path == "per-ace-icmp-enabled")
    {
        per_ace_icmp_enabled.yfilter = yfilter;
    }
    if(value_path == "next-hop-enabled")
    {
        next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "default-next-hop-enabled")
    {
        default_next_hop_enabled.yfilter = yfilter;
    }
    if(value_path == "total-tcam-entries")
    {
        total_tcam_entries.yfilter = yfilter;
    }
    if(value_path == "hits")
    {
        hits.yfilter = yfilter;
    }
    if(value_path == "npu-id")
    {
        npu_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "next-hop-address" || name == "grant" || name == "logging-enabled" || name == "per-ace-icmp-enabled" || name == "next-hop-enabled" || name == "default-next-hop-enabled" || name == "total-tcam-entries" || name == "hits" || name == "npu-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::NextHopAddress()
    :
    address_type{YType::enumeration, "address-type"},
    ipv4_address{YType::str, "ipv4-address"},
    ipv6_address{YType::str, "ipv6-address"}
{

    yang_name = "next-hop-address"; yang_parent_name = "ace-brief"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::~NextHopAddress()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::has_data() const
{
    if (is_presence_container) return true;
    return address_type.is_set
	|| ipv4_address.is_set
	|| ipv6_address.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(address_type.yfilter)
	|| ydk::is_set(ipv4_address.yfilter)
	|| ydk::is_set(ipv6_address.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "next-hop-address";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (address_type.is_set || is_set(address_type.yfilter)) leaf_name_data.push_back(address_type.get_name_leafdata());
    if (ipv4_address.is_set || is_set(ipv4_address.yfilter)) leaf_name_data.push_back(ipv4_address.get_name_leafdata());
    if (ipv6_address.is_set || is_set(ipv6_address.yfilter)) leaf_name_data.push_back(ipv6_address.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "address-type")
    {
        address_type = value;
        address_type.value_namespace = name_space;
        address_type.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address = value;
        ipv4_address.value_namespace = name_space;
        ipv4_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address = value;
        ipv6_address.value_namespace = name_space;
        ipv6_address.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "address-type")
    {
        address_type.yfilter = yfilter;
    }
    if(value_path == "ipv4-address")
    {
        ipv4_address.yfilter = yfilter;
    }
    if(value_path == "ipv6-address")
    {
        ipv6_address.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceBrief::NextHopAddress::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "address-type" || name == "ipv4-address" || name == "ipv6-address")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::AceDetail()
    :
    entry_id{YType::int32, "entry-id"}
        ,
    ipv4tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam>())
    , ipv6tcam(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam>())
{
    ipv4tcam->parent = this;
    ipv6tcam->parent = this;

    yang_name = "ace-detail"; yang_parent_name = "implicit-deny"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::~AceDetail()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::has_data() const
{
    if (is_presence_container) return true;
    return entry_id.is_set
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_data())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(entry_id.yfilter)
	|| (ipv4tcam !=  nullptr && ipv4tcam->has_operation())
	|| (ipv6tcam !=  nullptr && ipv6tcam->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ace-detail";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (entry_id.is_set || is_set(entry_id.yfilter)) leaf_name_data.push_back(entry_id.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "ipv4tcam")
    {
        if(ipv4tcam == nullptr)
        {
            ipv4tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam>();
        }
        return ipv4tcam;
    }

    if(child_yang_name == "ipv6tcam")
    {
        if(ipv6tcam == nullptr)
        {
            ipv6tcam = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam>();
        }
        return ipv6tcam;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(ipv4tcam != nullptr)
    {
        children["ipv4tcam"] = ipv4tcam;
    }

    if(ipv6tcam != nullptr)
    {
        children["ipv6tcam"] = ipv6tcam;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "entry-id")
    {
        entry_id = value;
        entry_id.value_namespace = name_space;
        entry_id.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "entry-id")
    {
        entry_id.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "ipv4tcam" || name == "ipv6tcam" || name == "entry-id")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::Ipv4tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv4tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::~Ipv4tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv4tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::TcamEntry()
    :
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv4tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::Value()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "value"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::~Value()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "value";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "value"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Value::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::Mask()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "mask"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::~Mask()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "mask";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "mask"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Mask::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::Result()
    :
    acl_id{YType::uint16, "acl-id"},
    source_range_id{YType::uint16, "source-range-id"},
    destination_range_id{YType::uint16, "destination-range-id"},
    source_address{YType::str, "source-address"},
    protocol{YType::uint8, "protocol"},
    fragment{YType::uint16, "fragment"},
    dscp{YType::uint8, "dscp"},
    ttl{YType::uint32, "ttl"},
    layer4_source_port{YType::uint16, "layer4-source-port"},
    destination_address{YType::str, "destination-address"},
    layer4_destination_port{YType::uint16, "layer4-destination-port"},
    packet_length_range{YType::uint8, "packet-length-range"}
        ,
    tcp_flags(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>())
{
    tcp_flags->parent = this;

    yang_name = "result"; yang_parent_name = "tcam-entry"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::~Result()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::has_data() const
{
    if (is_presence_container) return true;
    return acl_id.is_set
	|| source_range_id.is_set
	|| destination_range_id.is_set
	|| source_address.is_set
	|| protocol.is_set
	|| fragment.is_set
	|| dscp.is_set
	|| ttl.is_set
	|| layer4_source_port.is_set
	|| destination_address.is_set
	|| layer4_destination_port.is_set
	|| packet_length_range.is_set
	|| (tcp_flags !=  nullptr && tcp_flags->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(acl_id.yfilter)
	|| ydk::is_set(source_range_id.yfilter)
	|| ydk::is_set(destination_range_id.yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(protocol.yfilter)
	|| ydk::is_set(fragment.yfilter)
	|| ydk::is_set(dscp.yfilter)
	|| ydk::is_set(ttl.yfilter)
	|| ydk::is_set(layer4_source_port.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(layer4_destination_port.yfilter)
	|| ydk::is_set(packet_length_range.yfilter)
	|| (tcp_flags !=  nullptr && tcp_flags->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "result";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (acl_id.is_set || is_set(acl_id.yfilter)) leaf_name_data.push_back(acl_id.get_name_leafdata());
    if (source_range_id.is_set || is_set(source_range_id.yfilter)) leaf_name_data.push_back(source_range_id.get_name_leafdata());
    if (destination_range_id.is_set || is_set(destination_range_id.yfilter)) leaf_name_data.push_back(destination_range_id.get_name_leafdata());
    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (protocol.is_set || is_set(protocol.yfilter)) leaf_name_data.push_back(protocol.get_name_leafdata());
    if (fragment.is_set || is_set(fragment.yfilter)) leaf_name_data.push_back(fragment.get_name_leafdata());
    if (dscp.is_set || is_set(dscp.yfilter)) leaf_name_data.push_back(dscp.get_name_leafdata());
    if (ttl.is_set || is_set(ttl.yfilter)) leaf_name_data.push_back(ttl.get_name_leafdata());
    if (layer4_source_port.is_set || is_set(layer4_source_port.yfilter)) leaf_name_data.push_back(layer4_source_port.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (layer4_destination_port.is_set || is_set(layer4_destination_port.yfilter)) leaf_name_data.push_back(layer4_destination_port.get_name_leafdata());
    if (packet_length_range.is_set || is_set(packet_length_range.yfilter)) leaf_name_data.push_back(packet_length_range.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcp-flags")
    {
        if(tcp_flags == nullptr)
        {
            tcp_flags = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags>();
        }
        return tcp_flags;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcp_flags != nullptr)
    {
        children["tcp-flags"] = tcp_flags;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "acl-id")
    {
        acl_id = value;
        acl_id.value_namespace = name_space;
        acl_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-range-id")
    {
        source_range_id = value;
        source_range_id.value_namespace = name_space;
        source_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id = value;
        destination_range_id.value_namespace = name_space;
        destination_range_id.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "protocol")
    {
        protocol = value;
        protocol.value_namespace = name_space;
        protocol.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "fragment")
    {
        fragment = value;
        fragment.value_namespace = name_space;
        fragment.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "dscp")
    {
        dscp = value;
        dscp.value_namespace = name_space;
        dscp.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "ttl")
    {
        ttl = value;
        ttl.value_namespace = name_space;
        ttl.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port = value;
        layer4_source_port.value_namespace = name_space;
        layer4_source_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port = value;
        layer4_destination_port.value_namespace = name_space;
        layer4_destination_port.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range = value;
        packet_length_range.value_namespace = name_space;
        packet_length_range.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "acl-id")
    {
        acl_id.yfilter = yfilter;
    }
    if(value_path == "source-range-id")
    {
        source_range_id.yfilter = yfilter;
    }
    if(value_path == "destination-range-id")
    {
        destination_range_id.yfilter = yfilter;
    }
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "protocol")
    {
        protocol.yfilter = yfilter;
    }
    if(value_path == "fragment")
    {
        fragment.yfilter = yfilter;
    }
    if(value_path == "dscp")
    {
        dscp.yfilter = yfilter;
    }
    if(value_path == "ttl")
    {
        ttl.yfilter = yfilter;
    }
    if(value_path == "layer4-source-port")
    {
        layer4_source_port.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "layer4-destination-port")
    {
        layer4_destination_port.yfilter = yfilter;
    }
    if(value_path == "packet-length-range")
    {
        packet_length_range.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcp-flags" || name == "acl-id" || name == "source-range-id" || name == "destination-range-id" || name == "source-address" || name == "protocol" || name == "fragment" || name == "dscp" || name == "ttl" || name == "layer4-source-port" || name == "destination-address" || name == "layer4-destination-port" || name == "packet-length-range")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::TcpFlags()
    :
    urgent{YType::uint8, "urgent"},
    acknowledge{YType::uint8, "acknowledge"},
    push{YType::uint8, "push"},
    reset{YType::uint8, "reset"},
    synchronization{YType::uint8, "synchronization"},
    finish{YType::uint8, "finish"}
{

    yang_name = "tcp-flags"; yang_parent_name = "result"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::~TcpFlags()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_data() const
{
    if (is_presence_container) return true;
    return urgent.is_set
	|| acknowledge.is_set
	|| push.is_set
	|| reset.is_set
	|| synchronization.is_set
	|| finish.is_set;
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(urgent.yfilter)
	|| ydk::is_set(acknowledge.yfilter)
	|| ydk::is_set(push.yfilter)
	|| ydk::is_set(reset.yfilter)
	|| ydk::is_set(synchronization.yfilter)
	|| ydk::is_set(finish.yfilter);
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcp-flags";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (urgent.is_set || is_set(urgent.yfilter)) leaf_name_data.push_back(urgent.get_name_leafdata());
    if (acknowledge.is_set || is_set(acknowledge.yfilter)) leaf_name_data.push_back(acknowledge.get_name_leafdata());
    if (push.is_set || is_set(push.yfilter)) leaf_name_data.push_back(push.get_name_leafdata());
    if (reset.is_set || is_set(reset.yfilter)) leaf_name_data.push_back(reset.get_name_leafdata());
    if (synchronization.is_set || is_set(synchronization.yfilter)) leaf_name_data.push_back(synchronization.get_name_leafdata());
    if (finish.is_set || is_set(finish.yfilter)) leaf_name_data.push_back(finish.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "urgent")
    {
        urgent = value;
        urgent.value_namespace = name_space;
        urgent.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "acknowledge")
    {
        acknowledge = value;
        acknowledge.value_namespace = name_space;
        acknowledge.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "push")
    {
        push = value;
        push.value_namespace = name_space;
        push.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "reset")
    {
        reset = value;
        reset.value_namespace = name_space;
        reset.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "synchronization")
    {
        synchronization = value;
        synchronization.value_namespace = name_space;
        synchronization.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "finish")
    {
        finish = value;
        finish.value_namespace = name_space;
        finish.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "urgent")
    {
        urgent.yfilter = yfilter;
    }
    if(value_path == "acknowledge")
    {
        acknowledge.yfilter = yfilter;
    }
    if(value_path == "push")
    {
        push.yfilter = yfilter;
    }
    if(value_path == "reset")
    {
        reset.yfilter = yfilter;
    }
    if(value_path == "synchronization")
    {
        synchronization.yfilter = yfilter;
    }
    if(value_path == "finish")
    {
        finish.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv4tcam::TcamEntry::Result::TcpFlags::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "urgent" || name == "acknowledge" || name == "push" || name == "reset" || name == "synchronization" || name == "finish")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::Ipv6tcam()
    :
    tcam_entry(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry>())
{
    tcam_entry->parent = this;

    yang_name = "ipv6tcam"; yang_parent_name = "ace-detail"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::~Ipv6tcam()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::has_data() const
{
    if (is_presence_container) return true;
    return (tcam_entry !=  nullptr && tcam_entry->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::has_operation() const
{
    return is_set(yfilter)
	|| (tcam_entry !=  nullptr && tcam_entry->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "ipv6tcam";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};


    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "tcam-entry")
    {
        if(tcam_entry == nullptr)
        {
            tcam_entry = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry>();
        }
        return tcam_entry;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(tcam_entry != nullptr)
    {
        children["tcam-entry"] = tcam_entry;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::set_filter(const std::string & value_path, YFilter yfilter)
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "tcam-entry")
        return true;
    return false;
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::TcamEntry()
    :
    source_address{YType::str, "source-address"},
    source_address_mask{YType::str, "source-address-mask"},
    destination_address{YType::str, "destination-address"},
    destination_address_mask{YType::str, "destination-address-mask"}
        ,
    value_(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value>())
    , mask(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask>())
    , result(std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result>())
{
    value_->parent = this;
    mask->parent = this;
    result->parent = this;

    yang_name = "tcam-entry"; yang_parent_name = "ipv6tcam"; is_top_level_class = false; has_list_ancestor = true; 
}

AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::~TcamEntry()
{
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::has_data() const
{
    if (is_presence_container) return true;
    return source_address.is_set
	|| source_address_mask.is_set
	|| destination_address.is_set
	|| destination_address_mask.is_set
	|| (value_ !=  nullptr && value_->has_data())
	|| (mask !=  nullptr && mask->has_data())
	|| (result !=  nullptr && result->has_data());
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::has_operation() const
{
    return is_set(yfilter)
	|| ydk::is_set(source_address.yfilter)
	|| ydk::is_set(source_address_mask.yfilter)
	|| ydk::is_set(destination_address.yfilter)
	|| ydk::is_set(destination_address_mask.yfilter)
	|| (value_ !=  nullptr && value_->has_operation())
	|| (mask !=  nullptr && mask->has_operation())
	|| (result !=  nullptr && result->has_operation());
}

std::string AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_segment_path() const
{
    std::ostringstream path_buffer;
    path_buffer << "tcam-entry";
    return path_buffer.str();
}

std::vector<std::pair<std::string, LeafData> > AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_name_leaf_data() const
{
    std::vector<std::pair<std::string, LeafData> > leaf_name_data {};

    if (source_address.is_set || is_set(source_address.yfilter)) leaf_name_data.push_back(source_address.get_name_leafdata());
    if (source_address_mask.is_set || is_set(source_address_mask.yfilter)) leaf_name_data.push_back(source_address_mask.get_name_leafdata());
    if (destination_address.is_set || is_set(destination_address.yfilter)) leaf_name_data.push_back(destination_address.get_name_leafdata());
    if (destination_address_mask.is_set || is_set(destination_address_mask.yfilter)) leaf_name_data.push_back(destination_address_mask.get_name_leafdata());

    return leaf_name_data;

}

std::shared_ptr<Entity> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_child_by_name(const std::string & child_yang_name, const std::string & segment_path)
{
    if(child_yang_name == "value")
    {
        if(value_ == nullptr)
        {
            value_ = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Value>();
        }
        return value_;
    }

    if(child_yang_name == "mask")
    {
        if(mask == nullptr)
        {
            mask = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Mask>();
        }
        return mask;
    }

    if(child_yang_name == "result")
    {
        if(result == nullptr)
        {
            result = std::make_shared<AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::Result>();
        }
        return result;
    }

    return nullptr;
}

std::map<std::string, std::shared_ptr<Entity>> AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::get_children() const
{
    std::map<std::string, std::shared_ptr<Entity>> children{};
    char count=0;
    if(value_ != nullptr)
    {
        children["value"] = value_;
    }

    if(mask != nullptr)
    {
        children["mask"] = mask;
    }

    if(result != nullptr)
    {
        children["result"] = result;
    }

    return children;
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::set_value(const std::string & value_path, const std::string & value, const std::string & name_space, const std::string & name_space_prefix)
{
    if(value_path == "source-address")
    {
        source_address = value;
        source_address.value_namespace = name_space;
        source_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask = value;
        source_address_mask.value_namespace = name_space;
        source_address_mask.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address")
    {
        destination_address = value;
        destination_address.value_namespace = name_space;
        destination_address.value_namespace_prefix = name_space_prefix;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask = value;
        destination_address_mask.value_namespace = name_space;
        destination_address_mask.value_namespace_prefix = name_space_prefix;
    }
}

void AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::set_filter(const std::string & value_path, YFilter yfilter)
{
    if(value_path == "source-address")
    {
        source_address.yfilter = yfilter;
    }
    if(value_path == "source-address-mask")
    {
        source_address_mask.yfilter = yfilter;
    }
    if(value_path == "destination-address")
    {
        destination_address.yfilter = yfilter;
    }
    if(value_path == "destination-address-mask")
    {
        destination_address_mask.yfilter = yfilter;
    }
}

bool AccessListHardware::Nodes::Node::Egress::Ipv6::Accesses::Access::Implicit::ImplicitAcl::InterfaceAclImplicit::ImplicitDeny::AceDetail::Ipv6tcam::TcamEntry::has_leaf_or_child_of_name(const std::string & name) const
{
    if(name == "value" || name == "mask" || name == "result" || name == "source-address" || name == "source-address-mask" || name == "destination-address" || name == "destination-address-mask")
        return true;
    return false;
}


}
}

