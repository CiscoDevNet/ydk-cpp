#ifndef _CISCO_IOS_XR_IPV4_PIM_OPER_
#define _CISCO_IOS_XR_IPV4_PIM_OPER_

#include <memory>
#include <vector>
#include <string>
#include "ydk/types.hpp"
#include "ydk/errors.hpp"

namespace ydk {
namespace Cisco_IOS_XR_ipv4_pim_oper {

class PimMa : public Entity
{
    public:
        PimMa();
        ~PimMa();

        bool has_data() const override;
        bool has_operation() const override;
        EntityPath get_entity_path(Entity* parent) const override;
        std::string get_segment_path() const override;
        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
        void set_value(const std::string & value_path, std::string value) override;
        std::map<std::string, Entity*> & get_children() override;
        std::unique_ptr<Entity> clone_ptr() override;



    class Active : public Entity
    {
        public:
            Active();
            ~Active();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class InterfaceTable : public Entity
        {
            public:
                InterfaceTable();
                ~InterfaceTable();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class InterfaceByHandles : public Entity
            {
                public:
                    InterfaceByHandles();
                    ~InterfaceByHandles();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByHandle : public Entity
                {
                    public:
                        InterfaceByHandle();
                        ~InterfaceByHandle();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_handle; //type: int32
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress> source_address;


                }; // PimMa::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle> > interface_by_handle;


            }; // PimMa::Active::InterfaceTable::InterfaceByHandles


            class InterfaceByNames : public Entity
            {
                public:
                    InterfaceByNames();
                    ~InterfaceByNames();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByName : public Entity
                {
                    public:
                        InterfaceByName();
                        ~InterfaceByName();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Active::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Active::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress> source_address;


                }; // PimMa::Active::InterfaceTable::InterfaceByNames::InterfaceByName


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByNames::InterfaceByName> > interface_by_name;


            }; // PimMa::Active::InterfaceTable::InterfaceByNames


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByHandles> interface_by_handles;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable::InterfaceByNames> interface_by_names;


        }; // PimMa::Active::InterfaceTable


        class PimMaSummary : public Entity
        {
            public:
                PimMaSummary();
                ~PimMaSummary();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;


                YLeaf is_im_connection_open; //type: boolean
                YLeaf is_netio_connection_open; //type: boolean
                YLeaf is_edm_connection_open; //type: boolean
                YLeaf is_standby_edm_connection_open; //type: boolean
                YLeaf encap_interface_count; //type: uint32
                YLeaf decap_interface_count; //type: uint32
                YLeaf mdt_interface_count; //type: uint32



        }; // PimMa::Active::PimMaSummary


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::InterfaceTable> interface_table;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active::PimMaSummary> pim_ma_summary;


    }; // PimMa::Active


    class Standby : public Entity
    {
        public:
            Standby();
            ~Standby();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class InterfaceTable : public Entity
        {
            public:
                InterfaceTable();
                ~InterfaceTable();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class InterfaceByHandles : public Entity
            {
                public:
                    InterfaceByHandles();
                    ~InterfaceByHandles();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByHandle : public Entity
                {
                    public:
                        InterfaceByHandle();
                        ~InterfaceByHandle();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_handle; //type: int32
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress> source_address;


                }; // PimMa::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle> > interface_by_handle;


            }; // PimMa::Standby::InterfaceTable::InterfaceByHandles


            class InterfaceByNames : public Entity
            {
                public:
                    InterfaceByNames();
                    ~InterfaceByNames();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByName : public Entity
                {
                    public:
                        InterfaceByName();
                        ~InterfaceByName();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // PimMa::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress> source_address;


                }; // PimMa::Standby::InterfaceTable::InterfaceByNames::InterfaceByName


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByNames::InterfaceByName> > interface_by_name;


            }; // PimMa::Standby::InterfaceTable::InterfaceByNames


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByHandles> interface_by_handles;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable::InterfaceByNames> interface_by_names;


        }; // PimMa::Standby::InterfaceTable


        class PimMaSummary : public Entity
        {
            public:
                PimMaSummary();
                ~PimMaSummary();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;


                YLeaf is_im_connection_open; //type: boolean
                YLeaf is_netio_connection_open; //type: boolean
                YLeaf is_edm_connection_open; //type: boolean
                YLeaf is_standby_edm_connection_open; //type: boolean
                YLeaf encap_interface_count; //type: uint32
                YLeaf decap_interface_count; //type: uint32
                YLeaf mdt_interface_count; //type: uint32



        }; // PimMa::Standby::PimMaSummary


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::InterfaceTable> interface_table;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby::PimMaSummary> pim_ma_summary;


    }; // PimMa::Standby


        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Active> active;
        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::PimMa::Standby> standby;


}; // PimMa

class Pim : public Entity
{
    public:
        Pim();
        ~Pim();

        bool has_data() const override;
        bool has_operation() const override;
        EntityPath get_entity_path(Entity* parent) const override;
        std::string get_segment_path() const override;
        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
        void set_value(const std::string & value_path, std::string value) override;
        std::map<std::string, Entity*> & get_children() override;
        std::unique_ptr<Entity> clone_ptr() override;



    class Standby : public Entity
    {
        public:
            Standby();
            ~Standby();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                }; // Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Pim::Standby::DefaultContext::IfrsInterfaces


            class Safs : public Entity
            {
                public:
                    Safs();
                    ~Safs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Saf : public Entity
                {
                    public:
                        Saf();
                        ~Saf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string

                    class RpfHashSourceGroups : public Entity
                    {
                        public:
                            RpfHashSourceGroups();
                            ~RpfHashSourceGroups();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSourceGroup : public Entity
                        {
                            public:
                                RpfHashSourceGroup();
                                ~RpfHashSourceGroup();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf mask_length; //type: int32
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                    }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups


                    class RpfNeighbors : public Entity
                    {
                        public:
                            RpfNeighbors();
                            ~RpfNeighbors();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf neighbor_address; //type: string
                                YLeaf rib_neighbor_interface; //type: string

                            class RibNeighborAddress : public Entity
                            {
                                public:
                                    RibNeighborAddress();
                                    ~RibNeighborAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                            class RpfRegisteredAddresses : public Entity
                            {
                                public:
                                    RpfRegisteredAddresses();
                                    ~RpfRegisteredAddresses();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_registered_address_references; //type: uint32

                                class RibRegistrationAddress : public Entity
                                {
                                    public:
                                        RibRegistrationAddress();
                                        ~RibRegistrationAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                            }; // Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                        }; // Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                    }; // Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors


                    class RpfHashSources : public Entity
                    {
                        public:
                            RpfHashSources();
                            ~RpfHashSources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSource : public Entity
                        {
                            public:
                                RpfHashSource();
                                ~RpfHashSource();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                    }; // Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources


                    class Rpfs : public Entity
                    {
                        public:
                            Rpfs();
                            ~Rpfs();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class Rpf : public Entity
                        {
                            public:
                                Rpf();
                                ~Rpf();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf registered_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8
                                YLeaf is_rpf_bgp_route; //type: boolean

                            class RegisteredAddressXr : public Entity
                            {
                                public:
                                    RegisteredAddressXr();
                                    ~RegisteredAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                            class RpfPath : public Entity
                            {
                                public:
                                    RpfPath();
                                    ~RpfPath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_interface_name; //type: string
                                    YLeaf is_rpf_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_via_mlsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf connector; //type: string
                                    YLeaf extranet_vrf_name; //type: string

                                class RpfNeighbor : public Entity
                                {
                                    public:
                                        RpfNeighbor();
                                        ~RpfNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                class RpfNexthop : public Entity
                                {
                                    public:
                                        RpfNexthop();
                                        ~RpfNexthop();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                            }; // Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                        }; // Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf> > rpf;


                    }; // Pim::Standby::DefaultContext::Safs::Saf::Rpfs


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources> rpf_hash_sources;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors> rpf_neighbors;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf::Rpfs> rpfs;


                }; // Pim::Standby::DefaultContext::Safs::Saf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs::Saf> > saf;


            }; // Pim::Standby::DefaultContext::Safs


            class InterfaceStatistics : public Entity
            {
                public:
                    InterfaceStatistics();
                    ~InterfaceStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStatistic : public Entity
                {
                    public:
                        InterfaceStatistic();
                        ~InterfaceStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_register; //type: uint32
                        YLeaf output_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf input_graft_message; //type: uint32
                        YLeaf output_graft_message; //type: uint32
                        YLeaf input_graft_ack_message; //type: uint32
                        YLeaf output_graft_ack_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_miscellaneous; //type: uint32



                }; // Pim::Standby::DefaultContext::InterfaceStatistics::InterfaceStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


            }; // Pim::Standby::DefaultContext::InterfaceStatistics


            class TopologyRouteCount : public Entity
            {
                public:
                    TopologyRouteCount();
                    ~TopologyRouteCount();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf group_ranges; //type: uint32
                    YLeaf active_group_ranges; //type: uint32
                    YLeaf groute_count; //type: uint32
                    YLeaf sg_route_count; //type: uint32
                    YLeaf sgr_route_count; //type: uint32
                    YLeaf is_node_low_memory; //type: boolean

                class GroupAddress : public Entity
                {
                    public:
                        GroupAddress();
                        ~GroupAddress();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Pim::Standby::DefaultContext::TopologyRouteCount::GroupAddress


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyRouteCount::GroupAddress> group_address;


            }; // Pim::Standby::DefaultContext::TopologyRouteCount


            class JpStatistics : public Entity
            {
                public:
                    JpStatistics();
                    ~JpStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JpStatistic : public Entity
                {
                    public:
                        JpStatistic();
                        ~JpStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf mtu; //type: uint32
                        YLeaf transmitted; //type: uint32
                        YLeaf transmitted100; //type: uint16
                        YLeaf transmitted_1k; //type: uint16
                        YLeaf transmitted_10k; //type: uint16
                        YLeaf transmitted_50k; //type: uint16
                        YLeaf received; //type: uint32
                        YLeaf received100; //type: uint16
                        YLeaf received_1k; //type: uint16
                        YLeaf received_10k; //type: uint16
                        YLeaf received_50k; //type: uint16



                }; // Pim::Standby::DefaultContext::JpStatistics::JpStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::JpStatistics::JpStatistic> > jp_statistic;


            }; // Pim::Standby::DefaultContext::JpStatistics


            class MibDatabases : public Entity
            {
                public:
                    MibDatabases();
                    ~MibDatabases();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MibDatabase : public Entity
                {
                    public:
                        MibDatabase();
                        ~MibDatabase();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf source_netmask; //type: int32
                        YLeaf upstream_assert_timer; //type: int32
                        YLeaf assert_metric; //type: uint32
                        YLeaf assert_metric_preference; //type: uint32
                        YLeaf assert_rpt_bit; //type: boolean
                        YLeaf spt_bit; //type: boolean
                        YLeaf rpf_mask; //type: uint32
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf bidirectional_route; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf protocol; //type: PimShowProtocolEnum

                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr


                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfRoot


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                }; // Pim::Standby::DefaultContext::MibDatabases::MibDatabase


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MibDatabases::MibDatabase> > mib_database;


            }; // Pim::Standby::DefaultContext::MibDatabases


            class GroupMapMatchRpfs : public Entity
            {
                public:
                    GroupMapMatchRpfs();
                    ~GroupMapMatchRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchRpf : public Entity
                {
                    public:
                        GroupMapMatchRpf();
                        ~GroupMapMatchRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                }; // Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


            }; // Pim::Standby::DefaultContext::GroupMapMatchRpfs


            class NeighborOldFormats : public Entity
            {
                public:
                    NeighborOldFormats();
                    ~NeighborOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborOldFormat : public Entity
                {
                    public:
                        NeighborOldFormat();
                        ~NeighborOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                }; // Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


            }; // Pim::Standby::DefaultContext::NeighborOldFormats


            class IfrsSummary : public Entity
            {
                public:
                    IfrsSummary();
                    ~IfrsSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Pim::Standby::DefaultContext::IfrsSummary


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf client_xr; //type: PimShowRangeClientEnum
                        YLeaf expires; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Ranges::Range::RpAddressXr


                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Ranges::Range::SourceOfInformation


                    class GroupRange : public Entity
                    {
                        public:
                            GroupRange();
                            ~GroupRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Ranges::Range::GroupRange::Prefix


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges::Range::GroupRange::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                    }; // Pim::Standby::DefaultContext::Ranges::Range::GroupRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges::Range::GroupRange> > group_range;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges::Range::RpAddressXr> rp_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges::Range::SourceOfInformation> source_of_information;


                }; // Pim::Standby::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges::Range> > range;


            }; // Pim::Standby::DefaultContext::Ranges


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                }; // Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Pim::Standby::DefaultContext::InterfaceOldFormats


            class Bsr : public Entity
            {
                public:
                    Bsr();
                    ~Bsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RpCaches : public Entity
                {
                    public:
                        RpCaches();
                        ~RpCaches();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCache : public Entity
                    {
                        public:
                            RpCache();
                            ~RpCache();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_prefix; //type: string
                            YLeaf group_prefix_length; //type: uint32
                            YLeaf candidate_rp_group_count; //type: uint32

                        class GroupPrefixXr : public Entity
                        {
                            public:
                                GroupPrefixXr();
                                ~GroupPrefixXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr


                        class CandidateRpList : public Entity
                        {
                            public:
                                CandidateRpList();
                                ~CandidateRpList();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class PimBsrCrpBag : public Entity
                            {
                                public:
                                    PimBsrCrpBag();
                                    ~PimBsrCrpBag();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_holdtime; //type: uint16
                                    YLeaf candidate_rp_priority; //type: uint8
                                    YLeaf candidate_rp_up_time; //type: uint16
                                    YLeaf candidate_rp_expires; //type: uint16
                                    YLeaf protocol; //type: PimShowProtocolEnum

                                class CandidateRpAddress : public Entity
                                {
                                    public:
                                        CandidateRpAddress();
                                        ~CandidateRpAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                            }; // Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                        }; // Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                    }; // Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache> > rp_cache;


                }; // Pim::Standby::DefaultContext::Bsr::RpCaches


                class CandidateRps : public Entity
                {
                    public:
                        CandidateRps();
                        ~CandidateRps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class CandidateRp : public Entity
                    {
                        public:
                            CandidateRp();
                            ~CandidateRp();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                            YLeaf candidate_rp_scope; //type: int32
                            YLeaf crp_priority; //type: uint8
                            YLeaf crp_holdtime; //type: uint16
                            YLeaf candidate_rp_advance_interval; //type: uint16
                            YLeaf candidate_rp_uptime; //type: uint16
                            YLeaf acl_name; //type: string

                        class CandidateRp_ : public Entity
                        {
                            public:
                                CandidateRp_();
                                ~CandidateRp_();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_


                        class CrpAccess : public Entity
                        {
                            public:
                                CrpAccess();
                                ~CrpAccess();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf acl_name; //type: string



                        }; // Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                    }; // Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                }; // Pim::Standby::DefaultContext::Bsr::CandidateRps


                class BsrElections : public Entity
                {
                    public:
                        BsrElections();
                        ~BsrElections();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BsrElection : public Entity
                    {
                        public:
                            BsrElection();
                            ~BsrElection();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf pim_scope; //type: int32
                            YLeaf bsr_priority; //type: uint8
                            YLeaf bsr_mask_length; //type: uint8
                            YLeaf bsr_up_time; //type: uint16
                            YLeaf bootstrap_timeout; //type: uint16
                            YLeaf candidate_bsr_state; //type: uint32
                            YLeaf bsr_election_state; //type: uint32
                            YLeaf bsr_scope; //type: uint16
                            YLeaf candidate_bsr_flag; //type: boolean
                            YLeaf candidate_bsr_priority; //type: uint8
                            YLeaf candidate_bsr_mask_length; //type: uint8

                        class BsrAddress : public Entity
                        {
                            public:
                                BsrAddress();
                                ~BsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress


                        class CandidateBsrAddress : public Entity
                        {
                            public:
                                CandidateBsrAddress();
                                ~CandidateBsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                    }; // Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection> > bsr_election;


                }; // Pim::Standby::DefaultContext::Bsr::BsrElections


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::BsrElections> bsr_elections;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::CandidateRps> candidate_rps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr::RpCaches> rp_caches;


            }; // Pim::Standby::DefaultContext::Bsr


            class RoutePolicy : public Entity
            {
                public:
                    RoutePolicy();
                    ~RoutePolicy();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RoutePolicyStatistics : public Entity
                {
                    public:
                        RoutePolicyStatistics();
                        ~RoutePolicyStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf policy_name; //type: string
                        YLeaf requests; //type: uint32
                        YLeaf pass; //type: uint32
                        YLeaf drop; //type: uint32
                        YLeaf default_table; //type: uint32
                        YLeaf any_table; //type: uint32



                }; // Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyStatistics


                class RoutePolicyTests : public Entity
                {
                    public:
                        RoutePolicyTests();
                        ~RoutePolicyTests();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyTest : public Entity
                    {
                        public:
                            RoutePolicyTest();
                            ~RoutePolicyTest();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf ext_comm; //type: string
                            YLeaf policy_name; //type: string
                            YLeaf extended_community_rt; //type: string
                            YLeaf pass; //type: boolean
                            YLeaf default_table; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf table_exists; //type: boolean
                            YLeaf table_active; //type: boolean

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                    }; // Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                }; // Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests> route_policy_tests;


            }; // Pim::Standby::DefaultContext::RoutePolicy


            class RpfSummary : public Entity
            {
                public:
                    RpfSummary();
                    ~RpfSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf default_safi; //type: uint32
                    YLeaf default_table_name; //type: string
                    YLeaf is_mbgp_configured; //type: boolean
                    YLeaf is_ospf_te_configured; //type: boolean
                    YLeaf is_isis_te_configured; //type: boolean
                    YLeaf is_isis_mtr_configured; //type: boolean
                    YLeaf mo_frr_configured; //type: boolean
                    YLeaf rib_mo_frr_configured; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf rib_convergence_timeout; //type: uint32
                    YLeaf rib_convergence_time_left; //type: uint32
                    YLeaf is_multipath_enabled; //type: boolean
                    YLeaf is_multipath_interface_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                    YLeaf rpf_registrations; //type: uint32
                    YLeaf is_rib_convergence; //type: boolean



            }; // Pim::Standby::DefaultContext::RpfSummary


            class Interfaces : public Entity
            {
                public:
                    Interfaces();
                    ~Interfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Interfaces::Interface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Interfaces::Interface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Interfaces::Interface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Interfaces::Interface::InterfaceAddress> > interface_address;


                }; // Pim::Standby::DefaultContext::Interfaces::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Interfaces::Interface> > interface;


            }; // Pim::Standby::DefaultContext::Interfaces


            class NetIoTunnels : public Entity
            {
                public:
                    NetIoTunnels();
                    ~NetIoTunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NetIoTunnel : public Entity
                {
                    public:
                        NetIoTunnel();
                        ~NetIoTunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                }; // Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


            }; // Pim::Standby::DefaultContext::NetIoTunnels


            class BidirDfStates : public Entity
            {
                public:
                    BidirDfStates();
                    ~BidirDfStates();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfState : public Entity
                {
                    public:
                        BidirDfState();
                        ~BidirDfState();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf election_state; //type: string
                        YLeaf time_seconds; //type: uint64
                        YLeaf time_nano_seconds; //type: uint64
                        YLeaf our_metric; //type: uint32
                        YLeaf our_metric_preference; //type: uint32

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                }; // Pim::Standby::DefaultContext::BidirDfStates::BidirDfState


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfStates::BidirDfState> > bidir_df_state;


            }; // Pim::Standby::DefaultContext::BidirDfStates


            class Topologies : public Entity
            {
                public:
                    Topologies();
                    ~Topologies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Topology : public Entity
                {
                    public:
                        Topology();
                        ~Topology();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf rpt; //type: int32
                        YLeaf limit_reached; //type: boolean
                        YLeaf low_memory; //type: boolean
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf wildcard; //type: boolean
                        YLeaf rpt_xr; //type: boolean
                        YLeaf spt; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf expiry; //type: uint64
                        YLeaf alive; //type: int32
                        YLeaf register_received_timer; //type: int32
                        YLeaf remote_source; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf is_via_lsm; //type: boolean
                        YLeaf secondary_rpf_interface_name; //type: string
                        YLeaf connected; //type: boolean
                        YLeaf proxy; //type: boolean
                        YLeaf rpf_proxy_enabled; //type: boolean
                        YLeaf mofrr_enabled; //type: boolean
                        YLeaf rib_mo_frr_enabled; //type: boolean
                        YLeaf jp_timer; //type: int32
                        YLeaf jp_status; //type: int32
                        YLeaf suppress_registers; //type: int32
                        YLeaf assume_alive; //type: boolean
                        YLeaf probe_alive; //type: boolean
                        YLeaf really_alive; //type: boolean
                        YLeaf inherit_alive; //type: boolean
                        YLeaf inherit_spt; //type: boolean
                        YLeaf signal_sources; //type: boolean
                        YLeaf dont_check_connected; //type: boolean
                        YLeaf register_received; //type: boolean
                        YLeaf last_hop; //type: boolean
                        YLeaf sending_registers; //type: boolean
                        YLeaf sending_null_registers; //type: boolean
                        YLeaf sa_sent; //type: boolean
                        YLeaf sa_received; //type: boolean
                        YLeaf sa_joined; //type: boolean
                        YLeaf anycast_rp_match; //type: boolean
                        YLeaf anycast_rp_route_target; //type: string
                        YLeaf bgp_join; //type: boolean
                        YLeaf bgpjp_time; //type: uint64
                        YLeaf customer_routing_type; //type: int32
                        YLeaf extranet_route; //type: boolean
                        YLeaf mofrr_active; //type: boolean
                        YLeaf mofrr_primary; //type: boolean
                        YLeaf mofrr_backup; //type: boolean
                        YLeaf vxlan; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::GroupAddressXr


                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::SourceAddressXr


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::RpAddress


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::RpfNeighbor


                    class SecondaryRpfNeighbor : public Entity
                    {
                        public:
                            SecondaryRpfNeighbor();
                            ~SecondaryRpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::RpfRoot


                    class ProxyAddress : public Entity
                    {
                        public:
                            ProxyAddress();
                            ~ProxyAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::ProxyAddress


                    class OrigSrcAddress : public Entity
                    {
                        public:
                            OrigSrcAddress();
                            ~OrigSrcAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Topologies::Topology::OrigSrcAddress


                    class OutgoingInterface : public Entity
                    {
                        public:
                            OutgoingInterface();
                            ~OutgoingInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_state; //type: int32
                            YLeaf assert_timer; //type: int32
                            YLeaf local_members; //type: int32
                            YLeaf internal_interest_info; //type: int32
                            YLeaf forwarding_state; //type: int32
                            YLeaf immediate_state; //type: int32
                            YLeaf last_hop; //type: boolean
                            YLeaf mldp_inband_mdt; //type: boolean
                            YLeaf mldp_stale; //type: boolean
                            YLeaf sa_prune; //type: boolean
                            YLeaf admin_boundary; //type: boolean
                            YLeaf igmp_membership; //type: boolean
                            YLeaf mdt_safi_join; //type: boolean
                            YLeaf mvpn_safi_join; //type: boolean
                            YLeaf local_mdt_join; //type: boolean
                            YLeaf data_mdt_join; //type: boolean
                            YLeaf mvp_nv6_safi_join; //type: boolean
                            YLeaf bgp_c_mcast_join; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf extranet_interface; //type: boolean

                        class AssertWinner : public Entity
                        {
                            public:
                                AssertWinner();
                                ~AssertWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                    }; // Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::OrigSrcAddress> orig_src_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::ProxyAddress> proxy_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology::SourceAddressXr> source_address_xr;


                }; // Pim::Standby::DefaultContext::Topologies::Topology


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies::Topology> > topology;


            }; // Pim::Standby::DefaultContext::Topologies


            class BgpAfs : public Entity
            {
                public:
                    BgpAfs();
                    ~BgpAfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BgpAf : public Entity
                {
                    public:
                        BgpAf();
                        ~BgpAf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf route_distinguisher; //type: string
                        YLeaf extranet_path_count; //type: uint32
                        YLeaf is_bgp_added; //type: boolean

                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::BgpAfs::BgpAf::Source


                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::BgpAfs::BgpAf::Group


                    class NextHop : public Entity
                    {
                        public:
                            NextHop();
                            ~NextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::BgpAfs::BgpAf::NextHop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BgpAfs::BgpAf::Group> group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BgpAfs::BgpAf::NextHop> next_hop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BgpAfs::BgpAf::Source> source;


                }; // Pim::Standby::DefaultContext::BgpAfs::BgpAf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BgpAfs::BgpAf> > bgp_af;


            }; // Pim::Standby::DefaultContext::BgpAfs


            class AutoRp : public Entity
            {
                public:
                    AutoRp();
                    ~AutoRp();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;





            }; // Pim::Standby::DefaultContext::AutoRp


            class TopologyInterfaceFlagRouteCounts : public Entity
            {
                public:
                    TopologyInterfaceFlagRouteCounts();
                    ~TopologyInterfaceFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyInterfaceFlagRouteCount : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCount();
                        ~TopologyInterfaceFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                }; // Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


            }; // Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts


            class GroupMapSources : public Entity
            {
                public:
                    GroupMapSources();
                    ~GroupMapSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapSource : public Entity
                {
                    public:
                        GroupMapSource();
                        ~GroupMapSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf priority; //type: int32
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                }; // Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource> > group_map_source;


            }; // Pim::Standby::DefaultContext::GroupMapSources


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf inputs; //type: uint32
                    YLeaf outputs; //type: uint32
                    YLeaf format_error; //type: uint32
                    YLeaf pakman_error; //type: uint32
                    YLeaf standby_packets_error; //type: uint32
                    YLeaf checksum_error; //type: uint32
                    YLeaf socket_error; //type: uint32
                    YLeaf send_queue_full; //type: uint32
                    YLeaf boundary_acl_rx_drop; //type: uint32
                    YLeaf boundary_acl_tx_drop; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf no_source_address; //type: uint32
                    YLeaf input_hello; //type: uint32
                    YLeaf output_hello; //type: uint32
                    YLeaf input_jp; //type: uint32
                    YLeaf output_jp; //type: uint32
                    YLeaf input_data_register; //type: uint32
                    YLeaf input_null_register; //type: uint32
                    YLeaf output_data_register; //type: uint32
                    YLeaf output_null_register; //type: uint32
                    YLeaf input_register_stop; //type: uint32
                    YLeaf output_register_stop; //type: uint32
                    YLeaf input_assert; //type: uint32
                    YLeaf input_assert_batched; //type: uint32
                    YLeaf output_assert; //type: uint32
                    YLeaf output_assert_batched; //type: uint32
                    YLeaf input_df_election; //type: uint32
                    YLeaf output_df_election; //type: uint32
                    YLeaf input_bsr_message; //type: uint32
                    YLeaf output_bsr_message; //type: uint32
                    YLeaf input_candidate_rp_advertisement; //type: uint32
                    YLeaf output_candidate_rp_advertisement; //type: uint32
                    YLeaf input_ecmp_redirect; //type: uint32
                    YLeaf output_ecmp_redirect; //type: uint32
                    YLeaf output_loop_error; //type: uint32
                    YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                    YLeaf input_no_idb_error; //type: uint32
                    YLeaf input_no_vrf_error; //type: uint32
                    YLeaf input_no_pim_error; //type: uint32
                    YLeaf input_pim_version_error; //type: uint32
                    YLeaf output_join_group; //type: uint32
                    YLeaf output_prune_group; //type: uint32
                    YLeaf output_join_prune_bytes; //type: uint32
                    YLeaf output_hello_bytes; //type: uint32
                    YLeaf non_supported_packets; //type: uint32
                    YLeaf invalid_registers; //type: uint32
                    YLeaf invalid_join_prunes; //type: uint32
                    YLeaf packet_packman_error; //type: uint32
                    YLeaf packet_read_socket_error; //type: uint32
                    YLeaf packet_queue_last_clear; //type: uint32
                    YLeaf packets_standby; //type: uint32
                    YLeaf no_mdt_socket_connection; //type: uint32
                    YLeaf mdt_send_queue_full; //type: uint32
                    YLeaf mdt_socket_error; //type: uint32
                    YLeaf mdt_join_tlv_sent; //type: uint32
                    YLeaf mdt_join_tlv_received; //type: uint32
                    YLeaf mdt_join_bad_type; //type: uint32
                    YLeaf mdt_drop_local_source_address; //type: uint32
                    YLeaf mdt_drop_null_local_address; //type: uint32
                    YLeaf mdt_drop_no_idb; //type: uint32
                    YLeaf mdt_drop_no_vrf; //type: uint32
                    YLeaf invalid_destination_packets; //type: uint32
                    YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                    YLeaf truncated_pim_packets; //type: uint32
                    YLeafList packet_enqueued; //type: list of  uint32
                    YLeafList packet_dequeued; //type: list of  uint32
                    YLeafList packet_queue_length; //type: list of  uint32
                    YLeafList packet_queue_size; //type: list of  uint32
                    YLeafList packet_tail_drop; //type: list of  uint32

                class PacketQueue : public Entity
                {
                    public:
                        PacketQueue();
                        ~PacketQueue();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf packet_queue_priority; //type: uint32

                    class PacketQueueState : public Entity
                    {
                        public:
                            PacketQueueState();
                            ~PacketQueueState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf max_queue_size; //type: uint32
                            YLeaf queue_size_bytes; //type: uint32
                            YLeaf queue_size_packets; //type: uint32



                    }; // Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState


                    class PacketQueueStats : public Entity
                    {
                        public:
                            PacketQueueStats();
                            ~PacketQueueStats();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf enqueued_packets; //type: uint32
                            YLeaf dequeued_packets; //type: uint32
                            YLeaf high_water_mark_packets; //type: uint32
                            YLeaf high_water_mark_bytes; //type: uint32
                            YLeaf tail_drops; //type: uint32



                    }; // Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                }; // Pim::Standby::DefaultContext::TrafficCounters::PacketQueue


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TrafficCounters::PacketQueue> > packet_queue;


            }; // Pim::Standby::DefaultContext::TrafficCounters


            class GroupMapRpfs : public Entity
            {
                public:
                    GroupMapRpfs();
                    ~GroupMapRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapRpf : public Entity
                {
                    public:
                        GroupMapRpf();
                        ~GroupMapRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf rp_priority; //type: int32
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                }; // Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


            }; // Pim::Standby::DefaultContext::GroupMapRpfs


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Pim::Standby::DefaultContext::Summary


            class Gre : public Entity
            {
                public:
                    Gre();
                    ~Gre();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GreHashes : public Entity
                {
                    public:
                        GreHashes();
                        ~GreHashes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHash : public Entity
                    {
                        public:
                            GreHash();
                            ~GreHash();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf destination_address; //type: string
                            YLeaf ifname; //type: string
                            YLeaf next_hop_interface; //type: string



                    }; // Pim::Standby::DefaultContext::Gre::GreHashes::GreHash


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreHashes::GreHash> > gre_hash;


                }; // Pim::Standby::DefaultContext::Gre::GreHashes


                class GreNextHops : public Entity
                {
                    public:
                        GreNextHops();
                        ~GreNextHops();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreNextHop : public Entity
                    {
                        public:
                            GreNextHop();
                            ~GreNextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf destination_address; //type: string
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf is_connected; //type: uint8

                        class RegisteredAddress : public Entity
                        {
                            public:
                                RegisteredAddress();
                                ~RegisteredAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress


                        class GrePath : public Entity
                        {
                            public:
                                GrePath();
                                ~GrePath();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf gre_interface_name; //type: string
                                YLeaf is_gre_interface_disabled; //type: boolean
                                YLeaf is_via_lsm; //type: boolean
                                YLeaf is_connector_attribute_present; //type: boolean
                                YLeaf extranet_vrf_name; //type: string

                            class GreNeighbor : public Entity
                            {
                                public:
                                    GreNeighbor();
                                    ~GreNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                            class GreNextHop_ : public Entity
                            {
                                public:
                                    GreNextHop_();
                                    ~GreNextHop_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                        }; // Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                    }; // Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                }; // Pim::Standby::DefaultContext::Gre::GreNextHops


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreHashes> gre_hashes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre::GreNextHops> gre_next_hops;


            }; // Pim::Standby::DefaultContext::Gre


            class BidirDfWinners : public Entity
            {
                public:
                    BidirDfWinners();
                    ~BidirDfWinners();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfWinner : public Entity
                {
                    public:
                        BidirDfWinner();
                        ~BidirDfWinner();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf are_we_df; //type: boolean
                        YLeaf rp_lan; //type: boolean
                        YLeaf metric; //type: uint32
                        YLeaf metric_preference; //type: uint32
                        YLeaf uptime; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr


                    class DfWinner : public Entity
                    {
                        public:
                            DfWinner();
                            ~DfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                }; // Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


            }; // Pim::Standby::DefaultContext::BidirDfWinners


            class TableContexts : public Entity
            {
                public:
                    TableContexts();
                    ~TableContexts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TableContext : public Entity
                {
                    public:
                        TableContext();
                        ~TableContext();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string
                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Pim::Standby::DefaultContext::TableContexts::TableContext


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TableContexts::TableContext> > table_context;


            }; // Pim::Standby::DefaultContext::TableContexts


            class GlobalInterfaces : public Entity
            {
                public:
                    GlobalInterfaces();
                    ~GlobalInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GlobalInterface : public Entity
                {
                    public:
                        GlobalInterface();
                        ~GlobalInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                }; // Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface> > global_interface;


            }; // Pim::Standby::DefaultContext::GlobalInterfaces


            class NeighborSummaries : public Entity
            {
                public:
                    NeighborSummaries();
                    ~NeighborSummaries();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborSummary : public Entity
                {
                    public:
                        NeighborSummary();
                        ~NeighborSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf number_of_neighbors; //type: int32
                        YLeaf number_of_external_neighbors; //type: int32



                }; // Pim::Standby::DefaultContext::NeighborSummaries::NeighborSummary


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NeighborSummaries::NeighborSummary> > neighbor_summary;


            }; // Pim::Standby::DefaultContext::NeighborSummaries


            class Context : public Entity
            {
                public:
                    Context();
                    ~Context();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_id; //type: uint32
                    YLeaf table_id; //type: uint32
                    YLeaf murib_id; //type: uint32
                    YLeaf rpf_id; //type: uint32
                    YLeaf remote_table_id; //type: uint32
                    YLeaf mdt_default_group; //type: string
                    YLeaf mdt_interface; //type: string
                    YLeaf mdt_gre_rpf_identifier; //type: uint32
                    YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                    YLeaf is_unicast_rib_registration; //type: boolean
                    YLeaf is_multicast_rib_registration; //type: boolean
                    YLeaf is_active; //type: boolean
                    YLeaf is_active_ital; //type: boolean
                    YLeaf is_mrib_register; //type: boolean
                    YLeaf is_mdt_owner; //type: boolean
                    YLeaf is_routing_enabled; //type: boolean
                    YLeaf is_socket_add_required; //type: boolean
                    YLeaf is_socket_added; //type: boolean
                    YLeaf is_lpts_socket_add_required; //type: boolean
                    YLeaf is_lpts_socket_added; //type: boolean
                    YLeaf is_udp_socket_add_required; //type: boolean
                    YLeaf is_udp_socket_added; //type: boolean
                    YLeaf is_udp_socket_bind_required; //type: boolean
                    YLeaf is_udp_socket_bind; //type: boolean
                    YLeaf is_register_injection_socket_add_required; //type: boolean
                    YLeaf is_register_injection_socket_added; //type: boolean
                    YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                    YLeaf is_register_injection_lpts_socket_added; //type: boolean
                    YLeaf is_m_host_publish_pending; //type: boolean
                    YLeaf mhost_interface; //type: string
                    YLeaf mhost_default_interface_config; //type: string
                    YLeaf mdt_mtu; //type: uint32
                    YLeaf maximum_mdt_aggregation; //type: uint32
                    YLeaf mdt_data_switchover_interval; //type: uint32
                    YLeaf mdt_data_announce_interval; //type: uint32
                    YLeaf non_default_vrf_count_on_socket; //type: uint32
                    YLeaf neighbor_filter_name; //type: string
                    YLeaf mdt_neighbor_filter_name; //type: string
                    YLeaf allow_rp_configured; //type: boolean
                    YLeaf allow_rp_group_list; //type: string
                    YLeaf allow_rp_rp_list; //type: string
                    YLeaf sg_expiry_timer_configured; //type: boolean
                    YLeaf sg_expiry_time; //type: uint16
                    YLeaf sg_expiry_timer_sg_list; //type: string
                    YLeaf mldp_mdt_name; //type: string
                    YLeaf mldp_mdt_interface; //type: string
                    YLeaf mldp_mdt_mtu; //type: uint32
                    YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                    YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                    YLeaf mldp_mdt_data_announce_interval; //type: uint32
                    YLeaf mldp_mdt_rpf_identifier; //type: uint32
                    YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                    YLeaf is_create_mldp_mdt_interface; //type: boolean
                    YLeaf is_mldp_mdt_owner; //type: boolean
                    YLeaf mldp_root_count; //type: uint32
                    YLeaf mldp_head_lsm_identifier; //type: uint32
                    YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                    YLeaf organization_unique_identifier; //type: uint32
                    YLeaf vpn_index; //type: uint32
                    YLeaf mldp_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                    YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                    YLeaf mldp_head_local_label; //type: uint32
                    YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                    YLeaf bgp_auto_discovery_configured; //type: boolean
                    YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                    YLeaf inter_autonomous_system_enabled; //type: boolean
                    YLeaf bgp_source_active_announce; //type: boolean
                    YLeaf bgp_i_pmsi_added; //type: boolean
                    YLeaf mldp_bsr_control_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                    YLeaf bgp_auto_discovery_type; //type: uint32
                    YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                    YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                    YLeaf mldp_control_head_lsm_identifier; //type: uint32
                    YLeaf umh; //type: boolean
                    YLeaf suppress_shared_tree_join; //type: boolean
                    YLeaf rsvp_te_mdt_name; //type: string
                    YLeaf rsvp_te_mdt_interface; //type: string
                    YLeaf rsvp_te_mdt_mtu; //type: uint32
                    YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                    YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                    YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                    YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                    YLeaf is_rsvp_te_mdt_owner; //type: boolean
                    YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                    YLeaf p2mpte_li_drop; //type: uint32
                    YLeaf ir_mdt_name; //type: string
                    YLeaf ir_mdt_interface; //type: string
                    YLeaf ir_mdt_mtu; //type: uint32
                    YLeaf ir_maximum_mdt_aggregation; //type: uint32
                    YLeaf ir_mdt_data_switchover_interval; //type: uint32
                    YLeaf ir_mdt_data_announce_interval; //type: uint32
                    YLeaf ir_mdt_rpf_identifier; //type: uint32
                    YLeaf ir_mdt_tail_label; //type: uint32
                    YLeaf is_create_ir_mdt_interface; //type: boolean
                    YLeaf is_ir_mdt_owner; //type: boolean
                    YLeaf in_b_and_mdt_name; //type: string
                    YLeaf in_b_and_mdt_interface; //type: string
                    YLeaf in_b_and_mdt_mtu; //type: uint32
                    YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                    YLeaf is_in_b_and_mdt_owner; //type: boolean
                    YLeaf in_band_signaling_local_enabled; //type: boolean
                    YLeaf in_band_signaling_remote_enabled; //type: boolean
                    YLeaf valid_rd_present; //type: boolean
                    YLeaf stale_rd_present; //type: boolean
                    YLeaf route_distinguisher; //type: string
                    YLeaf gin_b_and_mdt_name; //type: string
                    YLeaf gin_b_and_mdt_interface; //type: string
                    YLeaf gin_b_and_mdt_mtu; //type: uint32
                    YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                    YLeaf is_gin_b_and_mdt_owner; //type: boolean
                    YLeaf is_pim_nsf_rib_converged; //type: boolean
                    YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                    YLeaf is_rib_multipath_enabled; //type: boolean
                    YLeaf is_rib_multipath_interface_hash; //type: boolean
                    YLeaf is_rib_multipath_source_hash; //type: boolean
                    YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf is_create_mdt_interface; //type: boolean
                    YLeaf is_auto_rp_listen_enabled; //type: boolean
                    YLeaf is_all_interface_disable_operation; //type: boolean
                    YLeaf is_default_granges; //type: boolean
                    YLeaf is_auto_rp_listen_sock_add; //type: boolean
                    YLeaf is_redistribution_reset; //type: boolean
                    YLeaf redistribution_reset_count; //type: uint32
                    YLeaf rpf_policy_name; //type: string
                    YLeaf table_count; //type: uint32
                    YLeaf active_table_count; //type: uint32
                    YLeaf anycast_rp_policy_name; //type: string
                    YLeaf anycast_rp_configured; //type: boolean
                    YLeaf bgp_remote_on; //type: boolean
                    YLeaf bgp_remote_interface_name; //type: string
                    YLeaf bgp_remote_interface; //type: string
                    YLeaf bgp_remote_address; //type: string
                    YLeaf bgp_remote_state; //type: uint32
                    YLeafList mldp_root_address; //type: list of  uint32

                class RemoteDefaultGroup : public Entity
                {
                    public:
                        RemoteDefaultGroup();
                        ~RemoteDefaultGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Pim::Standby::DefaultContext::Context::RemoteDefaultGroup


                class RpfDefaultTable : public Entity
                {
                    public:
                        RpfDefaultTable();
                        ~RpfDefaultTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Pim::Standby::DefaultContext::Context::RpfDefaultTable


                class ExportRouteTarget : public Entity
                {
                    public:
                        ExportRouteTarget();
                        ~ExportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Pim::Standby::DefaultContext::Context::ExportRouteTarget


                class ImportRouteTarget : public Entity
                {
                    public:
                        ImportRouteTarget();
                        ~ImportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Pim::Standby::DefaultContext::Context::ImportRouteTarget


                class AnycastRpRange : public Entity
                {
                    public:
                        AnycastRpRange();
                        ~AnycastRpRange();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix_length; //type: uint8
                        YLeaf ancast_rp_marked; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Context::AnycastRpRange::Prefix


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context::AnycastRpRange::Prefix> prefix;


                }; // Pim::Standby::DefaultContext::Context::AnycastRpRange


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context::AnycastRpRange> > anycast_rp_range;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context::ExportRouteTarget> > export_route_target;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context::ImportRouteTarget> > import_route_target;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context::RemoteDefaultGroup> remote_default_group;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context::RpfDefaultTable> rpf_default_table;


            }; // Pim::Standby::DefaultContext::Context


            class TopologyEntryFlagRouteCounts : public Entity
            {
                public:
                    TopologyEntryFlagRouteCounts();
                    ~TopologyEntryFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyEntryFlagRouteCount : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCount();
                        ~TopologyEntryFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                }; // Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


            }; // Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts


            class RpfRedirect : public Entity
            {
                public:
                    RpfRedirect();
                    ~RpfRedirect();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RedirectRouteDatabases : public Entity
                {
                    public:
                        RedirectRouteDatabases();
                        ~RedirectRouteDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabase : public Entity
                    {
                        public:
                            RedirectRouteDatabase();
                            ~RedirectRouteDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf bandwidth; //type: uint32
                            YLeaf uptime; //type: uint64

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                        class Interface : public Entity
                        {
                            public:
                                Interface();
                                ~Interface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf is_rpf_interface; //type: boolean
                                YLeaf is_outgoing_interface; //type: boolean
                                YLeaf is_snoop_interface; //type: boolean

                            class RpfAddress : public Entity
                            {
                                public:
                                    RpfAddress();
                                    ~RpfAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                        }; // Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                    }; // Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                }; // Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases


                class BundleInterfaces : public Entity
                {
                    public:
                        BundleInterfaces();
                        ~BundleInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BundleInterface : public Entity
                    {
                        public:
                            BundleInterface();
                            ~BundleInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf bundle_name; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf rpf_redirect_bundle_name; //type: string
                            YLeaf rpf_redirect_interface_name; //type: string
                            YLeaf available_bandwidth; //type: int32
                            YLeaf allocated_bandwidth; //type: int32
                            YLeaf total_bandwidth; //type: int32
                            YLeaf topology_bandwidth_used; //type: int32
                            YLeaf snooping_bandwidth_used; //type: int32
                            YLeaf allocated_threshold_bandwidth; //type: int32
                            YLeaf available_threshold_bandwidth; //type: int32



                    }; // Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                }; // Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces> bundle_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


            }; // Pim::Standby::DefaultContext::RpfRedirect


            class Tunnels : public Entity
            {
                public:
                    Tunnels();
                    ~Tunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Tunnel : public Entity
                {
                    public:
                        Tunnel();
                        ~Tunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Tunnels::Tunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Tunnels::Tunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Tunnels::Tunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                }; // Pim::Standby::DefaultContext::Tunnels::Tunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Tunnels::Tunnel> > tunnel;


            }; // Pim::Standby::DefaultContext::Tunnels


            class MulticastStaticRoutes : public Entity
            {
                public:
                    MulticastStaticRoutes();
                    ~MulticastStaticRoutes();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MulticastStaticRoute : public Entity
                {
                    public:
                        MulticastStaticRoute();
                        ~MulticastStaticRoute();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf address; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf interface_name; //type: string
                        YLeaf distance; //type: uint32
                        YLeaf prefix_length_xr; //type: uint8
                        YLeaf is_via_lsm; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                    class Nexthop : public Entity
                    {
                        public:
                            Nexthop();
                            ~Nexthop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                }; // Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


            }; // Pim::Standby::DefaultContext::MulticastStaticRoutes


            class GroupMapMatchSources : public Entity
            {
                public:
                    GroupMapMatchSources();
                    ~GroupMapMatchSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchSource : public Entity
                {
                    public:
                        GroupMapMatchSource();
                        ~GroupMapMatchSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                }; // Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


            }; // Pim::Standby::DefaultContext::GroupMapMatchSources


            class Neighbors : public Entity
            {
                public:
                    Neighbors();
                    ~Neighbors();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Neighbor : public Entity
                {
                    public:
                        Neighbor();
                        ~Neighbor();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::DefaultContext::Neighbors::Neighbor::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                }; // Pim::Standby::DefaultContext::Neighbors::Neighbor


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Neighbors::Neighbor> > neighbor;


            }; // Pim::Standby::DefaultContext::Neighbors


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::AutoRp> auto_rp;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BgpAfs> bgp_afs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfStates> bidir_df_states;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::BidirDfWinners> bidir_df_winners;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Bsr> bsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Context> context;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GlobalInterfaces> global_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Gre> gre;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchRpfs> group_map_match_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapMatchSources> group_map_match_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapRpfs> group_map_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::GroupMapSources> group_map_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::IfrsSummary> ifrs_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::InterfaceStatistics> interface_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Interfaces> interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::JpStatistics> jp_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MibDatabases> mib_databases;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::MulticastStaticRoutes> multicast_static_routes;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NeighborOldFormats> neighbor_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NeighborSummaries> neighbor_summaries;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Neighbors> neighbors;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::NetIoTunnels> net_io_tunnels;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RoutePolicy> route_policy;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfRedirect> rpf_redirect;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::RpfSummary> rpf_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Safs> safs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TableContexts> table_contexts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Topologies> topologies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TopologyRouteCount> topology_route_count;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::TrafficCounters> traffic_counters;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext::Tunnels> tunnels;


        }; // Pim::Standby::DefaultContext


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class CheckpointStatistics : public Entity
            {
                public:
                    CheckpointStatistics();
                    ~CheckpointStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class CheckpointTable : public Entity
                {
                    public:
                        CheckpointTable();
                        ~CheckpointTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf table_description; //type: string
                        YLeaf table_name; //type: uint32
                        YLeaf is_mirrored; //type: boolean
                        YLeafList statistic; //type: list of  uint32



                }; // Pim::Standby::Process::CheckpointStatistics::CheckpointTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process::CheckpointStatistics::CheckpointTable> > checkpoint_table;


            }; // Pim::Standby::Process::CheckpointStatistics


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_connected; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf rmf_timer_valid; //type: boolean
                    YLeaf rmf_timer_expiry; //type: uint64
                    YLeaf last_connection_up; //type: uint64
                    YLeaf last_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_connection_up; //type: uint32
                    YLeaf count_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Pim::Standby::Process::Nsr


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Pim::Standby::Process::Summary


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf configured_state; //type: boolean
                    YLeaf nsf_state; //type: boolean
                    YLeaf nsf_timeout; //type: uint32
                    YLeaf nsf_time_left; //type: uint32
                    YLeaf waiting_timer; //type: boolean
                    YLeaf waiting_membership; //type: boolean
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_sec; //type: int32
                    YLeaf last_nsf_off_sec; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_sec; //type: int32



            }; // Pim::Standby::Process::Nsf


            class Issu : public Entity
            {
                public:
                    Issu();
                    ~Issu();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf informationvalid; //type: boolean
                    YLeaf role_ha; //type: int32
                    YLeaf role_issu; //type: int32
                    YLeaf phase_issu; //type: int32
                    YLeaf ha_option_issu; //type: int32
                    YLeaf last_ready_bool; //type: boolean
                    YLeaf last_ready_sent; //type: uint64
                    YLeaf last_ha_role_notification_received; //type: uint64
                    YLeaf last_issu_role_notification_received; //type: uint64
                    YLeaf last_issu_phase_notification_received; //type: uint64
                    YLeaf is_eoc_received; //type: boolean
                    YLeaf eoc_received_timestamp; //type: uint64
                    YLeaf is_ihms_done_received; //type: boolean
                    YLeaf ihms_received_timestamp; //type: uint64
                    YLeaf is_rib_sync_received; //type: boolean
                    YLeaf rib_sync_received_timestamp; //type: uint64
                    YLeaf is_nbr_sync_received; //type: boolean
                    YLeaf nbr_sync_received_timestamp; //type: uint64



            }; // Pim::Standby::Process::Issu


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process::CheckpointStatistics> checkpoint_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process::Issu> issu;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process::Summary> summary;


        }; // Pim::Standby::Process


        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                    }; // Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Pim::Standby::Vrfs::Vrf::IfrsInterfaces


                class Safs : public Entity
                {
                    public:
                        Safs();
                        ~Safs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Saf : public Entity
                    {
                        public:
                            Saf();
                            ~Saf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string

                        class RpfHashSourceGroups : public Entity
                        {
                            public:
                                RpfHashSourceGroups();
                                ~RpfHashSourceGroups();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSourceGroup : public Entity
                            {
                                public:
                                    RpfHashSourceGroup();
                                    ~RpfHashSourceGroup();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf group_address; //type: string
                                    YLeaf mask_length; //type: int32
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                        }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups


                        class RpfNeighbors : public Entity
                        {
                            public:
                                RpfNeighbors();
                                ~RpfNeighbors();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfNeighbor : public Entity
                            {
                                public:
                                    RpfNeighbor();
                                    ~RpfNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf neighbor_address; //type: string
                                    YLeaf rib_neighbor_interface; //type: string

                                class RibNeighborAddress : public Entity
                                {
                                    public:
                                        RibNeighborAddress();
                                        ~RibNeighborAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                                class RpfRegisteredAddresses : public Entity
                                {
                                    public:
                                        RpfRegisteredAddresses();
                                        ~RpfRegisteredAddresses();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_registered_address_references; //type: uint32

                                    class RibRegistrationAddress : public Entity
                                    {
                                        public:
                                            RibRegistrationAddress();
                                            ~RibRegistrationAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                            }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                        }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors


                        class RpfHashSources : public Entity
                        {
                            public:
                                RpfHashSources();
                                ~RpfHashSources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSource : public Entity
                            {
                                public:
                                    RpfHashSource();
                                    ~RpfHashSource();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                        }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources


                        class Rpfs : public Entity
                        {
                            public:
                                Rpfs();
                                ~Rpfs();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class Rpf : public Entity
                            {
                                public:
                                    Rpf();
                                    ~Rpf();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf registered_address; //type: string
                                    YLeaf metric; //type: uint32
                                    YLeaf metric_preference; //type: uint32
                                    YLeaf is_connected; //type: uint8
                                    YLeaf is_rpf_bgp_route; //type: boolean

                                class RegisteredAddressXr : public Entity
                                {
                                    public:
                                        RegisteredAddressXr();
                                        ~RegisteredAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                                class RpfPath : public Entity
                                {
                                    public:
                                        RpfPath();
                                        ~RpfPath();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_interface_name; //type: string
                                        YLeaf is_rpf_interface_disabled; //type: boolean
                                        YLeaf is_via_lsm; //type: boolean
                                        YLeaf is_via_mlsm; //type: boolean
                                        YLeaf is_connector_attribute_present; //type: boolean
                                        YLeaf connector; //type: string
                                        YLeaf extranet_vrf_name; //type: string

                                    class RpfNeighbor : public Entity
                                    {
                                        public:
                                            RpfNeighbor();
                                            ~RpfNeighbor();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                    class RpfNexthop : public Entity
                                    {
                                        public:
                                            RpfNexthop();
                                            ~RpfNexthop();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                                }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                            }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf> > rpf;


                        }; // Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources> rpf_hash_sources;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors> rpf_neighbors;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs> rpfs;


                    }; // Pim::Standby::Vrfs::Vrf::Safs::Saf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs::Saf> > saf;


                }; // Pim::Standby::Vrfs::Vrf::Safs


                class InterfaceStatistics : public Entity
                {
                    public:
                        InterfaceStatistics();
                        ~InterfaceStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStatistic : public Entity
                    {
                        public:
                            InterfaceStatistic();
                            ~InterfaceStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf input_hello; //type: uint32
                            YLeaf output_hello; //type: uint32
                            YLeaf input_register; //type: uint32
                            YLeaf output_register; //type: uint32
                            YLeaf input_register_stop; //type: uint32
                            YLeaf output_register_stop; //type: uint32
                            YLeaf input_jp; //type: uint32
                            YLeaf output_jp; //type: uint32
                            YLeaf input_bsr_message; //type: uint32
                            YLeaf output_bsr_message; //type: uint32
                            YLeaf input_assert; //type: uint32
                            YLeaf output_assert; //type: uint32
                            YLeaf input_graft_message; //type: uint32
                            YLeaf output_graft_message; //type: uint32
                            YLeaf input_graft_ack_message; //type: uint32
                            YLeaf output_graft_ack_message; //type: uint32
                            YLeaf input_candidate_rp_advertisement; //type: uint32
                            YLeaf output_candidate_rp_advertisement; //type: uint32
                            YLeaf input_df_election; //type: uint32
                            YLeaf output_df_election; //type: uint32
                            YLeaf input_miscellaneous; //type: uint32



                    }; // Pim::Standby::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


                }; // Pim::Standby::Vrfs::Vrf::InterfaceStatistics


                class TopologyRouteCount : public Entity
                {
                    public:
                        TopologyRouteCount();
                        ~TopologyRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::Vrfs::Vrf::TopologyRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyRouteCount::GroupAddress> group_address;


                }; // Pim::Standby::Vrfs::Vrf::TopologyRouteCount


                class JpStatistics : public Entity
                {
                    public:
                        JpStatistics();
                        ~JpStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JpStatistic : public Entity
                    {
                        public:
                            JpStatistic();
                            ~JpStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf mtu; //type: uint32
                            YLeaf transmitted; //type: uint32
                            YLeaf transmitted100; //type: uint16
                            YLeaf transmitted_1k; //type: uint16
                            YLeaf transmitted_10k; //type: uint16
                            YLeaf transmitted_50k; //type: uint16
                            YLeaf received; //type: uint32
                            YLeaf received100; //type: uint16
                            YLeaf received_1k; //type: uint16
                            YLeaf received_10k; //type: uint16
                            YLeaf received_50k; //type: uint16



                    }; // Pim::Standby::Vrfs::Vrf::JpStatistics::JpStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::JpStatistics::JpStatistic> > jp_statistic;


                }; // Pim::Standby::Vrfs::Vrf::JpStatistics


                class MibDatabases : public Entity
                {
                    public:
                        MibDatabases();
                        ~MibDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MibDatabase : public Entity
                    {
                        public:
                            MibDatabase();
                            ~MibDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf source_netmask; //type: int32
                            YLeaf upstream_assert_timer; //type: int32
                            YLeaf assert_metric; //type: uint32
                            YLeaf assert_metric_preference; //type: uint32
                            YLeaf assert_rpt_bit; //type: boolean
                            YLeaf spt_bit; //type: boolean
                            YLeaf rpf_mask; //type: uint32
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf bidirectional_route; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf protocol; //type: PimShowProtocolEnum

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                    }; // Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase> > mib_database;


                }; // Pim::Standby::Vrfs::Vrf::MibDatabases


                class GroupMapMatchRpfs : public Entity
                {
                    public:
                        GroupMapMatchRpfs();
                        ~GroupMapMatchRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchRpf : public Entity
                    {
                        public:
                            GroupMapMatchRpf();
                            ~GroupMapMatchRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                    }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


                }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs


                class NeighborOldFormats : public Entity
                {
                    public:
                        NeighborOldFormats();
                        ~NeighborOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborOldFormat : public Entity
                    {
                        public:
                            NeighborOldFormat();
                            ~NeighborOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                    }; // Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


                }; // Pim::Standby::Vrfs::Vrf::NeighborOldFormats


                class IfrsSummary : public Entity
                {
                    public:
                        IfrsSummary();
                        ~IfrsSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Pim::Standby::Vrfs::Vrf::IfrsSummary


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf client_xr; //type: PimShowRangeClientEnum
                            YLeaf expires; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Ranges::Range::RpAddressXr


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Ranges::Range::SourceOfInformation


                        class GroupRange : public Entity
                        {
                            public:
                                GroupRange();
                                ~GroupRange();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf uptime; //type: uint64
                                YLeaf expires; //type: uint64

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix


                            class SourceOfInformation : public Entity
                            {
                                public:
                                    SourceOfInformation();
                                    ~SourceOfInformation();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                        }; // Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange> > group_range;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges::Range::RpAddressXr> rp_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges::Range::SourceOfInformation> source_of_information;


                    }; // Pim::Standby::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges::Range> > range;


                }; // Pim::Standby::Vrfs::Vrf::Ranges


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                    }; // Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Pim::Standby::Vrfs::Vrf::InterfaceOldFormats


                class Bsr : public Entity
                {
                    public:
                        Bsr();
                        ~Bsr();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCaches : public Entity
                    {
                        public:
                            RpCaches();
                            ~RpCaches();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpCache : public Entity
                        {
                            public:
                                RpCache();
                                ~RpCache();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf group_prefix; //type: string
                                YLeaf group_prefix_length; //type: uint32
                                YLeaf candidate_rp_group_count; //type: uint32

                            class GroupPrefixXr : public Entity
                            {
                                public:
                                    GroupPrefixXr();
                                    ~GroupPrefixXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr


                            class CandidateRpList : public Entity
                            {
                                public:
                                    CandidateRpList();
                                    ~CandidateRpList();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;



                                class PimBsrCrpBag : public Entity
                                {
                                    public:
                                        PimBsrCrpBag();
                                        ~PimBsrCrpBag();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf candidate_rp_holdtime; //type: uint16
                                        YLeaf candidate_rp_priority; //type: uint8
                                        YLeaf candidate_rp_up_time; //type: uint16
                                        YLeaf candidate_rp_expires; //type: uint16
                                        YLeaf protocol; //type: PimShowProtocolEnum

                                    class CandidateRpAddress : public Entity
                                    {
                                        public:
                                            CandidateRpAddress();
                                            ~CandidateRpAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                                }; // Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                            }; // Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                        }; // Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache> > rp_cache;


                    }; // Pim::Standby::Vrfs::Vrf::Bsr::RpCaches


                    class CandidateRps : public Entity
                    {
                        public:
                            CandidateRps();
                            ~CandidateRps();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class CandidateRp : public Entity
                        {
                            public:
                                CandidateRp();
                                ~CandidateRp();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf rp_address; //type: string
                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf candidate_rp_scope; //type: int32
                                YLeaf crp_priority; //type: uint8
                                YLeaf crp_holdtime; //type: uint16
                                YLeaf candidate_rp_advance_interval; //type: uint16
                                YLeaf candidate_rp_uptime; //type: uint16
                                YLeaf acl_name; //type: string

                            class CandidateRp_ : public Entity
                            {
                                public:
                                    CandidateRp_();
                                    ~CandidateRp_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_


                            class CrpAccess : public Entity
                            {
                                public:
                                    CrpAccess();
                                    ~CrpAccess();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                    YLeaf acl_name; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                        }; // Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                    }; // Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps


                    class BsrElections : public Entity
                    {
                        public:
                            BsrElections();
                            ~BsrElections();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BsrElection : public Entity
                        {
                            public:
                                BsrElection();
                                ~BsrElection();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf pim_scope; //type: int32
                                YLeaf bsr_priority; //type: uint8
                                YLeaf bsr_mask_length; //type: uint8
                                YLeaf bsr_up_time; //type: uint16
                                YLeaf bootstrap_timeout; //type: uint16
                                YLeaf candidate_bsr_state; //type: uint32
                                YLeaf bsr_election_state; //type: uint32
                                YLeaf bsr_scope; //type: uint16
                                YLeaf candidate_bsr_flag; //type: boolean
                                YLeaf candidate_bsr_priority; //type: uint8
                                YLeaf candidate_bsr_mask_length; //type: uint8

                            class BsrAddress : public Entity
                            {
                                public:
                                    BsrAddress();
                                    ~BsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress


                            class CandidateBsrAddress : public Entity
                            {
                                public:
                                    CandidateBsrAddress();
                                    ~CandidateBsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                        }; // Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection> > bsr_election;


                    }; // Pim::Standby::Vrfs::Vrf::Bsr::BsrElections


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::BsrElections> bsr_elections;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps> candidate_rps;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr::RpCaches> rp_caches;


                }; // Pim::Standby::Vrfs::Vrf::Bsr


                class RoutePolicy : public Entity
                {
                    public:
                        RoutePolicy();
                        ~RoutePolicy();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyStatistics : public Entity
                    {
                        public:
                            RoutePolicyStatistics();
                            ~RoutePolicyStatistics();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf policy_name; //type: string
                            YLeaf requests; //type: uint32
                            YLeaf pass; //type: uint32
                            YLeaf drop; //type: uint32
                            YLeaf default_table; //type: uint32
                            YLeaf any_table; //type: uint32



                    }; // Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics


                    class RoutePolicyTests : public Entity
                    {
                        public:
                            RoutePolicyTests();
                            ~RoutePolicyTests();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RoutePolicyTest : public Entity
                        {
                            public:
                                RoutePolicyTest();
                                ~RoutePolicyTest();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf ext_comm; //type: string
                                YLeaf policy_name; //type: string
                                YLeaf extended_community_rt; //type: string
                                YLeaf pass; //type: boolean
                                YLeaf default_table; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf afi; //type: uint32
                                YLeaf safi; //type: uint32
                                YLeaf table_name; //type: string
                                YLeaf table_exists; //type: boolean
                                YLeaf table_active; //type: boolean

                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                        }; // Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                    }; // Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests> route_policy_tests;


                }; // Pim::Standby::Vrfs::Vrf::RoutePolicy


                class RpfSummary : public Entity
                {
                    public:
                        RpfSummary();
                        ~RpfSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf default_safi; //type: uint32
                        YLeaf default_table_name; //type: string
                        YLeaf is_mbgp_configured; //type: boolean
                        YLeaf is_ospf_te_configured; //type: boolean
                        YLeaf is_isis_te_configured; //type: boolean
                        YLeaf is_isis_mtr_configured; //type: boolean
                        YLeaf mo_frr_configured; //type: boolean
                        YLeaf rib_mo_frr_configured; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf rib_convergence_timeout; //type: uint32
                        YLeaf rib_convergence_time_left; //type: uint32
                        YLeaf is_multipath_enabled; //type: boolean
                        YLeaf is_multipath_interface_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                        YLeaf rpf_registrations; //type: uint32
                        YLeaf is_rib_convergence; //type: boolean



                }; // Pim::Standby::Vrfs::Vrf::RpfSummary


                class Interfaces : public Entity
                {
                    public:
                        Interfaces();
                        ~Interfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Interfaces::Interface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Interfaces::Interface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress> > interface_address;


                    }; // Pim::Standby::Vrfs::Vrf::Interfaces::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Interfaces::Interface> > interface;


                }; // Pim::Standby::Vrfs::Vrf::Interfaces


                class NetIoTunnels : public Entity
                {
                    public:
                        NetIoTunnels();
                        ~NetIoTunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NetIoTunnel : public Entity
                    {
                        public:
                            NetIoTunnel();
                            ~NetIoTunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                    }; // Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


                }; // Pim::Standby::Vrfs::Vrf::NetIoTunnels


                class BidirDfStates : public Entity
                {
                    public:
                        BidirDfStates();
                        ~BidirDfStates();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfState : public Entity
                    {
                        public:
                            BidirDfState();
                            ~BidirDfState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf election_state; //type: string
                            YLeaf time_seconds; //type: uint64
                            YLeaf time_nano_seconds; //type: uint64
                            YLeaf our_metric; //type: uint32
                            YLeaf our_metric_preference; //type: uint32

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                    }; // Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState> > bidir_df_state;


                }; // Pim::Standby::Vrfs::Vrf::BidirDfStates


                class Topologies : public Entity
                {
                    public:
                        Topologies();
                        ~Topologies();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Topology : public Entity
                    {
                        public:
                            Topology();
                            ~Topology();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf rpt; //type: int32
                            YLeaf limit_reached; //type: boolean
                            YLeaf low_memory; //type: boolean
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf wildcard; //type: boolean
                            YLeaf rpt_xr; //type: boolean
                            YLeaf spt; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf alive; //type: int32
                            YLeaf register_received_timer; //type: int32
                            YLeaf remote_source; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf is_via_lsm; //type: boolean
                            YLeaf secondary_rpf_interface_name; //type: string
                            YLeaf connected; //type: boolean
                            YLeaf proxy; //type: boolean
                            YLeaf rpf_proxy_enabled; //type: boolean
                            YLeaf mofrr_enabled; //type: boolean
                            YLeaf rib_mo_frr_enabled; //type: boolean
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_status; //type: int32
                            YLeaf suppress_registers; //type: int32
                            YLeaf assume_alive; //type: boolean
                            YLeaf probe_alive; //type: boolean
                            YLeaf really_alive; //type: boolean
                            YLeaf inherit_alive; //type: boolean
                            YLeaf inherit_spt; //type: boolean
                            YLeaf signal_sources; //type: boolean
                            YLeaf dont_check_connected; //type: boolean
                            YLeaf register_received; //type: boolean
                            YLeaf last_hop; //type: boolean
                            YLeaf sending_registers; //type: boolean
                            YLeaf sending_null_registers; //type: boolean
                            YLeaf sa_sent; //type: boolean
                            YLeaf sa_received; //type: boolean
                            YLeaf sa_joined; //type: boolean
                            YLeaf anycast_rp_match; //type: boolean
                            YLeaf anycast_rp_route_target; //type: string
                            YLeaf bgp_join; //type: boolean
                            YLeaf bgpjp_time; //type: uint64
                            YLeaf customer_routing_type; //type: int32
                            YLeaf extranet_route; //type: boolean
                            YLeaf mofrr_active; //type: boolean
                            YLeaf mofrr_primary; //type: boolean
                            YLeaf mofrr_backup; //type: boolean
                            YLeaf vxlan; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::SourceAddressXr


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpAddress


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfNeighbor


                        class SecondaryRpfNeighbor : public Entity
                        {
                            public:
                                SecondaryRpfNeighbor();
                                ~SecondaryRpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfRoot


                        class ProxyAddress : public Entity
                        {
                            public:
                                ProxyAddress();
                                ~ProxyAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::ProxyAddress


                        class OrigSrcAddress : public Entity
                        {
                            public:
                                OrigSrcAddress();
                                ~OrigSrcAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress


                        class OutgoingInterface : public Entity
                        {
                            public:
                                OutgoingInterface();
                                ~OutgoingInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                                YLeaf jp_timer; //type: int32
                                YLeaf jp_state; //type: int32
                                YLeaf assert_timer; //type: int32
                                YLeaf local_members; //type: int32
                                YLeaf internal_interest_info; //type: int32
                                YLeaf forwarding_state; //type: int32
                                YLeaf immediate_state; //type: int32
                                YLeaf last_hop; //type: boolean
                                YLeaf mldp_inband_mdt; //type: boolean
                                YLeaf mldp_stale; //type: boolean
                                YLeaf sa_prune; //type: boolean
                                YLeaf admin_boundary; //type: boolean
                                YLeaf igmp_membership; //type: boolean
                                YLeaf mdt_safi_join; //type: boolean
                                YLeaf mvpn_safi_join; //type: boolean
                                YLeaf local_mdt_join; //type: boolean
                                YLeaf data_mdt_join; //type: boolean
                                YLeaf mvp_nv6_safi_join; //type: boolean
                                YLeaf bgp_c_mcast_join; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf extranet_interface; //type: boolean

                            class AssertWinner : public Entity
                            {
                                public:
                                    AssertWinner();
                                    ~AssertWinner();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                        }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress> orig_src_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::ProxyAddress> proxy_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology::SourceAddressXr> source_address_xr;


                    }; // Pim::Standby::Vrfs::Vrf::Topologies::Topology


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies::Topology> > topology;


                }; // Pim::Standby::Vrfs::Vrf::Topologies


                class BgpAfs : public Entity
                {
                    public:
                        BgpAfs();
                        ~BgpAfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BgpAf : public Entity
                    {
                        public:
                            BgpAf();
                            ~BgpAf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf route_distinguisher; //type: string
                            YLeaf extranet_path_count; //type: uint32
                            YLeaf is_bgp_added; //type: boolean

                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Source


                        class Group : public Entity
                        {
                            public:
                                Group();
                                ~Group();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Group


                        class NextHop : public Entity
                        {
                            public:
                                NextHop();
                                ~NextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::NextHop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Group> group;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::NextHop> next_hop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Source> source;


                    }; // Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf> > bgp_af;


                }; // Pim::Standby::Vrfs::Vrf::BgpAfs


                class AutoRp : public Entity
                {
                    public:
                        AutoRp();
                        ~AutoRp();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;





                }; // Pim::Standby::Vrfs::Vrf::AutoRp


                class TopologyInterfaceFlagRouteCounts : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCounts();
                        ~TopologyInterfaceFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyInterfaceFlagRouteCount : public Entity
                    {
                        public:
                            TopologyInterfaceFlagRouteCount();
                            ~TopologyInterfaceFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                    }; // Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


                }; // Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts


                class GroupMapSources : public Entity
                {
                    public:
                        GroupMapSources();
                        ~GroupMapSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapSource : public Entity
                    {
                        public:
                            GroupMapSource();
                            ~GroupMapSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf priority; //type: int32
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                    }; // Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource> > group_map_source;


                }; // Pim::Standby::Vrfs::Vrf::GroupMapSources


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf inputs; //type: uint32
                        YLeaf outputs; //type: uint32
                        YLeaf format_error; //type: uint32
                        YLeaf pakman_error; //type: uint32
                        YLeaf standby_packets_error; //type: uint32
                        YLeaf checksum_error; //type: uint32
                        YLeaf socket_error; //type: uint32
                        YLeaf send_queue_full; //type: uint32
                        YLeaf boundary_acl_rx_drop; //type: uint32
                        YLeaf boundary_acl_tx_drop; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf no_source_address; //type: uint32
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_data_register; //type: uint32
                        YLeaf input_null_register; //type: uint32
                        YLeaf output_data_register; //type: uint32
                        YLeaf output_null_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf input_assert_batched; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf output_assert_batched; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_ecmp_redirect; //type: uint32
                        YLeaf output_ecmp_redirect; //type: uint32
                        YLeaf output_loop_error; //type: uint32
                        YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                        YLeaf input_no_idb_error; //type: uint32
                        YLeaf input_no_vrf_error; //type: uint32
                        YLeaf input_no_pim_error; //type: uint32
                        YLeaf input_pim_version_error; //type: uint32
                        YLeaf output_join_group; //type: uint32
                        YLeaf output_prune_group; //type: uint32
                        YLeaf output_join_prune_bytes; //type: uint32
                        YLeaf output_hello_bytes; //type: uint32
                        YLeaf non_supported_packets; //type: uint32
                        YLeaf invalid_registers; //type: uint32
                        YLeaf invalid_join_prunes; //type: uint32
                        YLeaf packet_packman_error; //type: uint32
                        YLeaf packet_read_socket_error; //type: uint32
                        YLeaf packet_queue_last_clear; //type: uint32
                        YLeaf packets_standby; //type: uint32
                        YLeaf no_mdt_socket_connection; //type: uint32
                        YLeaf mdt_send_queue_full; //type: uint32
                        YLeaf mdt_socket_error; //type: uint32
                        YLeaf mdt_join_tlv_sent; //type: uint32
                        YLeaf mdt_join_tlv_received; //type: uint32
                        YLeaf mdt_join_bad_type; //type: uint32
                        YLeaf mdt_drop_local_source_address; //type: uint32
                        YLeaf mdt_drop_null_local_address; //type: uint32
                        YLeaf mdt_drop_no_idb; //type: uint32
                        YLeaf mdt_drop_no_vrf; //type: uint32
                        YLeaf invalid_destination_packets; //type: uint32
                        YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                        YLeaf truncated_pim_packets; //type: uint32
                        YLeafList packet_enqueued; //type: list of  uint32
                        YLeafList packet_dequeued; //type: list of  uint32
                        YLeafList packet_queue_length; //type: list of  uint32
                        YLeafList packet_queue_size; //type: list of  uint32
                        YLeafList packet_tail_drop; //type: list of  uint32

                    class PacketQueue : public Entity
                    {
                        public:
                            PacketQueue();
                            ~PacketQueue();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf packet_queue_priority; //type: uint32

                        class PacketQueueState : public Entity
                        {
                            public:
                                PacketQueueState();
                                ~PacketQueueState();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf max_queue_size; //type: uint32
                                YLeaf queue_size_bytes; //type: uint32
                                YLeaf queue_size_packets; //type: uint32



                        }; // Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState


                        class PacketQueueStats : public Entity
                        {
                            public:
                                PacketQueueStats();
                                ~PacketQueueStats();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf enqueued_packets; //type: uint32
                                YLeaf dequeued_packets; //type: uint32
                                YLeaf high_water_mark_packets; //type: uint32
                                YLeaf high_water_mark_bytes; //type: uint32
                                YLeaf tail_drops; //type: uint32



                        }; // Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                    }; // Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue> > packet_queue;


                }; // Pim::Standby::Vrfs::Vrf::TrafficCounters


                class GroupMapRpfs : public Entity
                {
                    public:
                        GroupMapRpfs();
                        ~GroupMapRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapRpf : public Entity
                    {
                        public:
                            GroupMapRpf();
                            ~GroupMapRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf rp_priority; //type: int32
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                    }; // Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


                }; // Pim::Standby::Vrfs::Vrf::GroupMapRpfs


                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_limit; //type: uint32
                        YLeaf route_count; //type: uint32
                        YLeaf route_low_water_mark; //type: uint32
                        YLeaf is_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_limit; //type: uint32
                        YLeaf topology_interface_state_count; //type: uint32
                        YLeaf rxi_low_water_mark; //type: uint32
                        YLeaf rxi_limit_reached; //type: boolean
                        YLeaf register_limit; //type: uint32
                        YLeaf register_count; //type: uint32
                        YLeaf register_limit_reached; //type: boolean
                        YLeaf ranges_limit; //type: uint32
                        YLeaf ranges_count; //type: uint32
                        YLeaf ranges_threshold; //type: uint32
                        YLeaf is_ranges_limit_reached; //type: boolean
                        YLeaf bsr_ranges_limit; //type: uint32
                        YLeaf bsr_ranges_count; //type: uint32
                        YLeaf bsr_range_threshold; //type: uint32
                        YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                        YLeaf bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf bsr_candidate_rp_set_count; //type: uint32
                        YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_maximum_enforcement_disabled; //type: boolean
                        YLeaf is_node_low_memory; //type: boolean
                        YLeaf route_threshold; //type: uint32
                        YLeaf global_auto_rp_ranges_limit; //type: uint32
                        YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_ranges_limit; //type: uint32
                        YLeaf global_bsr_ranges_count; //type: uint32
                        YLeaf global_bsr_ranges_threshold; //type: uint32
                        YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_global_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_threshold; //type: uint32
                        YLeaf is_global_rxi_limit_reached; //type: boolean
                        YLeaf register_threshold; //type: uint32
                        YLeaf global_register_limit; //type: uint32
                        YLeaf is_global_register_limit_reached; //type: boolean



                }; // Pim::Standby::Vrfs::Vrf::Summary


                class Gre : public Entity
                {
                    public:
                        Gre();
                        ~Gre();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHashes : public Entity
                    {
                        public:
                            GreHashes();
                            ~GreHashes();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreHash : public Entity
                        {
                            public:
                                GreHash();
                                ~GreHash();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf destination_address; //type: string
                                YLeaf ifname; //type: string
                                YLeaf next_hop_interface; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Gre::GreHashes::GreHash


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreHashes::GreHash> > gre_hash;


                    }; // Pim::Standby::Vrfs::Vrf::Gre::GreHashes


                    class GreNextHops : public Entity
                    {
                        public:
                            GreNextHops();
                            ~GreNextHops();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreNextHop : public Entity
                        {
                            public:
                                GreNextHop();
                                ~GreNextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf destination_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8

                            class RegisteredAddress : public Entity
                            {
                                public:
                                    RegisteredAddress();
                                    ~RegisteredAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress


                            class GrePath : public Entity
                            {
                                public:
                                    GrePath();
                                    ~GrePath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf gre_interface_name; //type: string
                                    YLeaf is_gre_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf extranet_vrf_name; //type: string

                                class GreNeighbor : public Entity
                                {
                                    public:
                                        GreNeighbor();
                                        ~GreNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                                class GreNextHop_ : public Entity
                                {
                                    public:
                                        GreNextHop_();
                                        ~GreNextHop_();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                            }; // Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                        }; // Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                    }; // Pim::Standby::Vrfs::Vrf::Gre::GreNextHops


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreHashes> gre_hashes;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre::GreNextHops> gre_next_hops;


                }; // Pim::Standby::Vrfs::Vrf::Gre


                class BidirDfWinners : public Entity
                {
                    public:
                        BidirDfWinners();
                        ~BidirDfWinners();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfWinner : public Entity
                    {
                        public:
                            BidirDfWinner();
                            ~BidirDfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf are_we_df; //type: boolean
                            YLeaf rp_lan; //type: boolean
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf uptime; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr


                        class DfWinner : public Entity
                        {
                            public:
                                DfWinner();
                                ~DfWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                    }; // Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


                }; // Pim::Standby::Vrfs::Vrf::BidirDfWinners


                class TableContexts : public Entity
                {
                    public:
                        TableContexts();
                        ~TableContexts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TableContext : public Entity
                    {
                        public:
                            TableContext();
                            ~TableContext();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Pim::Standby::Vrfs::Vrf::TableContexts::TableContext


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TableContexts::TableContext> > table_context;


                }; // Pim::Standby::Vrfs::Vrf::TableContexts


                class GlobalInterfaces : public Entity
                {
                    public:
                        GlobalInterfaces();
                        ~GlobalInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GlobalInterface : public Entity
                    {
                        public:
                            GlobalInterface();
                            ~GlobalInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                    }; // Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface> > global_interface;


                }; // Pim::Standby::Vrfs::Vrf::GlobalInterfaces


                class NeighborSummaries : public Entity
                {
                    public:
                        NeighborSummaries();
                        ~NeighborSummaries();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborSummary : public Entity
                    {
                        public:
                            NeighborSummary();
                            ~NeighborSummary();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf number_of_neighbors; //type: int32
                            YLeaf number_of_external_neighbors; //type: int32



                    }; // Pim::Standby::Vrfs::Vrf::NeighborSummaries::NeighborSummary


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NeighborSummaries::NeighborSummary> > neighbor_summary;


                }; // Pim::Standby::Vrfs::Vrf::NeighborSummaries


                class Context : public Entity
                {
                    public:
                        Context();
                        ~Context();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf murib_id; //type: uint32
                        YLeaf rpf_id; //type: uint32
                        YLeaf remote_table_id; //type: uint32
                        YLeaf mdt_default_group; //type: string
                        YLeaf mdt_interface; //type: string
                        YLeaf mdt_gre_rpf_identifier; //type: uint32
                        YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                        YLeaf is_unicast_rib_registration; //type: boolean
                        YLeaf is_multicast_rib_registration; //type: boolean
                        YLeaf is_active; //type: boolean
                        YLeaf is_active_ital; //type: boolean
                        YLeaf is_mrib_register; //type: boolean
                        YLeaf is_mdt_owner; //type: boolean
                        YLeaf is_routing_enabled; //type: boolean
                        YLeaf is_socket_add_required; //type: boolean
                        YLeaf is_socket_added; //type: boolean
                        YLeaf is_lpts_socket_add_required; //type: boolean
                        YLeaf is_lpts_socket_added; //type: boolean
                        YLeaf is_udp_socket_add_required; //type: boolean
                        YLeaf is_udp_socket_added; //type: boolean
                        YLeaf is_udp_socket_bind_required; //type: boolean
                        YLeaf is_udp_socket_bind; //type: boolean
                        YLeaf is_register_injection_socket_add_required; //type: boolean
                        YLeaf is_register_injection_socket_added; //type: boolean
                        YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                        YLeaf is_register_injection_lpts_socket_added; //type: boolean
                        YLeaf is_m_host_publish_pending; //type: boolean
                        YLeaf mhost_interface; //type: string
                        YLeaf mhost_default_interface_config; //type: string
                        YLeaf mdt_mtu; //type: uint32
                        YLeaf maximum_mdt_aggregation; //type: uint32
                        YLeaf mdt_data_switchover_interval; //type: uint32
                        YLeaf mdt_data_announce_interval; //type: uint32
                        YLeaf non_default_vrf_count_on_socket; //type: uint32
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf mdt_neighbor_filter_name; //type: string
                        YLeaf allow_rp_configured; //type: boolean
                        YLeaf allow_rp_group_list; //type: string
                        YLeaf allow_rp_rp_list; //type: string
                        YLeaf sg_expiry_timer_configured; //type: boolean
                        YLeaf sg_expiry_time; //type: uint16
                        YLeaf sg_expiry_timer_sg_list; //type: string
                        YLeaf mldp_mdt_name; //type: string
                        YLeaf mldp_mdt_interface; //type: string
                        YLeaf mldp_mdt_mtu; //type: uint32
                        YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                        YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                        YLeaf mldp_mdt_data_announce_interval; //type: uint32
                        YLeaf mldp_mdt_rpf_identifier; //type: uint32
                        YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                        YLeaf is_create_mldp_mdt_interface; //type: boolean
                        YLeaf is_mldp_mdt_owner; //type: boolean
                        YLeaf mldp_root_count; //type: uint32
                        YLeaf mldp_head_lsm_identifier; //type: uint32
                        YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                        YLeaf organization_unique_identifier; //type: uint32
                        YLeaf vpn_index; //type: uint32
                        YLeaf mldp_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                        YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                        YLeaf mldp_head_local_label; //type: uint32
                        YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                        YLeaf bgp_auto_discovery_configured; //type: boolean
                        YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                        YLeaf inter_autonomous_system_enabled; //type: boolean
                        YLeaf bgp_source_active_announce; //type: boolean
                        YLeaf bgp_i_pmsi_added; //type: boolean
                        YLeaf mldp_bsr_control_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                        YLeaf bgp_auto_discovery_type; //type: uint32
                        YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                        YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                        YLeaf mldp_control_head_lsm_identifier; //type: uint32
                        YLeaf umh; //type: boolean
                        YLeaf suppress_shared_tree_join; //type: boolean
                        YLeaf rsvp_te_mdt_name; //type: string
                        YLeaf rsvp_te_mdt_interface; //type: string
                        YLeaf rsvp_te_mdt_mtu; //type: uint32
                        YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                        YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                        YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                        YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                        YLeaf is_rsvp_te_mdt_owner; //type: boolean
                        YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                        YLeaf p2mpte_li_drop; //type: uint32
                        YLeaf ir_mdt_name; //type: string
                        YLeaf ir_mdt_interface; //type: string
                        YLeaf ir_mdt_mtu; //type: uint32
                        YLeaf ir_maximum_mdt_aggregation; //type: uint32
                        YLeaf ir_mdt_data_switchover_interval; //type: uint32
                        YLeaf ir_mdt_data_announce_interval; //type: uint32
                        YLeaf ir_mdt_rpf_identifier; //type: uint32
                        YLeaf ir_mdt_tail_label; //type: uint32
                        YLeaf is_create_ir_mdt_interface; //type: boolean
                        YLeaf is_ir_mdt_owner; //type: boolean
                        YLeaf in_b_and_mdt_name; //type: string
                        YLeaf in_b_and_mdt_interface; //type: string
                        YLeaf in_b_and_mdt_mtu; //type: uint32
                        YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                        YLeaf is_in_b_and_mdt_owner; //type: boolean
                        YLeaf in_band_signaling_local_enabled; //type: boolean
                        YLeaf in_band_signaling_remote_enabled; //type: boolean
                        YLeaf valid_rd_present; //type: boolean
                        YLeaf stale_rd_present; //type: boolean
                        YLeaf route_distinguisher; //type: string
                        YLeaf gin_b_and_mdt_name; //type: string
                        YLeaf gin_b_and_mdt_interface; //type: string
                        YLeaf gin_b_and_mdt_mtu; //type: uint32
                        YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                        YLeaf is_gin_b_and_mdt_owner; //type: boolean
                        YLeaf is_pim_nsf_rib_converged; //type: boolean
                        YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                        YLeaf is_rib_multipath_enabled; //type: boolean
                        YLeaf is_rib_multipath_interface_hash; //type: boolean
                        YLeaf is_rib_multipath_source_hash; //type: boolean
                        YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf is_create_mdt_interface; //type: boolean
                        YLeaf is_auto_rp_listen_enabled; //type: boolean
                        YLeaf is_all_interface_disable_operation; //type: boolean
                        YLeaf is_default_granges; //type: boolean
                        YLeaf is_auto_rp_listen_sock_add; //type: boolean
                        YLeaf is_redistribution_reset; //type: boolean
                        YLeaf redistribution_reset_count; //type: uint32
                        YLeaf rpf_policy_name; //type: string
                        YLeaf table_count; //type: uint32
                        YLeaf active_table_count; //type: uint32
                        YLeaf anycast_rp_policy_name; //type: string
                        YLeaf anycast_rp_configured; //type: boolean
                        YLeaf bgp_remote_on; //type: boolean
                        YLeaf bgp_remote_interface_name; //type: string
                        YLeaf bgp_remote_interface; //type: string
                        YLeaf bgp_remote_address; //type: string
                        YLeaf bgp_remote_state; //type: uint32
                        YLeafList mldp_root_address; //type: list of  uint32

                    class RemoteDefaultGroup : public Entity
                    {
                        public:
                            RemoteDefaultGroup();
                            ~RemoteDefaultGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Standby::Vrfs::Vrf::Context::RemoteDefaultGroup


                    class RpfDefaultTable : public Entity
                    {
                        public:
                            RpfDefaultTable();
                            ~RpfDefaultTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Pim::Standby::Vrfs::Vrf::Context::RpfDefaultTable


                    class ExportRouteTarget : public Entity
                    {
                        public:
                            ExportRouteTarget();
                            ~ExportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Pim::Standby::Vrfs::Vrf::Context::ExportRouteTarget


                    class ImportRouteTarget : public Entity
                    {
                        public:
                            ImportRouteTarget();
                            ~ImportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Pim::Standby::Vrfs::Vrf::Context::ImportRouteTarget


                    class AnycastRpRange : public Entity
                    {
                        public:
                            AnycastRpRange();
                            ~AnycastRpRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: uint8
                            YLeaf ancast_rp_marked; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange::Prefix


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange::Prefix> prefix;


                    }; // Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange> > anycast_rp_range;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context::ExportRouteTarget> > export_route_target;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context::ImportRouteTarget> > import_route_target;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context::RemoteDefaultGroup> remote_default_group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context::RpfDefaultTable> rpf_default_table;


                }; // Pim::Standby::Vrfs::Vrf::Context


                class TopologyEntryFlagRouteCounts : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCounts();
                        ~TopologyEntryFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyEntryFlagRouteCount : public Entity
                    {
                        public:
                            TopologyEntryFlagRouteCount();
                            ~TopologyEntryFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                    }; // Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


                }; // Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts


                class RpfRedirect : public Entity
                {
                    public:
                        RpfRedirect();
                        ~RpfRedirect();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabases : public Entity
                    {
                        public:
                            RedirectRouteDatabases();
                            ~RedirectRouteDatabases();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RedirectRouteDatabase : public Entity
                        {
                            public:
                                RedirectRouteDatabase();
                                ~RedirectRouteDatabase();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf bandwidth; //type: uint32
                                YLeaf uptime; //type: uint64

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                            class Interface : public Entity
                            {
                                public:
                                    Interface();
                                    ~Interface();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiry; //type: uint64
                                    YLeaf is_rpf_interface; //type: boolean
                                    YLeaf is_outgoing_interface; //type: boolean
                                    YLeaf is_snoop_interface; //type: boolean

                                class RpfAddress : public Entity
                                {
                                    public:
                                        RpfAddress();
                                        ~RpfAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                            }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                        }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                    }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases


                    class BundleInterfaces : public Entity
                    {
                        public:
                            BundleInterfaces();
                            ~BundleInterfaces();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BundleInterface : public Entity
                        {
                            public:
                                BundleInterface();
                                ~BundleInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf bundle_name; //type: string
                                YLeaf interface_name; //type: string
                                YLeaf rpf_redirect_bundle_name; //type: string
                                YLeaf rpf_redirect_interface_name; //type: string
                                YLeaf available_bandwidth; //type: int32
                                YLeaf allocated_bandwidth; //type: int32
                                YLeaf total_bandwidth; //type: int32
                                YLeaf topology_bandwidth_used; //type: int32
                                YLeaf snooping_bandwidth_used; //type: int32
                                YLeaf allocated_threshold_bandwidth; //type: int32
                                YLeaf available_threshold_bandwidth; //type: int32



                        }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                    }; // Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces> bundle_interfaces;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


                }; // Pim::Standby::Vrfs::Vrf::RpfRedirect


                class Tunnels : public Entity
                {
                    public:
                        Tunnels();
                        ~Tunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Tunnel : public Entity
                    {
                        public:
                            Tunnel();
                            ~Tunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                    }; // Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel> > tunnel;


                }; // Pim::Standby::Vrfs::Vrf::Tunnels


                class MulticastStaticRoutes : public Entity
                {
                    public:
                        MulticastStaticRoutes();
                        ~MulticastStaticRoutes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MulticastStaticRoute : public Entity
                    {
                        public:
                            MulticastStaticRoute();
                            ~MulticastStaticRoute();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf address; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf interface_name; //type: string
                            YLeaf distance; //type: uint32
                            YLeaf prefix_length_xr; //type: uint8
                            YLeaf is_via_lsm; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                        class Nexthop : public Entity
                        {
                            public:
                                Nexthop();
                                ~Nexthop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                    }; // Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


                }; // Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes


                class GroupMapMatchSources : public Entity
                {
                    public:
                        GroupMapMatchSources();
                        ~GroupMapMatchSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchSource : public Entity
                    {
                        public:
                            GroupMapMatchSource();
                            ~GroupMapMatchSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                    }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


                }; // Pim::Standby::Vrfs::Vrf::GroupMapMatchSources


                class Neighbors : public Entity
                {
                    public:
                        Neighbors();
                        ~Neighbors();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Neighbor : public Entity
                    {
                        public:
                            Neighbor();
                            ~Neighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                    }; // Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor> > neighbor;


                }; // Pim::Standby::Vrfs::Vrf::Neighbors


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::AutoRp> auto_rp;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BgpAfs> bgp_afs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfStates> bidir_df_states;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::BidirDfWinners> bidir_df_winners;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Bsr> bsr;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Context> context;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GlobalInterfaces> global_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Gre> gre;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs> group_map_match_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapMatchSources> group_map_match_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapRpfs> group_map_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::GroupMapSources> group_map_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::IfrsSummary> ifrs_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::InterfaceStatistics> interface_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Interfaces> interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::JpStatistics> jp_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MibDatabases> mib_databases;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes> multicast_static_routes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NeighborOldFormats> neighbor_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NeighborSummaries> neighbor_summaries;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Neighbors> neighbors;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::NetIoTunnels> net_io_tunnels;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RoutePolicy> route_policy;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfRedirect> rpf_redirect;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::RpfSummary> rpf_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Safs> safs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TableContexts> table_contexts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Topologies> topologies;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TopologyRouteCount> topology_route_count;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::TrafficCounters> traffic_counters;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf::Tunnels> tunnels;


            }; // Pim::Standby::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs::Vrf> > vrf;


        }; // Pim::Standby::Vrfs


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby::Vrfs> vrfs;


    }; // Pim::Standby


    class Active : public Entity
    {
        public:
            Active();
            ~Active();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                }; // Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Pim::Active::DefaultContext::IfrsInterfaces


            class Safs : public Entity
            {
                public:
                    Safs();
                    ~Safs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Saf : public Entity
                {
                    public:
                        Saf();
                        ~Saf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string

                    class RpfHashSourceGroups : public Entity
                    {
                        public:
                            RpfHashSourceGroups();
                            ~RpfHashSourceGroups();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSourceGroup : public Entity
                        {
                            public:
                                RpfHashSourceGroup();
                                ~RpfHashSourceGroup();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf mask_length; //type: int32
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                    }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups


                    class RpfNeighbors : public Entity
                    {
                        public:
                            RpfNeighbors();
                            ~RpfNeighbors();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf neighbor_address; //type: string
                                YLeaf rib_neighbor_interface; //type: string

                            class RibNeighborAddress : public Entity
                            {
                                public:
                                    RibNeighborAddress();
                                    ~RibNeighborAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                            class RpfRegisteredAddresses : public Entity
                            {
                                public:
                                    RpfRegisteredAddresses();
                                    ~RpfRegisteredAddresses();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_registered_address_references; //type: uint32

                                class RibRegistrationAddress : public Entity
                                {
                                    public:
                                        RibRegistrationAddress();
                                        ~RibRegistrationAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                            }; // Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                        }; // Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                    }; // Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors


                    class RpfHashSources : public Entity
                    {
                        public:
                            RpfHashSources();
                            ~RpfHashSources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSource : public Entity
                        {
                            public:
                                RpfHashSource();
                                ~RpfHashSource();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                    }; // Pim::Active::DefaultContext::Safs::Saf::RpfHashSources


                    class Rpfs : public Entity
                    {
                        public:
                            Rpfs();
                            ~Rpfs();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class Rpf : public Entity
                        {
                            public:
                                Rpf();
                                ~Rpf();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf registered_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8
                                YLeaf is_rpf_bgp_route; //type: boolean

                            class RegisteredAddressXr : public Entity
                            {
                                public:
                                    RegisteredAddressXr();
                                    ~RegisteredAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                            class RpfPath : public Entity
                            {
                                public:
                                    RpfPath();
                                    ~RpfPath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_interface_name; //type: string
                                    YLeaf is_rpf_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_via_mlsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf connector; //type: string
                                    YLeaf extranet_vrf_name; //type: string

                                class RpfNeighbor : public Entity
                                {
                                    public:
                                        RpfNeighbor();
                                        ~RpfNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                class RpfNexthop : public Entity
                                {
                                    public:
                                        RpfNexthop();
                                        ~RpfNexthop();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                            }; // Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                        }; // Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf> > rpf;


                    }; // Pim::Active::DefaultContext::Safs::Saf::Rpfs


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfHashSources> rpf_hash_sources;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors> rpf_neighbors;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf::Rpfs> rpfs;


                }; // Pim::Active::DefaultContext::Safs::Saf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs::Saf> > saf;


            }; // Pim::Active::DefaultContext::Safs


            class InterfaceStatistics : public Entity
            {
                public:
                    InterfaceStatistics();
                    ~InterfaceStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStatistic : public Entity
                {
                    public:
                        InterfaceStatistic();
                        ~InterfaceStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_register; //type: uint32
                        YLeaf output_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf input_graft_message; //type: uint32
                        YLeaf output_graft_message; //type: uint32
                        YLeaf input_graft_ack_message; //type: uint32
                        YLeaf output_graft_ack_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_miscellaneous; //type: uint32



                }; // Pim::Active::DefaultContext::InterfaceStatistics::InterfaceStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


            }; // Pim::Active::DefaultContext::InterfaceStatistics


            class TopologyRouteCount : public Entity
            {
                public:
                    TopologyRouteCount();
                    ~TopologyRouteCount();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf group_ranges; //type: uint32
                    YLeaf active_group_ranges; //type: uint32
                    YLeaf groute_count; //type: uint32
                    YLeaf sg_route_count; //type: uint32
                    YLeaf sgr_route_count; //type: uint32
                    YLeaf is_node_low_memory; //type: boolean

                class GroupAddress : public Entity
                {
                    public:
                        GroupAddress();
                        ~GroupAddress();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Pim::Active::DefaultContext::TopologyRouteCount::GroupAddress


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyRouteCount::GroupAddress> group_address;


            }; // Pim::Active::DefaultContext::TopologyRouteCount


            class JpStatistics : public Entity
            {
                public:
                    JpStatistics();
                    ~JpStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JpStatistic : public Entity
                {
                    public:
                        JpStatistic();
                        ~JpStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf mtu; //type: uint32
                        YLeaf transmitted; //type: uint32
                        YLeaf transmitted100; //type: uint16
                        YLeaf transmitted_1k; //type: uint16
                        YLeaf transmitted_10k; //type: uint16
                        YLeaf transmitted_50k; //type: uint16
                        YLeaf received; //type: uint32
                        YLeaf received100; //type: uint16
                        YLeaf received_1k; //type: uint16
                        YLeaf received_10k; //type: uint16
                        YLeaf received_50k; //type: uint16



                }; // Pim::Active::DefaultContext::JpStatistics::JpStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::JpStatistics::JpStatistic> > jp_statistic;


            }; // Pim::Active::DefaultContext::JpStatistics


            class MibDatabases : public Entity
            {
                public:
                    MibDatabases();
                    ~MibDatabases();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MibDatabase : public Entity
                {
                    public:
                        MibDatabase();
                        ~MibDatabase();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf source_netmask; //type: int32
                        YLeaf upstream_assert_timer; //type: int32
                        YLeaf assert_metric; //type: uint32
                        YLeaf assert_metric_preference; //type: uint32
                        YLeaf assert_rpt_bit; //type: boolean
                        YLeaf spt_bit; //type: boolean
                        YLeaf rpf_mask; //type: uint32
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf bidirectional_route; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf protocol; //type: PimShowProtocolEnum

                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr


                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfRoot


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                }; // Pim::Active::DefaultContext::MibDatabases::MibDatabase


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MibDatabases::MibDatabase> > mib_database;


            }; // Pim::Active::DefaultContext::MibDatabases


            class GroupMapMatchRpfs : public Entity
            {
                public:
                    GroupMapMatchRpfs();
                    ~GroupMapMatchRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchRpf : public Entity
                {
                    public:
                        GroupMapMatchRpf();
                        ~GroupMapMatchRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                }; // Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


            }; // Pim::Active::DefaultContext::GroupMapMatchRpfs


            class NeighborOldFormats : public Entity
            {
                public:
                    NeighborOldFormats();
                    ~NeighborOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborOldFormat : public Entity
                {
                    public:
                        NeighborOldFormat();
                        ~NeighborOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                }; // Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


            }; // Pim::Active::DefaultContext::NeighborOldFormats


            class IfrsSummary : public Entity
            {
                public:
                    IfrsSummary();
                    ~IfrsSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Pim::Active::DefaultContext::IfrsSummary


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf client_xr; //type: PimShowRangeClientEnum
                        YLeaf expires; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Ranges::Range::RpAddressXr


                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Ranges::Range::SourceOfInformation


                    class GroupRange : public Entity
                    {
                        public:
                            GroupRange();
                            ~GroupRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Ranges::Range::GroupRange::Prefix


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges::Range::GroupRange::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                    }; // Pim::Active::DefaultContext::Ranges::Range::GroupRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges::Range::GroupRange> > group_range;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges::Range::RpAddressXr> rp_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges::Range::SourceOfInformation> source_of_information;


                }; // Pim::Active::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges::Range> > range;


            }; // Pim::Active::DefaultContext::Ranges


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                }; // Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Pim::Active::DefaultContext::InterfaceOldFormats


            class Bsr : public Entity
            {
                public:
                    Bsr();
                    ~Bsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RpCaches : public Entity
                {
                    public:
                        RpCaches();
                        ~RpCaches();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCache : public Entity
                    {
                        public:
                            RpCache();
                            ~RpCache();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_prefix; //type: string
                            YLeaf group_prefix_length; //type: uint32
                            YLeaf candidate_rp_group_count; //type: uint32

                        class GroupPrefixXr : public Entity
                        {
                            public:
                                GroupPrefixXr();
                                ~GroupPrefixXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr


                        class CandidateRpList : public Entity
                        {
                            public:
                                CandidateRpList();
                                ~CandidateRpList();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class PimBsrCrpBag : public Entity
                            {
                                public:
                                    PimBsrCrpBag();
                                    ~PimBsrCrpBag();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_holdtime; //type: uint16
                                    YLeaf candidate_rp_priority; //type: uint8
                                    YLeaf candidate_rp_up_time; //type: uint16
                                    YLeaf candidate_rp_expires; //type: uint16
                                    YLeaf protocol; //type: PimShowProtocolEnum

                                class CandidateRpAddress : public Entity
                                {
                                    public:
                                        CandidateRpAddress();
                                        ~CandidateRpAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                            }; // Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                        }; // Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                    }; // Pim::Active::DefaultContext::Bsr::RpCaches::RpCache


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::RpCaches::RpCache> > rp_cache;


                }; // Pim::Active::DefaultContext::Bsr::RpCaches


                class CandidateRps : public Entity
                {
                    public:
                        CandidateRps();
                        ~CandidateRps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class CandidateRp : public Entity
                    {
                        public:
                            CandidateRp();
                            ~CandidateRp();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                            YLeaf candidate_rp_scope; //type: int32
                            YLeaf crp_priority; //type: uint8
                            YLeaf crp_holdtime; //type: uint16
                            YLeaf candidate_rp_advance_interval; //type: uint16
                            YLeaf candidate_rp_uptime; //type: uint16
                            YLeaf acl_name; //type: string

                        class CandidateRp_ : public Entity
                        {
                            public:
                                CandidateRp_();
                                ~CandidateRp_();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_


                        class CrpAccess : public Entity
                        {
                            public:
                                CrpAccess();
                                ~CrpAccess();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf acl_name; //type: string



                        }; // Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                    }; // Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                }; // Pim::Active::DefaultContext::Bsr::CandidateRps


                class BsrElections : public Entity
                {
                    public:
                        BsrElections();
                        ~BsrElections();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BsrElection : public Entity
                    {
                        public:
                            BsrElection();
                            ~BsrElection();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf pim_scope; //type: int32
                            YLeaf bsr_priority; //type: uint8
                            YLeaf bsr_mask_length; //type: uint8
                            YLeaf bsr_up_time; //type: uint16
                            YLeaf bootstrap_timeout; //type: uint16
                            YLeaf candidate_bsr_state; //type: uint32
                            YLeaf bsr_election_state; //type: uint32
                            YLeaf bsr_scope; //type: uint16
                            YLeaf candidate_bsr_flag; //type: boolean
                            YLeaf candidate_bsr_priority; //type: uint8
                            YLeaf candidate_bsr_mask_length; //type: uint8

                        class BsrAddress : public Entity
                        {
                            public:
                                BsrAddress();
                                ~BsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress


                        class CandidateBsrAddress : public Entity
                        {
                            public:
                                CandidateBsrAddress();
                                ~CandidateBsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                    }; // Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection> > bsr_election;


                }; // Pim::Active::DefaultContext::Bsr::BsrElections


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::BsrElections> bsr_elections;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::CandidateRps> candidate_rps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr::RpCaches> rp_caches;


            }; // Pim::Active::DefaultContext::Bsr


            class RoutePolicy : public Entity
            {
                public:
                    RoutePolicy();
                    ~RoutePolicy();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RoutePolicyStatistics : public Entity
                {
                    public:
                        RoutePolicyStatistics();
                        ~RoutePolicyStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf policy_name; //type: string
                        YLeaf requests; //type: uint32
                        YLeaf pass; //type: uint32
                        YLeaf drop; //type: uint32
                        YLeaf default_table; //type: uint32
                        YLeaf any_table; //type: uint32



                }; // Pim::Active::DefaultContext::RoutePolicy::RoutePolicyStatistics


                class RoutePolicyTests : public Entity
                {
                    public:
                        RoutePolicyTests();
                        ~RoutePolicyTests();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyTest : public Entity
                    {
                        public:
                            RoutePolicyTest();
                            ~RoutePolicyTest();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf ext_comm; //type: string
                            YLeaf policy_name; //type: string
                            YLeaf extended_community_rt; //type: string
                            YLeaf pass; //type: boolean
                            YLeaf default_table; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf table_exists; //type: boolean
                            YLeaf table_active; //type: boolean

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                    }; // Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                }; // Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests> route_policy_tests;


            }; // Pim::Active::DefaultContext::RoutePolicy


            class RpfSummary : public Entity
            {
                public:
                    RpfSummary();
                    ~RpfSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf default_safi; //type: uint32
                    YLeaf default_table_name; //type: string
                    YLeaf is_mbgp_configured; //type: boolean
                    YLeaf is_ospf_te_configured; //type: boolean
                    YLeaf is_isis_te_configured; //type: boolean
                    YLeaf is_isis_mtr_configured; //type: boolean
                    YLeaf mo_frr_configured; //type: boolean
                    YLeaf rib_mo_frr_configured; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf rib_convergence_timeout; //type: uint32
                    YLeaf rib_convergence_time_left; //type: uint32
                    YLeaf is_multipath_enabled; //type: boolean
                    YLeaf is_multipath_interface_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                    YLeaf rpf_registrations; //type: uint32
                    YLeaf is_rib_convergence; //type: boolean



            }; // Pim::Active::DefaultContext::RpfSummary


            class Interfaces : public Entity
            {
                public:
                    Interfaces();
                    ~Interfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Interfaces::Interface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Interfaces::Interface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Interfaces::Interface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Interfaces::Interface::InterfaceAddress> > interface_address;


                }; // Pim::Active::DefaultContext::Interfaces::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Interfaces::Interface> > interface;


            }; // Pim::Active::DefaultContext::Interfaces


            class NetIoTunnels : public Entity
            {
                public:
                    NetIoTunnels();
                    ~NetIoTunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NetIoTunnel : public Entity
                {
                    public:
                        NetIoTunnel();
                        ~NetIoTunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                }; // Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


            }; // Pim::Active::DefaultContext::NetIoTunnels


            class BidirDfStates : public Entity
            {
                public:
                    BidirDfStates();
                    ~BidirDfStates();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfState : public Entity
                {
                    public:
                        BidirDfState();
                        ~BidirDfState();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf election_state; //type: string
                        YLeaf time_seconds; //type: uint64
                        YLeaf time_nano_seconds; //type: uint64
                        YLeaf our_metric; //type: uint32
                        YLeaf our_metric_preference; //type: uint32

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                }; // Pim::Active::DefaultContext::BidirDfStates::BidirDfState


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfStates::BidirDfState> > bidir_df_state;


            }; // Pim::Active::DefaultContext::BidirDfStates


            class Topologies : public Entity
            {
                public:
                    Topologies();
                    ~Topologies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Topology : public Entity
                {
                    public:
                        Topology();
                        ~Topology();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf rpt; //type: int32
                        YLeaf limit_reached; //type: boolean
                        YLeaf low_memory; //type: boolean
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf wildcard; //type: boolean
                        YLeaf rpt_xr; //type: boolean
                        YLeaf spt; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf expiry; //type: uint64
                        YLeaf alive; //type: int32
                        YLeaf register_received_timer; //type: int32
                        YLeaf remote_source; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf is_via_lsm; //type: boolean
                        YLeaf secondary_rpf_interface_name; //type: string
                        YLeaf connected; //type: boolean
                        YLeaf proxy; //type: boolean
                        YLeaf rpf_proxy_enabled; //type: boolean
                        YLeaf mofrr_enabled; //type: boolean
                        YLeaf rib_mo_frr_enabled; //type: boolean
                        YLeaf jp_timer; //type: int32
                        YLeaf jp_status; //type: int32
                        YLeaf suppress_registers; //type: int32
                        YLeaf assume_alive; //type: boolean
                        YLeaf probe_alive; //type: boolean
                        YLeaf really_alive; //type: boolean
                        YLeaf inherit_alive; //type: boolean
                        YLeaf inherit_spt; //type: boolean
                        YLeaf signal_sources; //type: boolean
                        YLeaf dont_check_connected; //type: boolean
                        YLeaf register_received; //type: boolean
                        YLeaf last_hop; //type: boolean
                        YLeaf sending_registers; //type: boolean
                        YLeaf sending_null_registers; //type: boolean
                        YLeaf sa_sent; //type: boolean
                        YLeaf sa_received; //type: boolean
                        YLeaf sa_joined; //type: boolean
                        YLeaf anycast_rp_match; //type: boolean
                        YLeaf anycast_rp_route_target; //type: string
                        YLeaf bgp_join; //type: boolean
                        YLeaf bgpjp_time; //type: uint64
                        YLeaf customer_routing_type; //type: int32
                        YLeaf extranet_route; //type: boolean
                        YLeaf mofrr_active; //type: boolean
                        YLeaf mofrr_primary; //type: boolean
                        YLeaf mofrr_backup; //type: boolean
                        YLeaf vxlan; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::GroupAddressXr


                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::SourceAddressXr


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::RpAddress


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::RpfNeighbor


                    class SecondaryRpfNeighbor : public Entity
                    {
                        public:
                            SecondaryRpfNeighbor();
                            ~SecondaryRpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::RpfRoot


                    class ProxyAddress : public Entity
                    {
                        public:
                            ProxyAddress();
                            ~ProxyAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::ProxyAddress


                    class OrigSrcAddress : public Entity
                    {
                        public:
                            OrigSrcAddress();
                            ~OrigSrcAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Topologies::Topology::OrigSrcAddress


                    class OutgoingInterface : public Entity
                    {
                        public:
                            OutgoingInterface();
                            ~OutgoingInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_state; //type: int32
                            YLeaf assert_timer; //type: int32
                            YLeaf local_members; //type: int32
                            YLeaf internal_interest_info; //type: int32
                            YLeaf forwarding_state; //type: int32
                            YLeaf immediate_state; //type: int32
                            YLeaf last_hop; //type: boolean
                            YLeaf mldp_inband_mdt; //type: boolean
                            YLeaf mldp_stale; //type: boolean
                            YLeaf sa_prune; //type: boolean
                            YLeaf admin_boundary; //type: boolean
                            YLeaf igmp_membership; //type: boolean
                            YLeaf mdt_safi_join; //type: boolean
                            YLeaf mvpn_safi_join; //type: boolean
                            YLeaf local_mdt_join; //type: boolean
                            YLeaf data_mdt_join; //type: boolean
                            YLeaf mvp_nv6_safi_join; //type: boolean
                            YLeaf bgp_c_mcast_join; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf extranet_interface; //type: boolean

                        class AssertWinner : public Entity
                        {
                            public:
                                AssertWinner();
                                ~AssertWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                    }; // Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::OrigSrcAddress> orig_src_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::ProxyAddress> proxy_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology::SourceAddressXr> source_address_xr;


                }; // Pim::Active::DefaultContext::Topologies::Topology


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies::Topology> > topology;


            }; // Pim::Active::DefaultContext::Topologies


            class BgpAfs : public Entity
            {
                public:
                    BgpAfs();
                    ~BgpAfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BgpAf : public Entity
                {
                    public:
                        BgpAf();
                        ~BgpAf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf route_distinguisher; //type: string
                        YLeaf extranet_path_count; //type: uint32
                        YLeaf is_bgp_added; //type: boolean

                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::BgpAfs::BgpAf::Source


                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::BgpAfs::BgpAf::Group


                    class NextHop : public Entity
                    {
                        public:
                            NextHop();
                            ~NextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::BgpAfs::BgpAf::NextHop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BgpAfs::BgpAf::Group> group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BgpAfs::BgpAf::NextHop> next_hop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BgpAfs::BgpAf::Source> source;


                }; // Pim::Active::DefaultContext::BgpAfs::BgpAf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BgpAfs::BgpAf> > bgp_af;


            }; // Pim::Active::DefaultContext::BgpAfs


            class AutoRp : public Entity
            {
                public:
                    AutoRp();
                    ~AutoRp();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;





            }; // Pim::Active::DefaultContext::AutoRp


            class TopologyInterfaceFlagRouteCounts : public Entity
            {
                public:
                    TopologyInterfaceFlagRouteCounts();
                    ~TopologyInterfaceFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyInterfaceFlagRouteCount : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCount();
                        ~TopologyInterfaceFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                }; // Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


            }; // Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts


            class GroupMapSources : public Entity
            {
                public:
                    GroupMapSources();
                    ~GroupMapSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapSource : public Entity
                {
                    public:
                        GroupMapSource();
                        ~GroupMapSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf priority; //type: int32
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                }; // Pim::Active::DefaultContext::GroupMapSources::GroupMapSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapSources::GroupMapSource> > group_map_source;


            }; // Pim::Active::DefaultContext::GroupMapSources


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf inputs; //type: uint32
                    YLeaf outputs; //type: uint32
                    YLeaf format_error; //type: uint32
                    YLeaf pakman_error; //type: uint32
                    YLeaf standby_packets_error; //type: uint32
                    YLeaf checksum_error; //type: uint32
                    YLeaf socket_error; //type: uint32
                    YLeaf send_queue_full; //type: uint32
                    YLeaf boundary_acl_rx_drop; //type: uint32
                    YLeaf boundary_acl_tx_drop; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf no_source_address; //type: uint32
                    YLeaf input_hello; //type: uint32
                    YLeaf output_hello; //type: uint32
                    YLeaf input_jp; //type: uint32
                    YLeaf output_jp; //type: uint32
                    YLeaf input_data_register; //type: uint32
                    YLeaf input_null_register; //type: uint32
                    YLeaf output_data_register; //type: uint32
                    YLeaf output_null_register; //type: uint32
                    YLeaf input_register_stop; //type: uint32
                    YLeaf output_register_stop; //type: uint32
                    YLeaf input_assert; //type: uint32
                    YLeaf input_assert_batched; //type: uint32
                    YLeaf output_assert; //type: uint32
                    YLeaf output_assert_batched; //type: uint32
                    YLeaf input_df_election; //type: uint32
                    YLeaf output_df_election; //type: uint32
                    YLeaf input_bsr_message; //type: uint32
                    YLeaf output_bsr_message; //type: uint32
                    YLeaf input_candidate_rp_advertisement; //type: uint32
                    YLeaf output_candidate_rp_advertisement; //type: uint32
                    YLeaf input_ecmp_redirect; //type: uint32
                    YLeaf output_ecmp_redirect; //type: uint32
                    YLeaf output_loop_error; //type: uint32
                    YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                    YLeaf input_no_idb_error; //type: uint32
                    YLeaf input_no_vrf_error; //type: uint32
                    YLeaf input_no_pim_error; //type: uint32
                    YLeaf input_pim_version_error; //type: uint32
                    YLeaf output_join_group; //type: uint32
                    YLeaf output_prune_group; //type: uint32
                    YLeaf output_join_prune_bytes; //type: uint32
                    YLeaf output_hello_bytes; //type: uint32
                    YLeaf non_supported_packets; //type: uint32
                    YLeaf invalid_registers; //type: uint32
                    YLeaf invalid_join_prunes; //type: uint32
                    YLeaf packet_packman_error; //type: uint32
                    YLeaf packet_read_socket_error; //type: uint32
                    YLeaf packet_queue_last_clear; //type: uint32
                    YLeaf packets_standby; //type: uint32
                    YLeaf no_mdt_socket_connection; //type: uint32
                    YLeaf mdt_send_queue_full; //type: uint32
                    YLeaf mdt_socket_error; //type: uint32
                    YLeaf mdt_join_tlv_sent; //type: uint32
                    YLeaf mdt_join_tlv_received; //type: uint32
                    YLeaf mdt_join_bad_type; //type: uint32
                    YLeaf mdt_drop_local_source_address; //type: uint32
                    YLeaf mdt_drop_null_local_address; //type: uint32
                    YLeaf mdt_drop_no_idb; //type: uint32
                    YLeaf mdt_drop_no_vrf; //type: uint32
                    YLeaf invalid_destination_packets; //type: uint32
                    YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                    YLeaf truncated_pim_packets; //type: uint32
                    YLeafList packet_enqueued; //type: list of  uint32
                    YLeafList packet_dequeued; //type: list of  uint32
                    YLeafList packet_queue_length; //type: list of  uint32
                    YLeafList packet_queue_size; //type: list of  uint32
                    YLeafList packet_tail_drop; //type: list of  uint32

                class PacketQueue : public Entity
                {
                    public:
                        PacketQueue();
                        ~PacketQueue();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf packet_queue_priority; //type: uint32

                    class PacketQueueState : public Entity
                    {
                        public:
                            PacketQueueState();
                            ~PacketQueueState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf max_queue_size; //type: uint32
                            YLeaf queue_size_bytes; //type: uint32
                            YLeaf queue_size_packets; //type: uint32



                    }; // Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState


                    class PacketQueueStats : public Entity
                    {
                        public:
                            PacketQueueStats();
                            ~PacketQueueStats();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf enqueued_packets; //type: uint32
                            YLeaf dequeued_packets; //type: uint32
                            YLeaf high_water_mark_packets; //type: uint32
                            YLeaf high_water_mark_bytes; //type: uint32
                            YLeaf tail_drops; //type: uint32



                    }; // Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                }; // Pim::Active::DefaultContext::TrafficCounters::PacketQueue


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TrafficCounters::PacketQueue> > packet_queue;


            }; // Pim::Active::DefaultContext::TrafficCounters


            class GroupMapRpfs : public Entity
            {
                public:
                    GroupMapRpfs();
                    ~GroupMapRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapRpf : public Entity
                {
                    public:
                        GroupMapRpf();
                        ~GroupMapRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf rp_priority; //type: int32
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                }; // Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


            }; // Pim::Active::DefaultContext::GroupMapRpfs


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Pim::Active::DefaultContext::Summary


            class Gre : public Entity
            {
                public:
                    Gre();
                    ~Gre();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GreHashes : public Entity
                {
                    public:
                        GreHashes();
                        ~GreHashes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHash : public Entity
                    {
                        public:
                            GreHash();
                            ~GreHash();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf destination_address; //type: string
                            YLeaf ifname; //type: string
                            YLeaf next_hop_interface; //type: string



                    }; // Pim::Active::DefaultContext::Gre::GreHashes::GreHash


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreHashes::GreHash> > gre_hash;


                }; // Pim::Active::DefaultContext::Gre::GreHashes


                class GreNextHops : public Entity
                {
                    public:
                        GreNextHops();
                        ~GreNextHops();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreNextHop : public Entity
                    {
                        public:
                            GreNextHop();
                            ~GreNextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf destination_address; //type: string
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf is_connected; //type: uint8

                        class RegisteredAddress : public Entity
                        {
                            public:
                                RegisteredAddress();
                                ~RegisteredAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress


                        class GrePath : public Entity
                        {
                            public:
                                GrePath();
                                ~GrePath();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf gre_interface_name; //type: string
                                YLeaf is_gre_interface_disabled; //type: boolean
                                YLeaf is_via_lsm; //type: boolean
                                YLeaf is_connector_attribute_present; //type: boolean
                                YLeaf extranet_vrf_name; //type: string

                            class GreNeighbor : public Entity
                            {
                                public:
                                    GreNeighbor();
                                    ~GreNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                            class GreNextHop_ : public Entity
                            {
                                public:
                                    GreNextHop_();
                                    ~GreNextHop_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                        }; // Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                    }; // Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                }; // Pim::Active::DefaultContext::Gre::GreNextHops


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreHashes> gre_hashes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre::GreNextHops> gre_next_hops;


            }; // Pim::Active::DefaultContext::Gre


            class BidirDfWinners : public Entity
            {
                public:
                    BidirDfWinners();
                    ~BidirDfWinners();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfWinner : public Entity
                {
                    public:
                        BidirDfWinner();
                        ~BidirDfWinner();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf are_we_df; //type: boolean
                        YLeaf rp_lan; //type: boolean
                        YLeaf metric; //type: uint32
                        YLeaf metric_preference; //type: uint32
                        YLeaf uptime; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr


                    class DfWinner : public Entity
                    {
                        public:
                            DfWinner();
                            ~DfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                }; // Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


            }; // Pim::Active::DefaultContext::BidirDfWinners


            class TableContexts : public Entity
            {
                public:
                    TableContexts();
                    ~TableContexts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TableContext : public Entity
                {
                    public:
                        TableContext();
                        ~TableContext();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string
                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Pim::Active::DefaultContext::TableContexts::TableContext


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TableContexts::TableContext> > table_context;


            }; // Pim::Active::DefaultContext::TableContexts


            class GlobalInterfaces : public Entity
            {
                public:
                    GlobalInterfaces();
                    ~GlobalInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GlobalInterface : public Entity
                {
                    public:
                        GlobalInterface();
                        ~GlobalInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                }; // Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface> > global_interface;


            }; // Pim::Active::DefaultContext::GlobalInterfaces


            class NeighborSummaries : public Entity
            {
                public:
                    NeighborSummaries();
                    ~NeighborSummaries();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborSummary : public Entity
                {
                    public:
                        NeighborSummary();
                        ~NeighborSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf number_of_neighbors; //type: int32
                        YLeaf number_of_external_neighbors; //type: int32



                }; // Pim::Active::DefaultContext::NeighborSummaries::NeighborSummary


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NeighborSummaries::NeighborSummary> > neighbor_summary;


            }; // Pim::Active::DefaultContext::NeighborSummaries


            class Context : public Entity
            {
                public:
                    Context();
                    ~Context();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_id; //type: uint32
                    YLeaf table_id; //type: uint32
                    YLeaf murib_id; //type: uint32
                    YLeaf rpf_id; //type: uint32
                    YLeaf remote_table_id; //type: uint32
                    YLeaf mdt_default_group; //type: string
                    YLeaf mdt_interface; //type: string
                    YLeaf mdt_gre_rpf_identifier; //type: uint32
                    YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                    YLeaf is_unicast_rib_registration; //type: boolean
                    YLeaf is_multicast_rib_registration; //type: boolean
                    YLeaf is_active; //type: boolean
                    YLeaf is_active_ital; //type: boolean
                    YLeaf is_mrib_register; //type: boolean
                    YLeaf is_mdt_owner; //type: boolean
                    YLeaf is_routing_enabled; //type: boolean
                    YLeaf is_socket_add_required; //type: boolean
                    YLeaf is_socket_added; //type: boolean
                    YLeaf is_lpts_socket_add_required; //type: boolean
                    YLeaf is_lpts_socket_added; //type: boolean
                    YLeaf is_udp_socket_add_required; //type: boolean
                    YLeaf is_udp_socket_added; //type: boolean
                    YLeaf is_udp_socket_bind_required; //type: boolean
                    YLeaf is_udp_socket_bind; //type: boolean
                    YLeaf is_register_injection_socket_add_required; //type: boolean
                    YLeaf is_register_injection_socket_added; //type: boolean
                    YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                    YLeaf is_register_injection_lpts_socket_added; //type: boolean
                    YLeaf is_m_host_publish_pending; //type: boolean
                    YLeaf mhost_interface; //type: string
                    YLeaf mhost_default_interface_config; //type: string
                    YLeaf mdt_mtu; //type: uint32
                    YLeaf maximum_mdt_aggregation; //type: uint32
                    YLeaf mdt_data_switchover_interval; //type: uint32
                    YLeaf mdt_data_announce_interval; //type: uint32
                    YLeaf non_default_vrf_count_on_socket; //type: uint32
                    YLeaf neighbor_filter_name; //type: string
                    YLeaf mdt_neighbor_filter_name; //type: string
                    YLeaf allow_rp_configured; //type: boolean
                    YLeaf allow_rp_group_list; //type: string
                    YLeaf allow_rp_rp_list; //type: string
                    YLeaf sg_expiry_timer_configured; //type: boolean
                    YLeaf sg_expiry_time; //type: uint16
                    YLeaf sg_expiry_timer_sg_list; //type: string
                    YLeaf mldp_mdt_name; //type: string
                    YLeaf mldp_mdt_interface; //type: string
                    YLeaf mldp_mdt_mtu; //type: uint32
                    YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                    YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                    YLeaf mldp_mdt_data_announce_interval; //type: uint32
                    YLeaf mldp_mdt_rpf_identifier; //type: uint32
                    YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                    YLeaf is_create_mldp_mdt_interface; //type: boolean
                    YLeaf is_mldp_mdt_owner; //type: boolean
                    YLeaf mldp_root_count; //type: uint32
                    YLeaf mldp_head_lsm_identifier; //type: uint32
                    YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                    YLeaf organization_unique_identifier; //type: uint32
                    YLeaf vpn_index; //type: uint32
                    YLeaf mldp_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                    YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                    YLeaf mldp_head_local_label; //type: uint32
                    YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                    YLeaf bgp_auto_discovery_configured; //type: boolean
                    YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                    YLeaf inter_autonomous_system_enabled; //type: boolean
                    YLeaf bgp_source_active_announce; //type: boolean
                    YLeaf bgp_i_pmsi_added; //type: boolean
                    YLeaf mldp_bsr_control_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                    YLeaf bgp_auto_discovery_type; //type: uint32
                    YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                    YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                    YLeaf mldp_control_head_lsm_identifier; //type: uint32
                    YLeaf umh; //type: boolean
                    YLeaf suppress_shared_tree_join; //type: boolean
                    YLeaf rsvp_te_mdt_name; //type: string
                    YLeaf rsvp_te_mdt_interface; //type: string
                    YLeaf rsvp_te_mdt_mtu; //type: uint32
                    YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                    YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                    YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                    YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                    YLeaf is_rsvp_te_mdt_owner; //type: boolean
                    YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                    YLeaf p2mpte_li_drop; //type: uint32
                    YLeaf ir_mdt_name; //type: string
                    YLeaf ir_mdt_interface; //type: string
                    YLeaf ir_mdt_mtu; //type: uint32
                    YLeaf ir_maximum_mdt_aggregation; //type: uint32
                    YLeaf ir_mdt_data_switchover_interval; //type: uint32
                    YLeaf ir_mdt_data_announce_interval; //type: uint32
                    YLeaf ir_mdt_rpf_identifier; //type: uint32
                    YLeaf ir_mdt_tail_label; //type: uint32
                    YLeaf is_create_ir_mdt_interface; //type: boolean
                    YLeaf is_ir_mdt_owner; //type: boolean
                    YLeaf in_b_and_mdt_name; //type: string
                    YLeaf in_b_and_mdt_interface; //type: string
                    YLeaf in_b_and_mdt_mtu; //type: uint32
                    YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                    YLeaf is_in_b_and_mdt_owner; //type: boolean
                    YLeaf in_band_signaling_local_enabled; //type: boolean
                    YLeaf in_band_signaling_remote_enabled; //type: boolean
                    YLeaf valid_rd_present; //type: boolean
                    YLeaf stale_rd_present; //type: boolean
                    YLeaf route_distinguisher; //type: string
                    YLeaf gin_b_and_mdt_name; //type: string
                    YLeaf gin_b_and_mdt_interface; //type: string
                    YLeaf gin_b_and_mdt_mtu; //type: uint32
                    YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                    YLeaf is_gin_b_and_mdt_owner; //type: boolean
                    YLeaf is_pim_nsf_rib_converged; //type: boolean
                    YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                    YLeaf is_rib_multipath_enabled; //type: boolean
                    YLeaf is_rib_multipath_interface_hash; //type: boolean
                    YLeaf is_rib_multipath_source_hash; //type: boolean
                    YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf is_create_mdt_interface; //type: boolean
                    YLeaf is_auto_rp_listen_enabled; //type: boolean
                    YLeaf is_all_interface_disable_operation; //type: boolean
                    YLeaf is_default_granges; //type: boolean
                    YLeaf is_auto_rp_listen_sock_add; //type: boolean
                    YLeaf is_redistribution_reset; //type: boolean
                    YLeaf redistribution_reset_count; //type: uint32
                    YLeaf rpf_policy_name; //type: string
                    YLeaf table_count; //type: uint32
                    YLeaf active_table_count; //type: uint32
                    YLeaf anycast_rp_policy_name; //type: string
                    YLeaf anycast_rp_configured; //type: boolean
                    YLeaf bgp_remote_on; //type: boolean
                    YLeaf bgp_remote_interface_name; //type: string
                    YLeaf bgp_remote_interface; //type: string
                    YLeaf bgp_remote_address; //type: string
                    YLeaf bgp_remote_state; //type: uint32
                    YLeafList mldp_root_address; //type: list of  uint32

                class RemoteDefaultGroup : public Entity
                {
                    public:
                        RemoteDefaultGroup();
                        ~RemoteDefaultGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Pim::Active::DefaultContext::Context::RemoteDefaultGroup


                class RpfDefaultTable : public Entity
                {
                    public:
                        RpfDefaultTable();
                        ~RpfDefaultTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Pim::Active::DefaultContext::Context::RpfDefaultTable


                class ExportRouteTarget : public Entity
                {
                    public:
                        ExportRouteTarget();
                        ~ExportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Pim::Active::DefaultContext::Context::ExportRouteTarget


                class ImportRouteTarget : public Entity
                {
                    public:
                        ImportRouteTarget();
                        ~ImportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Pim::Active::DefaultContext::Context::ImportRouteTarget


                class AnycastRpRange : public Entity
                {
                    public:
                        AnycastRpRange();
                        ~AnycastRpRange();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix_length; //type: uint8
                        YLeaf ancast_rp_marked; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Context::AnycastRpRange::Prefix


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context::AnycastRpRange::Prefix> prefix;


                }; // Pim::Active::DefaultContext::Context::AnycastRpRange


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context::AnycastRpRange> > anycast_rp_range;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context::ExportRouteTarget> > export_route_target;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context::ImportRouteTarget> > import_route_target;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context::RemoteDefaultGroup> remote_default_group;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context::RpfDefaultTable> rpf_default_table;


            }; // Pim::Active::DefaultContext::Context


            class TopologyEntryFlagRouteCounts : public Entity
            {
                public:
                    TopologyEntryFlagRouteCounts();
                    ~TopologyEntryFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyEntryFlagRouteCount : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCount();
                        ~TopologyEntryFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                }; // Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


            }; // Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts


            class RpfRedirect : public Entity
            {
                public:
                    RpfRedirect();
                    ~RpfRedirect();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RedirectRouteDatabases : public Entity
                {
                    public:
                        RedirectRouteDatabases();
                        ~RedirectRouteDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabase : public Entity
                    {
                        public:
                            RedirectRouteDatabase();
                            ~RedirectRouteDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf bandwidth; //type: uint32
                            YLeaf uptime; //type: uint64

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                        class Interface : public Entity
                        {
                            public:
                                Interface();
                                ~Interface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf is_rpf_interface; //type: boolean
                                YLeaf is_outgoing_interface; //type: boolean
                                YLeaf is_snoop_interface; //type: boolean

                            class RpfAddress : public Entity
                            {
                                public:
                                    RpfAddress();
                                    ~RpfAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                        }; // Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                    }; // Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                }; // Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases


                class BundleInterfaces : public Entity
                {
                    public:
                        BundleInterfaces();
                        ~BundleInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BundleInterface : public Entity
                    {
                        public:
                            BundleInterface();
                            ~BundleInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf bundle_name; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf rpf_redirect_bundle_name; //type: string
                            YLeaf rpf_redirect_interface_name; //type: string
                            YLeaf available_bandwidth; //type: int32
                            YLeaf allocated_bandwidth; //type: int32
                            YLeaf total_bandwidth; //type: int32
                            YLeaf topology_bandwidth_used; //type: int32
                            YLeaf snooping_bandwidth_used; //type: int32
                            YLeaf allocated_threshold_bandwidth; //type: int32
                            YLeaf available_threshold_bandwidth; //type: int32



                    }; // Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                }; // Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces> bundle_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


            }; // Pim::Active::DefaultContext::RpfRedirect


            class Tunnels : public Entity
            {
                public:
                    Tunnels();
                    ~Tunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Tunnel : public Entity
                {
                    public:
                        Tunnel();
                        ~Tunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Tunnels::Tunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Tunnels::Tunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Tunnels::Tunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                }; // Pim::Active::DefaultContext::Tunnels::Tunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Tunnels::Tunnel> > tunnel;


            }; // Pim::Active::DefaultContext::Tunnels


            class MulticastStaticRoutes : public Entity
            {
                public:
                    MulticastStaticRoutes();
                    ~MulticastStaticRoutes();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MulticastStaticRoute : public Entity
                {
                    public:
                        MulticastStaticRoute();
                        ~MulticastStaticRoute();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf address; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf interface_name; //type: string
                        YLeaf distance; //type: uint32
                        YLeaf prefix_length_xr; //type: uint8
                        YLeaf is_via_lsm; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                    class Nexthop : public Entity
                    {
                        public:
                            Nexthop();
                            ~Nexthop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                }; // Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


            }; // Pim::Active::DefaultContext::MulticastStaticRoutes


            class GroupMapMatchSources : public Entity
            {
                public:
                    GroupMapMatchSources();
                    ~GroupMapMatchSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchSource : public Entity
                {
                    public:
                        GroupMapMatchSource();
                        ~GroupMapMatchSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                }; // Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


            }; // Pim::Active::DefaultContext::GroupMapMatchSources


            class Neighbors : public Entity
            {
                public:
                    Neighbors();
                    ~Neighbors();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Neighbor : public Entity
                {
                    public:
                        Neighbor();
                        ~Neighbor();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::DefaultContext::Neighbors::Neighbor::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                }; // Pim::Active::DefaultContext::Neighbors::Neighbor


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Neighbors::Neighbor> > neighbor;


            }; // Pim::Active::DefaultContext::Neighbors


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::AutoRp> auto_rp;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BgpAfs> bgp_afs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfStates> bidir_df_states;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::BidirDfWinners> bidir_df_winners;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Bsr> bsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Context> context;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GlobalInterfaces> global_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Gre> gre;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchRpfs> group_map_match_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapMatchSources> group_map_match_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapRpfs> group_map_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::GroupMapSources> group_map_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::IfrsSummary> ifrs_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::InterfaceStatistics> interface_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Interfaces> interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::JpStatistics> jp_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MibDatabases> mib_databases;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::MulticastStaticRoutes> multicast_static_routes;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NeighborOldFormats> neighbor_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NeighborSummaries> neighbor_summaries;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Neighbors> neighbors;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::NetIoTunnels> net_io_tunnels;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RoutePolicy> route_policy;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfRedirect> rpf_redirect;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::RpfSummary> rpf_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Safs> safs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TableContexts> table_contexts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Topologies> topologies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TopologyRouteCount> topology_route_count;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::TrafficCounters> traffic_counters;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext::Tunnels> tunnels;


        }; // Pim::Active::DefaultContext


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class CheckpointStatistics : public Entity
            {
                public:
                    CheckpointStatistics();
                    ~CheckpointStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class CheckpointTable : public Entity
                {
                    public:
                        CheckpointTable();
                        ~CheckpointTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf table_description; //type: string
                        YLeaf table_name; //type: uint32
                        YLeaf is_mirrored; //type: boolean
                        YLeafList statistic; //type: list of  uint32



                }; // Pim::Active::Process::CheckpointStatistics::CheckpointTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process::CheckpointStatistics::CheckpointTable> > checkpoint_table;


            }; // Pim::Active::Process::CheckpointStatistics


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_connected; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf rmf_timer_valid; //type: boolean
                    YLeaf rmf_timer_expiry; //type: uint64
                    YLeaf last_connection_up; //type: uint64
                    YLeaf last_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_connection_up; //type: uint32
                    YLeaf count_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Pim::Active::Process::Nsr


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Pim::Active::Process::Summary


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf configured_state; //type: boolean
                    YLeaf nsf_state; //type: boolean
                    YLeaf nsf_timeout; //type: uint32
                    YLeaf nsf_time_left; //type: uint32
                    YLeaf waiting_timer; //type: boolean
                    YLeaf waiting_membership; //type: boolean
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_sec; //type: int32
                    YLeaf last_nsf_off_sec; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_sec; //type: int32



            }; // Pim::Active::Process::Nsf


            class Issu : public Entity
            {
                public:
                    Issu();
                    ~Issu();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf informationvalid; //type: boolean
                    YLeaf role_ha; //type: int32
                    YLeaf role_issu; //type: int32
                    YLeaf phase_issu; //type: int32
                    YLeaf ha_option_issu; //type: int32
                    YLeaf last_ready_bool; //type: boolean
                    YLeaf last_ready_sent; //type: uint64
                    YLeaf last_ha_role_notification_received; //type: uint64
                    YLeaf last_issu_role_notification_received; //type: uint64
                    YLeaf last_issu_phase_notification_received; //type: uint64
                    YLeaf is_eoc_received; //type: boolean
                    YLeaf eoc_received_timestamp; //type: uint64
                    YLeaf is_ihms_done_received; //type: boolean
                    YLeaf ihms_received_timestamp; //type: uint64
                    YLeaf is_rib_sync_received; //type: boolean
                    YLeaf rib_sync_received_timestamp; //type: uint64
                    YLeaf is_nbr_sync_received; //type: boolean
                    YLeaf nbr_sync_received_timestamp; //type: uint64



            }; // Pim::Active::Process::Issu


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process::CheckpointStatistics> checkpoint_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process::Issu> issu;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process::Summary> summary;


        }; // Pim::Active::Process


        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                    }; // Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Pim::Active::Vrfs::Vrf::IfrsInterfaces


                class Safs : public Entity
                {
                    public:
                        Safs();
                        ~Safs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Saf : public Entity
                    {
                        public:
                            Saf();
                            ~Saf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string

                        class RpfHashSourceGroups : public Entity
                        {
                            public:
                                RpfHashSourceGroups();
                                ~RpfHashSourceGroups();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSourceGroup : public Entity
                            {
                                public:
                                    RpfHashSourceGroup();
                                    ~RpfHashSourceGroup();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf group_address; //type: string
                                    YLeaf mask_length; //type: int32
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                        }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups


                        class RpfNeighbors : public Entity
                        {
                            public:
                                RpfNeighbors();
                                ~RpfNeighbors();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfNeighbor : public Entity
                            {
                                public:
                                    RpfNeighbor();
                                    ~RpfNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf neighbor_address; //type: string
                                    YLeaf rib_neighbor_interface; //type: string

                                class RibNeighborAddress : public Entity
                                {
                                    public:
                                        RibNeighborAddress();
                                        ~RibNeighborAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                                class RpfRegisteredAddresses : public Entity
                                {
                                    public:
                                        RpfRegisteredAddresses();
                                        ~RpfRegisteredAddresses();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_registered_address_references; //type: uint32

                                    class RibRegistrationAddress : public Entity
                                    {
                                        public:
                                            RibRegistrationAddress();
                                            ~RibRegistrationAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                            }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                        }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors


                        class RpfHashSources : public Entity
                        {
                            public:
                                RpfHashSources();
                                ~RpfHashSources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSource : public Entity
                            {
                                public:
                                    RpfHashSource();
                                    ~RpfHashSource();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                        }; // Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources


                        class Rpfs : public Entity
                        {
                            public:
                                Rpfs();
                                ~Rpfs();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class Rpf : public Entity
                            {
                                public:
                                    Rpf();
                                    ~Rpf();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf registered_address; //type: string
                                    YLeaf metric; //type: uint32
                                    YLeaf metric_preference; //type: uint32
                                    YLeaf is_connected; //type: uint8
                                    YLeaf is_rpf_bgp_route; //type: boolean

                                class RegisteredAddressXr : public Entity
                                {
                                    public:
                                        RegisteredAddressXr();
                                        ~RegisteredAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                                class RpfPath : public Entity
                                {
                                    public:
                                        RpfPath();
                                        ~RpfPath();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_interface_name; //type: string
                                        YLeaf is_rpf_interface_disabled; //type: boolean
                                        YLeaf is_via_lsm; //type: boolean
                                        YLeaf is_via_mlsm; //type: boolean
                                        YLeaf is_connector_attribute_present; //type: boolean
                                        YLeaf connector; //type: string
                                        YLeaf extranet_vrf_name; //type: string

                                    class RpfNeighbor : public Entity
                                    {
                                        public:
                                            RpfNeighbor();
                                            ~RpfNeighbor();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                    class RpfNexthop : public Entity
                                    {
                                        public:
                                            RpfNexthop();
                                            ~RpfNexthop();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                                }; // Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                            }; // Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf> > rpf;


                        }; // Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources> rpf_hash_sources;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors> rpf_neighbors;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs> rpfs;


                    }; // Pim::Active::Vrfs::Vrf::Safs::Saf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs::Saf> > saf;


                }; // Pim::Active::Vrfs::Vrf::Safs


                class InterfaceStatistics : public Entity
                {
                    public:
                        InterfaceStatistics();
                        ~InterfaceStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStatistic : public Entity
                    {
                        public:
                            InterfaceStatistic();
                            ~InterfaceStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf input_hello; //type: uint32
                            YLeaf output_hello; //type: uint32
                            YLeaf input_register; //type: uint32
                            YLeaf output_register; //type: uint32
                            YLeaf input_register_stop; //type: uint32
                            YLeaf output_register_stop; //type: uint32
                            YLeaf input_jp; //type: uint32
                            YLeaf output_jp; //type: uint32
                            YLeaf input_bsr_message; //type: uint32
                            YLeaf output_bsr_message; //type: uint32
                            YLeaf input_assert; //type: uint32
                            YLeaf output_assert; //type: uint32
                            YLeaf input_graft_message; //type: uint32
                            YLeaf output_graft_message; //type: uint32
                            YLeaf input_graft_ack_message; //type: uint32
                            YLeaf output_graft_ack_message; //type: uint32
                            YLeaf input_candidate_rp_advertisement; //type: uint32
                            YLeaf output_candidate_rp_advertisement; //type: uint32
                            YLeaf input_df_election; //type: uint32
                            YLeaf output_df_election; //type: uint32
                            YLeaf input_miscellaneous; //type: uint32



                    }; // Pim::Active::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


                }; // Pim::Active::Vrfs::Vrf::InterfaceStatistics


                class TopologyRouteCount : public Entity
                {
                    public:
                        TopologyRouteCount();
                        ~TopologyRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::Vrfs::Vrf::TopologyRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyRouteCount::GroupAddress> group_address;


                }; // Pim::Active::Vrfs::Vrf::TopologyRouteCount


                class JpStatistics : public Entity
                {
                    public:
                        JpStatistics();
                        ~JpStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JpStatistic : public Entity
                    {
                        public:
                            JpStatistic();
                            ~JpStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf mtu; //type: uint32
                            YLeaf transmitted; //type: uint32
                            YLeaf transmitted100; //type: uint16
                            YLeaf transmitted_1k; //type: uint16
                            YLeaf transmitted_10k; //type: uint16
                            YLeaf transmitted_50k; //type: uint16
                            YLeaf received; //type: uint32
                            YLeaf received100; //type: uint16
                            YLeaf received_1k; //type: uint16
                            YLeaf received_10k; //type: uint16
                            YLeaf received_50k; //type: uint16



                    }; // Pim::Active::Vrfs::Vrf::JpStatistics::JpStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::JpStatistics::JpStatistic> > jp_statistic;


                }; // Pim::Active::Vrfs::Vrf::JpStatistics


                class MibDatabases : public Entity
                {
                    public:
                        MibDatabases();
                        ~MibDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MibDatabase : public Entity
                    {
                        public:
                            MibDatabase();
                            ~MibDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf source_netmask; //type: int32
                            YLeaf upstream_assert_timer; //type: int32
                            YLeaf assert_metric; //type: uint32
                            YLeaf assert_metric_preference; //type: uint32
                            YLeaf assert_rpt_bit; //type: boolean
                            YLeaf spt_bit; //type: boolean
                            YLeaf rpf_mask; //type: uint32
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf bidirectional_route; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf protocol; //type: PimShowProtocolEnum

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                    }; // Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase> > mib_database;


                }; // Pim::Active::Vrfs::Vrf::MibDatabases


                class GroupMapMatchRpfs : public Entity
                {
                    public:
                        GroupMapMatchRpfs();
                        ~GroupMapMatchRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchRpf : public Entity
                    {
                        public:
                            GroupMapMatchRpf();
                            ~GroupMapMatchRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                    }; // Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


                }; // Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs


                class NeighborOldFormats : public Entity
                {
                    public:
                        NeighborOldFormats();
                        ~NeighborOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborOldFormat : public Entity
                    {
                        public:
                            NeighborOldFormat();
                            ~NeighborOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                    }; // Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


                }; // Pim::Active::Vrfs::Vrf::NeighborOldFormats


                class IfrsSummary : public Entity
                {
                    public:
                        IfrsSummary();
                        ~IfrsSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Pim::Active::Vrfs::Vrf::IfrsSummary


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf client_xr; //type: PimShowRangeClientEnum
                            YLeaf expires; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Ranges::Range::RpAddressXr


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Ranges::Range::SourceOfInformation


                        class GroupRange : public Entity
                        {
                            public:
                                GroupRange();
                                ~GroupRange();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf uptime; //type: uint64
                                YLeaf expires; //type: uint64

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix


                            class SourceOfInformation : public Entity
                            {
                                public:
                                    SourceOfInformation();
                                    ~SourceOfInformation();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                        }; // Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange> > group_range;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges::Range::RpAddressXr> rp_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges::Range::SourceOfInformation> source_of_information;


                    }; // Pim::Active::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges::Range> > range;


                }; // Pim::Active::Vrfs::Vrf::Ranges


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                    }; // Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Pim::Active::Vrfs::Vrf::InterfaceOldFormats


                class Bsr : public Entity
                {
                    public:
                        Bsr();
                        ~Bsr();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCaches : public Entity
                    {
                        public:
                            RpCaches();
                            ~RpCaches();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpCache : public Entity
                        {
                            public:
                                RpCache();
                                ~RpCache();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf group_prefix; //type: string
                                YLeaf group_prefix_length; //type: uint32
                                YLeaf candidate_rp_group_count; //type: uint32

                            class GroupPrefixXr : public Entity
                            {
                                public:
                                    GroupPrefixXr();
                                    ~GroupPrefixXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr


                            class CandidateRpList : public Entity
                            {
                                public:
                                    CandidateRpList();
                                    ~CandidateRpList();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;



                                class PimBsrCrpBag : public Entity
                                {
                                    public:
                                        PimBsrCrpBag();
                                        ~PimBsrCrpBag();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf candidate_rp_holdtime; //type: uint16
                                        YLeaf candidate_rp_priority; //type: uint8
                                        YLeaf candidate_rp_up_time; //type: uint16
                                        YLeaf candidate_rp_expires; //type: uint16
                                        YLeaf protocol; //type: PimShowProtocolEnum

                                    class CandidateRpAddress : public Entity
                                    {
                                        public:
                                            CandidateRpAddress();
                                            ~CandidateRpAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                                }; // Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                            }; // Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                        }; // Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache> > rp_cache;


                    }; // Pim::Active::Vrfs::Vrf::Bsr::RpCaches


                    class CandidateRps : public Entity
                    {
                        public:
                            CandidateRps();
                            ~CandidateRps();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class CandidateRp : public Entity
                        {
                            public:
                                CandidateRp();
                                ~CandidateRp();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf rp_address; //type: string
                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf candidate_rp_scope; //type: int32
                                YLeaf crp_priority; //type: uint8
                                YLeaf crp_holdtime; //type: uint16
                                YLeaf candidate_rp_advance_interval; //type: uint16
                                YLeaf candidate_rp_uptime; //type: uint16
                                YLeaf acl_name; //type: string

                            class CandidateRp_ : public Entity
                            {
                                public:
                                    CandidateRp_();
                                    ~CandidateRp_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_


                            class CrpAccess : public Entity
                            {
                                public:
                                    CrpAccess();
                                    ~CrpAccess();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                    YLeaf acl_name; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                        }; // Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                    }; // Pim::Active::Vrfs::Vrf::Bsr::CandidateRps


                    class BsrElections : public Entity
                    {
                        public:
                            BsrElections();
                            ~BsrElections();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BsrElection : public Entity
                        {
                            public:
                                BsrElection();
                                ~BsrElection();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf pim_scope; //type: int32
                                YLeaf bsr_priority; //type: uint8
                                YLeaf bsr_mask_length; //type: uint8
                                YLeaf bsr_up_time; //type: uint16
                                YLeaf bootstrap_timeout; //type: uint16
                                YLeaf candidate_bsr_state; //type: uint32
                                YLeaf bsr_election_state; //type: uint32
                                YLeaf bsr_scope; //type: uint16
                                YLeaf candidate_bsr_flag; //type: boolean
                                YLeaf candidate_bsr_priority; //type: uint8
                                YLeaf candidate_bsr_mask_length; //type: uint8

                            class BsrAddress : public Entity
                            {
                                public:
                                    BsrAddress();
                                    ~BsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress


                            class CandidateBsrAddress : public Entity
                            {
                                public:
                                    CandidateBsrAddress();
                                    ~CandidateBsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                        }; // Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection> > bsr_election;


                    }; // Pim::Active::Vrfs::Vrf::Bsr::BsrElections


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::BsrElections> bsr_elections;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::CandidateRps> candidate_rps;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr::RpCaches> rp_caches;


                }; // Pim::Active::Vrfs::Vrf::Bsr


                class RoutePolicy : public Entity
                {
                    public:
                        RoutePolicy();
                        ~RoutePolicy();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyStatistics : public Entity
                    {
                        public:
                            RoutePolicyStatistics();
                            ~RoutePolicyStatistics();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf policy_name; //type: string
                            YLeaf requests; //type: uint32
                            YLeaf pass; //type: uint32
                            YLeaf drop; //type: uint32
                            YLeaf default_table; //type: uint32
                            YLeaf any_table; //type: uint32



                    }; // Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics


                    class RoutePolicyTests : public Entity
                    {
                        public:
                            RoutePolicyTests();
                            ~RoutePolicyTests();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RoutePolicyTest : public Entity
                        {
                            public:
                                RoutePolicyTest();
                                ~RoutePolicyTest();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf ext_comm; //type: string
                                YLeaf policy_name; //type: string
                                YLeaf extended_community_rt; //type: string
                                YLeaf pass; //type: boolean
                                YLeaf default_table; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf afi; //type: uint32
                                YLeaf safi; //type: uint32
                                YLeaf table_name; //type: string
                                YLeaf table_exists; //type: boolean
                                YLeaf table_active; //type: boolean

                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                        }; // Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                    }; // Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests> route_policy_tests;


                }; // Pim::Active::Vrfs::Vrf::RoutePolicy


                class RpfSummary : public Entity
                {
                    public:
                        RpfSummary();
                        ~RpfSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf default_safi; //type: uint32
                        YLeaf default_table_name; //type: string
                        YLeaf is_mbgp_configured; //type: boolean
                        YLeaf is_ospf_te_configured; //type: boolean
                        YLeaf is_isis_te_configured; //type: boolean
                        YLeaf is_isis_mtr_configured; //type: boolean
                        YLeaf mo_frr_configured; //type: boolean
                        YLeaf rib_mo_frr_configured; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf rib_convergence_timeout; //type: uint32
                        YLeaf rib_convergence_time_left; //type: uint32
                        YLeaf is_multipath_enabled; //type: boolean
                        YLeaf is_multipath_interface_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                        YLeaf rpf_registrations; //type: uint32
                        YLeaf is_rib_convergence; //type: boolean



                }; // Pim::Active::Vrfs::Vrf::RpfSummary


                class Interfaces : public Entity
                {
                    public:
                        Interfaces();
                        ~Interfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Interfaces::Interface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Interfaces::Interface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress> > interface_address;


                    }; // Pim::Active::Vrfs::Vrf::Interfaces::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Interfaces::Interface> > interface;


                }; // Pim::Active::Vrfs::Vrf::Interfaces


                class NetIoTunnels : public Entity
                {
                    public:
                        NetIoTunnels();
                        ~NetIoTunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NetIoTunnel : public Entity
                    {
                        public:
                            NetIoTunnel();
                            ~NetIoTunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                    }; // Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


                }; // Pim::Active::Vrfs::Vrf::NetIoTunnels


                class BidirDfStates : public Entity
                {
                    public:
                        BidirDfStates();
                        ~BidirDfStates();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfState : public Entity
                    {
                        public:
                            BidirDfState();
                            ~BidirDfState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf election_state; //type: string
                            YLeaf time_seconds; //type: uint64
                            YLeaf time_nano_seconds; //type: uint64
                            YLeaf our_metric; //type: uint32
                            YLeaf our_metric_preference; //type: uint32

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                    }; // Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState> > bidir_df_state;


                }; // Pim::Active::Vrfs::Vrf::BidirDfStates


                class Topologies : public Entity
                {
                    public:
                        Topologies();
                        ~Topologies();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Topology : public Entity
                    {
                        public:
                            Topology();
                            ~Topology();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf rpt; //type: int32
                            YLeaf limit_reached; //type: boolean
                            YLeaf low_memory; //type: boolean
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf wildcard; //type: boolean
                            YLeaf rpt_xr; //type: boolean
                            YLeaf spt; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf alive; //type: int32
                            YLeaf register_received_timer; //type: int32
                            YLeaf remote_source; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf is_via_lsm; //type: boolean
                            YLeaf secondary_rpf_interface_name; //type: string
                            YLeaf connected; //type: boolean
                            YLeaf proxy; //type: boolean
                            YLeaf rpf_proxy_enabled; //type: boolean
                            YLeaf mofrr_enabled; //type: boolean
                            YLeaf rib_mo_frr_enabled; //type: boolean
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_status; //type: int32
                            YLeaf suppress_registers; //type: int32
                            YLeaf assume_alive; //type: boolean
                            YLeaf probe_alive; //type: boolean
                            YLeaf really_alive; //type: boolean
                            YLeaf inherit_alive; //type: boolean
                            YLeaf inherit_spt; //type: boolean
                            YLeaf signal_sources; //type: boolean
                            YLeaf dont_check_connected; //type: boolean
                            YLeaf register_received; //type: boolean
                            YLeaf last_hop; //type: boolean
                            YLeaf sending_registers; //type: boolean
                            YLeaf sending_null_registers; //type: boolean
                            YLeaf sa_sent; //type: boolean
                            YLeaf sa_received; //type: boolean
                            YLeaf sa_joined; //type: boolean
                            YLeaf anycast_rp_match; //type: boolean
                            YLeaf anycast_rp_route_target; //type: string
                            YLeaf bgp_join; //type: boolean
                            YLeaf bgpjp_time; //type: uint64
                            YLeaf customer_routing_type; //type: int32
                            YLeaf extranet_route; //type: boolean
                            YLeaf mofrr_active; //type: boolean
                            YLeaf mofrr_primary; //type: boolean
                            YLeaf mofrr_backup; //type: boolean
                            YLeaf vxlan; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::SourceAddressXr


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::RpAddress


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfNeighbor


                        class SecondaryRpfNeighbor : public Entity
                        {
                            public:
                                SecondaryRpfNeighbor();
                                ~SecondaryRpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfRoot


                        class ProxyAddress : public Entity
                        {
                            public:
                                ProxyAddress();
                                ~ProxyAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::ProxyAddress


                        class OrigSrcAddress : public Entity
                        {
                            public:
                                OrigSrcAddress();
                                ~OrigSrcAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress


                        class OutgoingInterface : public Entity
                        {
                            public:
                                OutgoingInterface();
                                ~OutgoingInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                                YLeaf jp_timer; //type: int32
                                YLeaf jp_state; //type: int32
                                YLeaf assert_timer; //type: int32
                                YLeaf local_members; //type: int32
                                YLeaf internal_interest_info; //type: int32
                                YLeaf forwarding_state; //type: int32
                                YLeaf immediate_state; //type: int32
                                YLeaf last_hop; //type: boolean
                                YLeaf mldp_inband_mdt; //type: boolean
                                YLeaf mldp_stale; //type: boolean
                                YLeaf sa_prune; //type: boolean
                                YLeaf admin_boundary; //type: boolean
                                YLeaf igmp_membership; //type: boolean
                                YLeaf mdt_safi_join; //type: boolean
                                YLeaf mvpn_safi_join; //type: boolean
                                YLeaf local_mdt_join; //type: boolean
                                YLeaf data_mdt_join; //type: boolean
                                YLeaf mvp_nv6_safi_join; //type: boolean
                                YLeaf bgp_c_mcast_join; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf extranet_interface; //type: boolean

                            class AssertWinner : public Entity
                            {
                                public:
                                    AssertWinner();
                                    ~AssertWinner();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                        }; // Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress> orig_src_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::ProxyAddress> proxy_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology::SourceAddressXr> source_address_xr;


                    }; // Pim::Active::Vrfs::Vrf::Topologies::Topology


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies::Topology> > topology;


                }; // Pim::Active::Vrfs::Vrf::Topologies


                class BgpAfs : public Entity
                {
                    public:
                        BgpAfs();
                        ~BgpAfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BgpAf : public Entity
                    {
                        public:
                            BgpAf();
                            ~BgpAf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf route_distinguisher; //type: string
                            YLeaf extranet_path_count; //type: uint32
                            YLeaf is_bgp_added; //type: boolean

                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Source


                        class Group : public Entity
                        {
                            public:
                                Group();
                                ~Group();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Group


                        class NextHop : public Entity
                        {
                            public:
                                NextHop();
                                ~NextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::NextHop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Group> group;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::NextHop> next_hop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Source> source;


                    }; // Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf> > bgp_af;


                }; // Pim::Active::Vrfs::Vrf::BgpAfs


                class AutoRp : public Entity
                {
                    public:
                        AutoRp();
                        ~AutoRp();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;





                }; // Pim::Active::Vrfs::Vrf::AutoRp


                class TopologyInterfaceFlagRouteCounts : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCounts();
                        ~TopologyInterfaceFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyInterfaceFlagRouteCount : public Entity
                    {
                        public:
                            TopologyInterfaceFlagRouteCount();
                            ~TopologyInterfaceFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                    }; // Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


                }; // Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts


                class GroupMapSources : public Entity
                {
                    public:
                        GroupMapSources();
                        ~GroupMapSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapSource : public Entity
                    {
                        public:
                            GroupMapSource();
                            ~GroupMapSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf priority; //type: int32
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                    }; // Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource> > group_map_source;


                }; // Pim::Active::Vrfs::Vrf::GroupMapSources


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf inputs; //type: uint32
                        YLeaf outputs; //type: uint32
                        YLeaf format_error; //type: uint32
                        YLeaf pakman_error; //type: uint32
                        YLeaf standby_packets_error; //type: uint32
                        YLeaf checksum_error; //type: uint32
                        YLeaf socket_error; //type: uint32
                        YLeaf send_queue_full; //type: uint32
                        YLeaf boundary_acl_rx_drop; //type: uint32
                        YLeaf boundary_acl_tx_drop; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf no_source_address; //type: uint32
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_data_register; //type: uint32
                        YLeaf input_null_register; //type: uint32
                        YLeaf output_data_register; //type: uint32
                        YLeaf output_null_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf input_assert_batched; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf output_assert_batched; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_ecmp_redirect; //type: uint32
                        YLeaf output_ecmp_redirect; //type: uint32
                        YLeaf output_loop_error; //type: uint32
                        YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                        YLeaf input_no_idb_error; //type: uint32
                        YLeaf input_no_vrf_error; //type: uint32
                        YLeaf input_no_pim_error; //type: uint32
                        YLeaf input_pim_version_error; //type: uint32
                        YLeaf output_join_group; //type: uint32
                        YLeaf output_prune_group; //type: uint32
                        YLeaf output_join_prune_bytes; //type: uint32
                        YLeaf output_hello_bytes; //type: uint32
                        YLeaf non_supported_packets; //type: uint32
                        YLeaf invalid_registers; //type: uint32
                        YLeaf invalid_join_prunes; //type: uint32
                        YLeaf packet_packman_error; //type: uint32
                        YLeaf packet_read_socket_error; //type: uint32
                        YLeaf packet_queue_last_clear; //type: uint32
                        YLeaf packets_standby; //type: uint32
                        YLeaf no_mdt_socket_connection; //type: uint32
                        YLeaf mdt_send_queue_full; //type: uint32
                        YLeaf mdt_socket_error; //type: uint32
                        YLeaf mdt_join_tlv_sent; //type: uint32
                        YLeaf mdt_join_tlv_received; //type: uint32
                        YLeaf mdt_join_bad_type; //type: uint32
                        YLeaf mdt_drop_local_source_address; //type: uint32
                        YLeaf mdt_drop_null_local_address; //type: uint32
                        YLeaf mdt_drop_no_idb; //type: uint32
                        YLeaf mdt_drop_no_vrf; //type: uint32
                        YLeaf invalid_destination_packets; //type: uint32
                        YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                        YLeaf truncated_pim_packets; //type: uint32
                        YLeafList packet_enqueued; //type: list of  uint32
                        YLeafList packet_dequeued; //type: list of  uint32
                        YLeafList packet_queue_length; //type: list of  uint32
                        YLeafList packet_queue_size; //type: list of  uint32
                        YLeafList packet_tail_drop; //type: list of  uint32

                    class PacketQueue : public Entity
                    {
                        public:
                            PacketQueue();
                            ~PacketQueue();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf packet_queue_priority; //type: uint32

                        class PacketQueueState : public Entity
                        {
                            public:
                                PacketQueueState();
                                ~PacketQueueState();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf max_queue_size; //type: uint32
                                YLeaf queue_size_bytes; //type: uint32
                                YLeaf queue_size_packets; //type: uint32



                        }; // Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState


                        class PacketQueueStats : public Entity
                        {
                            public:
                                PacketQueueStats();
                                ~PacketQueueStats();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf enqueued_packets; //type: uint32
                                YLeaf dequeued_packets; //type: uint32
                                YLeaf high_water_mark_packets; //type: uint32
                                YLeaf high_water_mark_bytes; //type: uint32
                                YLeaf tail_drops; //type: uint32



                        }; // Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                    }; // Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue> > packet_queue;


                }; // Pim::Active::Vrfs::Vrf::TrafficCounters


                class GroupMapRpfs : public Entity
                {
                    public:
                        GroupMapRpfs();
                        ~GroupMapRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapRpf : public Entity
                    {
                        public:
                            GroupMapRpf();
                            ~GroupMapRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf rp_priority; //type: int32
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                    }; // Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


                }; // Pim::Active::Vrfs::Vrf::GroupMapRpfs


                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_limit; //type: uint32
                        YLeaf route_count; //type: uint32
                        YLeaf route_low_water_mark; //type: uint32
                        YLeaf is_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_limit; //type: uint32
                        YLeaf topology_interface_state_count; //type: uint32
                        YLeaf rxi_low_water_mark; //type: uint32
                        YLeaf rxi_limit_reached; //type: boolean
                        YLeaf register_limit; //type: uint32
                        YLeaf register_count; //type: uint32
                        YLeaf register_limit_reached; //type: boolean
                        YLeaf ranges_limit; //type: uint32
                        YLeaf ranges_count; //type: uint32
                        YLeaf ranges_threshold; //type: uint32
                        YLeaf is_ranges_limit_reached; //type: boolean
                        YLeaf bsr_ranges_limit; //type: uint32
                        YLeaf bsr_ranges_count; //type: uint32
                        YLeaf bsr_range_threshold; //type: uint32
                        YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                        YLeaf bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf bsr_candidate_rp_set_count; //type: uint32
                        YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_maximum_enforcement_disabled; //type: boolean
                        YLeaf is_node_low_memory; //type: boolean
                        YLeaf route_threshold; //type: uint32
                        YLeaf global_auto_rp_ranges_limit; //type: uint32
                        YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_ranges_limit; //type: uint32
                        YLeaf global_bsr_ranges_count; //type: uint32
                        YLeaf global_bsr_ranges_threshold; //type: uint32
                        YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_global_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_threshold; //type: uint32
                        YLeaf is_global_rxi_limit_reached; //type: boolean
                        YLeaf register_threshold; //type: uint32
                        YLeaf global_register_limit; //type: uint32
                        YLeaf is_global_register_limit_reached; //type: boolean



                }; // Pim::Active::Vrfs::Vrf::Summary


                class Gre : public Entity
                {
                    public:
                        Gre();
                        ~Gre();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHashes : public Entity
                    {
                        public:
                            GreHashes();
                            ~GreHashes();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreHash : public Entity
                        {
                            public:
                                GreHash();
                                ~GreHash();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf destination_address; //type: string
                                YLeaf ifname; //type: string
                                YLeaf next_hop_interface; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Gre::GreHashes::GreHash


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreHashes::GreHash> > gre_hash;


                    }; // Pim::Active::Vrfs::Vrf::Gre::GreHashes


                    class GreNextHops : public Entity
                    {
                        public:
                            GreNextHops();
                            ~GreNextHops();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreNextHop : public Entity
                        {
                            public:
                                GreNextHop();
                                ~GreNextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf destination_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8

                            class RegisteredAddress : public Entity
                            {
                                public:
                                    RegisteredAddress();
                                    ~RegisteredAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress


                            class GrePath : public Entity
                            {
                                public:
                                    GrePath();
                                    ~GrePath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf gre_interface_name; //type: string
                                    YLeaf is_gre_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf extranet_vrf_name; //type: string

                                class GreNeighbor : public Entity
                                {
                                    public:
                                        GreNeighbor();
                                        ~GreNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                                class GreNextHop_ : public Entity
                                {
                                    public:
                                        GreNextHop_();
                                        ~GreNextHop_();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                            }; // Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                        }; // Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                    }; // Pim::Active::Vrfs::Vrf::Gre::GreNextHops


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreHashes> gre_hashes;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre::GreNextHops> gre_next_hops;


                }; // Pim::Active::Vrfs::Vrf::Gre


                class BidirDfWinners : public Entity
                {
                    public:
                        BidirDfWinners();
                        ~BidirDfWinners();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfWinner : public Entity
                    {
                        public:
                            BidirDfWinner();
                            ~BidirDfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf are_we_df; //type: boolean
                            YLeaf rp_lan; //type: boolean
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf uptime; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr


                        class DfWinner : public Entity
                        {
                            public:
                                DfWinner();
                                ~DfWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                    }; // Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


                }; // Pim::Active::Vrfs::Vrf::BidirDfWinners


                class TableContexts : public Entity
                {
                    public:
                        TableContexts();
                        ~TableContexts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TableContext : public Entity
                    {
                        public:
                            TableContext();
                            ~TableContext();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Pim::Active::Vrfs::Vrf::TableContexts::TableContext


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TableContexts::TableContext> > table_context;


                }; // Pim::Active::Vrfs::Vrf::TableContexts


                class GlobalInterfaces : public Entity
                {
                    public:
                        GlobalInterfaces();
                        ~GlobalInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GlobalInterface : public Entity
                    {
                        public:
                            GlobalInterface();
                            ~GlobalInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                    }; // Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface> > global_interface;


                }; // Pim::Active::Vrfs::Vrf::GlobalInterfaces


                class NeighborSummaries : public Entity
                {
                    public:
                        NeighborSummaries();
                        ~NeighborSummaries();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborSummary : public Entity
                    {
                        public:
                            NeighborSummary();
                            ~NeighborSummary();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf number_of_neighbors; //type: int32
                            YLeaf number_of_external_neighbors; //type: int32



                    }; // Pim::Active::Vrfs::Vrf::NeighborSummaries::NeighborSummary


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NeighborSummaries::NeighborSummary> > neighbor_summary;


                }; // Pim::Active::Vrfs::Vrf::NeighborSummaries


                class Context : public Entity
                {
                    public:
                        Context();
                        ~Context();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf murib_id; //type: uint32
                        YLeaf rpf_id; //type: uint32
                        YLeaf remote_table_id; //type: uint32
                        YLeaf mdt_default_group; //type: string
                        YLeaf mdt_interface; //type: string
                        YLeaf mdt_gre_rpf_identifier; //type: uint32
                        YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                        YLeaf is_unicast_rib_registration; //type: boolean
                        YLeaf is_multicast_rib_registration; //type: boolean
                        YLeaf is_active; //type: boolean
                        YLeaf is_active_ital; //type: boolean
                        YLeaf is_mrib_register; //type: boolean
                        YLeaf is_mdt_owner; //type: boolean
                        YLeaf is_routing_enabled; //type: boolean
                        YLeaf is_socket_add_required; //type: boolean
                        YLeaf is_socket_added; //type: boolean
                        YLeaf is_lpts_socket_add_required; //type: boolean
                        YLeaf is_lpts_socket_added; //type: boolean
                        YLeaf is_udp_socket_add_required; //type: boolean
                        YLeaf is_udp_socket_added; //type: boolean
                        YLeaf is_udp_socket_bind_required; //type: boolean
                        YLeaf is_udp_socket_bind; //type: boolean
                        YLeaf is_register_injection_socket_add_required; //type: boolean
                        YLeaf is_register_injection_socket_added; //type: boolean
                        YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                        YLeaf is_register_injection_lpts_socket_added; //type: boolean
                        YLeaf is_m_host_publish_pending; //type: boolean
                        YLeaf mhost_interface; //type: string
                        YLeaf mhost_default_interface_config; //type: string
                        YLeaf mdt_mtu; //type: uint32
                        YLeaf maximum_mdt_aggregation; //type: uint32
                        YLeaf mdt_data_switchover_interval; //type: uint32
                        YLeaf mdt_data_announce_interval; //type: uint32
                        YLeaf non_default_vrf_count_on_socket; //type: uint32
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf mdt_neighbor_filter_name; //type: string
                        YLeaf allow_rp_configured; //type: boolean
                        YLeaf allow_rp_group_list; //type: string
                        YLeaf allow_rp_rp_list; //type: string
                        YLeaf sg_expiry_timer_configured; //type: boolean
                        YLeaf sg_expiry_time; //type: uint16
                        YLeaf sg_expiry_timer_sg_list; //type: string
                        YLeaf mldp_mdt_name; //type: string
                        YLeaf mldp_mdt_interface; //type: string
                        YLeaf mldp_mdt_mtu; //type: uint32
                        YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                        YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                        YLeaf mldp_mdt_data_announce_interval; //type: uint32
                        YLeaf mldp_mdt_rpf_identifier; //type: uint32
                        YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                        YLeaf is_create_mldp_mdt_interface; //type: boolean
                        YLeaf is_mldp_mdt_owner; //type: boolean
                        YLeaf mldp_root_count; //type: uint32
                        YLeaf mldp_head_lsm_identifier; //type: uint32
                        YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                        YLeaf organization_unique_identifier; //type: uint32
                        YLeaf vpn_index; //type: uint32
                        YLeaf mldp_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                        YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                        YLeaf mldp_head_local_label; //type: uint32
                        YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                        YLeaf bgp_auto_discovery_configured; //type: boolean
                        YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                        YLeaf inter_autonomous_system_enabled; //type: boolean
                        YLeaf bgp_source_active_announce; //type: boolean
                        YLeaf bgp_i_pmsi_added; //type: boolean
                        YLeaf mldp_bsr_control_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                        YLeaf bgp_auto_discovery_type; //type: uint32
                        YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                        YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                        YLeaf mldp_control_head_lsm_identifier; //type: uint32
                        YLeaf umh; //type: boolean
                        YLeaf suppress_shared_tree_join; //type: boolean
                        YLeaf rsvp_te_mdt_name; //type: string
                        YLeaf rsvp_te_mdt_interface; //type: string
                        YLeaf rsvp_te_mdt_mtu; //type: uint32
                        YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                        YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                        YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                        YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                        YLeaf is_rsvp_te_mdt_owner; //type: boolean
                        YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                        YLeaf p2mpte_li_drop; //type: uint32
                        YLeaf ir_mdt_name; //type: string
                        YLeaf ir_mdt_interface; //type: string
                        YLeaf ir_mdt_mtu; //type: uint32
                        YLeaf ir_maximum_mdt_aggregation; //type: uint32
                        YLeaf ir_mdt_data_switchover_interval; //type: uint32
                        YLeaf ir_mdt_data_announce_interval; //type: uint32
                        YLeaf ir_mdt_rpf_identifier; //type: uint32
                        YLeaf ir_mdt_tail_label; //type: uint32
                        YLeaf is_create_ir_mdt_interface; //type: boolean
                        YLeaf is_ir_mdt_owner; //type: boolean
                        YLeaf in_b_and_mdt_name; //type: string
                        YLeaf in_b_and_mdt_interface; //type: string
                        YLeaf in_b_and_mdt_mtu; //type: uint32
                        YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                        YLeaf is_in_b_and_mdt_owner; //type: boolean
                        YLeaf in_band_signaling_local_enabled; //type: boolean
                        YLeaf in_band_signaling_remote_enabled; //type: boolean
                        YLeaf valid_rd_present; //type: boolean
                        YLeaf stale_rd_present; //type: boolean
                        YLeaf route_distinguisher; //type: string
                        YLeaf gin_b_and_mdt_name; //type: string
                        YLeaf gin_b_and_mdt_interface; //type: string
                        YLeaf gin_b_and_mdt_mtu; //type: uint32
                        YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                        YLeaf is_gin_b_and_mdt_owner; //type: boolean
                        YLeaf is_pim_nsf_rib_converged; //type: boolean
                        YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                        YLeaf is_rib_multipath_enabled; //type: boolean
                        YLeaf is_rib_multipath_interface_hash; //type: boolean
                        YLeaf is_rib_multipath_source_hash; //type: boolean
                        YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf is_create_mdt_interface; //type: boolean
                        YLeaf is_auto_rp_listen_enabled; //type: boolean
                        YLeaf is_all_interface_disable_operation; //type: boolean
                        YLeaf is_default_granges; //type: boolean
                        YLeaf is_auto_rp_listen_sock_add; //type: boolean
                        YLeaf is_redistribution_reset; //type: boolean
                        YLeaf redistribution_reset_count; //type: uint32
                        YLeaf rpf_policy_name; //type: string
                        YLeaf table_count; //type: uint32
                        YLeaf active_table_count; //type: uint32
                        YLeaf anycast_rp_policy_name; //type: string
                        YLeaf anycast_rp_configured; //type: boolean
                        YLeaf bgp_remote_on; //type: boolean
                        YLeaf bgp_remote_interface_name; //type: string
                        YLeaf bgp_remote_interface; //type: string
                        YLeaf bgp_remote_address; //type: string
                        YLeaf bgp_remote_state; //type: uint32
                        YLeafList mldp_root_address; //type: list of  uint32

                    class RemoteDefaultGroup : public Entity
                    {
                        public:
                            RemoteDefaultGroup();
                            ~RemoteDefaultGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim::Active::Vrfs::Vrf::Context::RemoteDefaultGroup


                    class RpfDefaultTable : public Entity
                    {
                        public:
                            RpfDefaultTable();
                            ~RpfDefaultTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Pim::Active::Vrfs::Vrf::Context::RpfDefaultTable


                    class ExportRouteTarget : public Entity
                    {
                        public:
                            ExportRouteTarget();
                            ~ExportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Pim::Active::Vrfs::Vrf::Context::ExportRouteTarget


                    class ImportRouteTarget : public Entity
                    {
                        public:
                            ImportRouteTarget();
                            ~ImportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Pim::Active::Vrfs::Vrf::Context::ImportRouteTarget


                    class AnycastRpRange : public Entity
                    {
                        public:
                            AnycastRpRange();
                            ~AnycastRpRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: uint8
                            YLeaf ancast_rp_marked; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Context::AnycastRpRange::Prefix


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context::AnycastRpRange::Prefix> prefix;


                    }; // Pim::Active::Vrfs::Vrf::Context::AnycastRpRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context::AnycastRpRange> > anycast_rp_range;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context::ExportRouteTarget> > export_route_target;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context::ImportRouteTarget> > import_route_target;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context::RemoteDefaultGroup> remote_default_group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context::RpfDefaultTable> rpf_default_table;


                }; // Pim::Active::Vrfs::Vrf::Context


                class TopologyEntryFlagRouteCounts : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCounts();
                        ~TopologyEntryFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyEntryFlagRouteCount : public Entity
                    {
                        public:
                            TopologyEntryFlagRouteCount();
                            ~TopologyEntryFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                    }; // Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


                }; // Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts


                class RpfRedirect : public Entity
                {
                    public:
                        RpfRedirect();
                        ~RpfRedirect();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabases : public Entity
                    {
                        public:
                            RedirectRouteDatabases();
                            ~RedirectRouteDatabases();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RedirectRouteDatabase : public Entity
                        {
                            public:
                                RedirectRouteDatabase();
                                ~RedirectRouteDatabase();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf bandwidth; //type: uint32
                                YLeaf uptime; //type: uint64

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                            class Interface : public Entity
                            {
                                public:
                                    Interface();
                                    ~Interface();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiry; //type: uint64
                                    YLeaf is_rpf_interface; //type: boolean
                                    YLeaf is_outgoing_interface; //type: boolean
                                    YLeaf is_snoop_interface; //type: boolean

                                class RpfAddress : public Entity
                                {
                                    public:
                                        RpfAddress();
                                        ~RpfAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                            }; // Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                        }; // Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                    }; // Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases


                    class BundleInterfaces : public Entity
                    {
                        public:
                            BundleInterfaces();
                            ~BundleInterfaces();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BundleInterface : public Entity
                        {
                            public:
                                BundleInterface();
                                ~BundleInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf bundle_name; //type: string
                                YLeaf interface_name; //type: string
                                YLeaf rpf_redirect_bundle_name; //type: string
                                YLeaf rpf_redirect_interface_name; //type: string
                                YLeaf available_bandwidth; //type: int32
                                YLeaf allocated_bandwidth; //type: int32
                                YLeaf total_bandwidth; //type: int32
                                YLeaf topology_bandwidth_used; //type: int32
                                YLeaf snooping_bandwidth_used; //type: int32
                                YLeaf allocated_threshold_bandwidth; //type: int32
                                YLeaf available_threshold_bandwidth; //type: int32



                        }; // Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                    }; // Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces> bundle_interfaces;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


                }; // Pim::Active::Vrfs::Vrf::RpfRedirect


                class Tunnels : public Entity
                {
                    public:
                        Tunnels();
                        ~Tunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Tunnel : public Entity
                    {
                        public:
                            Tunnel();
                            ~Tunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                    }; // Pim::Active::Vrfs::Vrf::Tunnels::Tunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Tunnels::Tunnel> > tunnel;


                }; // Pim::Active::Vrfs::Vrf::Tunnels


                class MulticastStaticRoutes : public Entity
                {
                    public:
                        MulticastStaticRoutes();
                        ~MulticastStaticRoutes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MulticastStaticRoute : public Entity
                    {
                        public:
                            MulticastStaticRoute();
                            ~MulticastStaticRoute();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf address; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf interface_name; //type: string
                            YLeaf distance; //type: uint32
                            YLeaf prefix_length_xr; //type: uint8
                            YLeaf is_via_lsm; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                        class Nexthop : public Entity
                        {
                            public:
                                Nexthop();
                                ~Nexthop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                    }; // Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


                }; // Pim::Active::Vrfs::Vrf::MulticastStaticRoutes


                class GroupMapMatchSources : public Entity
                {
                    public:
                        GroupMapMatchSources();
                        ~GroupMapMatchSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchSource : public Entity
                    {
                        public:
                            GroupMapMatchSource();
                            ~GroupMapMatchSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                    }; // Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


                }; // Pim::Active::Vrfs::Vrf::GroupMapMatchSources


                class Neighbors : public Entity
                {
                    public:
                        Neighbors();
                        ~Neighbors();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Neighbor : public Entity
                    {
                        public:
                            Neighbor();
                            ~Neighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Pim::Active::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                    }; // Pim::Active::Vrfs::Vrf::Neighbors::Neighbor


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Neighbors::Neighbor> > neighbor;


                }; // Pim::Active::Vrfs::Vrf::Neighbors


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::AutoRp> auto_rp;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BgpAfs> bgp_afs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfStates> bidir_df_states;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::BidirDfWinners> bidir_df_winners;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Bsr> bsr;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Context> context;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GlobalInterfaces> global_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Gre> gre;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs> group_map_match_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapMatchSources> group_map_match_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapRpfs> group_map_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::GroupMapSources> group_map_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::IfrsSummary> ifrs_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::InterfaceStatistics> interface_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Interfaces> interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::JpStatistics> jp_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MibDatabases> mib_databases;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::MulticastStaticRoutes> multicast_static_routes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NeighborOldFormats> neighbor_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NeighborSummaries> neighbor_summaries;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Neighbors> neighbors;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::NetIoTunnels> net_io_tunnels;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RoutePolicy> route_policy;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfRedirect> rpf_redirect;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::RpfSummary> rpf_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Safs> safs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TableContexts> table_contexts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Topologies> topologies;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TopologyRouteCount> topology_route_count;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::TrafficCounters> traffic_counters;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf::Tunnels> tunnels;


            }; // Pim::Active::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs::Vrf> > vrf;


        }; // Pim::Active::Vrfs


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active::Vrfs> vrfs;


    }; // Pim::Active


        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Active> active;
        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim::Standby> standby;


}; // Pim

class Ipv6Pim : public Entity
{
    public:
        Ipv6Pim();
        ~Ipv6Pim();

        bool has_data() const override;
        bool has_operation() const override;
        EntityPath get_entity_path(Entity* parent) const override;
        std::string get_segment_path() const override;
        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
        void set_value(const std::string & value_path, std::string value) override;
        std::map<std::string, Entity*> & get_children() override;
        std::unique_ptr<Entity> clone_ptr() override;



    class Standby : public Entity
    {
        public:
            Standby();
            ~Standby();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Ipv6Pim::Standby::DefaultContext::IfrsInterfaces


            class Safs : public Entity
            {
                public:
                    Safs();
                    ~Safs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Saf : public Entity
                {
                    public:
                        Saf();
                        ~Saf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string

                    class RpfHashSourceGroups : public Entity
                    {
                        public:
                            RpfHashSourceGroups();
                            ~RpfHashSourceGroups();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSourceGroup : public Entity
                        {
                            public:
                                RpfHashSourceGroup();
                                ~RpfHashSourceGroup();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf mask_length; //type: int32
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                    }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups


                    class RpfNeighbors : public Entity
                    {
                        public:
                            RpfNeighbors();
                            ~RpfNeighbors();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf neighbor_address; //type: string
                                YLeaf rib_neighbor_interface; //type: string

                            class RibNeighborAddress : public Entity
                            {
                                public:
                                    RibNeighborAddress();
                                    ~RibNeighborAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                            class RpfRegisteredAddresses : public Entity
                            {
                                public:
                                    RpfRegisteredAddresses();
                                    ~RpfRegisteredAddresses();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_registered_address_references; //type: uint32

                                class RibRegistrationAddress : public Entity
                                {
                                    public:
                                        RibRegistrationAddress();
                                        ~RibRegistrationAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                        }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                    }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors


                    class RpfHashSources : public Entity
                    {
                        public:
                            RpfHashSources();
                            ~RpfHashSources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSource : public Entity
                        {
                            public:
                                RpfHashSource();
                                ~RpfHashSource();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                    }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources


                    class Rpfs : public Entity
                    {
                        public:
                            Rpfs();
                            ~Rpfs();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class Rpf : public Entity
                        {
                            public:
                                Rpf();
                                ~Rpf();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf registered_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8
                                YLeaf is_rpf_bgp_route; //type: boolean

                            class RegisteredAddressXr : public Entity
                            {
                                public:
                                    RegisteredAddressXr();
                                    ~RegisteredAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                            class RpfPath : public Entity
                            {
                                public:
                                    RpfPath();
                                    ~RpfPath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_interface_name; //type: string
                                    YLeaf is_rpf_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_via_mlsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf connector; //type: string
                                    YLeaf extranet_vrf_name; //type: string

                                class RpfNeighbor : public Entity
                                {
                                    public:
                                        RpfNeighbor();
                                        ~RpfNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                class RpfNexthop : public Entity
                                {
                                    public:
                                        RpfNexthop();
                                        ~RpfNexthop();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                            }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                        }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs::Rpf> > rpf;


                    }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfHashSources> rpf_hash_sources;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::RpfNeighbors> rpf_neighbors;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf::Rpfs> rpfs;


                }; // Ipv6Pim::Standby::DefaultContext::Safs::Saf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs::Saf> > saf;


            }; // Ipv6Pim::Standby::DefaultContext::Safs


            class InterfaceStatistics : public Entity
            {
                public:
                    InterfaceStatistics();
                    ~InterfaceStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStatistic : public Entity
                {
                    public:
                        InterfaceStatistic();
                        ~InterfaceStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_register; //type: uint32
                        YLeaf output_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf input_graft_message; //type: uint32
                        YLeaf output_graft_message; //type: uint32
                        YLeaf input_graft_ack_message; //type: uint32
                        YLeaf output_graft_ack_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_miscellaneous; //type: uint32



                }; // Ipv6Pim::Standby::DefaultContext::InterfaceStatistics::InterfaceStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


            }; // Ipv6Pim::Standby::DefaultContext::InterfaceStatistics


            class TopologyRouteCount : public Entity
            {
                public:
                    TopologyRouteCount();
                    ~TopologyRouteCount();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf group_ranges; //type: uint32
                    YLeaf active_group_ranges; //type: uint32
                    YLeaf groute_count; //type: uint32
                    YLeaf sg_route_count; //type: uint32
                    YLeaf sgr_route_count; //type: uint32
                    YLeaf is_node_low_memory; //type: boolean

                class GroupAddress : public Entity
                {
                    public:
                        GroupAddress();
                        ~GroupAddress();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Ipv6Pim::Standby::DefaultContext::TopologyRouteCount::GroupAddress


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyRouteCount::GroupAddress> group_address;


            }; // Ipv6Pim::Standby::DefaultContext::TopologyRouteCount


            class JpStatistics : public Entity
            {
                public:
                    JpStatistics();
                    ~JpStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JpStatistic : public Entity
                {
                    public:
                        JpStatistic();
                        ~JpStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf mtu; //type: uint32
                        YLeaf transmitted; //type: uint32
                        YLeaf transmitted100; //type: uint16
                        YLeaf transmitted_1k; //type: uint16
                        YLeaf transmitted_10k; //type: uint16
                        YLeaf transmitted_50k; //type: uint16
                        YLeaf received; //type: uint32
                        YLeaf received100; //type: uint16
                        YLeaf received_1k; //type: uint16
                        YLeaf received_10k; //type: uint16
                        YLeaf received_50k; //type: uint16



                }; // Ipv6Pim::Standby::DefaultContext::JpStatistics::JpStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::JpStatistics::JpStatistic> > jp_statistic;


            }; // Ipv6Pim::Standby::DefaultContext::JpStatistics


            class MibDatabases : public Entity
            {
                public:
                    MibDatabases();
                    ~MibDatabases();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MibDatabase : public Entity
                {
                    public:
                        MibDatabase();
                        ~MibDatabase();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf source_netmask; //type: int32
                        YLeaf upstream_assert_timer; //type: int32
                        YLeaf assert_metric; //type: uint32
                        YLeaf assert_metric_preference; //type: uint32
                        YLeaf assert_rpt_bit; //type: boolean
                        YLeaf spt_bit; //type: boolean
                        YLeaf rpf_mask; //type: uint32
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf bidirectional_route; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf protocol; //type: PimShowProtocolEnum

                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr


                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfRoot


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                }; // Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MibDatabases::MibDatabase> > mib_database;


            }; // Ipv6Pim::Standby::DefaultContext::MibDatabases


            class GroupMapMatchRpfs : public Entity
            {
                public:
                    GroupMapMatchRpfs();
                    ~GroupMapMatchRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchRpf : public Entity
                {
                    public:
                        GroupMapMatchRpf();
                        ~GroupMapMatchRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


            }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs


            class NeighborOldFormats : public Entity
            {
                public:
                    NeighborOldFormats();
                    ~NeighborOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborOldFormat : public Entity
                {
                    public:
                        NeighborOldFormat();
                        ~NeighborOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                }; // Ipv6Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


            }; // Ipv6Pim::Standby::DefaultContext::NeighborOldFormats


            class IfrsSummary : public Entity
            {
                public:
                    IfrsSummary();
                    ~IfrsSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Ipv6Pim::Standby::DefaultContext::IfrsSummary


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf client_xr; //type: PimShowRangeClientEnum
                        YLeaf expires; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Ranges::Range::RpAddressXr


                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Ranges::Range::SourceOfInformation


                    class GroupRange : public Entity
                    {
                        public:
                            GroupRange();
                            ~GroupRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Ranges::Range::GroupRange::Prefix


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges::Range::GroupRange::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Standby::DefaultContext::Ranges::Range::GroupRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges::Range::GroupRange> > group_range;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges::Range::RpAddressXr> rp_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges::Range::SourceOfInformation> source_of_information;


                }; // Ipv6Pim::Standby::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges::Range> > range;


            }; // Ipv6Pim::Standby::DefaultContext::Ranges


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats


            class Bsr : public Entity
            {
                public:
                    Bsr();
                    ~Bsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RpCaches : public Entity
                {
                    public:
                        RpCaches();
                        ~RpCaches();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCache : public Entity
                    {
                        public:
                            RpCache();
                            ~RpCache();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_prefix; //type: string
                            YLeaf group_prefix_length; //type: uint32
                            YLeaf candidate_rp_group_count; //type: uint32

                        class GroupPrefixXr : public Entity
                        {
                            public:
                                GroupPrefixXr();
                                ~GroupPrefixXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr


                        class CandidateRpList : public Entity
                        {
                            public:
                                CandidateRpList();
                                ~CandidateRpList();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class PimBsrCrpBag : public Entity
                            {
                                public:
                                    PimBsrCrpBag();
                                    ~PimBsrCrpBag();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_holdtime; //type: uint16
                                    YLeaf candidate_rp_priority; //type: uint8
                                    YLeaf candidate_rp_up_time; //type: uint16
                                    YLeaf candidate_rp_expires; //type: uint16
                                    YLeaf protocol; //type: PimShowProtocolEnum

                                class CandidateRpAddress : public Entity
                                {
                                    public:
                                        CandidateRpAddress();
                                        ~CandidateRpAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                            }; // Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                        }; // Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                    }; // Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches::RpCache> > rp_cache;


                }; // Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches


                class CandidateRps : public Entity
                {
                    public:
                        CandidateRps();
                        ~CandidateRps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class CandidateRp : public Entity
                    {
                        public:
                            CandidateRp();
                            ~CandidateRp();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                            YLeaf candidate_rp_scope; //type: int32
                            YLeaf crp_priority; //type: uint8
                            YLeaf crp_holdtime; //type: uint16
                            YLeaf candidate_rp_advance_interval; //type: uint16
                            YLeaf candidate_rp_uptime; //type: uint16
                            YLeaf acl_name; //type: string

                        class CandidateRp_ : public Entity
                        {
                            public:
                                CandidateRp_();
                                ~CandidateRp_();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_


                        class CrpAccess : public Entity
                        {
                            public:
                                CrpAccess();
                                ~CrpAccess();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf acl_name; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                    }; // Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                }; // Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps


                class BsrElections : public Entity
                {
                    public:
                        BsrElections();
                        ~BsrElections();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BsrElection : public Entity
                    {
                        public:
                            BsrElection();
                            ~BsrElection();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf pim_scope; //type: int32
                            YLeaf bsr_priority; //type: uint8
                            YLeaf bsr_mask_length; //type: uint8
                            YLeaf bsr_up_time; //type: uint16
                            YLeaf bootstrap_timeout; //type: uint16
                            YLeaf candidate_bsr_state; //type: uint32
                            YLeaf bsr_election_state; //type: uint32
                            YLeaf bsr_scope; //type: uint16
                            YLeaf candidate_bsr_flag; //type: boolean
                            YLeaf candidate_bsr_priority; //type: uint8
                            YLeaf candidate_bsr_mask_length; //type: uint8

                        class BsrAddress : public Entity
                        {
                            public:
                                BsrAddress();
                                ~BsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress


                        class CandidateBsrAddress : public Entity
                        {
                            public:
                                CandidateBsrAddress();
                                ~CandidateBsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                    }; // Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections::BsrElection> > bsr_election;


                }; // Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::BsrElections> bsr_elections;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::CandidateRps> candidate_rps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr::RpCaches> rp_caches;


            }; // Ipv6Pim::Standby::DefaultContext::Bsr


            class RoutePolicy : public Entity
            {
                public:
                    RoutePolicy();
                    ~RoutePolicy();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RoutePolicyStatistics : public Entity
                {
                    public:
                        RoutePolicyStatistics();
                        ~RoutePolicyStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf policy_name; //type: string
                        YLeaf requests; //type: uint32
                        YLeaf pass; //type: uint32
                        YLeaf drop; //type: uint32
                        YLeaf default_table; //type: uint32
                        YLeaf any_table; //type: uint32



                }; // Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyStatistics


                class RoutePolicyTests : public Entity
                {
                    public:
                        RoutePolicyTests();
                        ~RoutePolicyTests();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyTest : public Entity
                    {
                        public:
                            RoutePolicyTest();
                            ~RoutePolicyTest();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf ext_comm; //type: string
                            YLeaf policy_name; //type: string
                            YLeaf extended_community_rt; //type: string
                            YLeaf pass; //type: boolean
                            YLeaf default_table; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf table_exists; //type: boolean
                            YLeaf table_active; //type: boolean

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                }; // Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RoutePolicy::RoutePolicyTests> route_policy_tests;


            }; // Ipv6Pim::Standby::DefaultContext::RoutePolicy


            class RpfSummary : public Entity
            {
                public:
                    RpfSummary();
                    ~RpfSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf default_safi; //type: uint32
                    YLeaf default_table_name; //type: string
                    YLeaf is_mbgp_configured; //type: boolean
                    YLeaf is_ospf_te_configured; //type: boolean
                    YLeaf is_isis_te_configured; //type: boolean
                    YLeaf is_isis_mtr_configured; //type: boolean
                    YLeaf mo_frr_configured; //type: boolean
                    YLeaf rib_mo_frr_configured; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf rib_convergence_timeout; //type: uint32
                    YLeaf rib_convergence_time_left; //type: uint32
                    YLeaf is_multipath_enabled; //type: boolean
                    YLeaf is_multipath_interface_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                    YLeaf rpf_registrations; //type: uint32
                    YLeaf is_rib_convergence; //type: boolean



            }; // Ipv6Pim::Standby::DefaultContext::RpfSummary


            class Interfaces : public Entity
            {
                public:
                    Interfaces();
                    ~Interfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Interfaces::Interface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Interfaces::Interface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Interfaces::Interface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Interfaces::Interface::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Standby::DefaultContext::Interfaces::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Interfaces::Interface> > interface;


            }; // Ipv6Pim::Standby::DefaultContext::Interfaces


            class NetIoTunnels : public Entity
            {
                public:
                    NetIoTunnels();
                    ~NetIoTunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NetIoTunnel : public Entity
                {
                    public:
                        NetIoTunnel();
                        ~NetIoTunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                }; // Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


            }; // Ipv6Pim::Standby::DefaultContext::NetIoTunnels


            class BidirDfStates : public Entity
            {
                public:
                    BidirDfStates();
                    ~BidirDfStates();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfState : public Entity
                {
                    public:
                        BidirDfState();
                        ~BidirDfState();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf election_state; //type: string
                        YLeaf time_seconds; //type: uint64
                        YLeaf time_nano_seconds; //type: uint64
                        YLeaf our_metric; //type: uint32
                        YLeaf our_metric_preference; //type: uint32

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                }; // Ipv6Pim::Standby::DefaultContext::BidirDfStates::BidirDfState


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfStates::BidirDfState> > bidir_df_state;


            }; // Ipv6Pim::Standby::DefaultContext::BidirDfStates


            class Topologies : public Entity
            {
                public:
                    Topologies();
                    ~Topologies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Topology : public Entity
                {
                    public:
                        Topology();
                        ~Topology();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf rpt; //type: int32
                        YLeaf limit_reached; //type: boolean
                        YLeaf low_memory; //type: boolean
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf wildcard; //type: boolean
                        YLeaf rpt_xr; //type: boolean
                        YLeaf spt; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf expiry; //type: uint64
                        YLeaf alive; //type: int32
                        YLeaf register_received_timer; //type: int32
                        YLeaf remote_source; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf is_via_lsm; //type: boolean
                        YLeaf secondary_rpf_interface_name; //type: string
                        YLeaf connected; //type: boolean
                        YLeaf proxy; //type: boolean
                        YLeaf rpf_proxy_enabled; //type: boolean
                        YLeaf mofrr_enabled; //type: boolean
                        YLeaf rib_mo_frr_enabled; //type: boolean
                        YLeaf jp_timer; //type: int32
                        YLeaf jp_status; //type: int32
                        YLeaf suppress_registers; //type: int32
                        YLeaf assume_alive; //type: boolean
                        YLeaf probe_alive; //type: boolean
                        YLeaf really_alive; //type: boolean
                        YLeaf inherit_alive; //type: boolean
                        YLeaf inherit_spt; //type: boolean
                        YLeaf signal_sources; //type: boolean
                        YLeaf dont_check_connected; //type: boolean
                        YLeaf register_received; //type: boolean
                        YLeaf last_hop; //type: boolean
                        YLeaf sending_registers; //type: boolean
                        YLeaf sending_null_registers; //type: boolean
                        YLeaf sa_sent; //type: boolean
                        YLeaf sa_received; //type: boolean
                        YLeaf sa_joined; //type: boolean
                        YLeaf anycast_rp_match; //type: boolean
                        YLeaf anycast_rp_route_target; //type: string
                        YLeaf bgp_join; //type: boolean
                        YLeaf bgpjp_time; //type: uint64
                        YLeaf customer_routing_type; //type: int32
                        YLeaf extranet_route; //type: boolean
                        YLeaf mofrr_active; //type: boolean
                        YLeaf mofrr_primary; //type: boolean
                        YLeaf mofrr_backup; //type: boolean
                        YLeaf vxlan; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::GroupAddressXr


                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::SourceAddressXr


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::RpAddress


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::RpfNeighbor


                    class SecondaryRpfNeighbor : public Entity
                    {
                        public:
                            SecondaryRpfNeighbor();
                            ~SecondaryRpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::RpfRoot


                    class ProxyAddress : public Entity
                    {
                        public:
                            ProxyAddress();
                            ~ProxyAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::ProxyAddress


                    class OrigSrcAddress : public Entity
                    {
                        public:
                            OrigSrcAddress();
                            ~OrigSrcAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::OrigSrcAddress


                    class OutgoingInterface : public Entity
                    {
                        public:
                            OutgoingInterface();
                            ~OutgoingInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_state; //type: int32
                            YLeaf assert_timer; //type: int32
                            YLeaf local_members; //type: int32
                            YLeaf internal_interest_info; //type: int32
                            YLeaf forwarding_state; //type: int32
                            YLeaf immediate_state; //type: int32
                            YLeaf last_hop; //type: boolean
                            YLeaf mldp_inband_mdt; //type: boolean
                            YLeaf mldp_stale; //type: boolean
                            YLeaf sa_prune; //type: boolean
                            YLeaf admin_boundary; //type: boolean
                            YLeaf igmp_membership; //type: boolean
                            YLeaf mdt_safi_join; //type: boolean
                            YLeaf mvpn_safi_join; //type: boolean
                            YLeaf local_mdt_join; //type: boolean
                            YLeaf data_mdt_join; //type: boolean
                            YLeaf mvp_nv6_safi_join; //type: boolean
                            YLeaf bgp_c_mcast_join; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf extranet_interface; //type: boolean

                        class AssertWinner : public Entity
                        {
                            public:
                                AssertWinner();
                                ~AssertWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                    }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::OrigSrcAddress> orig_src_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::ProxyAddress> proxy_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology::SourceAddressXr> source_address_xr;


                }; // Ipv6Pim::Standby::DefaultContext::Topologies::Topology


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies::Topology> > topology;


            }; // Ipv6Pim::Standby::DefaultContext::Topologies


            class BgpAfs : public Entity
            {
                public:
                    BgpAfs();
                    ~BgpAfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BgpAf : public Entity
                {
                    public:
                        BgpAf();
                        ~BgpAf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf route_distinguisher; //type: string
                        YLeaf extranet_path_count; //type: uint32
                        YLeaf is_bgp_added; //type: boolean

                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf::Source


                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf::Group


                    class NextHop : public Entity
                    {
                        public:
                            NextHop();
                            ~NextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf::NextHop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf::Group> group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf::NextHop> next_hop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf::Source> source;


                }; // Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BgpAfs::BgpAf> > bgp_af;


            }; // Ipv6Pim::Standby::DefaultContext::BgpAfs


            class AutoRp : public Entity
            {
                public:
                    AutoRp();
                    ~AutoRp();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;





            }; // Ipv6Pim::Standby::DefaultContext::AutoRp


            class TopologyInterfaceFlagRouteCounts : public Entity
            {
                public:
                    TopologyInterfaceFlagRouteCounts();
                    ~TopologyInterfaceFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyInterfaceFlagRouteCount : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCount();
                        ~TopologyInterfaceFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                }; // Ipv6Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


            }; // Ipv6Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts


            class GroupMapSources : public Entity
            {
                public:
                    GroupMapSources();
                    ~GroupMapSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapSource : public Entity
                {
                    public:
                        GroupMapSource();
                        ~GroupMapSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf priority; //type: int32
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                }; // Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapSources::GroupMapSource> > group_map_source;


            }; // Ipv6Pim::Standby::DefaultContext::GroupMapSources


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf inputs; //type: uint32
                    YLeaf outputs; //type: uint32
                    YLeaf format_error; //type: uint32
                    YLeaf pakman_error; //type: uint32
                    YLeaf standby_packets_error; //type: uint32
                    YLeaf checksum_error; //type: uint32
                    YLeaf socket_error; //type: uint32
                    YLeaf send_queue_full; //type: uint32
                    YLeaf boundary_acl_rx_drop; //type: uint32
                    YLeaf boundary_acl_tx_drop; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf no_source_address; //type: uint32
                    YLeaf input_hello; //type: uint32
                    YLeaf output_hello; //type: uint32
                    YLeaf input_jp; //type: uint32
                    YLeaf output_jp; //type: uint32
                    YLeaf input_data_register; //type: uint32
                    YLeaf input_null_register; //type: uint32
                    YLeaf output_data_register; //type: uint32
                    YLeaf output_null_register; //type: uint32
                    YLeaf input_register_stop; //type: uint32
                    YLeaf output_register_stop; //type: uint32
                    YLeaf input_assert; //type: uint32
                    YLeaf input_assert_batched; //type: uint32
                    YLeaf output_assert; //type: uint32
                    YLeaf output_assert_batched; //type: uint32
                    YLeaf input_df_election; //type: uint32
                    YLeaf output_df_election; //type: uint32
                    YLeaf input_bsr_message; //type: uint32
                    YLeaf output_bsr_message; //type: uint32
                    YLeaf input_candidate_rp_advertisement; //type: uint32
                    YLeaf output_candidate_rp_advertisement; //type: uint32
                    YLeaf input_ecmp_redirect; //type: uint32
                    YLeaf output_ecmp_redirect; //type: uint32
                    YLeaf output_loop_error; //type: uint32
                    YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                    YLeaf input_no_idb_error; //type: uint32
                    YLeaf input_no_vrf_error; //type: uint32
                    YLeaf input_no_pim_error; //type: uint32
                    YLeaf input_pim_version_error; //type: uint32
                    YLeaf output_join_group; //type: uint32
                    YLeaf output_prune_group; //type: uint32
                    YLeaf output_join_prune_bytes; //type: uint32
                    YLeaf output_hello_bytes; //type: uint32
                    YLeaf non_supported_packets; //type: uint32
                    YLeaf invalid_registers; //type: uint32
                    YLeaf invalid_join_prunes; //type: uint32
                    YLeaf packet_packman_error; //type: uint32
                    YLeaf packet_read_socket_error; //type: uint32
                    YLeaf packet_queue_last_clear; //type: uint32
                    YLeaf packets_standby; //type: uint32
                    YLeaf no_mdt_socket_connection; //type: uint32
                    YLeaf mdt_send_queue_full; //type: uint32
                    YLeaf mdt_socket_error; //type: uint32
                    YLeaf mdt_join_tlv_sent; //type: uint32
                    YLeaf mdt_join_tlv_received; //type: uint32
                    YLeaf mdt_join_bad_type; //type: uint32
                    YLeaf mdt_drop_local_source_address; //type: uint32
                    YLeaf mdt_drop_null_local_address; //type: uint32
                    YLeaf mdt_drop_no_idb; //type: uint32
                    YLeaf mdt_drop_no_vrf; //type: uint32
                    YLeaf invalid_destination_packets; //type: uint32
                    YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                    YLeaf truncated_pim_packets; //type: uint32
                    YLeafList packet_enqueued; //type: list of  uint32
                    YLeafList packet_dequeued; //type: list of  uint32
                    YLeafList packet_queue_length; //type: list of  uint32
                    YLeafList packet_queue_size; //type: list of  uint32
                    YLeafList packet_tail_drop; //type: list of  uint32

                class PacketQueue : public Entity
                {
                    public:
                        PacketQueue();
                        ~PacketQueue();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf packet_queue_priority; //type: uint32

                    class PacketQueueState : public Entity
                    {
                        public:
                            PacketQueueState();
                            ~PacketQueueState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf max_queue_size; //type: uint32
                            YLeaf queue_size_bytes; //type: uint32
                            YLeaf queue_size_packets; //type: uint32



                    }; // Ipv6Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState


                    class PacketQueueStats : public Entity
                    {
                        public:
                            PacketQueueStats();
                            ~PacketQueueStats();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf enqueued_packets; //type: uint32
                            YLeaf dequeued_packets; //type: uint32
                            YLeaf high_water_mark_packets; //type: uint32
                            YLeaf high_water_mark_bytes; //type: uint32
                            YLeaf tail_drops; //type: uint32



                    }; // Ipv6Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                }; // Ipv6Pim::Standby::DefaultContext::TrafficCounters::PacketQueue


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TrafficCounters::PacketQueue> > packet_queue;


            }; // Ipv6Pim::Standby::DefaultContext::TrafficCounters


            class GroupMapRpfs : public Entity
            {
                public:
                    GroupMapRpfs();
                    ~GroupMapRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapRpf : public Entity
                {
                    public:
                        GroupMapRpf();
                        ~GroupMapRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf rp_priority; //type: int32
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                }; // Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


            }; // Ipv6Pim::Standby::DefaultContext::GroupMapRpfs


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Ipv6Pim::Standby::DefaultContext::Summary


            class Gre : public Entity
            {
                public:
                    Gre();
                    ~Gre();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GreHashes : public Entity
                {
                    public:
                        GreHashes();
                        ~GreHashes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHash : public Entity
                    {
                        public:
                            GreHash();
                            ~GreHash();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf destination_address; //type: string
                            YLeaf ifname; //type: string
                            YLeaf next_hop_interface; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Gre::GreHashes::GreHash


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreHashes::GreHash> > gre_hash;


                }; // Ipv6Pim::Standby::DefaultContext::Gre::GreHashes


                class GreNextHops : public Entity
                {
                    public:
                        GreNextHops();
                        ~GreNextHops();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreNextHop : public Entity
                    {
                        public:
                            GreNextHop();
                            ~GreNextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf destination_address; //type: string
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf is_connected; //type: uint8

                        class RegisteredAddress : public Entity
                        {
                            public:
                                RegisteredAddress();
                                ~RegisteredAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress


                        class GrePath : public Entity
                        {
                            public:
                                GrePath();
                                ~GrePath();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf gre_interface_name; //type: string
                                YLeaf is_gre_interface_disabled; //type: boolean
                                YLeaf is_via_lsm; //type: boolean
                                YLeaf is_connector_attribute_present; //type: boolean
                                YLeaf extranet_vrf_name; //type: string

                            class GreNeighbor : public Entity
                            {
                                public:
                                    GreNeighbor();
                                    ~GreNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                            class GreNextHop_ : public Entity
                            {
                                public:
                                    GreNextHop_();
                                    ~GreNextHop_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                        }; // Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                    }; // Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                }; // Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreHashes> gre_hashes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre::GreNextHops> gre_next_hops;


            }; // Ipv6Pim::Standby::DefaultContext::Gre


            class BidirDfWinners : public Entity
            {
                public:
                    BidirDfWinners();
                    ~BidirDfWinners();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfWinner : public Entity
                {
                    public:
                        BidirDfWinner();
                        ~BidirDfWinner();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf are_we_df; //type: boolean
                        YLeaf rp_lan; //type: boolean
                        YLeaf metric; //type: uint32
                        YLeaf metric_preference; //type: uint32
                        YLeaf uptime; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr


                    class DfWinner : public Entity
                    {
                        public:
                            DfWinner();
                            ~DfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                }; // Ipv6Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


            }; // Ipv6Pim::Standby::DefaultContext::BidirDfWinners


            class TableContexts : public Entity
            {
                public:
                    TableContexts();
                    ~TableContexts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TableContext : public Entity
                {
                    public:
                        TableContext();
                        ~TableContext();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string
                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Ipv6Pim::Standby::DefaultContext::TableContexts::TableContext


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TableContexts::TableContext> > table_context;


            }; // Ipv6Pim::Standby::DefaultContext::TableContexts


            class GlobalInterfaces : public Entity
            {
                public:
                    GlobalInterfaces();
                    ~GlobalInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GlobalInterface : public Entity
                {
                    public:
                        GlobalInterface();
                        ~GlobalInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GlobalInterfaces::GlobalInterface> > global_interface;


            }; // Ipv6Pim::Standby::DefaultContext::GlobalInterfaces


            class NeighborSummaries : public Entity
            {
                public:
                    NeighborSummaries();
                    ~NeighborSummaries();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborSummary : public Entity
                {
                    public:
                        NeighborSummary();
                        ~NeighborSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf number_of_neighbors; //type: int32
                        YLeaf number_of_external_neighbors; //type: int32



                }; // Ipv6Pim::Standby::DefaultContext::NeighborSummaries::NeighborSummary


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NeighborSummaries::NeighborSummary> > neighbor_summary;


            }; // Ipv6Pim::Standby::DefaultContext::NeighborSummaries


            class Context : public Entity
            {
                public:
                    Context();
                    ~Context();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_id; //type: uint32
                    YLeaf table_id; //type: uint32
                    YLeaf murib_id; //type: uint32
                    YLeaf rpf_id; //type: uint32
                    YLeaf remote_table_id; //type: uint32
                    YLeaf mdt_default_group; //type: string
                    YLeaf mdt_interface; //type: string
                    YLeaf mdt_gre_rpf_identifier; //type: uint32
                    YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                    YLeaf is_unicast_rib_registration; //type: boolean
                    YLeaf is_multicast_rib_registration; //type: boolean
                    YLeaf is_active; //type: boolean
                    YLeaf is_active_ital; //type: boolean
                    YLeaf is_mrib_register; //type: boolean
                    YLeaf is_mdt_owner; //type: boolean
                    YLeaf is_routing_enabled; //type: boolean
                    YLeaf is_socket_add_required; //type: boolean
                    YLeaf is_socket_added; //type: boolean
                    YLeaf is_lpts_socket_add_required; //type: boolean
                    YLeaf is_lpts_socket_added; //type: boolean
                    YLeaf is_udp_socket_add_required; //type: boolean
                    YLeaf is_udp_socket_added; //type: boolean
                    YLeaf is_udp_socket_bind_required; //type: boolean
                    YLeaf is_udp_socket_bind; //type: boolean
                    YLeaf is_register_injection_socket_add_required; //type: boolean
                    YLeaf is_register_injection_socket_added; //type: boolean
                    YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                    YLeaf is_register_injection_lpts_socket_added; //type: boolean
                    YLeaf is_m_host_publish_pending; //type: boolean
                    YLeaf mhost_interface; //type: string
                    YLeaf mhost_default_interface_config; //type: string
                    YLeaf mdt_mtu; //type: uint32
                    YLeaf maximum_mdt_aggregation; //type: uint32
                    YLeaf mdt_data_switchover_interval; //type: uint32
                    YLeaf mdt_data_announce_interval; //type: uint32
                    YLeaf non_default_vrf_count_on_socket; //type: uint32
                    YLeaf neighbor_filter_name; //type: string
                    YLeaf mdt_neighbor_filter_name; //type: string
                    YLeaf allow_rp_configured; //type: boolean
                    YLeaf allow_rp_group_list; //type: string
                    YLeaf allow_rp_rp_list; //type: string
                    YLeaf sg_expiry_timer_configured; //type: boolean
                    YLeaf sg_expiry_time; //type: uint16
                    YLeaf sg_expiry_timer_sg_list; //type: string
                    YLeaf mldp_mdt_name; //type: string
                    YLeaf mldp_mdt_interface; //type: string
                    YLeaf mldp_mdt_mtu; //type: uint32
                    YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                    YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                    YLeaf mldp_mdt_data_announce_interval; //type: uint32
                    YLeaf mldp_mdt_rpf_identifier; //type: uint32
                    YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                    YLeaf is_create_mldp_mdt_interface; //type: boolean
                    YLeaf is_mldp_mdt_owner; //type: boolean
                    YLeaf mldp_root_count; //type: uint32
                    YLeaf mldp_head_lsm_identifier; //type: uint32
                    YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                    YLeaf organization_unique_identifier; //type: uint32
                    YLeaf vpn_index; //type: uint32
                    YLeaf mldp_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                    YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                    YLeaf mldp_head_local_label; //type: uint32
                    YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                    YLeaf bgp_auto_discovery_configured; //type: boolean
                    YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                    YLeaf inter_autonomous_system_enabled; //type: boolean
                    YLeaf bgp_source_active_announce; //type: boolean
                    YLeaf bgp_i_pmsi_added; //type: boolean
                    YLeaf mldp_bsr_control_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                    YLeaf bgp_auto_discovery_type; //type: uint32
                    YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                    YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                    YLeaf mldp_control_head_lsm_identifier; //type: uint32
                    YLeaf umh; //type: boolean
                    YLeaf suppress_shared_tree_join; //type: boolean
                    YLeaf rsvp_te_mdt_name; //type: string
                    YLeaf rsvp_te_mdt_interface; //type: string
                    YLeaf rsvp_te_mdt_mtu; //type: uint32
                    YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                    YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                    YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                    YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                    YLeaf is_rsvp_te_mdt_owner; //type: boolean
                    YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                    YLeaf p2mpte_li_drop; //type: uint32
                    YLeaf ir_mdt_name; //type: string
                    YLeaf ir_mdt_interface; //type: string
                    YLeaf ir_mdt_mtu; //type: uint32
                    YLeaf ir_maximum_mdt_aggregation; //type: uint32
                    YLeaf ir_mdt_data_switchover_interval; //type: uint32
                    YLeaf ir_mdt_data_announce_interval; //type: uint32
                    YLeaf ir_mdt_rpf_identifier; //type: uint32
                    YLeaf ir_mdt_tail_label; //type: uint32
                    YLeaf is_create_ir_mdt_interface; //type: boolean
                    YLeaf is_ir_mdt_owner; //type: boolean
                    YLeaf in_b_and_mdt_name; //type: string
                    YLeaf in_b_and_mdt_interface; //type: string
                    YLeaf in_b_and_mdt_mtu; //type: uint32
                    YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                    YLeaf is_in_b_and_mdt_owner; //type: boolean
                    YLeaf in_band_signaling_local_enabled; //type: boolean
                    YLeaf in_band_signaling_remote_enabled; //type: boolean
                    YLeaf valid_rd_present; //type: boolean
                    YLeaf stale_rd_present; //type: boolean
                    YLeaf route_distinguisher; //type: string
                    YLeaf gin_b_and_mdt_name; //type: string
                    YLeaf gin_b_and_mdt_interface; //type: string
                    YLeaf gin_b_and_mdt_mtu; //type: uint32
                    YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                    YLeaf is_gin_b_and_mdt_owner; //type: boolean
                    YLeaf is_pim_nsf_rib_converged; //type: boolean
                    YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                    YLeaf is_rib_multipath_enabled; //type: boolean
                    YLeaf is_rib_multipath_interface_hash; //type: boolean
                    YLeaf is_rib_multipath_source_hash; //type: boolean
                    YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf is_create_mdt_interface; //type: boolean
                    YLeaf is_auto_rp_listen_enabled; //type: boolean
                    YLeaf is_all_interface_disable_operation; //type: boolean
                    YLeaf is_default_granges; //type: boolean
                    YLeaf is_auto_rp_listen_sock_add; //type: boolean
                    YLeaf is_redistribution_reset; //type: boolean
                    YLeaf redistribution_reset_count; //type: uint32
                    YLeaf rpf_policy_name; //type: string
                    YLeaf table_count; //type: uint32
                    YLeaf active_table_count; //type: uint32
                    YLeaf anycast_rp_policy_name; //type: string
                    YLeaf anycast_rp_configured; //type: boolean
                    YLeaf bgp_remote_on; //type: boolean
                    YLeaf bgp_remote_interface_name; //type: string
                    YLeaf bgp_remote_interface; //type: string
                    YLeaf bgp_remote_address; //type: string
                    YLeaf bgp_remote_state; //type: uint32
                    YLeafList mldp_root_address; //type: list of  uint32

                class RemoteDefaultGroup : public Entity
                {
                    public:
                        RemoteDefaultGroup();
                        ~RemoteDefaultGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Ipv6Pim::Standby::DefaultContext::Context::RemoteDefaultGroup


                class RpfDefaultTable : public Entity
                {
                    public:
                        RpfDefaultTable();
                        ~RpfDefaultTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Ipv6Pim::Standby::DefaultContext::Context::RpfDefaultTable


                class ExportRouteTarget : public Entity
                {
                    public:
                        ExportRouteTarget();
                        ~ExportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Ipv6Pim::Standby::DefaultContext::Context::ExportRouteTarget


                class ImportRouteTarget : public Entity
                {
                    public:
                        ImportRouteTarget();
                        ~ImportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Ipv6Pim::Standby::DefaultContext::Context::ImportRouteTarget


                class AnycastRpRange : public Entity
                {
                    public:
                        AnycastRpRange();
                        ~AnycastRpRange();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix_length; //type: uint8
                        YLeaf ancast_rp_marked; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Context::AnycastRpRange::Prefix


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context::AnycastRpRange::Prefix> prefix;


                }; // Ipv6Pim::Standby::DefaultContext::Context::AnycastRpRange


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context::AnycastRpRange> > anycast_rp_range;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context::ExportRouteTarget> > export_route_target;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context::ImportRouteTarget> > import_route_target;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context::RemoteDefaultGroup> remote_default_group;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context::RpfDefaultTable> rpf_default_table;


            }; // Ipv6Pim::Standby::DefaultContext::Context


            class TopologyEntryFlagRouteCounts : public Entity
            {
                public:
                    TopologyEntryFlagRouteCounts();
                    ~TopologyEntryFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyEntryFlagRouteCount : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCount();
                        ~TopologyEntryFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                }; // Ipv6Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


            }; // Ipv6Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts


            class RpfRedirect : public Entity
            {
                public:
                    RpfRedirect();
                    ~RpfRedirect();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RedirectRouteDatabases : public Entity
                {
                    public:
                        RedirectRouteDatabases();
                        ~RedirectRouteDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabase : public Entity
                    {
                        public:
                            RedirectRouteDatabase();
                            ~RedirectRouteDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf bandwidth; //type: uint32
                            YLeaf uptime; //type: uint64

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                        class Interface : public Entity
                        {
                            public:
                                Interface();
                                ~Interface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf is_rpf_interface; //type: boolean
                                YLeaf is_outgoing_interface; //type: boolean
                                YLeaf is_snoop_interface; //type: boolean

                            class RpfAddress : public Entity
                            {
                                public:
                                    RpfAddress();
                                    ~RpfAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                        }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases


                class BundleInterfaces : public Entity
                {
                    public:
                        BundleInterfaces();
                        ~BundleInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BundleInterface : public Entity
                    {
                        public:
                            BundleInterface();
                            ~BundleInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf bundle_name; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf rpf_redirect_bundle_name; //type: string
                            YLeaf rpf_redirect_interface_name; //type: string
                            YLeaf available_bandwidth; //type: int32
                            YLeaf allocated_bandwidth; //type: int32
                            YLeaf total_bandwidth; //type: int32
                            YLeaf topology_bandwidth_used; //type: int32
                            YLeaf snooping_bandwidth_used; //type: int32
                            YLeaf allocated_threshold_bandwidth; //type: int32
                            YLeaf available_threshold_bandwidth; //type: int32



                    }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::BundleInterfaces> bundle_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


            }; // Ipv6Pim::Standby::DefaultContext::RpfRedirect


            class Tunnels : public Entity
            {
                public:
                    Tunnels();
                    ~Tunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Tunnel : public Entity
                {
                    public:
                        Tunnel();
                        ~Tunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                }; // Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Tunnels::Tunnel> > tunnel;


            }; // Ipv6Pim::Standby::DefaultContext::Tunnels


            class MulticastStaticRoutes : public Entity
            {
                public:
                    MulticastStaticRoutes();
                    ~MulticastStaticRoutes();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MulticastStaticRoute : public Entity
                {
                    public:
                        MulticastStaticRoute();
                        ~MulticastStaticRoute();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf address; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf interface_name; //type: string
                        YLeaf distance; //type: uint32
                        YLeaf prefix_length_xr; //type: uint8
                        YLeaf is_via_lsm; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                    class Nexthop : public Entity
                    {
                        public:
                            Nexthop();
                            ~Nexthop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                }; // Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


            }; // Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes


            class GroupMapMatchSources : public Entity
            {
                public:
                    GroupMapMatchSources();
                    ~GroupMapMatchSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchSource : public Entity
                {
                    public:
                        GroupMapMatchSource();
                        ~GroupMapMatchSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


            }; // Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources


            class Neighbors : public Entity
            {
                public:
                    Neighbors();
                    ~Neighbors();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Neighbor : public Entity
                {
                    public:
                        Neighbor();
                        ~Neighbor();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::DefaultContext::Neighbors::Neighbor::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                }; // Ipv6Pim::Standby::DefaultContext::Neighbors::Neighbor


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Neighbors::Neighbor> > neighbor;


            }; // Ipv6Pim::Standby::DefaultContext::Neighbors


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::AutoRp> auto_rp;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BgpAfs> bgp_afs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfStates> bidir_df_states;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::BidirDfWinners> bidir_df_winners;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Bsr> bsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Context> context;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GlobalInterfaces> global_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Gre> gre;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchRpfs> group_map_match_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapMatchSources> group_map_match_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapRpfs> group_map_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::GroupMapSources> group_map_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::IfrsSummary> ifrs_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::InterfaceStatistics> interface_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Interfaces> interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::JpStatistics> jp_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MibDatabases> mib_databases;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::MulticastStaticRoutes> multicast_static_routes;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NeighborOldFormats> neighbor_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NeighborSummaries> neighbor_summaries;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Neighbors> neighbors;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::NetIoTunnels> net_io_tunnels;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RoutePolicy> route_policy;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfRedirect> rpf_redirect;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::RpfSummary> rpf_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Safs> safs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TableContexts> table_contexts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Topologies> topologies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TopologyRouteCount> topology_route_count;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::TrafficCounters> traffic_counters;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext::Tunnels> tunnels;


        }; // Ipv6Pim::Standby::DefaultContext


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class CheckpointStatistics : public Entity
            {
                public:
                    CheckpointStatistics();
                    ~CheckpointStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class CheckpointTable : public Entity
                {
                    public:
                        CheckpointTable();
                        ~CheckpointTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf table_description; //type: string
                        YLeaf table_name; //type: uint32
                        YLeaf is_mirrored; //type: boolean
                        YLeafList statistic; //type: list of  uint32



                }; // Ipv6Pim::Standby::Process::CheckpointStatistics::CheckpointTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process::CheckpointStatistics::CheckpointTable> > checkpoint_table;


            }; // Ipv6Pim::Standby::Process::CheckpointStatistics


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_connected; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf rmf_timer_valid; //type: boolean
                    YLeaf rmf_timer_expiry; //type: uint64
                    YLeaf last_connection_up; //type: uint64
                    YLeaf last_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_connection_up; //type: uint32
                    YLeaf count_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Ipv6Pim::Standby::Process::Nsr


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Ipv6Pim::Standby::Process::Summary


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf configured_state; //type: boolean
                    YLeaf nsf_state; //type: boolean
                    YLeaf nsf_timeout; //type: uint32
                    YLeaf nsf_time_left; //type: uint32
                    YLeaf waiting_timer; //type: boolean
                    YLeaf waiting_membership; //type: boolean
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_sec; //type: int32
                    YLeaf last_nsf_off_sec; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_sec; //type: int32



            }; // Ipv6Pim::Standby::Process::Nsf


            class Issu : public Entity
            {
                public:
                    Issu();
                    ~Issu();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf informationvalid; //type: boolean
                    YLeaf role_ha; //type: int32
                    YLeaf role_issu; //type: int32
                    YLeaf phase_issu; //type: int32
                    YLeaf ha_option_issu; //type: int32
                    YLeaf last_ready_bool; //type: boolean
                    YLeaf last_ready_sent; //type: uint64
                    YLeaf last_ha_role_notification_received; //type: uint64
                    YLeaf last_issu_role_notification_received; //type: uint64
                    YLeaf last_issu_phase_notification_received; //type: uint64
                    YLeaf is_eoc_received; //type: boolean
                    YLeaf eoc_received_timestamp; //type: uint64
                    YLeaf is_ihms_done_received; //type: boolean
                    YLeaf ihms_received_timestamp; //type: uint64
                    YLeaf is_rib_sync_received; //type: boolean
                    YLeaf rib_sync_received_timestamp; //type: uint64
                    YLeaf is_nbr_sync_received; //type: boolean
                    YLeaf nbr_sync_received_timestamp; //type: uint64



            }; // Ipv6Pim::Standby::Process::Issu


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process::CheckpointStatistics> checkpoint_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process::Issu> issu;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process::Summary> summary;


        }; // Ipv6Pim::Standby::Process


        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces


                class Safs : public Entity
                {
                    public:
                        Safs();
                        ~Safs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Saf : public Entity
                    {
                        public:
                            Saf();
                            ~Saf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string

                        class RpfHashSourceGroups : public Entity
                        {
                            public:
                                RpfHashSourceGroups();
                                ~RpfHashSourceGroups();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSourceGroup : public Entity
                            {
                                public:
                                    RpfHashSourceGroup();
                                    ~RpfHashSourceGroup();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf group_address; //type: string
                                    YLeaf mask_length; //type: int32
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups


                        class RpfNeighbors : public Entity
                        {
                            public:
                                RpfNeighbors();
                                ~RpfNeighbors();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfNeighbor : public Entity
                            {
                                public:
                                    RpfNeighbor();
                                    ~RpfNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf neighbor_address; //type: string
                                    YLeaf rib_neighbor_interface; //type: string

                                class RibNeighborAddress : public Entity
                                {
                                    public:
                                        RibNeighborAddress();
                                        ~RibNeighborAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                                class RpfRegisteredAddresses : public Entity
                                {
                                    public:
                                        RpfRegisteredAddresses();
                                        ~RpfRegisteredAddresses();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_registered_address_references; //type: uint32

                                    class RibRegistrationAddress : public Entity
                                    {
                                        public:
                                            RibRegistrationAddress();
                                            ~RibRegistrationAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors


                        class RpfHashSources : public Entity
                        {
                            public:
                                RpfHashSources();
                                ~RpfHashSources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSource : public Entity
                            {
                                public:
                                    RpfHashSource();
                                    ~RpfHashSource();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources


                        class Rpfs : public Entity
                        {
                            public:
                                Rpfs();
                                ~Rpfs();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class Rpf : public Entity
                            {
                                public:
                                    Rpf();
                                    ~Rpf();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf registered_address; //type: string
                                    YLeaf metric; //type: uint32
                                    YLeaf metric_preference; //type: uint32
                                    YLeaf is_connected; //type: uint8
                                    YLeaf is_rpf_bgp_route; //type: boolean

                                class RegisteredAddressXr : public Entity
                                {
                                    public:
                                        RegisteredAddressXr();
                                        ~RegisteredAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                                class RpfPath : public Entity
                                {
                                    public:
                                        RpfPath();
                                        ~RpfPath();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_interface_name; //type: string
                                        YLeaf is_rpf_interface_disabled; //type: boolean
                                        YLeaf is_via_lsm; //type: boolean
                                        YLeaf is_via_mlsm; //type: boolean
                                        YLeaf is_connector_attribute_present; //type: boolean
                                        YLeaf connector; //type: string
                                        YLeaf extranet_vrf_name; //type: string

                                    class RpfNeighbor : public Entity
                                    {
                                        public:
                                            RpfNeighbor();
                                            ~RpfNeighbor();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                    class RpfNexthop : public Entity
                                    {
                                        public:
                                            RpfNexthop();
                                            ~RpfNexthop();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf> > rpf;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfHashSources> rpf_hash_sources;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::RpfNeighbors> rpf_neighbors;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf::Rpfs> rpfs;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs::Saf> > saf;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Safs


                class InterfaceStatistics : public Entity
                {
                    public:
                        InterfaceStatistics();
                        ~InterfaceStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStatistic : public Entity
                    {
                        public:
                            InterfaceStatistic();
                            ~InterfaceStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf input_hello; //type: uint32
                            YLeaf output_hello; //type: uint32
                            YLeaf input_register; //type: uint32
                            YLeaf output_register; //type: uint32
                            YLeaf input_register_stop; //type: uint32
                            YLeaf output_register_stop; //type: uint32
                            YLeaf input_jp; //type: uint32
                            YLeaf output_jp; //type: uint32
                            YLeaf input_bsr_message; //type: uint32
                            YLeaf output_bsr_message; //type: uint32
                            YLeaf input_assert; //type: uint32
                            YLeaf output_assert; //type: uint32
                            YLeaf input_graft_message; //type: uint32
                            YLeaf output_graft_message; //type: uint32
                            YLeaf input_graft_ack_message; //type: uint32
                            YLeaf output_graft_ack_message; //type: uint32
                            YLeaf input_candidate_rp_advertisement; //type: uint32
                            YLeaf output_candidate_rp_advertisement; //type: uint32
                            YLeaf input_df_election; //type: uint32
                            YLeaf output_df_election; //type: uint32
                            YLeaf input_miscellaneous; //type: uint32



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::InterfaceStatistics


                class TopologyRouteCount : public Entity
                {
                    public:
                        TopologyRouteCount();
                        ~TopologyRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyRouteCount::GroupAddress> group_address;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyRouteCount


                class JpStatistics : public Entity
                {
                    public:
                        JpStatistics();
                        ~JpStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JpStatistic : public Entity
                    {
                        public:
                            JpStatistic();
                            ~JpStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf mtu; //type: uint32
                            YLeaf transmitted; //type: uint32
                            YLeaf transmitted100; //type: uint16
                            YLeaf transmitted_1k; //type: uint16
                            YLeaf transmitted_10k; //type: uint16
                            YLeaf transmitted_50k; //type: uint16
                            YLeaf received; //type: uint32
                            YLeaf received100; //type: uint16
                            YLeaf received_1k; //type: uint16
                            YLeaf received_10k; //type: uint16
                            YLeaf received_50k; //type: uint16



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::JpStatistics::JpStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::JpStatistics::JpStatistic> > jp_statistic;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::JpStatistics


                class MibDatabases : public Entity
                {
                    public:
                        MibDatabases();
                        ~MibDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MibDatabase : public Entity
                    {
                        public:
                            MibDatabase();
                            ~MibDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf source_netmask; //type: int32
                            YLeaf upstream_assert_timer; //type: int32
                            YLeaf assert_metric; //type: uint32
                            YLeaf assert_metric_preference; //type: uint32
                            YLeaf assert_rpt_bit; //type: boolean
                            YLeaf spt_bit; //type: boolean
                            YLeaf rpf_mask; //type: uint32
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf bidirectional_route; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf protocol; //type: PimShowProtocolEnum

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases::MibDatabase> > mib_database;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases


                class GroupMapMatchRpfs : public Entity
                {
                    public:
                        GroupMapMatchRpfs();
                        ~GroupMapMatchRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchRpf : public Entity
                    {
                        public:
                            GroupMapMatchRpf();
                            ~GroupMapMatchRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs


                class NeighborOldFormats : public Entity
                {
                    public:
                        NeighborOldFormats();
                        ~NeighborOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborOldFormat : public Entity
                    {
                        public:
                            NeighborOldFormat();
                            ~NeighborOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::NeighborOldFormats


                class IfrsSummary : public Entity
                {
                    public:
                        IfrsSummary();
                        ~IfrsSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Ipv6Pim::Standby::Vrfs::Vrf::IfrsSummary


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf client_xr; //type: PimShowRangeClientEnum
                            YLeaf expires; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::RpAddressXr


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::SourceOfInformation


                        class GroupRange : public Entity
                        {
                            public:
                                GroupRange();
                                ~GroupRange();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf uptime; //type: uint64
                                YLeaf expires; //type: uint64

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix


                            class SourceOfInformation : public Entity
                            {
                                public:
                                    SourceOfInformation();
                                    ~SourceOfInformation();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::GroupRange> > group_range;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::RpAddressXr> rp_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges::Range> > range;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Ranges


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats


                class Bsr : public Entity
                {
                    public:
                        Bsr();
                        ~Bsr();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCaches : public Entity
                    {
                        public:
                            RpCaches();
                            ~RpCaches();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpCache : public Entity
                        {
                            public:
                                RpCache();
                                ~RpCache();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf group_prefix; //type: string
                                YLeaf group_prefix_length; //type: uint32
                                YLeaf candidate_rp_group_count; //type: uint32

                            class GroupPrefixXr : public Entity
                            {
                                public:
                                    GroupPrefixXr();
                                    ~GroupPrefixXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr


                            class CandidateRpList : public Entity
                            {
                                public:
                                    CandidateRpList();
                                    ~CandidateRpList();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;



                                class PimBsrCrpBag : public Entity
                                {
                                    public:
                                        PimBsrCrpBag();
                                        ~PimBsrCrpBag();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf candidate_rp_holdtime; //type: uint16
                                        YLeaf candidate_rp_priority; //type: uint8
                                        YLeaf candidate_rp_up_time; //type: uint16
                                        YLeaf candidate_rp_expires; //type: uint16
                                        YLeaf protocol; //type: PimShowProtocolEnum

                                    class CandidateRpAddress : public Entity
                                    {
                                        public:
                                            CandidateRpAddress();
                                            ~CandidateRpAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches::RpCache> > rp_cache;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches


                    class CandidateRps : public Entity
                    {
                        public:
                            CandidateRps();
                            ~CandidateRps();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class CandidateRp : public Entity
                        {
                            public:
                                CandidateRp();
                                ~CandidateRp();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf rp_address; //type: string
                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf candidate_rp_scope; //type: int32
                                YLeaf crp_priority; //type: uint8
                                YLeaf crp_holdtime; //type: uint16
                                YLeaf candidate_rp_advance_interval; //type: uint16
                                YLeaf candidate_rp_uptime; //type: uint16
                                YLeaf acl_name; //type: string

                            class CandidateRp_ : public Entity
                            {
                                public:
                                    CandidateRp_();
                                    ~CandidateRp_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_


                            class CrpAccess : public Entity
                            {
                                public:
                                    CrpAccess();
                                    ~CrpAccess();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                    YLeaf acl_name; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps


                    class BsrElections : public Entity
                    {
                        public:
                            BsrElections();
                            ~BsrElections();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BsrElection : public Entity
                        {
                            public:
                                BsrElection();
                                ~BsrElection();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf pim_scope; //type: int32
                                YLeaf bsr_priority; //type: uint8
                                YLeaf bsr_mask_length; //type: uint8
                                YLeaf bsr_up_time; //type: uint16
                                YLeaf bootstrap_timeout; //type: uint16
                                YLeaf candidate_bsr_state; //type: uint32
                                YLeaf bsr_election_state; //type: uint32
                                YLeaf bsr_scope; //type: uint16
                                YLeaf candidate_bsr_flag; //type: boolean
                                YLeaf candidate_bsr_priority; //type: uint8
                                YLeaf candidate_bsr_mask_length; //type: uint8

                            class BsrAddress : public Entity
                            {
                                public:
                                    BsrAddress();
                                    ~BsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress


                            class CandidateBsrAddress : public Entity
                            {
                                public:
                                    CandidateBsrAddress();
                                    ~CandidateBsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections::BsrElection> > bsr_election;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::BsrElections> bsr_elections;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::CandidateRps> candidate_rps;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr::RpCaches> rp_caches;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Bsr


                class RoutePolicy : public Entity
                {
                    public:
                        RoutePolicy();
                        ~RoutePolicy();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyStatistics : public Entity
                    {
                        public:
                            RoutePolicyStatistics();
                            ~RoutePolicyStatistics();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf policy_name; //type: string
                            YLeaf requests; //type: uint32
                            YLeaf pass; //type: uint32
                            YLeaf drop; //type: uint32
                            YLeaf default_table; //type: uint32
                            YLeaf any_table; //type: uint32



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics


                    class RoutePolicyTests : public Entity
                    {
                        public:
                            RoutePolicyTests();
                            ~RoutePolicyTests();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RoutePolicyTest : public Entity
                        {
                            public:
                                RoutePolicyTest();
                                ~RoutePolicyTest();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf ext_comm; //type: string
                                YLeaf policy_name; //type: string
                                YLeaf extended_community_rt; //type: string
                                YLeaf pass; //type: boolean
                                YLeaf default_table; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf afi; //type: uint32
                                YLeaf safi; //type: uint32
                                YLeaf table_name; //type: string
                                YLeaf table_exists; //type: boolean
                                YLeaf table_active; //type: boolean

                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy::RoutePolicyTests> route_policy_tests;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy


                class RpfSummary : public Entity
                {
                    public:
                        RpfSummary();
                        ~RpfSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf default_safi; //type: uint32
                        YLeaf default_table_name; //type: string
                        YLeaf is_mbgp_configured; //type: boolean
                        YLeaf is_ospf_te_configured; //type: boolean
                        YLeaf is_isis_te_configured; //type: boolean
                        YLeaf is_isis_mtr_configured; //type: boolean
                        YLeaf mo_frr_configured; //type: boolean
                        YLeaf rib_mo_frr_configured; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf rib_convergence_timeout; //type: uint32
                        YLeaf rib_convergence_time_left; //type: uint32
                        YLeaf is_multipath_enabled; //type: boolean
                        YLeaf is_multipath_interface_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                        YLeaf rpf_registrations; //type: uint32
                        YLeaf is_rib_convergence; //type: boolean



                }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfSummary


                class Interfaces : public Entity
                {
                    public:
                        Interfaces();
                        ~Interfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Interfaces::Interface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Interfaces::Interface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Interfaces::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Interfaces::Interface> > interface;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Interfaces


                class NetIoTunnels : public Entity
                {
                    public:
                        NetIoTunnels();
                        ~NetIoTunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NetIoTunnel : public Entity
                    {
                        public:
                            NetIoTunnel();
                            ~NetIoTunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels


                class BidirDfStates : public Entity
                {
                    public:
                        BidirDfStates();
                        ~BidirDfStates();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfState : public Entity
                    {
                        public:
                            BidirDfState();
                            ~BidirDfState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf election_state; //type: string
                            YLeaf time_seconds; //type: uint64
                            YLeaf time_nano_seconds; //type: uint64
                            YLeaf our_metric; //type: uint32
                            YLeaf our_metric_preference; //type: uint32

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfStates::BidirDfState> > bidir_df_state;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfStates


                class Topologies : public Entity
                {
                    public:
                        Topologies();
                        ~Topologies();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Topology : public Entity
                    {
                        public:
                            Topology();
                            ~Topology();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf rpt; //type: int32
                            YLeaf limit_reached; //type: boolean
                            YLeaf low_memory; //type: boolean
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf wildcard; //type: boolean
                            YLeaf rpt_xr; //type: boolean
                            YLeaf spt; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf alive; //type: int32
                            YLeaf register_received_timer; //type: int32
                            YLeaf remote_source; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf is_via_lsm; //type: boolean
                            YLeaf secondary_rpf_interface_name; //type: string
                            YLeaf connected; //type: boolean
                            YLeaf proxy; //type: boolean
                            YLeaf rpf_proxy_enabled; //type: boolean
                            YLeaf mofrr_enabled; //type: boolean
                            YLeaf rib_mo_frr_enabled; //type: boolean
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_status; //type: int32
                            YLeaf suppress_registers; //type: int32
                            YLeaf assume_alive; //type: boolean
                            YLeaf probe_alive; //type: boolean
                            YLeaf really_alive; //type: boolean
                            YLeaf inherit_alive; //type: boolean
                            YLeaf inherit_spt; //type: boolean
                            YLeaf signal_sources; //type: boolean
                            YLeaf dont_check_connected; //type: boolean
                            YLeaf register_received; //type: boolean
                            YLeaf last_hop; //type: boolean
                            YLeaf sending_registers; //type: boolean
                            YLeaf sending_null_registers; //type: boolean
                            YLeaf sa_sent; //type: boolean
                            YLeaf sa_received; //type: boolean
                            YLeaf sa_joined; //type: boolean
                            YLeaf anycast_rp_match; //type: boolean
                            YLeaf anycast_rp_route_target; //type: string
                            YLeaf bgp_join; //type: boolean
                            YLeaf bgpjp_time; //type: uint64
                            YLeaf customer_routing_type; //type: int32
                            YLeaf extranet_route; //type: boolean
                            YLeaf mofrr_active; //type: boolean
                            YLeaf mofrr_primary; //type: boolean
                            YLeaf mofrr_backup; //type: boolean
                            YLeaf vxlan; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::SourceAddressXr


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpAddress


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfNeighbor


                        class SecondaryRpfNeighbor : public Entity
                        {
                            public:
                                SecondaryRpfNeighbor();
                                ~SecondaryRpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfRoot


                        class ProxyAddress : public Entity
                        {
                            public:
                                ProxyAddress();
                                ~ProxyAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::ProxyAddress


                        class OrigSrcAddress : public Entity
                        {
                            public:
                                OrigSrcAddress();
                                ~OrigSrcAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress


                        class OutgoingInterface : public Entity
                        {
                            public:
                                OutgoingInterface();
                                ~OutgoingInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                                YLeaf jp_timer; //type: int32
                                YLeaf jp_state; //type: int32
                                YLeaf assert_timer; //type: int32
                                YLeaf local_members; //type: int32
                                YLeaf internal_interest_info; //type: int32
                                YLeaf forwarding_state; //type: int32
                                YLeaf immediate_state; //type: int32
                                YLeaf last_hop; //type: boolean
                                YLeaf mldp_inband_mdt; //type: boolean
                                YLeaf mldp_stale; //type: boolean
                                YLeaf sa_prune; //type: boolean
                                YLeaf admin_boundary; //type: boolean
                                YLeaf igmp_membership; //type: boolean
                                YLeaf mdt_safi_join; //type: boolean
                                YLeaf mvpn_safi_join; //type: boolean
                                YLeaf local_mdt_join; //type: boolean
                                YLeaf data_mdt_join; //type: boolean
                                YLeaf mvp_nv6_safi_join; //type: boolean
                                YLeaf bgp_c_mcast_join; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf extranet_interface; //type: boolean

                            class AssertWinner : public Entity
                            {
                                public:
                                    AssertWinner();
                                    ~AssertWinner();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress> orig_src_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::ProxyAddress> proxy_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies::Topology> > topology;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Topologies


                class BgpAfs : public Entity
                {
                    public:
                        BgpAfs();
                        ~BgpAfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BgpAf : public Entity
                    {
                        public:
                            BgpAf();
                            ~BgpAf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf route_distinguisher; //type: string
                            YLeaf extranet_path_count; //type: uint32
                            YLeaf is_bgp_added; //type: boolean

                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Source


                        class Group : public Entity
                        {
                            public:
                                Group();
                                ~Group();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Group


                        class NextHop : public Entity
                        {
                            public:
                                NextHop();
                                ~NextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::NextHop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Group> group;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::NextHop> next_hop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf::Source> source;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs::BgpAf> > bgp_af;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs


                class AutoRp : public Entity
                {
                    public:
                        AutoRp();
                        ~AutoRp();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;





                }; // Ipv6Pim::Standby::Vrfs::Vrf::AutoRp


                class TopologyInterfaceFlagRouteCounts : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCounts();
                        ~TopologyInterfaceFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyInterfaceFlagRouteCount : public Entity
                    {
                        public:
                            TopologyInterfaceFlagRouteCount();
                            ~TopologyInterfaceFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts


                class GroupMapSources : public Entity
                {
                    public:
                        GroupMapSources();
                        ~GroupMapSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapSource : public Entity
                    {
                        public:
                            GroupMapSource();
                            ~GroupMapSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf priority; //type: int32
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources::GroupMapSource> > group_map_source;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf inputs; //type: uint32
                        YLeaf outputs; //type: uint32
                        YLeaf format_error; //type: uint32
                        YLeaf pakman_error; //type: uint32
                        YLeaf standby_packets_error; //type: uint32
                        YLeaf checksum_error; //type: uint32
                        YLeaf socket_error; //type: uint32
                        YLeaf send_queue_full; //type: uint32
                        YLeaf boundary_acl_rx_drop; //type: uint32
                        YLeaf boundary_acl_tx_drop; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf no_source_address; //type: uint32
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_data_register; //type: uint32
                        YLeaf input_null_register; //type: uint32
                        YLeaf output_data_register; //type: uint32
                        YLeaf output_null_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf input_assert_batched; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf output_assert_batched; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_ecmp_redirect; //type: uint32
                        YLeaf output_ecmp_redirect; //type: uint32
                        YLeaf output_loop_error; //type: uint32
                        YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                        YLeaf input_no_idb_error; //type: uint32
                        YLeaf input_no_vrf_error; //type: uint32
                        YLeaf input_no_pim_error; //type: uint32
                        YLeaf input_pim_version_error; //type: uint32
                        YLeaf output_join_group; //type: uint32
                        YLeaf output_prune_group; //type: uint32
                        YLeaf output_join_prune_bytes; //type: uint32
                        YLeaf output_hello_bytes; //type: uint32
                        YLeaf non_supported_packets; //type: uint32
                        YLeaf invalid_registers; //type: uint32
                        YLeaf invalid_join_prunes; //type: uint32
                        YLeaf packet_packman_error; //type: uint32
                        YLeaf packet_read_socket_error; //type: uint32
                        YLeaf packet_queue_last_clear; //type: uint32
                        YLeaf packets_standby; //type: uint32
                        YLeaf no_mdt_socket_connection; //type: uint32
                        YLeaf mdt_send_queue_full; //type: uint32
                        YLeaf mdt_socket_error; //type: uint32
                        YLeaf mdt_join_tlv_sent; //type: uint32
                        YLeaf mdt_join_tlv_received; //type: uint32
                        YLeaf mdt_join_bad_type; //type: uint32
                        YLeaf mdt_drop_local_source_address; //type: uint32
                        YLeaf mdt_drop_null_local_address; //type: uint32
                        YLeaf mdt_drop_no_idb; //type: uint32
                        YLeaf mdt_drop_no_vrf; //type: uint32
                        YLeaf invalid_destination_packets; //type: uint32
                        YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                        YLeaf truncated_pim_packets; //type: uint32
                        YLeafList packet_enqueued; //type: list of  uint32
                        YLeafList packet_dequeued; //type: list of  uint32
                        YLeafList packet_queue_length; //type: list of  uint32
                        YLeafList packet_queue_size; //type: list of  uint32
                        YLeafList packet_tail_drop; //type: list of  uint32

                    class PacketQueue : public Entity
                    {
                        public:
                            PacketQueue();
                            ~PacketQueue();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf packet_queue_priority; //type: uint32

                        class PacketQueueState : public Entity
                        {
                            public:
                                PacketQueueState();
                                ~PacketQueueState();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf max_queue_size; //type: uint32
                                YLeaf queue_size_bytes; //type: uint32
                                YLeaf queue_size_packets; //type: uint32



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState


                        class PacketQueueStats : public Entity
                        {
                            public:
                                PacketQueueStats();
                                ~PacketQueueStats();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf enqueued_packets; //type: uint32
                                YLeaf dequeued_packets; //type: uint32
                                YLeaf high_water_mark_packets; //type: uint32
                                YLeaf high_water_mark_bytes; //type: uint32
                                YLeaf tail_drops; //type: uint32



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters::PacketQueue> > packet_queue;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters


                class GroupMapRpfs : public Entity
                {
                    public:
                        GroupMapRpfs();
                        ~GroupMapRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapRpf : public Entity
                    {
                        public:
                            GroupMapRpf();
                            ~GroupMapRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf rp_priority; //type: int32
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs


                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_limit; //type: uint32
                        YLeaf route_count; //type: uint32
                        YLeaf route_low_water_mark; //type: uint32
                        YLeaf is_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_limit; //type: uint32
                        YLeaf topology_interface_state_count; //type: uint32
                        YLeaf rxi_low_water_mark; //type: uint32
                        YLeaf rxi_limit_reached; //type: boolean
                        YLeaf register_limit; //type: uint32
                        YLeaf register_count; //type: uint32
                        YLeaf register_limit_reached; //type: boolean
                        YLeaf ranges_limit; //type: uint32
                        YLeaf ranges_count; //type: uint32
                        YLeaf ranges_threshold; //type: uint32
                        YLeaf is_ranges_limit_reached; //type: boolean
                        YLeaf bsr_ranges_limit; //type: uint32
                        YLeaf bsr_ranges_count; //type: uint32
                        YLeaf bsr_range_threshold; //type: uint32
                        YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                        YLeaf bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf bsr_candidate_rp_set_count; //type: uint32
                        YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_maximum_enforcement_disabled; //type: boolean
                        YLeaf is_node_low_memory; //type: boolean
                        YLeaf route_threshold; //type: uint32
                        YLeaf global_auto_rp_ranges_limit; //type: uint32
                        YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_ranges_limit; //type: uint32
                        YLeaf global_bsr_ranges_count; //type: uint32
                        YLeaf global_bsr_ranges_threshold; //type: uint32
                        YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_global_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_threshold; //type: uint32
                        YLeaf is_global_rxi_limit_reached; //type: boolean
                        YLeaf register_threshold; //type: uint32
                        YLeaf global_register_limit; //type: uint32
                        YLeaf is_global_register_limit_reached; //type: boolean



                }; // Ipv6Pim::Standby::Vrfs::Vrf::Summary


                class Gre : public Entity
                {
                    public:
                        Gre();
                        ~Gre();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHashes : public Entity
                    {
                        public:
                            GreHashes();
                            ~GreHashes();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreHash : public Entity
                        {
                            public:
                                GreHash();
                                ~GreHash();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf destination_address; //type: string
                                YLeaf ifname; //type: string
                                YLeaf next_hop_interface; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreHashes::GreHash


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreHashes::GreHash> > gre_hash;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreHashes


                    class GreNextHops : public Entity
                    {
                        public:
                            GreNextHops();
                            ~GreNextHops();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreNextHop : public Entity
                        {
                            public:
                                GreNextHop();
                                ~GreNextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf destination_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8

                            class RegisteredAddress : public Entity
                            {
                                public:
                                    RegisteredAddress();
                                    ~RegisteredAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress


                            class GrePath : public Entity
                            {
                                public:
                                    GrePath();
                                    ~GrePath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf gre_interface_name; //type: string
                                    YLeaf is_gre_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf extranet_vrf_name; //type: string

                                class GreNeighbor : public Entity
                                {
                                    public:
                                        GreNeighbor();
                                        ~GreNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                                class GreNextHop_ : public Entity
                                {
                                    public:
                                        GreNextHop_();
                                        ~GreNextHop_();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreHashes> gre_hashes;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre::GreNextHops> gre_next_hops;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Gre


                class BidirDfWinners : public Entity
                {
                    public:
                        BidirDfWinners();
                        ~BidirDfWinners();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfWinner : public Entity
                    {
                        public:
                            BidirDfWinner();
                            ~BidirDfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf are_we_df; //type: boolean
                            YLeaf rp_lan; //type: boolean
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf uptime; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr


                        class DfWinner : public Entity
                        {
                            public:
                                DfWinner();
                                ~DfWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners


                class TableContexts : public Entity
                {
                    public:
                        TableContexts();
                        ~TableContexts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TableContext : public Entity
                    {
                        public:
                            TableContext();
                            ~TableContext();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::TableContexts::TableContext


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TableContexts::TableContext> > table_context;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::TableContexts


                class GlobalInterfaces : public Entity
                {
                    public:
                        GlobalInterfaces();
                        ~GlobalInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GlobalInterface : public Entity
                    {
                        public:
                            GlobalInterface();
                            ~GlobalInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces::GlobalInterface> > global_interface;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces


                class NeighborSummaries : public Entity
                {
                    public:
                        NeighborSummaries();
                        ~NeighborSummaries();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborSummary : public Entity
                    {
                        public:
                            NeighborSummary();
                            ~NeighborSummary();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf number_of_neighbors; //type: int32
                            YLeaf number_of_external_neighbors; //type: int32



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::NeighborSummaries::NeighborSummary


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NeighborSummaries::NeighborSummary> > neighbor_summary;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::NeighborSummaries


                class Context : public Entity
                {
                    public:
                        Context();
                        ~Context();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf murib_id; //type: uint32
                        YLeaf rpf_id; //type: uint32
                        YLeaf remote_table_id; //type: uint32
                        YLeaf mdt_default_group; //type: string
                        YLeaf mdt_interface; //type: string
                        YLeaf mdt_gre_rpf_identifier; //type: uint32
                        YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                        YLeaf is_unicast_rib_registration; //type: boolean
                        YLeaf is_multicast_rib_registration; //type: boolean
                        YLeaf is_active; //type: boolean
                        YLeaf is_active_ital; //type: boolean
                        YLeaf is_mrib_register; //type: boolean
                        YLeaf is_mdt_owner; //type: boolean
                        YLeaf is_routing_enabled; //type: boolean
                        YLeaf is_socket_add_required; //type: boolean
                        YLeaf is_socket_added; //type: boolean
                        YLeaf is_lpts_socket_add_required; //type: boolean
                        YLeaf is_lpts_socket_added; //type: boolean
                        YLeaf is_udp_socket_add_required; //type: boolean
                        YLeaf is_udp_socket_added; //type: boolean
                        YLeaf is_udp_socket_bind_required; //type: boolean
                        YLeaf is_udp_socket_bind; //type: boolean
                        YLeaf is_register_injection_socket_add_required; //type: boolean
                        YLeaf is_register_injection_socket_added; //type: boolean
                        YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                        YLeaf is_register_injection_lpts_socket_added; //type: boolean
                        YLeaf is_m_host_publish_pending; //type: boolean
                        YLeaf mhost_interface; //type: string
                        YLeaf mhost_default_interface_config; //type: string
                        YLeaf mdt_mtu; //type: uint32
                        YLeaf maximum_mdt_aggregation; //type: uint32
                        YLeaf mdt_data_switchover_interval; //type: uint32
                        YLeaf mdt_data_announce_interval; //type: uint32
                        YLeaf non_default_vrf_count_on_socket; //type: uint32
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf mdt_neighbor_filter_name; //type: string
                        YLeaf allow_rp_configured; //type: boolean
                        YLeaf allow_rp_group_list; //type: string
                        YLeaf allow_rp_rp_list; //type: string
                        YLeaf sg_expiry_timer_configured; //type: boolean
                        YLeaf sg_expiry_time; //type: uint16
                        YLeaf sg_expiry_timer_sg_list; //type: string
                        YLeaf mldp_mdt_name; //type: string
                        YLeaf mldp_mdt_interface; //type: string
                        YLeaf mldp_mdt_mtu; //type: uint32
                        YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                        YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                        YLeaf mldp_mdt_data_announce_interval; //type: uint32
                        YLeaf mldp_mdt_rpf_identifier; //type: uint32
                        YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                        YLeaf is_create_mldp_mdt_interface; //type: boolean
                        YLeaf is_mldp_mdt_owner; //type: boolean
                        YLeaf mldp_root_count; //type: uint32
                        YLeaf mldp_head_lsm_identifier; //type: uint32
                        YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                        YLeaf organization_unique_identifier; //type: uint32
                        YLeaf vpn_index; //type: uint32
                        YLeaf mldp_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                        YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                        YLeaf mldp_head_local_label; //type: uint32
                        YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                        YLeaf bgp_auto_discovery_configured; //type: boolean
                        YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                        YLeaf inter_autonomous_system_enabled; //type: boolean
                        YLeaf bgp_source_active_announce; //type: boolean
                        YLeaf bgp_i_pmsi_added; //type: boolean
                        YLeaf mldp_bsr_control_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                        YLeaf bgp_auto_discovery_type; //type: uint32
                        YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                        YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                        YLeaf mldp_control_head_lsm_identifier; //type: uint32
                        YLeaf umh; //type: boolean
                        YLeaf suppress_shared_tree_join; //type: boolean
                        YLeaf rsvp_te_mdt_name; //type: string
                        YLeaf rsvp_te_mdt_interface; //type: string
                        YLeaf rsvp_te_mdt_mtu; //type: uint32
                        YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                        YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                        YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                        YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                        YLeaf is_rsvp_te_mdt_owner; //type: boolean
                        YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                        YLeaf p2mpte_li_drop; //type: uint32
                        YLeaf ir_mdt_name; //type: string
                        YLeaf ir_mdt_interface; //type: string
                        YLeaf ir_mdt_mtu; //type: uint32
                        YLeaf ir_maximum_mdt_aggregation; //type: uint32
                        YLeaf ir_mdt_data_switchover_interval; //type: uint32
                        YLeaf ir_mdt_data_announce_interval; //type: uint32
                        YLeaf ir_mdt_rpf_identifier; //type: uint32
                        YLeaf ir_mdt_tail_label; //type: uint32
                        YLeaf is_create_ir_mdt_interface; //type: boolean
                        YLeaf is_ir_mdt_owner; //type: boolean
                        YLeaf in_b_and_mdt_name; //type: string
                        YLeaf in_b_and_mdt_interface; //type: string
                        YLeaf in_b_and_mdt_mtu; //type: uint32
                        YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                        YLeaf is_in_b_and_mdt_owner; //type: boolean
                        YLeaf in_band_signaling_local_enabled; //type: boolean
                        YLeaf in_band_signaling_remote_enabled; //type: boolean
                        YLeaf valid_rd_present; //type: boolean
                        YLeaf stale_rd_present; //type: boolean
                        YLeaf route_distinguisher; //type: string
                        YLeaf gin_b_and_mdt_name; //type: string
                        YLeaf gin_b_and_mdt_interface; //type: string
                        YLeaf gin_b_and_mdt_mtu; //type: uint32
                        YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                        YLeaf is_gin_b_and_mdt_owner; //type: boolean
                        YLeaf is_pim_nsf_rib_converged; //type: boolean
                        YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                        YLeaf is_rib_multipath_enabled; //type: boolean
                        YLeaf is_rib_multipath_interface_hash; //type: boolean
                        YLeaf is_rib_multipath_source_hash; //type: boolean
                        YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf is_create_mdt_interface; //type: boolean
                        YLeaf is_auto_rp_listen_enabled; //type: boolean
                        YLeaf is_all_interface_disable_operation; //type: boolean
                        YLeaf is_default_granges; //type: boolean
                        YLeaf is_auto_rp_listen_sock_add; //type: boolean
                        YLeaf is_redistribution_reset; //type: boolean
                        YLeaf redistribution_reset_count; //type: uint32
                        YLeaf rpf_policy_name; //type: string
                        YLeaf table_count; //type: uint32
                        YLeaf active_table_count; //type: uint32
                        YLeaf anycast_rp_policy_name; //type: string
                        YLeaf anycast_rp_configured; //type: boolean
                        YLeaf bgp_remote_on; //type: boolean
                        YLeaf bgp_remote_interface_name; //type: string
                        YLeaf bgp_remote_interface; //type: string
                        YLeaf bgp_remote_address; //type: string
                        YLeaf bgp_remote_state; //type: uint32
                        YLeafList mldp_root_address; //type: list of  uint32

                    class RemoteDefaultGroup : public Entity
                    {
                        public:
                            RemoteDefaultGroup();
                            ~RemoteDefaultGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Context::RemoteDefaultGroup


                    class RpfDefaultTable : public Entity
                    {
                        public:
                            RpfDefaultTable();
                            ~RpfDefaultTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Context::RpfDefaultTable


                    class ExportRouteTarget : public Entity
                    {
                        public:
                            ExportRouteTarget();
                            ~ExportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Context::ExportRouteTarget


                    class ImportRouteTarget : public Entity
                    {
                        public:
                            ImportRouteTarget();
                            ~ImportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Context::ImportRouteTarget


                    class AnycastRpRange : public Entity
                    {
                        public:
                            AnycastRpRange();
                            ~AnycastRpRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: uint8
                            YLeaf ancast_rp_marked; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange::Prefix


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange::Prefix> prefix;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context::AnycastRpRange> > anycast_rp_range;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context::ExportRouteTarget> > export_route_target;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context::ImportRouteTarget> > import_route_target;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context::RemoteDefaultGroup> remote_default_group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context::RpfDefaultTable> rpf_default_table;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Context


                class TopologyEntryFlagRouteCounts : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCounts();
                        ~TopologyEntryFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyEntryFlagRouteCount : public Entity
                    {
                        public:
                            TopologyEntryFlagRouteCount();
                            ~TopologyEntryFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts


                class RpfRedirect : public Entity
                {
                    public:
                        RpfRedirect();
                        ~RpfRedirect();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabases : public Entity
                    {
                        public:
                            RedirectRouteDatabases();
                            ~RedirectRouteDatabases();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RedirectRouteDatabase : public Entity
                        {
                            public:
                                RedirectRouteDatabase();
                                ~RedirectRouteDatabase();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf bandwidth; //type: uint32
                                YLeaf uptime; //type: uint64

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                            class Interface : public Entity
                            {
                                public:
                                    Interface();
                                    ~Interface();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiry; //type: uint64
                                    YLeaf is_rpf_interface; //type: boolean
                                    YLeaf is_outgoing_interface; //type: boolean
                                    YLeaf is_snoop_interface; //type: boolean

                                class RpfAddress : public Entity
                                {
                                    public:
                                        RpfAddress();
                                        ~RpfAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                            }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases


                    class BundleInterfaces : public Entity
                    {
                        public:
                            BundleInterfaces();
                            ~BundleInterfaces();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BundleInterface : public Entity
                        {
                            public:
                                BundleInterface();
                                ~BundleInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf bundle_name; //type: string
                                YLeaf interface_name; //type: string
                                YLeaf rpf_redirect_bundle_name; //type: string
                                YLeaf rpf_redirect_interface_name; //type: string
                                YLeaf available_bandwidth; //type: int32
                                YLeaf allocated_bandwidth; //type: int32
                                YLeaf total_bandwidth; //type: int32
                                YLeaf topology_bandwidth_used; //type: int32
                                YLeaf snooping_bandwidth_used; //type: int32
                                YLeaf allocated_threshold_bandwidth; //type: int32
                                YLeaf available_threshold_bandwidth; //type: int32



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::BundleInterfaces> bundle_interfaces;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect


                class Tunnels : public Entity
                {
                    public:
                        Tunnels();
                        ~Tunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Tunnel : public Entity
                    {
                        public:
                            Tunnel();
                            ~Tunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Tunnels::Tunnel> > tunnel;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Tunnels


                class MulticastStaticRoutes : public Entity
                {
                    public:
                        MulticastStaticRoutes();
                        ~MulticastStaticRoutes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MulticastStaticRoute : public Entity
                    {
                        public:
                            MulticastStaticRoute();
                            ~MulticastStaticRoute();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf address; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf interface_name; //type: string
                            YLeaf distance; //type: uint32
                            YLeaf prefix_length_xr; //type: uint8
                            YLeaf is_via_lsm; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                        class Nexthop : public Entity
                        {
                            public:
                                Nexthop();
                                ~Nexthop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes


                class GroupMapMatchSources : public Entity
                {
                    public:
                        GroupMapMatchSources();
                        ~GroupMapMatchSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchSource : public Entity
                    {
                        public:
                            GroupMapMatchSource();
                            ~GroupMapMatchSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources


                class Neighbors : public Entity
                {
                    public:
                        Neighbors();
                        ~Neighbors();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Neighbor : public Entity
                    {
                        public:
                            Neighbor();
                            ~Neighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                    }; // Ipv6Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Neighbors::Neighbor> > neighbor;


                }; // Ipv6Pim::Standby::Vrfs::Vrf::Neighbors


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::AutoRp> auto_rp;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BgpAfs> bgp_afs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfStates> bidir_df_states;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::BidirDfWinners> bidir_df_winners;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Bsr> bsr;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Context> context;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GlobalInterfaces> global_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Gre> gre;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchRpfs> group_map_match_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapMatchSources> group_map_match_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapRpfs> group_map_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::GroupMapSources> group_map_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::IfrsSummary> ifrs_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::InterfaceStatistics> interface_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Interfaces> interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::JpStatistics> jp_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MibDatabases> mib_databases;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::MulticastStaticRoutes> multicast_static_routes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NeighborOldFormats> neighbor_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NeighborSummaries> neighbor_summaries;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Neighbors> neighbors;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::NetIoTunnels> net_io_tunnels;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RoutePolicy> route_policy;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfRedirect> rpf_redirect;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::RpfSummary> rpf_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Safs> safs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TableContexts> table_contexts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Topologies> topologies;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TopologyRouteCount> topology_route_count;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::TrafficCounters> traffic_counters;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf::Tunnels> tunnels;


            }; // Ipv6Pim::Standby::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs::Vrf> > vrf;


        }; // Ipv6Pim::Standby::Vrfs


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby::Vrfs> vrfs;


    }; // Ipv6Pim::Standby


    class Active : public Entity
    {
        public:
            Active();
            ~Active();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class DefaultContext : public Entity
        {
            public:
                DefaultContext();
                ~DefaultContext();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class IfrsInterfaces : public Entity
            {
                public:
                    IfrsInterfaces();
                    ~IfrsInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class IfrsInterface : public Entity
                {
                    public:
                        IfrsInterface();
                        ~IfrsInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::IfrsInterfaces::IfrsInterface> > ifrs_interface;


            }; // Ipv6Pim::Active::DefaultContext::IfrsInterfaces


            class Safs : public Entity
            {
                public:
                    Safs();
                    ~Safs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Saf : public Entity
                {
                    public:
                        Saf();
                        ~Saf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string

                    class RpfHashSourceGroups : public Entity
                    {
                        public:
                            RpfHashSourceGroups();
                            ~RpfHashSourceGroups();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSourceGroup : public Entity
                        {
                            public:
                                RpfHashSourceGroup();
                                ~RpfHashSourceGroup();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf mask_length; //type: int32
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                    }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups


                    class RpfNeighbors : public Entity
                    {
                        public:
                            RpfNeighbors();
                            ~RpfNeighbors();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf neighbor_address; //type: string
                                YLeaf rib_neighbor_interface; //type: string

                            class RibNeighborAddress : public Entity
                            {
                                public:
                                    RibNeighborAddress();
                                    ~RibNeighborAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                            class RpfRegisteredAddresses : public Entity
                            {
                                public:
                                    RpfRegisteredAddresses();
                                    ~RpfRegisteredAddresses();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_registered_address_references; //type: uint32

                                class RibRegistrationAddress : public Entity
                                {
                                    public:
                                        RibRegistrationAddress();
                                        ~RibRegistrationAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                        }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                    }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors


                    class RpfHashSources : public Entity
                    {
                        public:
                            RpfHashSources();
                            ~RpfHashSources();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpfHashSource : public Entity
                        {
                            public:
                                RpfHashSource();
                                ~RpfHashSource();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf mofrr; //type: int32
                                YLeaf next_hop_multipath_enabled; //type: boolean
                                YLeaf next_hop_interface; //type: string
                                YLeaf secondary_next_hop_interface; //type: string

                            class NextHopAddress : public Entity
                            {
                                public:
                                    NextHopAddress();
                                    ~NextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                            class SecondaryNextHopAddress : public Entity
                            {
                                public:
                                    SecondaryNextHopAddress();
                                    ~SecondaryNextHopAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                        }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                    }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources


                    class Rpfs : public Entity
                    {
                        public:
                            Rpfs();
                            ~Rpfs();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class Rpf : public Entity
                        {
                            public:
                                Rpf();
                                ~Rpf();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf registered_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8
                                YLeaf is_rpf_bgp_route; //type: boolean

                            class RegisteredAddressXr : public Entity
                            {
                                public:
                                    RegisteredAddressXr();
                                    ~RegisteredAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                            class RpfPath : public Entity
                            {
                                public:
                                    RpfPath();
                                    ~RpfPath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf rpf_interface_name; //type: string
                                    YLeaf is_rpf_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_via_mlsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf connector; //type: string
                                    YLeaf extranet_vrf_name; //type: string

                                class RpfNeighbor : public Entity
                                {
                                    public:
                                        RpfNeighbor();
                                        ~RpfNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                class RpfNexthop : public Entity
                                {
                                    public:
                                        RpfNexthop();
                                        ~RpfNexthop();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                            }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                        }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs::Rpf> > rpf;


                    }; // Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfHashSources> rpf_hash_sources;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::RpfNeighbors> rpf_neighbors;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf::Rpfs> rpfs;


                }; // Ipv6Pim::Active::DefaultContext::Safs::Saf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs::Saf> > saf;


            }; // Ipv6Pim::Active::DefaultContext::Safs


            class InterfaceStatistics : public Entity
            {
                public:
                    InterfaceStatistics();
                    ~InterfaceStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceStatistic : public Entity
                {
                    public:
                        InterfaceStatistic();
                        ~InterfaceStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_register; //type: uint32
                        YLeaf output_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf input_graft_message; //type: uint32
                        YLeaf output_graft_message; //type: uint32
                        YLeaf input_graft_ack_message; //type: uint32
                        YLeaf output_graft_ack_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_miscellaneous; //type: uint32



                }; // Ipv6Pim::Active::DefaultContext::InterfaceStatistics::InterfaceStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


            }; // Ipv6Pim::Active::DefaultContext::InterfaceStatistics


            class TopologyRouteCount : public Entity
            {
                public:
                    TopologyRouteCount();
                    ~TopologyRouteCount();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf group_ranges; //type: uint32
                    YLeaf active_group_ranges; //type: uint32
                    YLeaf groute_count; //type: uint32
                    YLeaf sg_route_count; //type: uint32
                    YLeaf sgr_route_count; //type: uint32
                    YLeaf is_node_low_memory; //type: boolean

                class GroupAddress : public Entity
                {
                    public:
                        GroupAddress();
                        ~GroupAddress();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Ipv6Pim::Active::DefaultContext::TopologyRouteCount::GroupAddress


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyRouteCount::GroupAddress> group_address;


            }; // Ipv6Pim::Active::DefaultContext::TopologyRouteCount


            class JpStatistics : public Entity
            {
                public:
                    JpStatistics();
                    ~JpStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class JpStatistic : public Entity
                {
                    public:
                        JpStatistic();
                        ~JpStatistic();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf mtu; //type: uint32
                        YLeaf transmitted; //type: uint32
                        YLeaf transmitted100; //type: uint16
                        YLeaf transmitted_1k; //type: uint16
                        YLeaf transmitted_10k; //type: uint16
                        YLeaf transmitted_50k; //type: uint16
                        YLeaf received; //type: uint32
                        YLeaf received100; //type: uint16
                        YLeaf received_1k; //type: uint16
                        YLeaf received_10k; //type: uint16
                        YLeaf received_50k; //type: uint16



                }; // Ipv6Pim::Active::DefaultContext::JpStatistics::JpStatistic


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::JpStatistics::JpStatistic> > jp_statistic;


            }; // Ipv6Pim::Active::DefaultContext::JpStatistics


            class MibDatabases : public Entity
            {
                public:
                    MibDatabases();
                    ~MibDatabases();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MibDatabase : public Entity
                {
                    public:
                        MibDatabase();
                        ~MibDatabase();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf source_netmask; //type: int32
                        YLeaf upstream_assert_timer; //type: int32
                        YLeaf assert_metric; //type: uint32
                        YLeaf assert_metric_preference; //type: uint32
                        YLeaf assert_rpt_bit; //type: boolean
                        YLeaf spt_bit; //type: boolean
                        YLeaf rpf_mask; //type: uint32
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf bidirectional_route; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf protocol; //type: PimShowProtocolEnum

                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr


                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfRoot


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                }; // Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MibDatabases::MibDatabase> > mib_database;


            }; // Ipv6Pim::Active::DefaultContext::MibDatabases


            class GroupMapMatchRpfs : public Entity
            {
                public:
                    GroupMapMatchRpfs();
                    ~GroupMapMatchRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchRpf : public Entity
                {
                    public:
                        GroupMapMatchRpf();
                        ~GroupMapMatchRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


            }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs


            class NeighborOldFormats : public Entity
            {
                public:
                    NeighborOldFormats();
                    ~NeighborOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborOldFormat : public Entity
                {
                    public:
                        NeighborOldFormat();
                        ~NeighborOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                }; // Ipv6Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


            }; // Ipv6Pim::Active::DefaultContext::NeighborOldFormats


            class IfrsSummary : public Entity
            {
                public:
                    IfrsSummary();
                    ~IfrsSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf interface_count; //type: uint32
                    YLeaf configuration_count; //type: uint32



            }; // Ipv6Pim::Active::DefaultContext::IfrsSummary


            class Ranges : public Entity
            {
                public:
                    Ranges();
                    ~Ranges();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Range : public Entity
                {
                    public:
                        Range();
                        ~Range();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf client_xr; //type: PimShowRangeClientEnum
                        YLeaf expires; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Ranges::Range::RpAddressXr


                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Ranges::Range::SourceOfInformation


                    class GroupRange : public Entity
                    {
                        public:
                            GroupRange();
                            ~GroupRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Ranges::Range::GroupRange::Prefix


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges::Range::GroupRange::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Active::DefaultContext::Ranges::Range::GroupRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges::Range::GroupRange> > group_range;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges::Range::RpAddressXr> rp_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges::Range::SourceOfInformation> source_of_information;


                }; // Ipv6Pim::Active::DefaultContext::Ranges::Range


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges::Range> > range;


            }; // Ipv6Pim::Active::DefaultContext::Ranges


            class InterfaceOldFormats : public Entity
            {
                public:
                    InterfaceOldFormats();
                    ~InterfaceOldFormats();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceOldFormat : public Entity
                {
                    public:
                        InterfaceOldFormat();
                        ~InterfaceOldFormat();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


            }; // Ipv6Pim::Active::DefaultContext::InterfaceOldFormats


            class Bsr : public Entity
            {
                public:
                    Bsr();
                    ~Bsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RpCaches : public Entity
                {
                    public:
                        RpCaches();
                        ~RpCaches();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCache : public Entity
                    {
                        public:
                            RpCache();
                            ~RpCache();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_prefix; //type: string
                            YLeaf group_prefix_length; //type: uint32
                            YLeaf candidate_rp_group_count; //type: uint32

                        class GroupPrefixXr : public Entity
                        {
                            public:
                                GroupPrefixXr();
                                ~GroupPrefixXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr


                        class CandidateRpList : public Entity
                        {
                            public:
                                CandidateRpList();
                                ~CandidateRpList();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class PimBsrCrpBag : public Entity
                            {
                                public:
                                    PimBsrCrpBag();
                                    ~PimBsrCrpBag();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_holdtime; //type: uint16
                                    YLeaf candidate_rp_priority; //type: uint8
                                    YLeaf candidate_rp_up_time; //type: uint16
                                    YLeaf candidate_rp_expires; //type: uint16
                                    YLeaf protocol; //type: PimShowProtocolEnum

                                class CandidateRpAddress : public Entity
                                {
                                    public:
                                        CandidateRpAddress();
                                        ~CandidateRpAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                            }; // Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                        }; // Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                    }; // Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::RpCaches::RpCache> > rp_cache;


                }; // Ipv6Pim::Active::DefaultContext::Bsr::RpCaches


                class CandidateRps : public Entity
                {
                    public:
                        CandidateRps();
                        ~CandidateRps();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class CandidateRp : public Entity
                    {
                        public:
                            CandidateRp();
                            ~CandidateRp();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                            YLeaf candidate_rp_scope; //type: int32
                            YLeaf crp_priority; //type: uint8
                            YLeaf crp_holdtime; //type: uint16
                            YLeaf candidate_rp_advance_interval; //type: uint16
                            YLeaf candidate_rp_uptime; //type: uint16
                            YLeaf acl_name; //type: string

                        class CandidateRp_ : public Entity
                        {
                            public:
                                CandidateRp_();
                                ~CandidateRp_();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_


                        class CrpAccess : public Entity
                        {
                            public:
                                CrpAccess();
                                ~CrpAccess();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf acl_name; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                    }; // Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                }; // Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps


                class BsrElections : public Entity
                {
                    public:
                        BsrElections();
                        ~BsrElections();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BsrElection : public Entity
                    {
                        public:
                            BsrElection();
                            ~BsrElection();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf pim_scope; //type: int32
                            YLeaf bsr_priority; //type: uint8
                            YLeaf bsr_mask_length; //type: uint8
                            YLeaf bsr_up_time; //type: uint16
                            YLeaf bootstrap_timeout; //type: uint16
                            YLeaf candidate_bsr_state; //type: uint32
                            YLeaf bsr_election_state; //type: uint32
                            YLeaf bsr_scope; //type: uint16
                            YLeaf candidate_bsr_flag; //type: boolean
                            YLeaf candidate_bsr_priority; //type: uint8
                            YLeaf candidate_bsr_mask_length; //type: uint8

                        class BsrAddress : public Entity
                        {
                            public:
                                BsrAddress();
                                ~BsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress


                        class CandidateBsrAddress : public Entity
                        {
                            public:
                                CandidateBsrAddress();
                                ~CandidateBsrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                    }; // Ipv6Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::BsrElections::BsrElection> > bsr_election;


                }; // Ipv6Pim::Active::DefaultContext::Bsr::BsrElections


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::BsrElections> bsr_elections;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::CandidateRps> candidate_rps;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr::RpCaches> rp_caches;


            }; // Ipv6Pim::Active::DefaultContext::Bsr


            class RoutePolicy : public Entity
            {
                public:
                    RoutePolicy();
                    ~RoutePolicy();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RoutePolicyStatistics : public Entity
                {
                    public:
                        RoutePolicyStatistics();
                        ~RoutePolicyStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf policy_name; //type: string
                        YLeaf requests; //type: uint32
                        YLeaf pass; //type: uint32
                        YLeaf drop; //type: uint32
                        YLeaf default_table; //type: uint32
                        YLeaf any_table; //type: uint32



                }; // Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyStatistics


                class RoutePolicyTests : public Entity
                {
                    public:
                        RoutePolicyTests();
                        ~RoutePolicyTests();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyTest : public Entity
                    {
                        public:
                            RoutePolicyTest();
                            ~RoutePolicyTest();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf ext_comm; //type: string
                            YLeaf policy_name; //type: string
                            YLeaf extended_community_rt; //type: string
                            YLeaf pass; //type: boolean
                            YLeaf default_table; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf table_exists; //type: boolean
                            YLeaf table_active; //type: boolean

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                }; // Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RoutePolicy::RoutePolicyTests> route_policy_tests;


            }; // Ipv6Pim::Active::DefaultContext::RoutePolicy


            class RpfSummary : public Entity
            {
                public:
                    RpfSummary();
                    ~RpfSummary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf default_safi; //type: uint32
                    YLeaf default_table_name; //type: string
                    YLeaf is_mbgp_configured; //type: boolean
                    YLeaf is_ospf_te_configured; //type: boolean
                    YLeaf is_isis_te_configured; //type: boolean
                    YLeaf is_isis_mtr_configured; //type: boolean
                    YLeaf mo_frr_configured; //type: boolean
                    YLeaf rib_mo_frr_configured; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf rib_convergence_timeout; //type: uint32
                    YLeaf rib_convergence_time_left; //type: uint32
                    YLeaf is_multipath_enabled; //type: boolean
                    YLeaf is_multipath_interface_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_hash_enabled; //type: boolean
                    YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                    YLeaf rpf_registrations; //type: uint32
                    YLeaf is_rib_convergence; //type: boolean



            }; // Ipv6Pim::Active::DefaultContext::RpfSummary


            class Interfaces : public Entity
            {
                public:
                    Interfaces();
                    ~Interfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Interface : public Entity
                {
                    public:
                        Interface();
                        ~Interface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Interfaces::Interface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Interfaces::Interface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Interfaces::Interface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Interfaces::Interface::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Active::DefaultContext::Interfaces::Interface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Interfaces::Interface> > interface;


            }; // Ipv6Pim::Active::DefaultContext::Interfaces


            class NetIoTunnels : public Entity
            {
                public:
                    NetIoTunnels();
                    ~NetIoTunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NetIoTunnel : public Entity
                {
                    public:
                        NetIoTunnel();
                        ~NetIoTunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                }; // Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


            }; // Ipv6Pim::Active::DefaultContext::NetIoTunnels


            class BidirDfStates : public Entity
            {
                public:
                    BidirDfStates();
                    ~BidirDfStates();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfState : public Entity
                {
                    public:
                        BidirDfState();
                        ~BidirDfState();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf election_state; //type: string
                        YLeaf time_seconds; //type: uint64
                        YLeaf time_nano_seconds; //type: uint64
                        YLeaf our_metric; //type: uint32
                        YLeaf our_metric_preference; //type: uint32

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                }; // Ipv6Pim::Active::DefaultContext::BidirDfStates::BidirDfState


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfStates::BidirDfState> > bidir_df_state;


            }; // Ipv6Pim::Active::DefaultContext::BidirDfStates


            class Topologies : public Entity
            {
                public:
                    Topologies();
                    ~Topologies();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Topology : public Entity
                {
                    public:
                        Topology();
                        ~Topology();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf rpt; //type: int32
                        YLeaf limit_reached; //type: boolean
                        YLeaf low_memory; //type: boolean
                        YLeaf protocol; //type: PimShowProtocolEnum
                        YLeaf wildcard; //type: boolean
                        YLeaf rpt_xr; //type: boolean
                        YLeaf spt; //type: boolean
                        YLeaf uptime; //type: uint64
                        YLeaf expiry; //type: uint64
                        YLeaf alive; //type: int32
                        YLeaf register_received_timer; //type: int32
                        YLeaf remote_source; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string
                        YLeaf rpf_safi; //type: uint8
                        YLeaf rpf_table_name; //type: string
                        YLeaf rpf_drop; //type: boolean
                        YLeaf rpf_extranet; //type: boolean
                        YLeaf is_via_lsm; //type: boolean
                        YLeaf secondary_rpf_interface_name; //type: string
                        YLeaf connected; //type: boolean
                        YLeaf proxy; //type: boolean
                        YLeaf rpf_proxy_enabled; //type: boolean
                        YLeaf mofrr_enabled; //type: boolean
                        YLeaf rib_mo_frr_enabled; //type: boolean
                        YLeaf jp_timer; //type: int32
                        YLeaf jp_status; //type: int32
                        YLeaf suppress_registers; //type: int32
                        YLeaf assume_alive; //type: boolean
                        YLeaf probe_alive; //type: boolean
                        YLeaf really_alive; //type: boolean
                        YLeaf inherit_alive; //type: boolean
                        YLeaf inherit_spt; //type: boolean
                        YLeaf signal_sources; //type: boolean
                        YLeaf dont_check_connected; //type: boolean
                        YLeaf register_received; //type: boolean
                        YLeaf last_hop; //type: boolean
                        YLeaf sending_registers; //type: boolean
                        YLeaf sending_null_registers; //type: boolean
                        YLeaf sa_sent; //type: boolean
                        YLeaf sa_received; //type: boolean
                        YLeaf sa_joined; //type: boolean
                        YLeaf anycast_rp_match; //type: boolean
                        YLeaf anycast_rp_route_target; //type: string
                        YLeaf bgp_join; //type: boolean
                        YLeaf bgpjp_time; //type: uint64
                        YLeaf customer_routing_type; //type: int32
                        YLeaf extranet_route; //type: boolean
                        YLeaf mofrr_active; //type: boolean
                        YLeaf mofrr_primary; //type: boolean
                        YLeaf mofrr_backup; //type: boolean
                        YLeaf vxlan; //type: boolean

                    class GroupAddressXr : public Entity
                    {
                        public:
                            GroupAddressXr();
                            ~GroupAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::GroupAddressXr


                    class SourceAddressXr : public Entity
                    {
                        public:
                            SourceAddressXr();
                            ~SourceAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::SourceAddressXr


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::RpAddress


                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::RpfNeighbor


                    class SecondaryRpfNeighbor : public Entity
                    {
                        public:
                            SecondaryRpfNeighbor();
                            ~SecondaryRpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor


                    class RpfRoot : public Entity
                    {
                        public:
                            RpfRoot();
                            ~RpfRoot();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::RpfRoot


                    class ProxyAddress : public Entity
                    {
                        public:
                            ProxyAddress();
                            ~ProxyAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::ProxyAddress


                    class OrigSrcAddress : public Entity
                    {
                        public:
                            OrigSrcAddress();
                            ~OrigSrcAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::OrigSrcAddress


                    class OutgoingInterface : public Entity
                    {
                        public:
                            OutgoingInterface();
                            ~OutgoingInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_state; //type: int32
                            YLeaf assert_timer; //type: int32
                            YLeaf local_members; //type: int32
                            YLeaf internal_interest_info; //type: int32
                            YLeaf forwarding_state; //type: int32
                            YLeaf immediate_state; //type: int32
                            YLeaf last_hop; //type: boolean
                            YLeaf mldp_inband_mdt; //type: boolean
                            YLeaf mldp_stale; //type: boolean
                            YLeaf sa_prune; //type: boolean
                            YLeaf admin_boundary; //type: boolean
                            YLeaf igmp_membership; //type: boolean
                            YLeaf mdt_safi_join; //type: boolean
                            YLeaf mvpn_safi_join; //type: boolean
                            YLeaf local_mdt_join; //type: boolean
                            YLeaf data_mdt_join; //type: boolean
                            YLeaf mvp_nv6_safi_join; //type: boolean
                            YLeaf bgp_c_mcast_join; //type: boolean
                            YLeaf vrf_name; //type: string
                            YLeaf extranet_interface; //type: boolean

                        class AssertWinner : public Entity
                        {
                            public:
                                AssertWinner();
                                ~AssertWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                    }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::GroupAddressXr> group_address_xr;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::OrigSrcAddress> orig_src_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::ProxyAddress> proxy_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::RpfRoot> rpf_root;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology::SourceAddressXr> source_address_xr;


                }; // Ipv6Pim::Active::DefaultContext::Topologies::Topology


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies::Topology> > topology;


            }; // Ipv6Pim::Active::DefaultContext::Topologies


            class BgpAfs : public Entity
            {
                public:
                    BgpAfs();
                    ~BgpAfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BgpAf : public Entity
                {
                    public:
                        BgpAf();
                        ~BgpAf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf source_address; //type: string
                        YLeaf group_address; //type: string
                        YLeaf route_distinguisher; //type: string
                        YLeaf extranet_path_count; //type: uint32
                        YLeaf is_bgp_added; //type: boolean

                    class Source : public Entity
                    {
                        public:
                            Source();
                            ~Source();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf::Source


                    class Group : public Entity
                    {
                        public:
                            Group();
                            ~Group();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf::Group


                    class NextHop : public Entity
                    {
                        public:
                            NextHop();
                            ~NextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf::NextHop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf::Group> group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf::NextHop> next_hop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf::Source> source;


                }; // Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BgpAfs::BgpAf> > bgp_af;


            }; // Ipv6Pim::Active::DefaultContext::BgpAfs


            class AutoRp : public Entity
            {
                public:
                    AutoRp();
                    ~AutoRp();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;





            }; // Ipv6Pim::Active::DefaultContext::AutoRp


            class TopologyInterfaceFlagRouteCounts : public Entity
            {
                public:
                    TopologyInterfaceFlagRouteCounts();
                    ~TopologyInterfaceFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyInterfaceFlagRouteCount : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCount();
                        ~TopologyInterfaceFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                }; // Ipv6Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


            }; // Ipv6Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts


            class GroupMapSources : public Entity
            {
                public:
                    GroupMapSources();
                    ~GroupMapSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapSource : public Entity
                {
                    public:
                        GroupMapSource();
                        ~GroupMapSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf priority; //type: int32
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                }; // Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapSources::GroupMapSource> > group_map_source;


            }; // Ipv6Pim::Active::DefaultContext::GroupMapSources


            class TrafficCounters : public Entity
            {
                public:
                    TrafficCounters();
                    ~TrafficCounters();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf elapsed_time; //type: uint32
                    YLeaf inputs; //type: uint32
                    YLeaf outputs; //type: uint32
                    YLeaf format_error; //type: uint32
                    YLeaf pakman_error; //type: uint32
                    YLeaf standby_packets_error; //type: uint32
                    YLeaf checksum_error; //type: uint32
                    YLeaf socket_error; //type: uint32
                    YLeaf send_queue_full; //type: uint32
                    YLeaf boundary_acl_rx_drop; //type: uint32
                    YLeaf boundary_acl_tx_drop; //type: uint32
                    YLeaf no_socket_connection; //type: uint32
                    YLeaf no_source_address; //type: uint32
                    YLeaf input_hello; //type: uint32
                    YLeaf output_hello; //type: uint32
                    YLeaf input_jp; //type: uint32
                    YLeaf output_jp; //type: uint32
                    YLeaf input_data_register; //type: uint32
                    YLeaf input_null_register; //type: uint32
                    YLeaf output_data_register; //type: uint32
                    YLeaf output_null_register; //type: uint32
                    YLeaf input_register_stop; //type: uint32
                    YLeaf output_register_stop; //type: uint32
                    YLeaf input_assert; //type: uint32
                    YLeaf input_assert_batched; //type: uint32
                    YLeaf output_assert; //type: uint32
                    YLeaf output_assert_batched; //type: uint32
                    YLeaf input_df_election; //type: uint32
                    YLeaf output_df_election; //type: uint32
                    YLeaf input_bsr_message; //type: uint32
                    YLeaf output_bsr_message; //type: uint32
                    YLeaf input_candidate_rp_advertisement; //type: uint32
                    YLeaf output_candidate_rp_advertisement; //type: uint32
                    YLeaf input_ecmp_redirect; //type: uint32
                    YLeaf output_ecmp_redirect; //type: uint32
                    YLeaf output_loop_error; //type: uint32
                    YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                    YLeaf input_no_idb_error; //type: uint32
                    YLeaf input_no_vrf_error; //type: uint32
                    YLeaf input_no_pim_error; //type: uint32
                    YLeaf input_pim_version_error; //type: uint32
                    YLeaf output_join_group; //type: uint32
                    YLeaf output_prune_group; //type: uint32
                    YLeaf output_join_prune_bytes; //type: uint32
                    YLeaf output_hello_bytes; //type: uint32
                    YLeaf non_supported_packets; //type: uint32
                    YLeaf invalid_registers; //type: uint32
                    YLeaf invalid_join_prunes; //type: uint32
                    YLeaf packet_packman_error; //type: uint32
                    YLeaf packet_read_socket_error; //type: uint32
                    YLeaf packet_queue_last_clear; //type: uint32
                    YLeaf packets_standby; //type: uint32
                    YLeaf no_mdt_socket_connection; //type: uint32
                    YLeaf mdt_send_queue_full; //type: uint32
                    YLeaf mdt_socket_error; //type: uint32
                    YLeaf mdt_join_tlv_sent; //type: uint32
                    YLeaf mdt_join_tlv_received; //type: uint32
                    YLeaf mdt_join_bad_type; //type: uint32
                    YLeaf mdt_drop_local_source_address; //type: uint32
                    YLeaf mdt_drop_null_local_address; //type: uint32
                    YLeaf mdt_drop_no_idb; //type: uint32
                    YLeaf mdt_drop_no_vrf; //type: uint32
                    YLeaf invalid_destination_packets; //type: uint32
                    YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                    YLeaf truncated_pim_packets; //type: uint32
                    YLeafList packet_enqueued; //type: list of  uint32
                    YLeafList packet_dequeued; //type: list of  uint32
                    YLeafList packet_queue_length; //type: list of  uint32
                    YLeafList packet_queue_size; //type: list of  uint32
                    YLeafList packet_tail_drop; //type: list of  uint32

                class PacketQueue : public Entity
                {
                    public:
                        PacketQueue();
                        ~PacketQueue();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf packet_queue_priority; //type: uint32

                    class PacketQueueState : public Entity
                    {
                        public:
                            PacketQueueState();
                            ~PacketQueueState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf max_queue_size; //type: uint32
                            YLeaf queue_size_bytes; //type: uint32
                            YLeaf queue_size_packets; //type: uint32



                    }; // Ipv6Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState


                    class PacketQueueStats : public Entity
                    {
                        public:
                            PacketQueueStats();
                            ~PacketQueueStats();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf enqueued_packets; //type: uint32
                            YLeaf dequeued_packets; //type: uint32
                            YLeaf high_water_mark_packets; //type: uint32
                            YLeaf high_water_mark_bytes; //type: uint32
                            YLeaf tail_drops; //type: uint32



                    }; // Ipv6Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                }; // Ipv6Pim::Active::DefaultContext::TrafficCounters::PacketQueue


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TrafficCounters::PacketQueue> > packet_queue;


            }; // Ipv6Pim::Active::DefaultContext::TrafficCounters


            class GroupMapRpfs : public Entity
            {
                public:
                    GroupMapRpfs();
                    ~GroupMapRpfs();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapRpf : public Entity
                {
                    public:
                        GroupMapRpf();
                        ~GroupMapRpf();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf client; //type: PimClientEnum
                        YLeaf protocol; //type: PimProtocolEnum
                        YLeaf rp_address; //type: string
                        YLeaf rp_priority; //type: int32
                        YLeaf are_we_rp; //type: boolean
                        YLeaf rpf_interface_name; //type: string
                        YLeaf rpf_vrf_name; //type: string

                    class RpfNeighbor : public Entity
                    {
                        public:
                            RpfNeighbor();
                            ~RpfNeighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                }; // Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


            }; // Ipv6Pim::Active::DefaultContext::GroupMapRpfs


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Ipv6Pim::Active::DefaultContext::Summary


            class Gre : public Entity
            {
                public:
                    Gre();
                    ~Gre();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GreHashes : public Entity
                {
                    public:
                        GreHashes();
                        ~GreHashes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHash : public Entity
                    {
                        public:
                            GreHash();
                            ~GreHash();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf destination_address; //type: string
                            YLeaf ifname; //type: string
                            YLeaf next_hop_interface; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Gre::GreHashes::GreHash


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreHashes::GreHash> > gre_hash;


                }; // Ipv6Pim::Active::DefaultContext::Gre::GreHashes


                class GreNextHops : public Entity
                {
                    public:
                        GreNextHops();
                        ~GreNextHops();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreNextHop : public Entity
                    {
                        public:
                            GreNextHop();
                            ~GreNextHop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf destination_address; //type: string
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf is_connected; //type: uint8

                        class RegisteredAddress : public Entity
                        {
                            public:
                                RegisteredAddress();
                                ~RegisteredAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress


                        class GrePath : public Entity
                        {
                            public:
                                GrePath();
                                ~GrePath();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf gre_interface_name; //type: string
                                YLeaf is_gre_interface_disabled; //type: boolean
                                YLeaf is_via_lsm; //type: boolean
                                YLeaf is_connector_attribute_present; //type: boolean
                                YLeaf extranet_vrf_name; //type: string

                            class GreNeighbor : public Entity
                            {
                                public:
                                    GreNeighbor();
                                    ~GreNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                            class GreNextHop_ : public Entity
                            {
                                public:
                                    GreNextHop_();
                                    ~GreNextHop_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                        }; // Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                    }; // Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                }; // Ipv6Pim::Active::DefaultContext::Gre::GreNextHops


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreHashes> gre_hashes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre::GreNextHops> gre_next_hops;


            }; // Ipv6Pim::Active::DefaultContext::Gre


            class BidirDfWinners : public Entity
            {
                public:
                    BidirDfWinners();
                    ~BidirDfWinners();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class BidirDfWinner : public Entity
                {
                    public:
                        BidirDfWinner();
                        ~BidirDfWinner();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf rp_address; //type: string
                        YLeaf interface_name; //type: string
                        YLeaf pim_interface_name; //type: string
                        YLeaf are_we_df; //type: boolean
                        YLeaf rp_lan; //type: boolean
                        YLeaf metric; //type: uint32
                        YLeaf metric_preference; //type: uint32
                        YLeaf uptime; //type: uint64

                    class RpAddressXr : public Entity
                    {
                        public:
                            RpAddressXr();
                            ~RpAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr


                    class DfWinner : public Entity
                    {
                        public:
                            DfWinner();
                            ~DfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                }; // Ipv6Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


            }; // Ipv6Pim::Active::DefaultContext::BidirDfWinners


            class TableContexts : public Entity
            {
                public:
                    TableContexts();
                    ~TableContexts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TableContext : public Entity
                {
                    public:
                        TableContext();
                        ~TableContext();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf saf_name; //type: PimSafiEnum
                        YLeaf topology_name; //type: string
                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Ipv6Pim::Active::DefaultContext::TableContexts::TableContext


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TableContexts::TableContext> > table_context;


            }; // Ipv6Pim::Active::DefaultContext::TableContexts


            class GlobalInterfaces : public Entity
            {
                public:
                    GlobalInterfaces();
                    ~GlobalInterfaces();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GlobalInterface : public Entity
                {
                    public:
                        GlobalInterface();
                        ~GlobalInterface();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf interface_address_mask; //type: uint8
                        YLeaf is_enabled; //type: boolean
                        YLeaf neighbor_count; //type: uint16
                        YLeaf external_neighbor_count; //type: uint16
                        YLeaf hello_interval; //type: uint16
                        YLeaf dr_priority; //type: uint32
                        YLeaf hello_expiry; //type: uint64
                        YLeaf are_we_dr; //type: boolean
                        YLeaf bfd_enabled; //type: boolean
                        YLeaf bfd_interval; //type: uint32
                        YLeaf bfd_multiplier; //type: uint32
                        YLeaf virtual_interface; //type: boolean
                        YLeaf passive_interface; //type: boolean
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf join_prune_interval; //type: uint16
                        YLeaf prune_delay_enabled; //type: boolean
                        YLeaf configured_propagation_delay; //type: uint16
                        YLeaf propagation_delay; //type: uint16
                        YLeaf configured_override_interval; //type: uint16
                        YLeaf override_interval; //type: uint16
                        YLeaf generation_id; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf idb_oor_enabled; //type: boolean
                        YLeaf idb_acl_provided; //type: boolean
                        YLeaf idb_max_count; //type: uint32
                        YLeaf idb_threshold_count; //type: uint32
                        YLeaf idb_current_count; //type: uint32
                        YLeaf idb_acl_name; //type: string

                    class DrAddress : public Entity
                    {
                        public:
                            DrAddress();
                            ~DrAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress


                    class InterfaceAddress : public Entity
                    {
                        public:
                            InterfaceAddress();
                            ~InterfaceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                }; // Ipv6Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GlobalInterfaces::GlobalInterface> > global_interface;


            }; // Ipv6Pim::Active::DefaultContext::GlobalInterfaces


            class NeighborSummaries : public Entity
            {
                public:
                    NeighborSummaries();
                    ~NeighborSummaries();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class NeighborSummary : public Entity
                {
                    public:
                        NeighborSummary();
                        ~NeighborSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf number_of_neighbors; //type: int32
                        YLeaf number_of_external_neighbors; //type: int32



                }; // Ipv6Pim::Active::DefaultContext::NeighborSummaries::NeighborSummary


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NeighborSummaries::NeighborSummary> > neighbor_summary;


            }; // Ipv6Pim::Active::DefaultContext::NeighborSummaries


            class Context : public Entity
            {
                public:
                    Context();
                    ~Context();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_id; //type: uint32
                    YLeaf table_id; //type: uint32
                    YLeaf murib_id; //type: uint32
                    YLeaf rpf_id; //type: uint32
                    YLeaf remote_table_id; //type: uint32
                    YLeaf mdt_default_group; //type: string
                    YLeaf mdt_interface; //type: string
                    YLeaf mdt_gre_rpf_identifier; //type: uint32
                    YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                    YLeaf is_unicast_rib_registration; //type: boolean
                    YLeaf is_multicast_rib_registration; //type: boolean
                    YLeaf is_active; //type: boolean
                    YLeaf is_active_ital; //type: boolean
                    YLeaf is_mrib_register; //type: boolean
                    YLeaf is_mdt_owner; //type: boolean
                    YLeaf is_routing_enabled; //type: boolean
                    YLeaf is_socket_add_required; //type: boolean
                    YLeaf is_socket_added; //type: boolean
                    YLeaf is_lpts_socket_add_required; //type: boolean
                    YLeaf is_lpts_socket_added; //type: boolean
                    YLeaf is_udp_socket_add_required; //type: boolean
                    YLeaf is_udp_socket_added; //type: boolean
                    YLeaf is_udp_socket_bind_required; //type: boolean
                    YLeaf is_udp_socket_bind; //type: boolean
                    YLeaf is_register_injection_socket_add_required; //type: boolean
                    YLeaf is_register_injection_socket_added; //type: boolean
                    YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                    YLeaf is_register_injection_lpts_socket_added; //type: boolean
                    YLeaf is_m_host_publish_pending; //type: boolean
                    YLeaf mhost_interface; //type: string
                    YLeaf mhost_default_interface_config; //type: string
                    YLeaf mdt_mtu; //type: uint32
                    YLeaf maximum_mdt_aggregation; //type: uint32
                    YLeaf mdt_data_switchover_interval; //type: uint32
                    YLeaf mdt_data_announce_interval; //type: uint32
                    YLeaf non_default_vrf_count_on_socket; //type: uint32
                    YLeaf neighbor_filter_name; //type: string
                    YLeaf mdt_neighbor_filter_name; //type: string
                    YLeaf allow_rp_configured; //type: boolean
                    YLeaf allow_rp_group_list; //type: string
                    YLeaf allow_rp_rp_list; //type: string
                    YLeaf sg_expiry_timer_configured; //type: boolean
                    YLeaf sg_expiry_time; //type: uint16
                    YLeaf sg_expiry_timer_sg_list; //type: string
                    YLeaf mldp_mdt_name; //type: string
                    YLeaf mldp_mdt_interface; //type: string
                    YLeaf mldp_mdt_mtu; //type: uint32
                    YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                    YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                    YLeaf mldp_mdt_data_announce_interval; //type: uint32
                    YLeaf mldp_mdt_rpf_identifier; //type: uint32
                    YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                    YLeaf is_create_mldp_mdt_interface; //type: boolean
                    YLeaf is_mldp_mdt_owner; //type: boolean
                    YLeaf mldp_root_count; //type: uint32
                    YLeaf mldp_head_lsm_identifier; //type: uint32
                    YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                    YLeaf organization_unique_identifier; //type: uint32
                    YLeaf vpn_index; //type: uint32
                    YLeaf mldp_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                    YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                    YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                    YLeaf mldp_head_local_label; //type: uint32
                    YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                    YLeaf bgp_auto_discovery_configured; //type: boolean
                    YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                    YLeaf inter_autonomous_system_enabled; //type: boolean
                    YLeaf bgp_source_active_announce; //type: boolean
                    YLeaf bgp_i_pmsi_added; //type: boolean
                    YLeaf mldp_bsr_control_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                    YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                    YLeaf bgp_auto_discovery_type; //type: uint32
                    YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                    YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                    YLeaf mldp_control_head_lsm_identifier; //type: uint32
                    YLeaf umh; //type: boolean
                    YLeaf suppress_shared_tree_join; //type: boolean
                    YLeaf rsvp_te_mdt_name; //type: string
                    YLeaf rsvp_te_mdt_interface; //type: string
                    YLeaf rsvp_te_mdt_mtu; //type: uint32
                    YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                    YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                    YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                    YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                    YLeaf is_rsvp_te_mdt_owner; //type: boolean
                    YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                    YLeaf p2mpte_li_drop; //type: uint32
                    YLeaf ir_mdt_name; //type: string
                    YLeaf ir_mdt_interface; //type: string
                    YLeaf ir_mdt_mtu; //type: uint32
                    YLeaf ir_maximum_mdt_aggregation; //type: uint32
                    YLeaf ir_mdt_data_switchover_interval; //type: uint32
                    YLeaf ir_mdt_data_announce_interval; //type: uint32
                    YLeaf ir_mdt_rpf_identifier; //type: uint32
                    YLeaf ir_mdt_tail_label; //type: uint32
                    YLeaf is_create_ir_mdt_interface; //type: boolean
                    YLeaf is_ir_mdt_owner; //type: boolean
                    YLeaf in_b_and_mdt_name; //type: string
                    YLeaf in_b_and_mdt_interface; //type: string
                    YLeaf in_b_and_mdt_mtu; //type: uint32
                    YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                    YLeaf is_in_b_and_mdt_owner; //type: boolean
                    YLeaf in_band_signaling_local_enabled; //type: boolean
                    YLeaf in_band_signaling_remote_enabled; //type: boolean
                    YLeaf valid_rd_present; //type: boolean
                    YLeaf stale_rd_present; //type: boolean
                    YLeaf route_distinguisher; //type: string
                    YLeaf gin_b_and_mdt_name; //type: string
                    YLeaf gin_b_and_mdt_interface; //type: string
                    YLeaf gin_b_and_mdt_mtu; //type: uint32
                    YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                    YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                    YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                    YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                    YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                    YLeaf is_gin_b_and_mdt_owner; //type: boolean
                    YLeaf is_pim_nsf_rib_converged; //type: boolean
                    YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                    YLeaf is_rib_multipath_enabled; //type: boolean
                    YLeaf is_rib_multipath_interface_hash; //type: boolean
                    YLeaf is_rib_multipath_source_hash; //type: boolean
                    YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                    YLeaf rump_enabled; //type: boolean
                    YLeaf is_create_mdt_interface; //type: boolean
                    YLeaf is_auto_rp_listen_enabled; //type: boolean
                    YLeaf is_all_interface_disable_operation; //type: boolean
                    YLeaf is_default_granges; //type: boolean
                    YLeaf is_auto_rp_listen_sock_add; //type: boolean
                    YLeaf is_redistribution_reset; //type: boolean
                    YLeaf redistribution_reset_count; //type: uint32
                    YLeaf rpf_policy_name; //type: string
                    YLeaf table_count; //type: uint32
                    YLeaf active_table_count; //type: uint32
                    YLeaf anycast_rp_policy_name; //type: string
                    YLeaf anycast_rp_configured; //type: boolean
                    YLeaf bgp_remote_on; //type: boolean
                    YLeaf bgp_remote_interface_name; //type: string
                    YLeaf bgp_remote_interface; //type: string
                    YLeaf bgp_remote_address; //type: string
                    YLeaf bgp_remote_state; //type: uint32
                    YLeafList mldp_root_address; //type: list of  uint32

                class RemoteDefaultGroup : public Entity
                {
                    public:
                        RemoteDefaultGroup();
                        ~RemoteDefaultGroup();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf af_name; //type: PimAfiEnum
                        YLeaf ipv4_address; //type: string
                        YLeaf ipv6_address; //type: string



                }; // Ipv6Pim::Active::DefaultContext::Context::RemoteDefaultGroup


                class RpfDefaultTable : public Entity
                {
                    public:
                        RpfDefaultTable();
                        ~RpfDefaultTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf afi; //type: uint32
                        YLeaf safi; //type: uint32
                        YLeaf table_name; //type: string
                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf is_active; //type: boolean
                        YLeaf is_ital_registration_done; //type: boolean
                        YLeaf is_rib_registration_done; //type: boolean
                        YLeaf is_rib_convergence_received; //type: boolean
                        YLeaf is_rib_convergence; //type: boolean
                        YLeaf rpf_registrations; //type: uint32



                }; // Ipv6Pim::Active::DefaultContext::Context::RpfDefaultTable


                class ExportRouteTarget : public Entity
                {
                    public:
                        ExportRouteTarget();
                        ~ExportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Ipv6Pim::Active::DefaultContext::Context::ExportRouteTarget


                class ImportRouteTarget : public Entity
                {
                    public:
                        ImportRouteTarget();
                        ~ImportRouteTarget();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_target; //type: string
                        YLeaf configured; //type: boolean
                        YLeaf anycast_rp; //type: boolean
                        YLeaf anycast_rp_marked; //type: boolean
                        YLeaf update_pending; //type: boolean
                        YLeaf bgp_auto_discovery; //type: boolean
                        YLeaf segment_border; //type: boolean



                }; // Ipv6Pim::Active::DefaultContext::Context::ImportRouteTarget


                class AnycastRpRange : public Entity
                {
                    public:
                        AnycastRpRange();
                        ~AnycastRpRange();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf prefix_length; //type: uint8
                        YLeaf ancast_rp_marked; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Context::AnycastRpRange::Prefix


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context::AnycastRpRange::Prefix> prefix;


                }; // Ipv6Pim::Active::DefaultContext::Context::AnycastRpRange


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context::AnycastRpRange> > anycast_rp_range;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context::ExportRouteTarget> > export_route_target;
                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context::ImportRouteTarget> > import_route_target;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context::RemoteDefaultGroup> remote_default_group;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context::RpfDefaultTable> rpf_default_table;


            }; // Ipv6Pim::Active::DefaultContext::Context


            class TopologyEntryFlagRouteCounts : public Entity
            {
                public:
                    TopologyEntryFlagRouteCounts();
                    ~TopologyEntryFlagRouteCounts();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class TopologyEntryFlagRouteCount : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCount();
                        ~TopologyEntryFlagRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                }; // Ipv6Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


            }; // Ipv6Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts


            class RpfRedirect : public Entity
            {
                public:
                    RpfRedirect();
                    ~RpfRedirect();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class RedirectRouteDatabases : public Entity
                {
                    public:
                        RedirectRouteDatabases();
                        ~RedirectRouteDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabase : public Entity
                    {
                        public:
                            RedirectRouteDatabase();
                            ~RedirectRouteDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf bandwidth; //type: uint32
                            YLeaf uptime; //type: uint64

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                        class Interface : public Entity
                        {
                            public:
                                Interface();
                                ~Interface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf is_rpf_interface; //type: boolean
                                YLeaf is_outgoing_interface; //type: boolean
                                YLeaf is_snoop_interface; //type: boolean

                            class RpfAddress : public Entity
                            {
                                public:
                                    RpfAddress();
                                    ~RpfAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                        }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases


                class BundleInterfaces : public Entity
                {
                    public:
                        BundleInterfaces();
                        ~BundleInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BundleInterface : public Entity
                    {
                        public:
                            BundleInterface();
                            ~BundleInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf bundle_name; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf rpf_redirect_bundle_name; //type: string
                            YLeaf rpf_redirect_interface_name; //type: string
                            YLeaf available_bandwidth; //type: int32
                            YLeaf allocated_bandwidth; //type: int32
                            YLeaf total_bandwidth; //type: int32
                            YLeaf topology_bandwidth_used; //type: int32
                            YLeaf snooping_bandwidth_used; //type: int32
                            YLeaf allocated_threshold_bandwidth; //type: int32
                            YLeaf available_threshold_bandwidth; //type: int32



                    }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                }; // Ipv6Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::BundleInterfaces> bundle_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


            }; // Ipv6Pim::Active::DefaultContext::RpfRedirect


            class Tunnels : public Entity
            {
                public:
                    Tunnels();
                    ~Tunnels();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Tunnel : public Entity
                {
                    public:
                        Tunnel();
                        ~Tunnel();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf tunnel_name; //type: string
                        YLeaf vrf_name; //type: string

                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddress


                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::RpAddress


                    class SourceAddressNetio : public Entity
                    {
                        public:
                            SourceAddressNetio();
                            ~SourceAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddressNetio


                    class GroupAddressNetio : public Entity
                    {
                        public:
                            GroupAddressNetio();
                            ~GroupAddressNetio();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::GroupAddressNetio


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddress> source_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                }; // Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Tunnels::Tunnel> > tunnel;


            }; // Ipv6Pim::Active::DefaultContext::Tunnels


            class MulticastStaticRoutes : public Entity
            {
                public:
                    MulticastStaticRoutes();
                    ~MulticastStaticRoutes();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class MulticastStaticRoute : public Entity
                {
                    public:
                        MulticastStaticRoute();
                        ~MulticastStaticRoute();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf address; //type: string
                        YLeaf prefix_length; //type: int32
                        YLeaf interface_name; //type: string
                        YLeaf distance; //type: uint32
                        YLeaf prefix_length_xr; //type: uint8
                        YLeaf is_via_lsm; //type: boolean

                    class Prefix : public Entity
                    {
                        public:
                            Prefix();
                            ~Prefix();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                    class Nexthop : public Entity
                    {
                        public:
                            Nexthop();
                            ~Nexthop();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                }; // Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


            }; // Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes


            class GroupMapMatchSources : public Entity
            {
                public:
                    GroupMapMatchSources();
                    ~GroupMapMatchSources();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class GroupMapMatchSource : public Entity
                {
                    public:
                        GroupMapMatchSource();
                        ~GroupMapMatchSource();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_address; //type: string
                        YLeaf holdtime; //type: int32
                        YLeaf expires; //type: uint64
                        YLeaf uptime; //type: uint64

                    class SourceOfInformation : public Entity
                    {
                        public:
                            SourceOfInformation();
                            ~SourceOfInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                    class GroupMapInformation : public Entity
                    {
                        public:
                            GroupMapInformation();
                            ~GroupMapInformation();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimShowRangeClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf group_count; //type: uint32
                            YLeaf is_used; //type: boolean
                            YLeaf mrib_active; //type: boolean
                            YLeaf is_override; //type: boolean
                            YLeaf priority; //type: uint32

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                    }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


            }; // Ipv6Pim::Active::DefaultContext::GroupMapMatchSources


            class Neighbors : public Entity
            {
                public:
                    Neighbors();
                    ~Neighbors();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class Neighbor : public Entity
                {
                    public:
                        Neighbor();
                        ~Neighbor();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf neighbor_address; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf uptime; //type: uint64
                        YLeaf expires; //type: uint64
                        YLeaf expiry_timer; //type: uint64
                        YLeaf is_this_neighbor_us; //type: boolean
                        YLeaf is_this_neighbor_dr; //type: boolean
                        YLeaf is_dr_priority_capable; //type: boolean
                        YLeaf dr_priority; //type: uint32
                        YLeaf is_bidirectional_capable; //type: boolean
                        YLeaf is_proxy_capable; //type: boolean
                        YLeaf is_batch_asserts_capable; //type: boolean
                        YLeaf is_ecmp_redirect_capable; //type: boolean
                        YLeaf is_bfd_state; //type: boolean
                        YLeaf propagation_delay; //type: uint16
                        YLeaf override_interval; //type: uint16

                    class NeighborAddressXr : public Entity
                    {
                        public:
                            NeighborAddressXr();
                            ~NeighborAddressXr();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::DefaultContext::Neighbors::Neighbor::NeighborAddressXr


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                }; // Ipv6Pim::Active::DefaultContext::Neighbors::Neighbor


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Neighbors::Neighbor> > neighbor;


            }; // Ipv6Pim::Active::DefaultContext::Neighbors


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::AutoRp> auto_rp;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BgpAfs> bgp_afs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfStates> bidir_df_states;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::BidirDfWinners> bidir_df_winners;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Bsr> bsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Context> context;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GlobalInterfaces> global_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Gre> gre;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchRpfs> group_map_match_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapMatchSources> group_map_match_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapRpfs> group_map_rpfs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::GroupMapSources> group_map_sources;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::IfrsInterfaces> ifrs_interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::IfrsSummary> ifrs_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::InterfaceOldFormats> interface_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::InterfaceStatistics> interface_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Interfaces> interfaces;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::JpStatistics> jp_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MibDatabases> mib_databases;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::MulticastStaticRoutes> multicast_static_routes;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NeighborOldFormats> neighbor_old_formats;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NeighborSummaries> neighbor_summaries;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Neighbors> neighbors;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::NetIoTunnels> net_io_tunnels;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Ranges> ranges;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RoutePolicy> route_policy;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfRedirect> rpf_redirect;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::RpfSummary> rpf_summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Safs> safs;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Summary> summary;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TableContexts> table_contexts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Topologies> topologies;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TopologyRouteCount> topology_route_count;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::TrafficCounters> traffic_counters;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext::Tunnels> tunnels;


        }; // Ipv6Pim::Active::DefaultContext


        class Process : public Entity
        {
            public:
                Process();
                ~Process();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class CheckpointStatistics : public Entity
            {
                public:
                    CheckpointStatistics();
                    ~CheckpointStatistics();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class CheckpointTable : public Entity
                {
                    public:
                        CheckpointTable();
                        ~CheckpointTable();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf table_description; //type: string
                        YLeaf table_name; //type: uint32
                        YLeaf is_mirrored; //type: boolean
                        YLeafList statistic; //type: list of  uint32



                }; // Ipv6Pim::Active::Process::CheckpointStatistics::CheckpointTable


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process::CheckpointStatistics::CheckpointTable> > checkpoint_table;


            }; // Ipv6Pim::Active::Process::CheckpointStatistics


            class Nsr : public Entity
            {
                public:
                    Nsr();
                    ~Nsr();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf state; //type: uint8
                    YLeaf partner_connected; //type: boolean
                    YLeaf rmf_notification_done; //type: boolean
                    YLeaf rmf_timer_valid; //type: boolean
                    YLeaf rmf_timer_expiry; //type: uint64
                    YLeaf last_connection_up; //type: uint64
                    YLeaf last_connection_dn; //type: uint64
                    YLeaf last_rmf_ready; //type: uint64
                    YLeaf last_rmf_not_ready; //type: uint64
                    YLeaf count_connection_up; //type: uint32
                    YLeaf count_connection_dn; //type: uint32
                    YLeaf count_rmf_ready; //type: uint32
                    YLeaf count_rmf_not_ready; //type: uint32



            }; // Ipv6Pim::Active::Process::Nsr


            class Summary : public Entity
            {
                public:
                    Summary();
                    ~Summary();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf route_limit; //type: uint32
                    YLeaf route_count; //type: uint32
                    YLeaf route_low_water_mark; //type: uint32
                    YLeaf is_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_limit; //type: uint32
                    YLeaf topology_interface_state_count; //type: uint32
                    YLeaf rxi_low_water_mark; //type: uint32
                    YLeaf rxi_limit_reached; //type: boolean
                    YLeaf register_limit; //type: uint32
                    YLeaf register_count; //type: uint32
                    YLeaf register_limit_reached; //type: boolean
                    YLeaf ranges_limit; //type: uint32
                    YLeaf ranges_count; //type: uint32
                    YLeaf ranges_threshold; //type: uint32
                    YLeaf is_ranges_limit_reached; //type: boolean
                    YLeaf bsr_ranges_limit; //type: uint32
                    YLeaf bsr_ranges_count; //type: uint32
                    YLeaf bsr_range_threshold; //type: uint32
                    YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                    YLeaf bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf bsr_candidate_rp_set_count; //type: uint32
                    YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_maximum_enforcement_disabled; //type: boolean
                    YLeaf is_node_low_memory; //type: boolean
                    YLeaf route_threshold; //type: uint32
                    YLeaf global_auto_rp_ranges_limit; //type: uint32
                    YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_ranges_limit; //type: uint32
                    YLeaf global_bsr_ranges_count; //type: uint32
                    YLeaf global_bsr_ranges_threshold; //type: uint32
                    YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                    YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                    YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                    YLeaf is_global_route_limit_reached; //type: boolean
                    YLeaf topology_interface_state_threshold; //type: uint32
                    YLeaf is_global_rxi_limit_reached; //type: boolean
                    YLeaf register_threshold; //type: uint32
                    YLeaf global_register_limit; //type: uint32
                    YLeaf is_global_register_limit_reached; //type: boolean



            }; // Ipv6Pim::Active::Process::Summary


            class Nsf : public Entity
            {
                public:
                    Nsf();
                    ~Nsf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf configured_state; //type: boolean
                    YLeaf nsf_state; //type: boolean
                    YLeaf nsf_timeout; //type: uint32
                    YLeaf nsf_time_left; //type: uint32
                    YLeaf waiting_timer; //type: boolean
                    YLeaf waiting_membership; //type: boolean
                    YLeaf respawn_count; //type: uint32
                    YLeaf last_nsf_on; //type: int64
                    YLeaf last_nsf_off; //type: int64
                    YLeaf last_nsf_on_sec; //type: int32
                    YLeaf last_nsf_off_sec; //type: int32
                    YLeaf last_icd_notif_recv; //type: int64
                    YLeaf last_icd_notif_recv_sec; //type: int32



            }; // Ipv6Pim::Active::Process::Nsf


            class Issu : public Entity
            {
                public:
                    Issu();
                    ~Issu();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf informationvalid; //type: boolean
                    YLeaf role_ha; //type: int32
                    YLeaf role_issu; //type: int32
                    YLeaf phase_issu; //type: int32
                    YLeaf ha_option_issu; //type: int32
                    YLeaf last_ready_bool; //type: boolean
                    YLeaf last_ready_sent; //type: uint64
                    YLeaf last_ha_role_notification_received; //type: uint64
                    YLeaf last_issu_role_notification_received; //type: uint64
                    YLeaf last_issu_phase_notification_received; //type: uint64
                    YLeaf is_eoc_received; //type: boolean
                    YLeaf eoc_received_timestamp; //type: uint64
                    YLeaf is_ihms_done_received; //type: boolean
                    YLeaf ihms_received_timestamp; //type: uint64
                    YLeaf is_rib_sync_received; //type: boolean
                    YLeaf rib_sync_received_timestamp; //type: uint64
                    YLeaf is_nbr_sync_received; //type: boolean
                    YLeaf nbr_sync_received_timestamp; //type: uint64



            }; // Ipv6Pim::Active::Process::Issu


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process::CheckpointStatistics> checkpoint_statistics;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process::Issu> issu;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process::Nsf> nsf;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process::Nsr> nsr;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process::Summary> summary;


        }; // Ipv6Pim::Active::Process


        class Vrfs : public Entity
        {
            public:
                Vrfs();
                ~Vrfs();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class Vrf : public Entity
            {
                public:
                    Vrf();
                    ~Vrf();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;


                    YLeaf vrf_name; //type: string

                class IfrsInterfaces : public Entity
                {
                    public:
                        IfrsInterfaces();
                        ~IfrsInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class IfrsInterface : public Entity
                    {
                        public:
                            IfrsInterface();
                            ~IfrsInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces::IfrsInterface> > ifrs_interface;


                }; // Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces


                class Safs : public Entity
                {
                    public:
                        Safs();
                        ~Safs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Saf : public Entity
                    {
                        public:
                            Saf();
                            ~Saf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string

                        class RpfHashSourceGroups : public Entity
                        {
                            public:
                                RpfHashSourceGroups();
                                ~RpfHashSourceGroups();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSourceGroup : public Entity
                            {
                                public:
                                    RpfHashSourceGroup();
                                    ~RpfHashSourceGroup();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf group_address; //type: string
                                    YLeaf mask_length; //type: int32
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups::RpfHashSourceGroup> > rpf_hash_source_group;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups


                        class RpfNeighbors : public Entity
                        {
                            public:
                                RpfNeighbors();
                                ~RpfNeighbors();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfNeighbor : public Entity
                            {
                                public:
                                    RpfNeighbor();
                                    ~RpfNeighbor();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf neighbor_address; //type: string
                                    YLeaf rib_neighbor_interface; //type: string

                                class RibNeighborAddress : public Entity
                                {
                                    public:
                                        RibNeighborAddress();
                                        ~RibNeighborAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress


                                class RpfRegisteredAddresses : public Entity
                                {
                                    public:
                                        RpfRegisteredAddresses();
                                        ~RpfRegisteredAddresses();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_registered_address_references; //type: uint32

                                    class RibRegistrationAddress : public Entity
                                    {
                                        public:
                                            RibRegistrationAddress();
                                            ~RibRegistrationAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses::RibRegistrationAddress> rib_registration_address;


                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RibNeighborAddress> rib_neighbor_address;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor::RpfRegisteredAddresses> > rpf_registered_addresses;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors::RpfNeighbor> > rpf_neighbor;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors


                        class RpfHashSources : public Entity
                        {
                            public:
                                RpfHashSources();
                                ~RpfHashSources();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class RpfHashSource : public Entity
                            {
                                public:
                                    RpfHashSource();
                                    ~RpfHashSource();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf source_address; //type: string
                                    YLeaf mofrr; //type: int32
                                    YLeaf next_hop_multipath_enabled; //type: boolean
                                    YLeaf next_hop_interface; //type: string
                                    YLeaf secondary_next_hop_interface; //type: string

                                class NextHopAddress : public Entity
                                {
                                    public:
                                        NextHopAddress();
                                        ~NextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress


                                class SecondaryNextHopAddress : public Entity
                                {
                                    public:
                                        SecondaryNextHopAddress();
                                        ~SecondaryNextHopAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::NextHopAddress> next_hop_address;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource::SecondaryNextHopAddress> secondary_next_hop_address;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources::RpfHashSource> > rpf_hash_source;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources


                        class Rpfs : public Entity
                        {
                            public:
                                Rpfs();
                                ~Rpfs();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;



                            class Rpf : public Entity
                            {
                                public:
                                    Rpf();
                                    ~Rpf();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf registered_address; //type: string
                                    YLeaf metric; //type: uint32
                                    YLeaf metric_preference; //type: uint32
                                    YLeaf is_connected; //type: uint8
                                    YLeaf is_rpf_bgp_route; //type: boolean

                                class RegisteredAddressXr : public Entity
                                {
                                    public:
                                        RegisteredAddressXr();
                                        ~RegisteredAddressXr();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr


                                class RpfPath : public Entity
                                {
                                    public:
                                        RpfPath();
                                        ~RpfPath();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf rpf_interface_name; //type: string
                                        YLeaf is_rpf_interface_disabled; //type: boolean
                                        YLeaf is_via_lsm; //type: boolean
                                        YLeaf is_via_mlsm; //type: boolean
                                        YLeaf is_connector_attribute_present; //type: boolean
                                        YLeaf connector; //type: string
                                        YLeaf extranet_vrf_name; //type: string

                                    class RpfNeighbor : public Entity
                                    {
                                        public:
                                            RpfNeighbor();
                                            ~RpfNeighbor();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor


                                    class RpfNexthop : public Entity
                                    {
                                        public:
                                            RpfNexthop();
                                            ~RpfNexthop();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNeighbor> rpf_neighbor;
                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath::RpfNexthop> rpf_nexthop;


                                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RegisteredAddressXr> registered_address_xr;
                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf::RpfPath> > rpf_path;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs::Rpf> > rpf;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSourceGroups> rpf_hash_source_groups;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfHashSources> rpf_hash_sources;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::RpfNeighbors> rpf_neighbors;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf::Rpfs> rpfs;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs::Saf> > saf;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Safs


                class InterfaceStatistics : public Entity
                {
                    public:
                        InterfaceStatistics();
                        ~InterfaceStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceStatistic : public Entity
                    {
                        public:
                            InterfaceStatistic();
                            ~InterfaceStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf input_hello; //type: uint32
                            YLeaf output_hello; //type: uint32
                            YLeaf input_register; //type: uint32
                            YLeaf output_register; //type: uint32
                            YLeaf input_register_stop; //type: uint32
                            YLeaf output_register_stop; //type: uint32
                            YLeaf input_jp; //type: uint32
                            YLeaf output_jp; //type: uint32
                            YLeaf input_bsr_message; //type: uint32
                            YLeaf output_bsr_message; //type: uint32
                            YLeaf input_assert; //type: uint32
                            YLeaf output_assert; //type: uint32
                            YLeaf input_graft_message; //type: uint32
                            YLeaf output_graft_message; //type: uint32
                            YLeaf input_graft_ack_message; //type: uint32
                            YLeaf output_graft_ack_message; //type: uint32
                            YLeaf input_candidate_rp_advertisement; //type: uint32
                            YLeaf output_candidate_rp_advertisement; //type: uint32
                            YLeaf input_df_election; //type: uint32
                            YLeaf output_df_election; //type: uint32
                            YLeaf input_miscellaneous; //type: uint32



                    }; // Ipv6Pim::Active::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::InterfaceStatistics::InterfaceStatistic> > interface_statistic;


                }; // Ipv6Pim::Active::Vrfs::Vrf::InterfaceStatistics


                class TopologyRouteCount : public Entity
                {
                    public:
                        TopologyRouteCount();
                        ~TopologyRouteCount();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf group_ranges; //type: uint32
                        YLeaf active_group_ranges; //type: uint32
                        YLeaf groute_count; //type: uint32
                        YLeaf sg_route_count; //type: uint32
                        YLeaf sgr_route_count; //type: uint32
                        YLeaf is_node_low_memory; //type: boolean

                    class GroupAddress : public Entity
                    {
                        public:
                            GroupAddress();
                            ~GroupAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyRouteCount::GroupAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyRouteCount::GroupAddress> group_address;


                }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyRouteCount


                class JpStatistics : public Entity
                {
                    public:
                        JpStatistics();
                        ~JpStatistics();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class JpStatistic : public Entity
                    {
                        public:
                            JpStatistic();
                            ~JpStatistic();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf mtu; //type: uint32
                            YLeaf transmitted; //type: uint32
                            YLeaf transmitted100; //type: uint16
                            YLeaf transmitted_1k; //type: uint16
                            YLeaf transmitted_10k; //type: uint16
                            YLeaf transmitted_50k; //type: uint16
                            YLeaf received; //type: uint32
                            YLeaf received100; //type: uint16
                            YLeaf received_1k; //type: uint16
                            YLeaf received_10k; //type: uint16
                            YLeaf received_50k; //type: uint16



                    }; // Ipv6Pim::Active::Vrfs::Vrf::JpStatistics::JpStatistic


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::JpStatistics::JpStatistic> > jp_statistic;


                }; // Ipv6Pim::Active::Vrfs::Vrf::JpStatistics


                class MibDatabases : public Entity
                {
                    public:
                        MibDatabases();
                        ~MibDatabases();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MibDatabase : public Entity
                    {
                        public:
                            MibDatabase();
                            ~MibDatabase();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf source_netmask; //type: int32
                            YLeaf upstream_assert_timer; //type: int32
                            YLeaf assert_metric; //type: uint32
                            YLeaf assert_metric_preference; //type: uint32
                            YLeaf assert_rpt_bit; //type: boolean
                            YLeaf spt_bit; //type: boolean
                            YLeaf rpf_mask; //type: uint32
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf bidirectional_route; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf protocol; //type: PimShowProtocolEnum

                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr


                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MibDatabases::MibDatabase> > mib_database;


                }; // Ipv6Pim::Active::Vrfs::Vrf::MibDatabases


                class GroupMapMatchRpfs : public Entity
                {
                    public:
                        GroupMapMatchRpfs();
                        ~GroupMapMatchRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchRpf : public Entity
                    {
                        public:
                            GroupMapMatchRpf();
                            ~GroupMapMatchRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf::RpfNeighbor> rpf_neighbor;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs::GroupMapMatchRpf> > group_map_match_rpf;


                }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs


                class NeighborOldFormats : public Entity
                {
                    public:
                        NeighborOldFormats();
                        ~NeighborOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborOldFormat : public Entity
                    {
                        public:
                            NeighborOldFormat();
                            ~NeighborOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat::NeighborAddressXr> > neighbor_address_xr;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NeighborOldFormats::NeighborOldFormat> > neighbor_old_format;


                }; // Ipv6Pim::Active::Vrfs::Vrf::NeighborOldFormats


                class IfrsSummary : public Entity
                {
                    public:
                        IfrsSummary();
                        ~IfrsSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_count; //type: uint32
                        YLeaf configuration_count; //type: uint32



                }; // Ipv6Pim::Active::Vrfs::Vrf::IfrsSummary


                class Ranges : public Entity
                {
                    public:
                        Ranges();
                        ~Ranges();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Range : public Entity
                    {
                        public:
                            Range();
                            ~Range();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf client_xr; //type: PimShowRangeClientEnum
                            YLeaf expires; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::RpAddressXr


                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::SourceOfInformation


                        class GroupRange : public Entity
                        {
                            public:
                                GroupRange();
                                ~GroupRange();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf uptime; //type: uint64
                                YLeaf expires; //type: uint64

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix


                            class SourceOfInformation : public Entity
                            {
                                public:
                                    SourceOfInformation();
                                    ~SourceOfInformation();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange::SourceOfInformation> source_of_information;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::GroupRange> > group_range;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::RpAddressXr> rp_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges::Range> > range;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Ranges


                class InterfaceOldFormats : public Entity
                {
                    public:
                        InterfaceOldFormats();
                        ~InterfaceOldFormats();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class InterfaceOldFormat : public Entity
                    {
                        public:
                            InterfaceOldFormat();
                            ~InterfaceOldFormat();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats::InterfaceOldFormat> > interface_old_format;


                }; // Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats


                class Bsr : public Entity
                {
                    public:
                        Bsr();
                        ~Bsr();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RpCaches : public Entity
                    {
                        public:
                            RpCaches();
                            ~RpCaches();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RpCache : public Entity
                        {
                            public:
                                RpCache();
                                ~RpCache();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf group_prefix; //type: string
                                YLeaf group_prefix_length; //type: uint32
                                YLeaf candidate_rp_group_count; //type: uint32

                            class GroupPrefixXr : public Entity
                            {
                                public:
                                    GroupPrefixXr();
                                    ~GroupPrefixXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr


                            class CandidateRpList : public Entity
                            {
                                public:
                                    CandidateRpList();
                                    ~CandidateRpList();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;



                                class PimBsrCrpBag : public Entity
                                {
                                    public:
                                        PimBsrCrpBag();
                                        ~PimBsrCrpBag();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf candidate_rp_holdtime; //type: uint16
                                        YLeaf candidate_rp_priority; //type: uint8
                                        YLeaf candidate_rp_up_time; //type: uint16
                                        YLeaf candidate_rp_expires; //type: uint16
                                        YLeaf protocol; //type: PimShowProtocolEnum

                                    class CandidateRpAddress : public Entity
                                    {
                                        public:
                                            CandidateRpAddress();
                                            ~CandidateRpAddress();

                                            bool has_data() const override;
                                            bool has_operation() const override;
                                            EntityPath get_entity_path(Entity* parent) const override;
                                            std::string get_segment_path() const override;
                                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                            void set_value(const std::string & value_path, std::string value) override;
                                            std::map<std::string, Entity*> & get_children() override;


                                            YLeaf af_name; //type: PimAfiEnum
                                            YLeaf ipv4_address; //type: string
                                            YLeaf ipv6_address; //type: string



                                    }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress


                                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag::CandidateRpAddress> candidate_rp_address;


                                }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag


                                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList::PimBsrCrpBag> > pim_bsr_crp_bag;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::CandidateRpList> candidate_rp_list;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache::GroupPrefixXr> group_prefix_xr;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches::RpCache> > rp_cache;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches


                    class CandidateRps : public Entity
                    {
                        public:
                            CandidateRps();
                            ~CandidateRps();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class CandidateRp : public Entity
                        {
                            public:
                                CandidateRp();
                                ~CandidateRp();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf rp_address; //type: string
                                YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                YLeaf candidate_rp_scope; //type: int32
                                YLeaf crp_priority; //type: uint8
                                YLeaf crp_holdtime; //type: uint16
                                YLeaf candidate_rp_advance_interval; //type: uint16
                                YLeaf candidate_rp_uptime; //type: uint16
                                YLeaf acl_name; //type: string

                            class CandidateRp_ : public Entity
                            {
                                public:
                                    CandidateRp_();
                                    ~CandidateRp_();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_


                            class CrpAccess : public Entity
                            {
                                public:
                                    CrpAccess();
                                    ~CrpAccess();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf candidate_rp_mode; //type: PimShowProtocolEnum
                                    YLeaf acl_name; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CandidateRp_> candidate_rp;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp::CrpAccess> > crp_access;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps::CandidateRp> > candidate_rp;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps


                    class BsrElections : public Entity
                    {
                        public:
                            BsrElections();
                            ~BsrElections();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BsrElection : public Entity
                        {
                            public:
                                BsrElection();
                                ~BsrElection();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf pim_scope; //type: int32
                                YLeaf bsr_priority; //type: uint8
                                YLeaf bsr_mask_length; //type: uint8
                                YLeaf bsr_up_time; //type: uint16
                                YLeaf bootstrap_timeout; //type: uint16
                                YLeaf candidate_bsr_state; //type: uint32
                                YLeaf bsr_election_state; //type: uint32
                                YLeaf bsr_scope; //type: uint16
                                YLeaf candidate_bsr_flag; //type: boolean
                                YLeaf candidate_bsr_priority; //type: uint8
                                YLeaf candidate_bsr_mask_length; //type: uint8

                            class BsrAddress : public Entity
                            {
                                public:
                                    BsrAddress();
                                    ~BsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress


                            class CandidateBsrAddress : public Entity
                            {
                                public:
                                    CandidateBsrAddress();
                                    ~CandidateBsrAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::BsrAddress> bsr_address;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection::CandidateBsrAddress> candidate_bsr_address;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections::BsrElection> > bsr_election;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::BsrElections> bsr_elections;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::CandidateRps> candidate_rps;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr::RpCaches> rp_caches;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Bsr


                class RoutePolicy : public Entity
                {
                    public:
                        RoutePolicy();
                        ~RoutePolicy();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RoutePolicyStatistics : public Entity
                    {
                        public:
                            RoutePolicyStatistics();
                            ~RoutePolicyStatistics();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf policy_name; //type: string
                            YLeaf requests; //type: uint32
                            YLeaf pass; //type: uint32
                            YLeaf drop; //type: uint32
                            YLeaf default_table; //type: uint32
                            YLeaf any_table; //type: uint32



                    }; // Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics


                    class RoutePolicyTests : public Entity
                    {
                        public:
                            RoutePolicyTests();
                            ~RoutePolicyTests();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RoutePolicyTest : public Entity
                        {
                            public:
                                RoutePolicyTest();
                                ~RoutePolicyTest();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf ext_comm; //type: string
                                YLeaf policy_name; //type: string
                                YLeaf extended_community_rt; //type: string
                                YLeaf pass; //type: boolean
                                YLeaf default_table; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf afi; //type: uint32
                                YLeaf safi; //type: uint32
                                YLeaf table_name; //type: string
                                YLeaf table_exists; //type: boolean
                                YLeaf table_active; //type: boolean

                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr


                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::GroupAddressXr> group_address_xr;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest::SourceAddressXr> source_address_xr;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests::RoutePolicyTest> > route_policy_test;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyStatistics> route_policy_statistics;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy::RoutePolicyTests> route_policy_tests;


                }; // Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy


                class RpfSummary : public Entity
                {
                    public:
                        RpfSummary();
                        ~RpfSummary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf default_safi; //type: uint32
                        YLeaf default_table_name; //type: string
                        YLeaf is_mbgp_configured; //type: boolean
                        YLeaf is_ospf_te_configured; //type: boolean
                        YLeaf is_isis_te_configured; //type: boolean
                        YLeaf is_isis_mtr_configured; //type: boolean
                        YLeaf mo_frr_configured; //type: boolean
                        YLeaf rib_mo_frr_configured; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf rib_convergence_timeout; //type: uint32
                        YLeaf rib_convergence_time_left; //type: uint32
                        YLeaf is_multipath_enabled; //type: boolean
                        YLeaf is_multipath_interface_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_hash_enabled; //type: boolean
                        YLeaf is_multipath_source_next_hop_hash_enabled; //type: boolean
                        YLeaf rpf_registrations; //type: uint32
                        YLeaf is_rib_convergence; //type: boolean



                }; // Ipv6Pim::Active::Vrfs::Vrf::RpfSummary


                class Interfaces : public Entity
                {
                    public:
                        Interfaces();
                        ~Interfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Interface : public Entity
                    {
                        public:
                            Interface();
                            ~Interface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Interfaces::Interface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Interfaces::Interface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Interfaces::Interface::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Interfaces::Interface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Interfaces::Interface> > interface;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Interfaces


                class NetIoTunnels : public Entity
                {
                    public:
                        NetIoTunnels();
                        ~NetIoTunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NetIoTunnel : public Entity
                    {
                        public:
                            NetIoTunnel();
                            ~NetIoTunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel::SourceAddressNetio> source_address_netio;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels::NetIoTunnel> > net_io_tunnel;


                }; // Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels


                class BidirDfStates : public Entity
                {
                    public:
                        BidirDfStates();
                        ~BidirDfStates();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfState : public Entity
                    {
                        public:
                            BidirDfState();
                            ~BidirDfState();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf election_state; //type: string
                            YLeaf time_seconds; //type: uint64
                            YLeaf time_nano_seconds; //type: uint64
                            YLeaf our_metric; //type: uint32
                            YLeaf our_metric_preference; //type: uint32

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState::RpAddressXr> rp_address_xr;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfStates::BidirDfState> > bidir_df_state;


                }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfStates


                class Topologies : public Entity
                {
                    public:
                        Topologies();
                        ~Topologies();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Topology : public Entity
                    {
                        public:
                            Topology();
                            ~Topology();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf rpt; //type: int32
                            YLeaf limit_reached; //type: boolean
                            YLeaf low_memory; //type: boolean
                            YLeaf protocol; //type: PimShowProtocolEnum
                            YLeaf wildcard; //type: boolean
                            YLeaf rpt_xr; //type: boolean
                            YLeaf spt; //type: boolean
                            YLeaf uptime; //type: uint64
                            YLeaf expiry; //type: uint64
                            YLeaf alive; //type: int32
                            YLeaf register_received_timer; //type: int32
                            YLeaf remote_source; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string
                            YLeaf rpf_safi; //type: uint8
                            YLeaf rpf_table_name; //type: string
                            YLeaf rpf_drop; //type: boolean
                            YLeaf rpf_extranet; //type: boolean
                            YLeaf is_via_lsm; //type: boolean
                            YLeaf secondary_rpf_interface_name; //type: string
                            YLeaf connected; //type: boolean
                            YLeaf proxy; //type: boolean
                            YLeaf rpf_proxy_enabled; //type: boolean
                            YLeaf mofrr_enabled; //type: boolean
                            YLeaf rib_mo_frr_enabled; //type: boolean
                            YLeaf jp_timer; //type: int32
                            YLeaf jp_status; //type: int32
                            YLeaf suppress_registers; //type: int32
                            YLeaf assume_alive; //type: boolean
                            YLeaf probe_alive; //type: boolean
                            YLeaf really_alive; //type: boolean
                            YLeaf inherit_alive; //type: boolean
                            YLeaf inherit_spt; //type: boolean
                            YLeaf signal_sources; //type: boolean
                            YLeaf dont_check_connected; //type: boolean
                            YLeaf register_received; //type: boolean
                            YLeaf last_hop; //type: boolean
                            YLeaf sending_registers; //type: boolean
                            YLeaf sending_null_registers; //type: boolean
                            YLeaf sa_sent; //type: boolean
                            YLeaf sa_received; //type: boolean
                            YLeaf sa_joined; //type: boolean
                            YLeaf anycast_rp_match; //type: boolean
                            YLeaf anycast_rp_route_target; //type: string
                            YLeaf bgp_join; //type: boolean
                            YLeaf bgpjp_time; //type: uint64
                            YLeaf customer_routing_type; //type: int32
                            YLeaf extranet_route; //type: boolean
                            YLeaf mofrr_active; //type: boolean
                            YLeaf mofrr_primary; //type: boolean
                            YLeaf mofrr_backup; //type: boolean
                            YLeaf vxlan; //type: boolean

                        class GroupAddressXr : public Entity
                        {
                            public:
                                GroupAddressXr();
                                ~GroupAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::GroupAddressXr


                        class SourceAddressXr : public Entity
                        {
                            public:
                                SourceAddressXr();
                                ~SourceAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::SourceAddressXr


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::RpAddress


                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfNeighbor


                        class SecondaryRpfNeighbor : public Entity
                        {
                            public:
                                SecondaryRpfNeighbor();
                                ~SecondaryRpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor


                        class RpfRoot : public Entity
                        {
                            public:
                                RpfRoot();
                                ~RpfRoot();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfRoot


                        class ProxyAddress : public Entity
                        {
                            public:
                                ProxyAddress();
                                ~ProxyAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::ProxyAddress


                        class OrigSrcAddress : public Entity
                        {
                            public:
                                OrigSrcAddress();
                                ~OrigSrcAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress


                        class OutgoingInterface : public Entity
                        {
                            public:
                                OutgoingInterface();
                                ~OutgoingInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf interface_name; //type: string
                                YLeaf uptime; //type: uint64
                                YLeaf expiry; //type: uint64
                                YLeaf bgp_c_mcast_prune_delay_timer; //type: uint64
                                YLeaf jp_timer; //type: int32
                                YLeaf jp_state; //type: int32
                                YLeaf assert_timer; //type: int32
                                YLeaf local_members; //type: int32
                                YLeaf internal_interest_info; //type: int32
                                YLeaf forwarding_state; //type: int32
                                YLeaf immediate_state; //type: int32
                                YLeaf last_hop; //type: boolean
                                YLeaf mldp_inband_mdt; //type: boolean
                                YLeaf mldp_stale; //type: boolean
                                YLeaf sa_prune; //type: boolean
                                YLeaf admin_boundary; //type: boolean
                                YLeaf igmp_membership; //type: boolean
                                YLeaf mdt_safi_join; //type: boolean
                                YLeaf mvpn_safi_join; //type: boolean
                                YLeaf local_mdt_join; //type: boolean
                                YLeaf data_mdt_join; //type: boolean
                                YLeaf mvp_nv6_safi_join; //type: boolean
                                YLeaf bgp_c_mcast_join; //type: boolean
                                YLeaf vrf_name; //type: string
                                YLeaf extranet_interface; //type: boolean

                            class AssertWinner : public Entity
                            {
                                public:
                                    AssertWinner();
                                    ~AssertWinner();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface::AssertWinner> assert_winner;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::GroupAddressXr> group_address_xr;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::OrigSrcAddress> orig_src_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::OutgoingInterface> > outgoing_interface;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::ProxyAddress> proxy_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfNeighbor> rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::RpfRoot> rpf_root;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::SecondaryRpfNeighbor> secondary_rpf_neighbor;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology::SourceAddressXr> source_address_xr;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies::Topology> > topology;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Topologies


                class BgpAfs : public Entity
                {
                    public:
                        BgpAfs();
                        ~BgpAfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BgpAf : public Entity
                    {
                        public:
                            BgpAf();
                            ~BgpAf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf source_address; //type: string
                            YLeaf group_address; //type: string
                            YLeaf route_distinguisher; //type: string
                            YLeaf extranet_path_count; //type: uint32
                            YLeaf is_bgp_added; //type: boolean

                        class Source : public Entity
                        {
                            public:
                                Source();
                                ~Source();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Source


                        class Group : public Entity
                        {
                            public:
                                Group();
                                ~Group();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Group


                        class NextHop : public Entity
                        {
                            public:
                                NextHop();
                                ~NextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::NextHop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Group> group;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::NextHop> next_hop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf::Source> source;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BgpAfs::BgpAf> > bgp_af;


                }; // Ipv6Pim::Active::Vrfs::Vrf::BgpAfs


                class AutoRp : public Entity
                {
                    public:
                        AutoRp();
                        ~AutoRp();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;





                }; // Ipv6Pim::Active::Vrfs::Vrf::AutoRp


                class TopologyInterfaceFlagRouteCounts : public Entity
                {
                    public:
                        TopologyInterfaceFlagRouteCounts();
                        ~TopologyInterfaceFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyInterfaceFlagRouteCount : public Entity
                    {
                        public:
                            TopologyInterfaceFlagRouteCount();
                            ~TopologyInterfaceFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_flag; //type: PimTopologyInterfaceFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount::GroupAddress> group_address;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts::TopologyInterfaceFlagRouteCount> > topology_interface_flag_route_count;


                }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts


                class GroupMapSources : public Entity
                {
                    public:
                        GroupMapSources();
                        ~GroupMapSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapSource : public Entity
                    {
                        public:
                            GroupMapSource();
                            ~GroupMapSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf priority; //type: int32
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources::GroupMapSource> > group_map_source;


                }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources


                class TrafficCounters : public Entity
                {
                    public:
                        TrafficCounters();
                        ~TrafficCounters();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf elapsed_time; //type: uint32
                        YLeaf inputs; //type: uint32
                        YLeaf outputs; //type: uint32
                        YLeaf format_error; //type: uint32
                        YLeaf pakman_error; //type: uint32
                        YLeaf standby_packets_error; //type: uint32
                        YLeaf checksum_error; //type: uint32
                        YLeaf socket_error; //type: uint32
                        YLeaf send_queue_full; //type: uint32
                        YLeaf boundary_acl_rx_drop; //type: uint32
                        YLeaf boundary_acl_tx_drop; //type: uint32
                        YLeaf no_socket_connection; //type: uint32
                        YLeaf no_source_address; //type: uint32
                        YLeaf input_hello; //type: uint32
                        YLeaf output_hello; //type: uint32
                        YLeaf input_jp; //type: uint32
                        YLeaf output_jp; //type: uint32
                        YLeaf input_data_register; //type: uint32
                        YLeaf input_null_register; //type: uint32
                        YLeaf output_data_register; //type: uint32
                        YLeaf output_null_register; //type: uint32
                        YLeaf input_register_stop; //type: uint32
                        YLeaf output_register_stop; //type: uint32
                        YLeaf input_assert; //type: uint32
                        YLeaf input_assert_batched; //type: uint32
                        YLeaf output_assert; //type: uint32
                        YLeaf output_assert_batched; //type: uint32
                        YLeaf input_df_election; //type: uint32
                        YLeaf output_df_election; //type: uint32
                        YLeaf input_bsr_message; //type: uint32
                        YLeaf output_bsr_message; //type: uint32
                        YLeaf input_candidate_rp_advertisement; //type: uint32
                        YLeaf output_candidate_rp_advertisement; //type: uint32
                        YLeaf input_ecmp_redirect; //type: uint32
                        YLeaf output_ecmp_redirect; //type: uint32
                        YLeaf output_loop_error; //type: uint32
                        YLeaf mldp_mdt_invalid_lsm_identifier; //type: uint32
                        YLeaf input_no_idb_error; //type: uint32
                        YLeaf input_no_vrf_error; //type: uint32
                        YLeaf input_no_pim_error; //type: uint32
                        YLeaf input_pim_version_error; //type: uint32
                        YLeaf output_join_group; //type: uint32
                        YLeaf output_prune_group; //type: uint32
                        YLeaf output_join_prune_bytes; //type: uint32
                        YLeaf output_hello_bytes; //type: uint32
                        YLeaf non_supported_packets; //type: uint32
                        YLeaf invalid_registers; //type: uint32
                        YLeaf invalid_join_prunes; //type: uint32
                        YLeaf packet_packman_error; //type: uint32
                        YLeaf packet_read_socket_error; //type: uint32
                        YLeaf packet_queue_last_clear; //type: uint32
                        YLeaf packets_standby; //type: uint32
                        YLeaf no_mdt_socket_connection; //type: uint32
                        YLeaf mdt_send_queue_full; //type: uint32
                        YLeaf mdt_socket_error; //type: uint32
                        YLeaf mdt_join_tlv_sent; //type: uint32
                        YLeaf mdt_join_tlv_received; //type: uint32
                        YLeaf mdt_join_bad_type; //type: uint32
                        YLeaf mdt_drop_local_source_address; //type: uint32
                        YLeaf mdt_drop_null_local_address; //type: uint32
                        YLeaf mdt_drop_no_idb; //type: uint32
                        YLeaf mdt_drop_no_vrf; //type: uint32
                        YLeaf invalid_destination_packets; //type: uint32
                        YLeaf mdt_joins_drop_multiple_encapsulation; //type: uint32
                        YLeaf truncated_pim_packets; //type: uint32
                        YLeafList packet_enqueued; //type: list of  uint32
                        YLeafList packet_dequeued; //type: list of  uint32
                        YLeafList packet_queue_length; //type: list of  uint32
                        YLeafList packet_queue_size; //type: list of  uint32
                        YLeafList packet_tail_drop; //type: list of  uint32

                    class PacketQueue : public Entity
                    {
                        public:
                            PacketQueue();
                            ~PacketQueue();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf packet_queue_priority; //type: uint32

                        class PacketQueueState : public Entity
                        {
                            public:
                                PacketQueueState();
                                ~PacketQueueState();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf max_queue_size; //type: uint32
                                YLeaf queue_size_bytes; //type: uint32
                                YLeaf queue_size_packets; //type: uint32



                        }; // Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState


                        class PacketQueueStats : public Entity
                        {
                            public:
                                PacketQueueStats();
                                ~PacketQueueStats();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf enqueued_packets; //type: uint32
                                YLeaf dequeued_packets; //type: uint32
                                YLeaf high_water_mark_packets; //type: uint32
                                YLeaf high_water_mark_bytes; //type: uint32
                                YLeaf tail_drops; //type: uint32



                        }; // Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueState> packet_queue_state;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue::PacketQueueStats> packet_queue_stats;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters::PacketQueue> > packet_queue;


                }; // Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters


                class GroupMapRpfs : public Entity
                {
                    public:
                        GroupMapRpfs();
                        ~GroupMapRpfs();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapRpf : public Entity
                    {
                        public:
                            GroupMapRpf();
                            ~GroupMapRpf();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf client; //type: PimClientEnum
                            YLeaf protocol; //type: PimProtocolEnum
                            YLeaf rp_address; //type: string
                            YLeaf rp_priority; //type: int32
                            YLeaf are_we_rp; //type: boolean
                            YLeaf rpf_interface_name; //type: string
                            YLeaf rpf_vrf_name; //type: string

                        class RpfNeighbor : public Entity
                        {
                            public:
                                RpfNeighbor();
                                ~RpfNeighbor();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf::RpfNeighbor> rpf_neighbor;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs::GroupMapRpf> > group_map_rpf;


                }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs


                class Summary : public Entity
                {
                    public:
                        Summary();
                        ~Summary();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf route_limit; //type: uint32
                        YLeaf route_count; //type: uint32
                        YLeaf route_low_water_mark; //type: uint32
                        YLeaf is_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_limit; //type: uint32
                        YLeaf topology_interface_state_count; //type: uint32
                        YLeaf rxi_low_water_mark; //type: uint32
                        YLeaf rxi_limit_reached; //type: boolean
                        YLeaf register_limit; //type: uint32
                        YLeaf register_count; //type: uint32
                        YLeaf register_limit_reached; //type: boolean
                        YLeaf ranges_limit; //type: uint32
                        YLeaf ranges_count; //type: uint32
                        YLeaf ranges_threshold; //type: uint32
                        YLeaf is_ranges_limit_reached; //type: boolean
                        YLeaf bsr_ranges_limit; //type: uint32
                        YLeaf bsr_ranges_count; //type: uint32
                        YLeaf bsr_range_threshold; //type: uint32
                        YLeaf is_bsr_ranges_threshold_reached; //type: boolean
                        YLeaf bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf bsr_candidate_rp_set_count; //type: uint32
                        YLeaf bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_maximum_enforcement_disabled; //type: boolean
                        YLeaf is_node_low_memory; //type: boolean
                        YLeaf route_threshold; //type: uint32
                        YLeaf global_auto_rp_ranges_limit; //type: uint32
                        YLeaf is_global_auto_rp_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_ranges_limit; //type: uint32
                        YLeaf global_bsr_ranges_count; //type: uint32
                        YLeaf global_bsr_ranges_threshold; //type: uint32
                        YLeaf is_global_bsr_ranges_limit_reached; //type: boolean
                        YLeaf global_bsr_candidate_rp_set_limit; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_count; //type: uint32
                        YLeaf global_bsr_candidate_rp_set_threshold; //type: uint32
                        YLeaf is_global_route_limit_reached; //type: boolean
                        YLeaf topology_interface_state_threshold; //type: uint32
                        YLeaf is_global_rxi_limit_reached; //type: boolean
                        YLeaf register_threshold; //type: uint32
                        YLeaf global_register_limit; //type: uint32
                        YLeaf is_global_register_limit_reached; //type: boolean



                }; // Ipv6Pim::Active::Vrfs::Vrf::Summary


                class Gre : public Entity
                {
                    public:
                        Gre();
                        ~Gre();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GreHashes : public Entity
                    {
                        public:
                            GreHashes();
                            ~GreHashes();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreHash : public Entity
                        {
                            public:
                                GreHash();
                                ~GreHash();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf destination_address; //type: string
                                YLeaf ifname; //type: string
                                YLeaf next_hop_interface; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreHashes::GreHash


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreHashes::GreHash> > gre_hash;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreHashes


                    class GreNextHops : public Entity
                    {
                        public:
                            GreNextHops();
                            ~GreNextHops();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class GreNextHop : public Entity
                        {
                            public:
                                GreNextHop();
                                ~GreNextHop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf destination_address; //type: string
                                YLeaf metric; //type: uint32
                                YLeaf metric_preference; //type: uint32
                                YLeaf is_connected; //type: uint8

                            class RegisteredAddress : public Entity
                            {
                                public:
                                    RegisteredAddress();
                                    ~RegisteredAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress


                            class GrePath : public Entity
                            {
                                public:
                                    GrePath();
                                    ~GrePath();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf gre_interface_name; //type: string
                                    YLeaf is_gre_interface_disabled; //type: boolean
                                    YLeaf is_via_lsm; //type: boolean
                                    YLeaf is_connector_attribute_present; //type: boolean
                                    YLeaf extranet_vrf_name; //type: string

                                class GreNeighbor : public Entity
                                {
                                    public:
                                        GreNeighbor();
                                        ~GreNeighbor();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor


                                class GreNextHop_ : public Entity
                                {
                                    public:
                                        GreNextHop_();
                                        ~GreNextHop_();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNeighbor> gre_neighbor;
                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath::GreNextHop_> gre_next_hop;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath


                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::GrePath> > gre_path;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop::RegisteredAddress> registered_address;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops::GreNextHop> > gre_next_hop;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreHashes> gre_hashes;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre::GreNextHops> gre_next_hops;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Gre


                class BidirDfWinners : public Entity
                {
                    public:
                        BidirDfWinners();
                        ~BidirDfWinners();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class BidirDfWinner : public Entity
                    {
                        public:
                            BidirDfWinner();
                            ~BidirDfWinner();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf rp_address; //type: string
                            YLeaf interface_name; //type: string
                            YLeaf pim_interface_name; //type: string
                            YLeaf are_we_df; //type: boolean
                            YLeaf rp_lan; //type: boolean
                            YLeaf metric; //type: uint32
                            YLeaf metric_preference; //type: uint32
                            YLeaf uptime; //type: uint64

                        class RpAddressXr : public Entity
                        {
                            public:
                                RpAddressXr();
                                ~RpAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr


                        class DfWinner : public Entity
                        {
                            public:
                                DfWinner();
                                ~DfWinner();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::DfWinner> df_winner;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner::RpAddressXr> rp_address_xr;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners::BidirDfWinner> > bidir_df_winner;


                }; // Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners


                class TableContexts : public Entity
                {
                    public:
                        TableContexts();
                        ~TableContexts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TableContext : public Entity
                    {
                        public:
                            TableContext();
                            ~TableContext();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf saf_name; //type: PimSafiEnum
                            YLeaf topology_name; //type: string
                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Ipv6Pim::Active::Vrfs::Vrf::TableContexts::TableContext


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TableContexts::TableContext> > table_context;


                }; // Ipv6Pim::Active::Vrfs::Vrf::TableContexts


                class GlobalInterfaces : public Entity
                {
                    public:
                        GlobalInterfaces();
                        ~GlobalInterfaces();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GlobalInterface : public Entity
                    {
                        public:
                            GlobalInterface();
                            ~GlobalInterface();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf interface_address_mask; //type: uint8
                            YLeaf is_enabled; //type: boolean
                            YLeaf neighbor_count; //type: uint16
                            YLeaf external_neighbor_count; //type: uint16
                            YLeaf hello_interval; //type: uint16
                            YLeaf dr_priority; //type: uint32
                            YLeaf hello_expiry; //type: uint64
                            YLeaf are_we_dr; //type: boolean
                            YLeaf bfd_enabled; //type: boolean
                            YLeaf bfd_interval; //type: uint32
                            YLeaf bfd_multiplier; //type: uint32
                            YLeaf virtual_interface; //type: boolean
                            YLeaf passive_interface; //type: boolean
                            YLeaf neighbor_filter_name; //type: string
                            YLeaf join_prune_interval; //type: uint16
                            YLeaf prune_delay_enabled; //type: boolean
                            YLeaf configured_propagation_delay; //type: uint16
                            YLeaf propagation_delay; //type: uint16
                            YLeaf configured_override_interval; //type: uint16
                            YLeaf override_interval; //type: uint16
                            YLeaf generation_id; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf idb_oor_enabled; //type: boolean
                            YLeaf idb_acl_provided; //type: boolean
                            YLeaf idb_max_count; //type: uint32
                            YLeaf idb_threshold_count; //type: uint32
                            YLeaf idb_current_count; //type: uint32
                            YLeaf idb_acl_name; //type: string

                        class DrAddress : public Entity
                        {
                            public:
                                DrAddress();
                                ~DrAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress


                        class InterfaceAddress : public Entity
                        {
                            public:
                                InterfaceAddress();
                                ~InterfaceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::DrAddress> dr_address;
                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface::InterfaceAddress> > interface_address;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces::GlobalInterface> > global_interface;


                }; // Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces


                class NeighborSummaries : public Entity
                {
                    public:
                        NeighborSummaries();
                        ~NeighborSummaries();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class NeighborSummary : public Entity
                    {
                        public:
                            NeighborSummary();
                            ~NeighborSummary();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf number_of_neighbors; //type: int32
                            YLeaf number_of_external_neighbors; //type: int32



                    }; // Ipv6Pim::Active::Vrfs::Vrf::NeighborSummaries::NeighborSummary


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NeighborSummaries::NeighborSummary> > neighbor_summary;


                }; // Ipv6Pim::Active::Vrfs::Vrf::NeighborSummaries


                class Context : public Entity
                {
                    public:
                        Context();
                        ~Context();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf vrf_id; //type: uint32
                        YLeaf table_id; //type: uint32
                        YLeaf murib_id; //type: uint32
                        YLeaf rpf_id; //type: uint32
                        YLeaf remote_table_id; //type: uint32
                        YLeaf mdt_default_group; //type: string
                        YLeaf mdt_interface; //type: string
                        YLeaf mdt_gre_rpf_identifier; //type: uint32
                        YLeaf mdt_gre_remote_rpf_identifier; //type: uint32
                        YLeaf is_unicast_rib_registration; //type: boolean
                        YLeaf is_multicast_rib_registration; //type: boolean
                        YLeaf is_active; //type: boolean
                        YLeaf is_active_ital; //type: boolean
                        YLeaf is_mrib_register; //type: boolean
                        YLeaf is_mdt_owner; //type: boolean
                        YLeaf is_routing_enabled; //type: boolean
                        YLeaf is_socket_add_required; //type: boolean
                        YLeaf is_socket_added; //type: boolean
                        YLeaf is_lpts_socket_add_required; //type: boolean
                        YLeaf is_lpts_socket_added; //type: boolean
                        YLeaf is_udp_socket_add_required; //type: boolean
                        YLeaf is_udp_socket_added; //type: boolean
                        YLeaf is_udp_socket_bind_required; //type: boolean
                        YLeaf is_udp_socket_bind; //type: boolean
                        YLeaf is_register_injection_socket_add_required; //type: boolean
                        YLeaf is_register_injection_socket_added; //type: boolean
                        YLeaf is_register_injection_lpts_socket_add_required; //type: boolean
                        YLeaf is_register_injection_lpts_socket_added; //type: boolean
                        YLeaf is_m_host_publish_pending; //type: boolean
                        YLeaf mhost_interface; //type: string
                        YLeaf mhost_default_interface_config; //type: string
                        YLeaf mdt_mtu; //type: uint32
                        YLeaf maximum_mdt_aggregation; //type: uint32
                        YLeaf mdt_data_switchover_interval; //type: uint32
                        YLeaf mdt_data_announce_interval; //type: uint32
                        YLeaf non_default_vrf_count_on_socket; //type: uint32
                        YLeaf neighbor_filter_name; //type: string
                        YLeaf mdt_neighbor_filter_name; //type: string
                        YLeaf allow_rp_configured; //type: boolean
                        YLeaf allow_rp_group_list; //type: string
                        YLeaf allow_rp_rp_list; //type: string
                        YLeaf sg_expiry_timer_configured; //type: boolean
                        YLeaf sg_expiry_time; //type: uint16
                        YLeaf sg_expiry_timer_sg_list; //type: string
                        YLeaf mldp_mdt_name; //type: string
                        YLeaf mldp_mdt_interface; //type: string
                        YLeaf mldp_mdt_mtu; //type: uint32
                        YLeaf mldp_maximum_mdt_aggregation; //type: uint32
                        YLeaf mldp_mdt_data_switchover_interval; //type: uint32
                        YLeaf mldp_mdt_data_announce_interval; //type: uint32
                        YLeaf mldp_mdt_rpf_identifier; //type: uint32
                        YLeaf mldp_mdt_remote_rpf_identifier; //type: uint32
                        YLeaf is_create_mldp_mdt_interface; //type: boolean
                        YLeaf is_mldp_mdt_owner; //type: boolean
                        YLeaf mldp_root_count; //type: uint32
                        YLeaf mldp_head_lsm_identifier; //type: uint32
                        YLeaf mldp_remote_head_lsm_identifier; //type: uint32
                        YLeaf organization_unique_identifier; //type: uint32
                        YLeaf vpn_index; //type: uint32
                        YLeaf mldp_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_remote_partitioned_mdt_configured; //type: boolean
                        YLeaf mldp_partioned_mp2m_ptree; //type: boolean
                        YLeaf mldp_partitioned_head_lsm_identifier; //type: uint32
                        YLeaf mldp_head_local_label; //type: uint32
                        YLeaf mldp_partitioned_mdt_identifier; //type: uint32
                        YLeaf bgp_auto_discovery_configured; //type: boolean
                        YLeaf suppress_pim_data_mdt_tlv; //type: boolean
                        YLeaf inter_autonomous_system_enabled; //type: boolean
                        YLeaf bgp_source_active_announce; //type: boolean
                        YLeaf bgp_i_pmsi_added; //type: boolean
                        YLeaf mldp_bsr_control_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_discovery_tree_added; //type: boolean
                        YLeaf mldp_auto_rp_announce_tree_added; //type: boolean
                        YLeaf bgp_auto_discovery_type; //type: uint32
                        YLeaf mdt_partitioned_mdt_control_identifier; //type: uint32
                        YLeaf mdt_partitioned_ir_control_identifier; //type: uint32
                        YLeaf mldp_control_head_lsm_identifier; //type: uint32
                        YLeaf umh; //type: boolean
                        YLeaf suppress_shared_tree_join; //type: boolean
                        YLeaf rsvp_te_mdt_name; //type: string
                        YLeaf rsvp_te_mdt_interface; //type: string
                        YLeaf rsvp_te_mdt_mtu; //type: uint32
                        YLeaf rsvp_te_maximum_mdt_aggregation; //type: uint32
                        YLeaf rsvp_te_mdt_data_switchover_interval; //type: uint32
                        YLeaf rsvp_te_mdt_data_announce_interval; //type: uint32
                        YLeaf rsvp_te_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_rsvp_te_mdt_interface; //type: boolean
                        YLeaf is_rsvp_te_mdt_owner; //type: boolean
                        YLeaf rsvp_te_mdt_static_p2mp_count; //type: uint32
                        YLeaf p2mpte_li_drop; //type: uint32
                        YLeaf ir_mdt_name; //type: string
                        YLeaf ir_mdt_interface; //type: string
                        YLeaf ir_mdt_mtu; //type: uint32
                        YLeaf ir_maximum_mdt_aggregation; //type: uint32
                        YLeaf ir_mdt_data_switchover_interval; //type: uint32
                        YLeaf ir_mdt_data_announce_interval; //type: uint32
                        YLeaf ir_mdt_rpf_identifier; //type: uint32
                        YLeaf ir_mdt_tail_label; //type: uint32
                        YLeaf is_create_ir_mdt_interface; //type: boolean
                        YLeaf is_ir_mdt_owner; //type: boolean
                        YLeaf in_b_and_mdt_name; //type: string
                        YLeaf in_b_and_mdt_interface; //type: string
                        YLeaf in_b_and_mdt_mtu; //type: uint32
                        YLeaf in_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf in_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf in_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf in_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_in_b_and_mdt_interface; //type: boolean
                        YLeaf is_in_b_and_mdt_owner; //type: boolean
                        YLeaf in_band_signaling_local_enabled; //type: boolean
                        YLeaf in_band_signaling_remote_enabled; //type: boolean
                        YLeaf valid_rd_present; //type: boolean
                        YLeaf stale_rd_present; //type: boolean
                        YLeaf route_distinguisher; //type: string
                        YLeaf gin_b_and_mdt_name; //type: string
                        YLeaf gin_b_and_mdt_interface; //type: string
                        YLeaf gin_b_and_mdt_mtu; //type: uint32
                        YLeaf gin_band_maximum_mdt_aggregation; //type: uint32
                        YLeaf gin_b_and_mdt_data_switchover_interval; //type: uint32
                        YLeaf gin_b_and_mdt_data_announce_interval; //type: uint32
                        YLeaf gin_b_and_mdt_rpf_identifier; //type: uint32
                        YLeaf is_create_gin_b_and_mdt_interface; //type: boolean
                        YLeaf is_gin_b_and_mdt_owner; //type: boolean
                        YLeaf is_pim_nsf_rib_converged; //type: boolean
                        YLeaf is_pim_nsf_rib_converge_received; //type: boolean
                        YLeaf is_rib_multipath_enabled; //type: boolean
                        YLeaf is_rib_multipath_interface_hash; //type: boolean
                        YLeaf is_rib_multipath_source_hash; //type: boolean
                        YLeaf is_rib_multipath_source_next_hop_hash; //type: boolean
                        YLeaf rump_enabled; //type: boolean
                        YLeaf is_create_mdt_interface; //type: boolean
                        YLeaf is_auto_rp_listen_enabled; //type: boolean
                        YLeaf is_all_interface_disable_operation; //type: boolean
                        YLeaf is_default_granges; //type: boolean
                        YLeaf is_auto_rp_listen_sock_add; //type: boolean
                        YLeaf is_redistribution_reset; //type: boolean
                        YLeaf redistribution_reset_count; //type: uint32
                        YLeaf rpf_policy_name; //type: string
                        YLeaf table_count; //type: uint32
                        YLeaf active_table_count; //type: uint32
                        YLeaf anycast_rp_policy_name; //type: string
                        YLeaf anycast_rp_configured; //type: boolean
                        YLeaf bgp_remote_on; //type: boolean
                        YLeaf bgp_remote_interface_name; //type: string
                        YLeaf bgp_remote_interface; //type: string
                        YLeaf bgp_remote_address; //type: string
                        YLeaf bgp_remote_state; //type: uint32
                        YLeafList mldp_root_address; //type: list of  uint32

                    class RemoteDefaultGroup : public Entity
                    {
                        public:
                            RemoteDefaultGroup();
                            ~RemoteDefaultGroup();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Ipv6Pim::Active::Vrfs::Vrf::Context::RemoteDefaultGroup


                    class RpfDefaultTable : public Entity
                    {
                        public:
                            RpfDefaultTable();
                            ~RpfDefaultTable();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf afi; //type: uint32
                            YLeaf safi; //type: uint32
                            YLeaf table_name; //type: string
                            YLeaf vrf_id; //type: uint32
                            YLeaf table_id; //type: uint32
                            YLeaf is_active; //type: boolean
                            YLeaf is_ital_registration_done; //type: boolean
                            YLeaf is_rib_registration_done; //type: boolean
                            YLeaf is_rib_convergence_received; //type: boolean
                            YLeaf is_rib_convergence; //type: boolean
                            YLeaf rpf_registrations; //type: uint32



                    }; // Ipv6Pim::Active::Vrfs::Vrf::Context::RpfDefaultTable


                    class ExportRouteTarget : public Entity
                    {
                        public:
                            ExportRouteTarget();
                            ~ExportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Ipv6Pim::Active::Vrfs::Vrf::Context::ExportRouteTarget


                    class ImportRouteTarget : public Entity
                    {
                        public:
                            ImportRouteTarget();
                            ~ImportRouteTarget();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf route_target; //type: string
                            YLeaf configured; //type: boolean
                            YLeaf anycast_rp; //type: boolean
                            YLeaf anycast_rp_marked; //type: boolean
                            YLeaf update_pending; //type: boolean
                            YLeaf bgp_auto_discovery; //type: boolean
                            YLeaf segment_border; //type: boolean



                    }; // Ipv6Pim::Active::Vrfs::Vrf::Context::ImportRouteTarget


                    class AnycastRpRange : public Entity
                    {
                        public:
                            AnycastRpRange();
                            ~AnycastRpRange();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf prefix_length; //type: uint8
                            YLeaf ancast_rp_marked; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Context::AnycastRpRange::Prefix


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context::AnycastRpRange::Prefix> prefix;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Context::AnycastRpRange


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context::AnycastRpRange> > anycast_rp_range;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context::ExportRouteTarget> > export_route_target;
                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context::ImportRouteTarget> > import_route_target;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context::RemoteDefaultGroup> remote_default_group;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context::RpfDefaultTable> rpf_default_table;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Context


                class TopologyEntryFlagRouteCounts : public Entity
                {
                    public:
                        TopologyEntryFlagRouteCounts();
                        ~TopologyEntryFlagRouteCounts();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class TopologyEntryFlagRouteCount : public Entity
                    {
                        public:
                            TopologyEntryFlagRouteCount();
                            ~TopologyEntryFlagRouteCount();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf entry_flag; //type: PimTopologyEntryFlagEnum
                            YLeaf group_ranges; //type: uint32
                            YLeaf active_group_ranges; //type: uint32
                            YLeaf groute_count; //type: uint32
                            YLeaf sg_route_count; //type: uint32
                            YLeaf sgr_route_count; //type: uint32
                            YLeaf is_node_low_memory; //type: boolean

                        class GroupAddress : public Entity
                        {
                            public:
                                GroupAddress();
                                ~GroupAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount::GroupAddress> group_address;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts::TopologyEntryFlagRouteCount> > topology_entry_flag_route_count;


                }; // Ipv6Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts


                class RpfRedirect : public Entity
                {
                    public:
                        RpfRedirect();
                        ~RpfRedirect();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class RedirectRouteDatabases : public Entity
                    {
                        public:
                            RedirectRouteDatabases();
                            ~RedirectRouteDatabases();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class RedirectRouteDatabase : public Entity
                        {
                            public:
                                RedirectRouteDatabase();
                                ~RedirectRouteDatabase();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf source_address; //type: string
                                YLeaf group_address; //type: string
                                YLeaf bandwidth; //type: uint32
                                YLeaf uptime; //type: uint64

                            class GroupAddressXr : public Entity
                            {
                                public:
                                    GroupAddressXr();
                                    ~GroupAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr


                            class SourceAddressXr : public Entity
                            {
                                public:
                                    SourceAddressXr();
                                    ~SourceAddressXr();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr


                            class Interface : public Entity
                            {
                                public:
                                    Interface();
                                    ~Interface();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf interface_name; //type: string
                                    YLeaf uptime; //type: uint64
                                    YLeaf expiry; //type: uint64
                                    YLeaf is_rpf_interface; //type: boolean
                                    YLeaf is_outgoing_interface; //type: boolean
                                    YLeaf is_snoop_interface; //type: boolean

                                class RpfAddress : public Entity
                                {
                                    public:
                                        RpfAddress();
                                        ~RpfAddress();

                                        bool has_data() const override;
                                        bool has_operation() const override;
                                        EntityPath get_entity_path(Entity* parent) const override;
                                        std::string get_segment_path() const override;
                                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                        void set_value(const std::string & value_path, std::string value) override;
                                        std::map<std::string, Entity*> & get_children() override;


                                        YLeaf af_name; //type: PimAfiEnum
                                        YLeaf ipv4_address; //type: string
                                        YLeaf ipv6_address; //type: string



                                }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress


                                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface::RpfAddress> rpf_address;


                            }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::GroupAddressXr> group_address_xr;
                                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::Interface> > interface;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase::SourceAddressXr> source_address_xr;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases::RedirectRouteDatabase> > redirect_route_database;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases


                    class BundleInterfaces : public Entity
                    {
                        public:
                            BundleInterfaces();
                            ~BundleInterfaces();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;



                        class BundleInterface : public Entity
                        {
                            public:
                                BundleInterface();
                                ~BundleInterface();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf bundle_name; //type: string
                                YLeaf interface_name; //type: string
                                YLeaf rpf_redirect_bundle_name; //type: string
                                YLeaf rpf_redirect_interface_name; //type: string
                                YLeaf available_bandwidth; //type: int32
                                YLeaf allocated_bandwidth; //type: int32
                                YLeaf total_bandwidth; //type: int32
                                YLeaf topology_bandwidth_used; //type: int32
                                YLeaf snooping_bandwidth_used; //type: int32
                                YLeaf allocated_threshold_bandwidth; //type: int32
                                YLeaf available_threshold_bandwidth; //type: int32



                        }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces::BundleInterface> > bundle_interface;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::BundleInterfaces> bundle_interfaces;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect::RedirectRouteDatabases> redirect_route_databases;


                }; // Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect


                class Tunnels : public Entity
                {
                    public:
                        Tunnels();
                        ~Tunnels();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Tunnel : public Entity
                    {
                        public:
                            Tunnel();
                            ~Tunnel();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf tunnel_name; //type: string
                            YLeaf vrf_name; //type: string

                        class SourceAddress : public Entity
                        {
                            public:
                                SourceAddress();
                                ~SourceAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress


                        class RpAddress : public Entity
                        {
                            public:
                                RpAddress();
                                ~RpAddress();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::RpAddress


                        class SourceAddressNetio : public Entity
                        {
                            public:
                                SourceAddressNetio();
                                ~SourceAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio


                        class GroupAddressNetio : public Entity
                        {
                            public:
                                GroupAddressNetio();
                                ~GroupAddressNetio();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::GroupAddressNetio> group_address_netio;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::RpAddress> rp_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddress> source_address;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel::SourceAddressNetio> source_address_netio;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Tunnels::Tunnel> > tunnel;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Tunnels


                class MulticastStaticRoutes : public Entity
                {
                    public:
                        MulticastStaticRoutes();
                        ~MulticastStaticRoutes();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class MulticastStaticRoute : public Entity
                    {
                        public:
                            MulticastStaticRoute();
                            ~MulticastStaticRoute();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf address; //type: string
                            YLeaf prefix_length; //type: int32
                            YLeaf interface_name; //type: string
                            YLeaf distance; //type: uint32
                            YLeaf prefix_length_xr; //type: uint8
                            YLeaf is_via_lsm; //type: boolean

                        class Prefix : public Entity
                        {
                            public:
                                Prefix();
                                ~Prefix();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix


                        class Nexthop : public Entity
                        {
                            public:
                                Nexthop();
                                ~Nexthop();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Nexthop> nexthop;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute::Prefix> prefix;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes::MulticastStaticRoute> > multicast_static_route;


                }; // Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes


                class GroupMapMatchSources : public Entity
                {
                    public:
                        GroupMapMatchSources();
                        ~GroupMapMatchSources();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class GroupMapMatchSource : public Entity
                    {
                        public:
                            GroupMapMatchSource();
                            ~GroupMapMatchSource();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf group_address; //type: string
                            YLeaf holdtime; //type: int32
                            YLeaf expires; //type: uint64
                            YLeaf uptime; //type: uint64

                        class SourceOfInformation : public Entity
                        {
                            public:
                                SourceOfInformation();
                                ~SourceOfInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation


                        class GroupMapInformation : public Entity
                        {
                            public:
                                GroupMapInformation();
                                ~GroupMapInformation();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf prefix_length; //type: int32
                                YLeaf client; //type: PimShowRangeClientEnum
                                YLeaf protocol; //type: PimShowProtocolEnum
                                YLeaf group_count; //type: uint32
                                YLeaf is_used; //type: boolean
                                YLeaf mrib_active; //type: boolean
                                YLeaf is_override; //type: boolean
                                YLeaf priority; //type: uint32

                            class Prefix : public Entity
                            {
                                public:
                                    Prefix();
                                    ~Prefix();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix


                            class RpAddress : public Entity
                            {
                                public:
                                    RpAddress();
                                    ~RpAddress();

                                    bool has_data() const override;
                                    bool has_operation() const override;
                                    EntityPath get_entity_path(Entity* parent) const override;
                                    std::string get_segment_path() const override;
                                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                    void set_value(const std::string & value_path, std::string value) override;
                                    std::map<std::string, Entity*> & get_children() override;


                                    YLeaf af_name; //type: PimAfiEnum
                                    YLeaf ipv4_address; //type: string
                                    YLeaf ipv6_address; //type: string



                            }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress


                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::Prefix> prefix;
                                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation::RpAddress> rp_address;


                        }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation


                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::GroupMapInformation> group_map_information;
                            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource::SourceOfInformation> source_of_information;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources::GroupMapMatchSource> > group_map_match_source;


                }; // Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources


                class Neighbors : public Entity
                {
                    public:
                        Neighbors();
                        ~Neighbors();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;



                    class Neighbor : public Entity
                    {
                        public:
                            Neighbor();
                            ~Neighbor();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf interface_name; //type: string
                            YLeaf neighbor_address; //type: string
                            YLeaf interface_name_xr; //type: string
                            YLeaf uptime; //type: uint64
                            YLeaf expires; //type: uint64
                            YLeaf expiry_timer; //type: uint64
                            YLeaf is_this_neighbor_us; //type: boolean
                            YLeaf is_this_neighbor_dr; //type: boolean
                            YLeaf is_dr_priority_capable; //type: boolean
                            YLeaf dr_priority; //type: uint32
                            YLeaf is_bidirectional_capable; //type: boolean
                            YLeaf is_proxy_capable; //type: boolean
                            YLeaf is_batch_asserts_capable; //type: boolean
                            YLeaf is_ecmp_redirect_capable; //type: boolean
                            YLeaf is_bfd_state; //type: boolean
                            YLeaf propagation_delay; //type: uint16
                            YLeaf override_interval; //type: uint16

                        class NeighborAddressXr : public Entity
                        {
                            public:
                                NeighborAddressXr();
                                ~NeighborAddressXr();

                                bool has_data() const override;
                                bool has_operation() const override;
                                EntityPath get_entity_path(Entity* parent) const override;
                                std::string get_segment_path() const override;
                                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                                void set_value(const std::string & value_path, std::string value) override;
                                std::map<std::string, Entity*> & get_children() override;


                                YLeaf af_name; //type: PimAfiEnum
                                YLeaf ipv4_address; //type: string
                                YLeaf ipv6_address; //type: string



                        }; // Ipv6Pim::Active::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr


                            std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Neighbors::Neighbor::NeighborAddressXr> > neighbor_address_xr;


                    }; // Ipv6Pim::Active::Vrfs::Vrf::Neighbors::Neighbor


                        std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Neighbors::Neighbor> > neighbor;


                }; // Ipv6Pim::Active::Vrfs::Vrf::Neighbors


                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::AutoRp> auto_rp;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BgpAfs> bgp_afs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfStates> bidir_df_states;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::BidirDfWinners> bidir_df_winners;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Bsr> bsr;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Context> context;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GlobalInterfaces> global_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Gre> gre;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchRpfs> group_map_match_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapMatchSources> group_map_match_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapRpfs> group_map_rpfs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::GroupMapSources> group_map_sources;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::IfrsInterfaces> ifrs_interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::IfrsSummary> ifrs_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::InterfaceOldFormats> interface_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::InterfaceStatistics> interface_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Interfaces> interfaces;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::JpStatistics> jp_statistics;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MibDatabases> mib_databases;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::MulticastStaticRoutes> multicast_static_routes;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NeighborOldFormats> neighbor_old_formats;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NeighborSummaries> neighbor_summaries;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Neighbors> neighbors;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::NetIoTunnels> net_io_tunnels;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Ranges> ranges;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RoutePolicy> route_policy;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfRedirect> rpf_redirect;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::RpfSummary> rpf_summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Safs> safs;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Summary> summary;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TableContexts> table_contexts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Topologies> topologies;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyEntryFlagRouteCounts> topology_entry_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyInterfaceFlagRouteCounts> topology_interface_flag_route_counts;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TopologyRouteCount> topology_route_count;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::TrafficCounters> traffic_counters;
                    std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf::Tunnels> tunnels;


            }; // Ipv6Pim::Active::Vrfs::Vrf


                std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs::Vrf> > vrf;


        }; // Ipv6Pim::Active::Vrfs


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::DefaultContext> default_context;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Process> process;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active::Vrfs> vrfs;


    }; // Ipv6Pim::Active


        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Active> active;
        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Ipv6Pim::Standby> standby;


}; // Ipv6Pim

class Pim6Ma : public Entity
{
    public:
        Pim6Ma();
        ~Pim6Ma();

        bool has_data() const override;
        bool has_operation() const override;
        EntityPath get_entity_path(Entity* parent) const override;
        std::string get_segment_path() const override;
        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
        void set_value(const std::string & value_path, std::string value) override;
        std::map<std::string, Entity*> & get_children() override;
        std::unique_ptr<Entity> clone_ptr() override;



    class Active : public Entity
    {
        public:
            Active();
            ~Active();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class InterfaceTable : public Entity
        {
            public:
                InterfaceTable();
                ~InterfaceTable();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class InterfaceByHandles : public Entity
            {
                public:
                    InterfaceByHandles();
                    ~InterfaceByHandles();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByHandle : public Entity
                {
                    public:
                        InterfaceByHandle();
                        ~InterfaceByHandle();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_handle; //type: int32
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress> source_address;


                }; // Pim6Ma::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByHandles::InterfaceByHandle> > interface_by_handle;


            }; // Pim6Ma::Active::InterfaceTable::InterfaceByHandles


            class InterfaceByNames : public Entity
            {
                public:
                    InterfaceByNames();
                    ~InterfaceByNames();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByName : public Entity
                {
                    public:
                        InterfaceByName();
                        ~InterfaceByName();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Active::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Active::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress> source_address;


                }; // Pim6Ma::Active::InterfaceTable::InterfaceByNames::InterfaceByName


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByNames::InterfaceByName> > interface_by_name;


            }; // Pim6Ma::Active::InterfaceTable::InterfaceByNames


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByHandles> interface_by_handles;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable::InterfaceByNames> interface_by_names;


        }; // Pim6Ma::Active::InterfaceTable


        class PimMaSummary : public Entity
        {
            public:
                PimMaSummary();
                ~PimMaSummary();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;


                YLeaf is_im_connection_open; //type: boolean
                YLeaf is_netio_connection_open; //type: boolean
                YLeaf is_edm_connection_open; //type: boolean
                YLeaf is_standby_edm_connection_open; //type: boolean
                YLeaf encap_interface_count; //type: uint32
                YLeaf decap_interface_count; //type: uint32
                YLeaf mdt_interface_count; //type: uint32



        }; // Pim6Ma::Active::PimMaSummary


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::InterfaceTable> interface_table;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active::PimMaSummary> pim_ma_summary;


    }; // Pim6Ma::Active


    class Standby : public Entity
    {
        public:
            Standby();
            ~Standby();

            bool has_data() const override;
            bool has_operation() const override;
            EntityPath get_entity_path(Entity* parent) const override;
            std::string get_segment_path() const override;
            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
            void set_value(const std::string & value_path, std::string value) override;
            std::map<std::string, Entity*> & get_children() override;



        class InterfaceTable : public Entity
        {
            public:
                InterfaceTable();
                ~InterfaceTable();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;



            class InterfaceByHandles : public Entity
            {
                public:
                    InterfaceByHandles();
                    ~InterfaceByHandles();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByHandle : public Entity
                {
                    public:
                        InterfaceByHandle();
                        ~InterfaceByHandle();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_handle; //type: int32
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle::SourceAddress> source_address;


                }; // Pim6Ma::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByHandles::InterfaceByHandle> > interface_by_handle;


            }; // Pim6Ma::Standby::InterfaceTable::InterfaceByHandles


            class InterfaceByNames : public Entity
            {
                public:
                    InterfaceByNames();
                    ~InterfaceByNames();

                    bool has_data() const override;
                    bool has_operation() const override;
                    EntityPath get_entity_path(Entity* parent) const override;
                    std::string get_segment_path() const override;
                    Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                    void set_value(const std::string & value_path, std::string value) override;
                    std::map<std::string, Entity*> & get_children() override;



                class InterfaceByName : public Entity
                {
                    public:
                        InterfaceByName();
                        ~InterfaceByName();

                        bool has_data() const override;
                        bool has_operation() const override;
                        EntityPath get_entity_path(Entity* parent) const override;
                        std::string get_segment_path() const override;
                        Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                        void set_value(const std::string & value_path, std::string value) override;
                        std::map<std::string, Entity*> & get_children() override;


                        YLeaf interface_name; //type: string
                        YLeaf interface_name_xr; //type: string
                        YLeaf vrf_name; //type: string
                        YLeaf interface_type; //type: PimInterfaceEnum

                    class RpAddress : public Entity
                    {
                        public:
                            RpAddress();
                            ~RpAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress


                    class SourceAddress : public Entity
                    {
                        public:
                            SourceAddress();
                            ~SourceAddress();

                            bool has_data() const override;
                            bool has_operation() const override;
                            EntityPath get_entity_path(Entity* parent) const override;
                            std::string get_segment_path() const override;
                            Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                            void set_value(const std::string & value_path, std::string value) override;
                            std::map<std::string, Entity*> & get_children() override;


                            YLeaf af_name; //type: PimAfiEnum
                            YLeaf ipv4_address; //type: string
                            YLeaf ipv6_address; //type: string



                    }; // Pim6Ma::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress


                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::RpAddress> rp_address;
                        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByNames::InterfaceByName::SourceAddress> source_address;


                }; // Pim6Ma::Standby::InterfaceTable::InterfaceByNames::InterfaceByName


                    std::vector<std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByNames::InterfaceByName> > interface_by_name;


            }; // Pim6Ma::Standby::InterfaceTable::InterfaceByNames


                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByHandles> interface_by_handles;
                std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable::InterfaceByNames> interface_by_names;


        }; // Pim6Ma::Standby::InterfaceTable


        class PimMaSummary : public Entity
        {
            public:
                PimMaSummary();
                ~PimMaSummary();

                bool has_data() const override;
                bool has_operation() const override;
                EntityPath get_entity_path(Entity* parent) const override;
                std::string get_segment_path() const override;
                Entity* get_child_by_name(const std::string & yang_name, const std::string & segment_path) override;
                void set_value(const std::string & value_path, std::string value) override;
                std::map<std::string, Entity*> & get_children() override;


                YLeaf is_im_connection_open; //type: boolean
                YLeaf is_netio_connection_open; //type: boolean
                YLeaf is_edm_connection_open; //type: boolean
                YLeaf is_standby_edm_connection_open; //type: boolean
                YLeaf encap_interface_count; //type: uint32
                YLeaf decap_interface_count; //type: uint32
                YLeaf mdt_interface_count; //type: uint32



        }; // Pim6Ma::Standby::PimMaSummary


            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::InterfaceTable> interface_table;
            std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby::PimMaSummary> pim_ma_summary;


    }; // Pim6Ma::Standby


        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Active> active;
        std::unique_ptr<Cisco_IOS_XR_ipv4_pim_oper::Pim6Ma::Standby> standby;


}; // Pim6Ma


class PimTopologyEntryFlagEnum : public Enum
{
    public:
        static const Enum::YLeaf kat;
        static const Enum::YLeaf aa;
        static const Enum::YLeaf pa;
        static const Enum::YLeaf ra;
        static const Enum::YLeaf ia;
        static const Enum::YLeaf rr;
        static const Enum::YLeaf lh;
        static const Enum::YLeaf dss;
        static const Enum::YLeaf dcc;
        static const Enum::YLeaf sr;
        static const Enum::YLeaf e;
        static const Enum::YLeaf ex;
        static const Enum::YLeaf ma;
        static const Enum::YLeaf mt;
        static const Enum::YLeaf mfa;
        static const Enum::YLeaf mfp;
        static const Enum::YLeaf mfb;

};

class PimAfiEnum : public Enum
{
    public:
        static const Enum::YLeaf ipv4_unicast;
        static const Enum::YLeaf ipv6_unicast;

};

class PimInterfaceEnum : public Enum
{
    public:
        static const Enum::YLeaf encap_interface;
        static const Enum::YLeaf decap_interface;
        static const Enum::YLeaf mdt_interface;

};

class PimShowRangeClientEnum : public Enum
{
    public:
        static const Enum::YLeaf no_client;
        static const Enum::YLeaf embedded_config;
        static const Enum::YLeaf embedded;
        static const Enum::YLeaf permanent;
        static const Enum::YLeaf auto_rp;
        static const Enum::YLeaf bsr;
        static const Enum::YLeaf config;
        static const Enum::YLeaf static_;

};

class PimProtocolEnum : public Enum
{
    public:
        static const Enum::YLeaf non_routable;
        static const Enum::YLeaf sparse_mode;
        static const Enum::YLeaf dense_mode;
        static const Enum::YLeaf bidir;
        static const Enum::YLeaf ssm;
        static const Enum::YLeaf maximum;
        static const Enum::YLeaf any;

};

class PimSafiEnum : public Enum
{
    public:
        static const Enum::YLeaf unicast;
        static const Enum::YLeaf multicast;
        static const Enum::YLeaf all;
        static const Enum::YLeaf default_;

};

class PimClientEnum : public Enum
{
    public:
        static const Enum::YLeaf none;
        static const Enum::YLeaf configured_embedded_rp;
        static const Enum::YLeaf embedded;
        static const Enum::YLeaf permanent;
        static const Enum::YLeaf auto_rp;
        static const Enum::YLeaf bsr;
        static const Enum::YLeaf configured;
        static const Enum::YLeaf static_;

};

class PimShowProtocolEnum : public Enum
{
    public:
        static const Enum::YLeaf no_route;
        static const Enum::YLeaf sm;
        static const Enum::YLeaf dm;
        static const Enum::YLeaf bidir;
        static const Enum::YLeaf ssm;
        static const Enum::YLeaf maximum;
        static const Enum::YLeaf any;

};

class PimTopologyInterfaceFlagEnum : public Enum
{
    public:
        static const Enum::YLeaf lh;
        static const Enum::YLeaf ld;
        static const Enum::YLeaf li;
        static const Enum::YLeaf ii;
        static const Enum::YLeaf id;
        static const Enum::YLeaf as;
        static const Enum::YLeaf ab;
        static const Enum::YLeaf ex;

};


}
}

#endif /* _CISCO_IOS_XR_IPV4_PIM_OPER_ */

